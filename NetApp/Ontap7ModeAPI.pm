##
# $Id$
# 
# Copyright (c) 2014 Network Appliance, Inc.
# All rights reserved.
# 
# This file was generated at Jan 14, 2014 3:33:09 AM
##

package Ontap7ModeAPI;

use strict;

use constant FIELD_SCALAR => 0x0;
use constant FIELD_TYPEDEF => 0x1;
use constant FIELD_ARRAY => 0x2;
use constant FIELD_OPTIONAL => 0x4;
use constant FIELD_ENCRYPTED => 0x8;

my $APIS = {
    'aggr-add' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'aggregate' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'allow-mixed-rpm' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'allow-same-carrier' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'cache-raid-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'checksum-style' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'disk-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'disk-size' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'disk-size-with-unit' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'disk-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'disks' => {
                'type' => 'disk-info',
                'flags' => 7,
                'scope' => [],
            },
            'force-cache-size' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
            },
            'force-spare-pool' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'group-selection-mode' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'ignore-pool-checks' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'mirror-disks' => {
                'type' => 'disk-info',
                'flags' => 7,
                'scope' => [],
            },
            'pre-check' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'raid-group' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'simulate' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => ['ontap-c', 'ontap-d'],
            },
            'upgrade-64bit-mode' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'bad-disks' => {
                'type' => 'disk-info',
                'flags' => 7,
                'scope' => [],
            },
            'pre-check-results' => {
                'type' => 'warning-code',
                'flags' => 7,
                'scope' => [],
            },
            'selected-disks' => {
                'type' => 'disk-info',
                'flags' => 7,
                'scope' => ['ontap-c', 'ontap-d'],
            },
            'selected-mirror-disks' => {
                'type' => 'disk-info',
                'flags' => 7,
                'scope' => ['ontap-c', 'ontap-d'],
            },
            'upgrade-64bit-cookie' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'aggr-check-spare-low' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
        },
        'outputs' => {
            'is-spare-low' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'aggr-create' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'aggregate' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'allow-mixed-rpm' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'allow-same-carrier' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'block-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'checksum-style' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'disk-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'disk-size' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'disk-size-with-unit' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'disk-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'disks' => {
                'type' => 'disk-info',
                'flags' => 7,
                'scope' => [],
            },
            'force-spare-pool' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'ha-policy' => {
                'type' => 'ha-policy-type',
                'flags' => 4,
                'scope' => ['ontap-c', 'ontap-d'],
            },
            'ignore-pool-checks' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-mirrored' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-snaplock' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => ['ontap-c', 'ontap-d'],
            },
            'language-code' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => ['ontap-c', 'ontap-d'],
            },
            'mirror-disks' => {
                'type' => 'disk-info',
                'flags' => 7,
                'scope' => [],
            },
            'pre-check' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'raid-size' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'raid-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'rpm' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'simulate' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => ['ontap-c', 'ontap-d'],
            },
            'snaplock-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => ['ontap-c', 'ontap-d'],
            },
            'spare-pool' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => ['ontap-c'],
            },
            'striping' => {
                'type' => 'striping-type',
                'flags' => 4,
                'scope' => [],
            },
            'type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => ['ontap-c', 'ontap-d'],
            },
        },
        'outputs' => {
            'bad-disks' => {
                'type' => 'disk-info',
                'flags' => 7,
                'scope' => [],
            },
            'pre-check-results' => {
                'type' => 'warning-code',
                'flags' => 7,
                'scope' => [],
            },
            'selected-disks' => {
                'type' => 'disk-info',
                'flags' => 7,
                'scope' => ['ontap-c', 'ontap-d'],
            },
            'selected-mirror-disks' => {
                'type' => 'disk-info',
                'flags' => 7,
                'scope' => ['ontap-c'],
            },
        },
    },
    'aggr-destroy' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'aggregate' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => ['ontap-c'],
            },
        },
        'outputs' => {
        },
    },
    'aggr-get-filer-info' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
        },
        'outputs' => {
            'allowed-raidtypes' => {
                'type' => 'raidtype-info',
                'flags' => 3,
                'scope' => [],
            },
            'checksum-types' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'default-raidtype' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'disk-types' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'max-named-disks-per-request' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'raidgroup-size' => {
                'type' => 'raidgroup-size-info',
                'flags' => 3,
                'scope' => [],
            },
            'root-volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'snapshots-max' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'aggr-get-root-name' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'root-volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'aggr-list-info' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'ontap-d', 'vfiler'],
        'inputs' => {
            'aggregate' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'filter-attrs' => {
                'type' => 'filter-attrs-info',
                'flags' => 5,
                'scope' => [],
            },
            'verbose' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'aggregates' => {
                'type' => 'aggr-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'aggr-mediascrub-list-info' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'aggregate' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'mediascrub-details' => {
                'type' => 'mediascrub-detail-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'aggr-mirror' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'aggregate' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'allow-mixed-rpm' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'allow-same-carrier' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'ignore-pool-checks' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'mirror-disks' => {
                'type' => 'disk-info',
                'flags' => 7,
                'scope' => [],
            },
            'override-vfiler-ownership' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'pre-check' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'victim-aggregate' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => ['ontap-c', 'ontap-d'],
            },
        },
        'outputs' => {
            'bad-disks' => {
                'type' => 'disk-info',
                'flags' => 7,
                'scope' => [],
            },
            'pre-check-results' => {
                'type' => 'warning-code',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'aggr-modify-raid-type' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'aggregate' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'disk-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'raid-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'aggr-offline' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'aggregate' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'cifs-delay-seconds' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => ['ontap-c'],
            },
            'unmount-volumes' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'aggr-online' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'aggregate' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'force-online' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'keep-same-uuid' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => ['ontap-c', 'ontap-d'],
            },
        },
        'outputs' => {
        },
    },
    'aggr-options-list-info' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'aggregate' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'options' => {
                'type' => 'aggr-option-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'aggr-rename' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'aggregate' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'new-aggregate-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'aggr-restrict' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'aggregate' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'cifs-delay-seconds' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => ['ontap-c'],
            },
            'unmount-volumes' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'aggr-scrub-list-info' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'aggregate' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'verbose' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'scrub-details' => {
                'type' => 'scrub-detail-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'aggr-scrub-resume' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'aggregate' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'aggr-scrub-start' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'aggregate' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'aggr-scrub-stop' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'aggregate' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'aggr-scrub-suspend' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'aggregate' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'aggr-set-option' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'aggregate' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'option-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'option-value' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'aggr-space-list-info' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'aggregate' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'aggregates' => {
                'type' => 'aggr-space-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'aggr-split' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'aggregate' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'new-aggr-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'aggr-verify-list-info' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'aggregate' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'verify-details' => {
                'type' => 'verify-detail-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'aggr-verify-resume' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'aggregate' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'aggr-verify-start' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'aggregate' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'fix-plex' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'log-only' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'aggr-verify-stop' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'aggregate' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'aggr-verify-suspend' => {
        'category' => 'aggr',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'aggregate' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'cf-force-takeover' => {
        'category' => 'cf',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'disaster' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => ['ontap-c'],
            },
        },
        'outputs' => {
        },
    },
    'cf-get-partner' => {
        'category' => 'cf',
        'family' => ['ontap-c', 'ontap-cluster', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'partner' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'cf-giveback' => {
        'category' => 'cf',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'cf-hwassist-stats' => {
        'category' => 'cf',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
        },
        'outputs' => {
            'hwassist-stats-abnormal-reboot' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'hwassist-stats-bad-nvram-id' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'hwassist-stats-keep-alive' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'hwassist-stats-loss-of-heartbeat' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'hwassist-stats-post-error' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'hwassist-stats-power-cycle-via-rlm' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'hwassist-stats-power-cycle-via-sp' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'hwassist-stats-power-loss' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'hwassist-stats-power-off-via-rlm' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'hwassist-stats-power-off-via-sp' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'hwassist-stats-reset-via-rlm' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'hwassist-stats-reset-via-sp' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'hwassist-stats-ss-mismatch' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'hwassist-stats-test' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'hwassist-stats-times-throttled' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'hwassist-stats-unknown-alerts' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'hwassist-stats-watchdog-reset' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'no-stats' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'cf-hwassist-status' => {
        'category' => 'cf',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
        },
        'outputs' => {
            'keep-alive-status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'local-hwassist-inactive-corrective-action' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'local-hwassist-inactive-reason' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'local-hwassist-ipaddr' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'local-hwassist-port' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'local-hwassist-status' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'no-status' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'partner-hwassist-inactive-corrective-action' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'partner-hwassist-inactive-reason' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'partner-hwassist-ipaddr' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'partner-hwassist-port' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'partner-hwassist-status' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'cf-negotiated-failover-disable' => {
        'category' => 'cf',
        'family' => ['ontap-c'],
        'inputs' => {
            'module' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'cf-negotiated-failover-enable' => {
        'category' => 'cf',
        'family' => ['ontap-c'],
        'inputs' => {
            'module' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'cf-negotiated-failover-status' => {
        'category' => 'cf',
        'family' => ['ontap-c'],
        'inputs' => {
            'module' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'is-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'cf-service-disable' => {
        'category' => 'cf',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'cf-service-enable' => {
        'category' => 'cf',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'cf-status' => {
        'category' => 'cf',
        'family' => ['ontap-c', 'ontap-cluster', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'current-mode' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'current-time' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'is-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-interconnect-up' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'local-in-headswap' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => ['ontap-c', 'ontap-cluster'],
            },
            'new-partner-sysid' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => ['ontap-c', 'ontap-cluster'],
            },
            'node-state' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'partner' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'partner-in-headswap' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => ['ontap-c', 'ontap-cluster'],
            },
            'state' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'takeover-failure-reason' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'time-until-takeover' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'cf-takeover' => {
        'category' => 'cf',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'cg-commit' => {
        'category' => 'cg',
        'family' => ['ontap-c', 'ontap-d', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'cg-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'cg-delete' => {
        'category' => 'cg',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'snapshot' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volumes' => {
                'type' => 'volume-name',
                'flags' => 2,
                'scope' => ['ontap-c'],
            },
        },
        'outputs' => {
        },
    },
    'cg-start' => {
        'category' => 'cg',
        'family' => ['ontap-c', 'ontap-d', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'snapshot' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'timeout' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volumes' => {
                'type' => 'volume-name',
                'flags' => 2,
                'scope' => ['ontap-c', 'ontap-vserver', 'vfiler'],
            },
        },
        'outputs' => {
            'cg-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'cifs-branchcache-hash-stat' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'include-filesize-stats' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'include-flush-stats' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'filesize-more-than-100mb' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'filesize-range-0kb-to-10kb' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'filesize-range-100kb-to-250kb' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'filesize-range-10kb-to-100kb' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'filesize-range-10mb-to-100mb' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'filesize-range-1mb-to-10mb' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'filesize-range-250kb-to-1mb' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'hashes-flashed-post-fifth-timeout' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'hashes-flashed-post-first-timeout' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'hashes-flashed-post-fourth-timeout' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'hashes-flashed-post-second-timeout' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'hashes-flashed-post-third-timeout' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'cifs-branchcache-set-key' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'server-secret' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'cifs-homedir-path-get-for-user' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'user-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'homedir-path-user' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'cifs-homedir-paths-get' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'homedir-paths' => {
                'type' => 'homedir-path-info',
                'flags' => 6,
                'scope' => [],
            },
        },
    },
    'cifs-homedir-paths-set' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'homedir-paths' => {
                'type' => 'homedir-path-info',
                'flags' => 6,
                'scope' => [],
            },
        },
        'outputs' => {
            'path-error' => {
                'type' => 'path-error-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'cifs-list-config' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'AD-site' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'DC-connection' => {
                'type' => 'connection-info',
                'flags' => 7,
                'scope' => [],
            },
            'DNS-domainname' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'LDAP-connection' => {
                'type' => 'connection-info',
                'flags' => 7,
                'scope' => [],
            },
            'NetBIOS-domainname' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'NetBIOS-servername' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'Windows-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'auth-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'domain-controller-functionality' => {
                'type' => 'cifs-functional-level',
                'flags' => 4,
                'scope' => [],
            },
            'domain-functionality' => {
                'type' => 'cifs-functional-level',
                'flags' => 4,
                'scope' => [],
            },
            'forest-functionality' => {
                'type' => 'cifs-functional-level',
                'flags' => 4,
                'scope' => [],
            },
            'security-style' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'cifs-nbalias-names-get' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'nbalias-names' => {
                'type' => 'nbalias-name-info',
                'flags' => 6,
                'scope' => [],
            },
        },
    },
    'cifs-nbalias-names-set' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'nbalias-names' => {
                'type' => 'nbalias-name-info',
                'flags' => 6,
                'scope' => [],
            },
        },
    },
    'cifs-session-list-iter-end' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'cifs-session-list-iter-next' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'maximum' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'cifs-sessions' => {
                'type' => 'cifs-session-info',
                'flags' => 3,
                'scope' => [],
            },
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'cifs-session-list-iter-start' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'host' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'protocol' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'user' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'cifs-setup' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'auth-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'domain-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'login-password' => {
                'type' => 'string',
                'flags' => 12,
                'scope' => [],
            },
            'login-user' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'ou-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'pdc-ip-address' => {
                'type' => 'ip-address',
                'flags' => 4,
                'scope' => [],
            },
            'security-style' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'server-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'site-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'cifs-setup-create-group-file' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'cifs-setup-create-passwd-file' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'default-root-password' => {
                'type' => 'string',
                'flags' => 8,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'cifs-setup-ou-list-iter-end' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'cifs-setup-ou-list-iter-next' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'maximum' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'cifs-setup-ous' => {
                'type' => 'cifs-setup-ou',
                'flags' => 2,
                'scope' => [],
            },
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'cifs-setup-ou-list-iter-start' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'domain-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'login-password' => {
                'type' => 'string',
                'flags' => 8,
                'scope' => [],
            },
            'login-user' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'cifs-setup-site-list-iter-end' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'cifs-setup-site-list-iter-next' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'maximum' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'cifs-setup-sites' => {
                'type' => 'cifs-setup-site',
                'flags' => 2,
                'scope' => [],
            },
            'default-site' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'cifs-setup-site-list-iter-start' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'domain-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'login-password' => {
                'type' => 'string',
                'flags' => 8,
                'scope' => [],
            },
            'login-user' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'default-site' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'cifs-setup-verify-name' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'auth-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'domain-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'login-password' => {
                'type' => 'string',
                'flags' => 12,
                'scope' => [],
            },
            'login-user' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'pdc-ip-address' => {
                'type' => 'ip-address',
                'flags' => 4,
                'scope' => [],
            },
            'server-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'is-in-domain' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-in-use' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'cifs-setup-verify-passwd-and-group' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'group-file-exists' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'passwd-file-exists' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'required' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'cifs-share-ace-delete' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'is-unixgroup' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'share-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'unix-group-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'user-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'cifs-share-ace-set' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'access-rights' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'is-unixgroup' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'share-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'unix-group-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'user-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'cifs-share-acl-list-iter-end' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'cifs-share-acl-list-iter-next' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'maximum' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'cifs-share-acls' => {
                'type' => 'cifs-share-acl-info',
                'flags' => 3,
                'scope' => [],
            },
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'cifs-share-acl-list-iter-start' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'share-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'cifs-share-add' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'caching' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'comment' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'dir-umask' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'file-umask' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'forcegroup' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'is-access-based-enum' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-browse' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-namespace-caching-allowed' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-symlink-strict-security' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-vscan' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-vscanread' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-widelink' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'maxusers' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'share-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'umask' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'cifs-share-change' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'caching' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'comment' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'dir-umask' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'file-umask' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'forcegroup' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'is-access-based-enum' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-browse' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-namespace-caching-allowed' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-symlink-strict-security' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-vscan' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-vscanread' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-widelink' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'maxusers' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'share-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'umask' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'cifs-share-delete' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'share-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'cifs-share-list-iter-end' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'cifs-share-list-iter-next' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'maximum' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'cifs-shares' => {
                'type' => 'cifs-share-info',
                'flags' => 3,
                'scope' => [],
            },
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'cifs-share-list-iter-start' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'share-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'cifs-start' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'cifs-status' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'cifs-stop' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'workstation' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'cifs-top-iter-end' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'cifs-top-iter-next' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'maximum' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'cifs-top' => {
                'type' => 'cifs-top-info',
                'flags' => 3,
                'scope' => [],
            },
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'cifs-top-iter-start' => {
        'category' => 'cifs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'avgtype' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'maxclients' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'sortgroup' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'clock-get-clock' => {
        'category' => 'clock',
        'family' => ['ontap-c'],
        'inputs' => {
            'is-compliance-clock' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'local-time' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'utc-time' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'clock-get-timezone' => {
        'category' => 'clock',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-vserver'],
        'inputs' => {
        },
        'outputs' => {
            'timezone' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'timezone-UTC' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'timezone-version' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'clock-set-clock' => {
        'category' => 'clock',
        'family' => ['ontap-c'],
        'inputs' => {
            'is-utc-clock' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'time' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'clock-set-timezone' => {
        'category' => 'clock',
        'family' => ['ontap-c'],
        'inputs' => {
            'timezone' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'clone-clear' => {
        'category' => 'clone',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'clone-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'clone-list-status' => {
        'category' => 'clone',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'clone-id' => {
                'type' => 'clone-id-info',
                'flags' => 5,
                'scope' => [],
            },
        },
        'outputs' => {
            'status' => {
                'type' => 'ops-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'clone-start' => {
        'category' => 'clone',
        'family' => ['ontap-c', 'ontap-d', 'vfiler'],
        'inputs' => {
            'block-ranges' => {
                'type' => 'block-range',
                'flags' => 7,
                'scope' => [],
            },
            'change-log' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'destination-path' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'ignore-locks' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'ignore-streams' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'no-snap' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'snapshot-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'source-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'space-reserve' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'clone-id' => {
                'type' => 'clone-id-info',
                'flags' => 1,
                'scope' => [],
            },
        },
    },
    'clone-stop' => {
        'category' => 'clone',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'clone-id' => {
                'type' => 'clone-id-info',
                'flags' => 1,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'copyoffload-copy-abort' => {
        'category' => 'copyoffload',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'copy-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'bytes-copied' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'copyoffload-copy-start' => {
        'category' => 'copyoffload',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'destination-offset' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'destination-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'length' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'source-offset' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'source-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'copy-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'copyoffload-copy-status' => {
        'category' => 'copyoffload',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'copy-id' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'copy-status' => {
                'type' => 'copyoffload-status-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'copyoffload-modify' => {
        'category' => 'copyoffload',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'copyoffload-state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'copyoffload-show' => {
        'category' => 'copyoffload',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'copyoffload-state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'dfm-get-server-info' => {
        'category' => 'dfm',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'dfm-server' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'is-dfm-cross-linked' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'port' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'protocol' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'dfm-set-server-info' => {
        'category' => 'dfm',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'dfm-server' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-dfm-cross-linked' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'port' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'protocol' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'diagnosis-alert-definition-get' => {
        'category' => 'diagnosis',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'alert-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'desired-attributes' => {
                'type' => 'diagnosis-alert-definition-info',
                'flags' => 5,
                'scope' => [],
            },
            'monitor' => {
                'type' => 'hm-type',
                'flags' => 0,
                'scope' => [],
            },
            'node' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'attributes' => {
                'type' => 'diagnosis-alert-definition-info',
                'flags' => 1,
                'scope' => [],
            },
        },
    },
    'diagnosis-alert-definition-get-iter' => {
        'category' => 'diagnosis',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'desired-attributes' => {
                'type' => 'diagnosis-alert-definition-info',
                'flags' => 5,
                'scope' => [],
            },
            'max-records' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'query' => {
                'type' => 'diagnosis-alert-definition-info',
                'flags' => 5,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'attributes-list' => {
                'type' => 'diagnosis-alert-definition-info',
                'flags' => 7,
                'scope' => [],
            },
            'next-tag' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'num-records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'diagnosis-alert-get' => {
        'category' => 'diagnosis',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'alert-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'alerting-resource' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'desired-attributes' => {
                'type' => 'diagnosis-alert-info',
                'flags' => 5,
                'scope' => [],
            },
            'monitor' => {
                'type' => 'hm-type',
                'flags' => 0,
                'scope' => [],
            },
            'node' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'attributes' => {
                'type' => 'diagnosis-alert-info',
                'flags' => 1,
                'scope' => [],
            },
        },
    },
    'diagnosis-alert-get-iter' => {
        'category' => 'diagnosis',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'desired-attributes' => {
                'type' => 'diagnosis-alert-info',
                'flags' => 5,
                'scope' => [],
            },
            'max-records' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'query' => {
                'type' => 'diagnosis-alert-info',
                'flags' => 5,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'attributes-list' => {
                'type' => 'diagnosis-alert-info',
                'flags' => 7,
                'scope' => [],
            },
            'next-tag' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'num-records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'diagnosis-alert-modify' => {
        'category' => 'diagnosis',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'acknowledge' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'acknowledger' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'alert-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'alerting-resource' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'monitor' => {
                'type' => 'hm-type',
                'flags' => 0,
                'scope' => [],
            },
            'node' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'suppress' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'suppressor' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'diagnosis-config-get' => {
        'category' => 'diagnosis',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'desired-attributes' => {
                'type' => 'diagnosis-config-info',
                'flags' => 5,
                'scope' => [],
            },
            'monitor' => {
                'type' => 'hm-type',
                'flags' => 0,
                'scope' => [],
            },
            'node' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'attributes' => {
                'type' => 'diagnosis-config-info',
                'flags' => 1,
                'scope' => [],
            },
        },
    },
    'diagnosis-config-get-iter' => {
        'category' => 'diagnosis',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'desired-attributes' => {
                'type' => 'diagnosis-config-info',
                'flags' => 5,
                'scope' => [],
            },
            'max-records' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'query' => {
                'type' => 'diagnosis-config-info',
                'flags' => 5,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'attributes-list' => {
                'type' => 'diagnosis-config-info',
                'flags' => 7,
                'scope' => [],
            },
            'next-tag' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'num-records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'diagnosis-delete-alert' => {
        'category' => 'diagnosis',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'alert-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'alerting-resource' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'monitor' => {
                'type' => 'hm-type',
                'flags' => 0,
                'scope' => [],
            },
            'node' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'diagnosis-policy-definition-get' => {
        'category' => 'diagnosis',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'desired-attributes' => {
                'type' => 'diagnosis-policy-definition-info',
                'flags' => 5,
                'scope' => [],
            },
            'monitor' => {
                'type' => 'hm-type',
                'flags' => 0,
                'scope' => [],
            },
            'node' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'policy-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'attributes' => {
                'type' => 'diagnosis-policy-definition-info',
                'flags' => 1,
                'scope' => [],
            },
        },
    },
    'diagnosis-policy-definition-get-iter' => {
        'category' => 'diagnosis',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'desired-attributes' => {
                'type' => 'diagnosis-policy-definition-info',
                'flags' => 5,
                'scope' => [],
            },
            'max-records' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'query' => {
                'type' => 'diagnosis-policy-definition-info',
                'flags' => 5,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'attributes-list' => {
                'type' => 'diagnosis-policy-definition-info',
                'flags' => 7,
                'scope' => [],
            },
            'next-tag' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'num-records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'diagnosis-policy-modify' => {
        'category' => 'diagnosis',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'enable' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'monitor' => {
                'type' => 'hm-type',
                'flags' => 0,
                'scope' => [],
            },
            'node' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'policy-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'diagnosis-status-get' => {
        'category' => 'diagnosis',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'desired-attributes' => {
                'type' => 'diagnosis-status',
                'flags' => 5,
                'scope' => [],
            },
        },
        'outputs' => {
            'attributes' => {
                'type' => 'diagnosis-status',
                'flags' => 1,
                'scope' => [],
            },
        },
    },
    'diagnosis-subscriptions-create' => {
        'category' => 'diagnosis',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'class-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'event-type' => {
                'type' => 'hm-event-type',
                'flags' => 0,
                'scope' => [],
            },
            'fail-thresh' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'instance-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'max-notify-period' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'monitor' => {
                'type' => 'hm-type',
                'flags' => 0,
                'scope' => [],
            },
            'node' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'notify-dest-hm' => {
                'type' => 'hm-type',
                'flags' => 0,
                'scope' => [],
            },
            'notify-dest-node' => {
                'type' => 'node-name',
                'flags' => 0,
                'scope' => [],
            },
            'notify-table' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'psc-option' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'return-record' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'subscription-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'time-gap-notify' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'result' => {
                'type' => 'diagnosis-subscriptions-info',
                'flags' => 5,
                'scope' => [],
            },
        },
    },
    'diagnosis-subscriptions-get' => {
        'category' => 'diagnosis',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'class-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'desired-attributes' => {
                'type' => 'diagnosis-subscriptions-info',
                'flags' => 5,
                'scope' => [],
            },
            'event-type' => {
                'type' => 'hm-event-type',
                'flags' => 0,
                'scope' => [],
            },
            'monitor' => {
                'type' => 'hm-type',
                'flags' => 0,
                'scope' => [],
            },
            'node' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'notify-dest-hm' => {
                'type' => 'hm-type',
                'flags' => 0,
                'scope' => [],
            },
            'notify-dest-node' => {
                'type' => 'node-name',
                'flags' => 0,
                'scope' => [],
            },
            'subscription-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'attributes' => {
                'type' => 'diagnosis-subscriptions-info',
                'flags' => 1,
                'scope' => [],
            },
        },
    },
    'diagnosis-subscriptions-get-iter' => {
        'category' => 'diagnosis',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'desired-attributes' => {
                'type' => 'diagnosis-subscriptions-info',
                'flags' => 5,
                'scope' => [],
            },
            'max-records' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'query' => {
                'type' => 'diagnosis-subscriptions-info',
                'flags' => 5,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'attributes-list' => {
                'type' => 'diagnosis-subscriptions-info',
                'flags' => 7,
                'scope' => [],
            },
            'next-tag' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'num-records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'diagnosis-subscriptions-modify' => {
        'category' => 'diagnosis',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'class-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'event-type' => {
                'type' => 'hm-event-type',
                'flags' => 0,
                'scope' => [],
            },
            'fail-thresh' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'instance-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'max-notify-period' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'monitor' => {
                'type' => 'hm-type',
                'flags' => 0,
                'scope' => [],
            },
            'node' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'notify-dest-hm' => {
                'type' => 'hm-type',
                'flags' => 0,
                'scope' => [],
            },
            'notify-dest-node' => {
                'type' => 'node-name',
                'flags' => 0,
                'scope' => [],
            },
            'notify-table' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'psc-option' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'subscription-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'time-gap-notify' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'diagnosis-subsystem-config-get' => {
        'category' => 'diagnosis',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'desired-attributes' => {
                'type' => 'diagnosis-subsystem-config-info',
                'flags' => 5,
                'scope' => [],
            },
            'subsystem' => {
                'type' => 'hm-subsystem',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'attributes' => {
                'type' => 'diagnosis-subsystem-config-info',
                'flags' => 1,
                'scope' => [],
            },
        },
    },
    'diagnosis-subsystem-config-get-iter' => {
        'category' => 'diagnosis',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'desired-attributes' => {
                'type' => 'diagnosis-subsystem-config-info',
                'flags' => 5,
                'scope' => [],
            },
            'max-records' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'query' => {
                'type' => 'diagnosis-subsystem-config-info',
                'flags' => 5,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'attributes-list' => {
                'type' => 'diagnosis-subsystem-config-info',
                'flags' => 7,
                'scope' => [],
            },
            'next-tag' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'num-records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'disk-fail' => {
        'category' => 'disk',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'disk' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'is-immediate' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'disk-list-info' => {
        'category' => 'disk',
        'family' => ['ontap-c', 'ontap-d', 'vfiler'],
        'inputs' => {
            'disk' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'ownership-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'disk-details' => {
                'type' => 'disk-detail-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'disk-release-all-reservations' => {
        'category' => 'disk',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'disk-remove' => {
        'category' => 'disk',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'disk' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'disk-replace-start' => {
        'category' => 'disk',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'allow-same-carrier' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'disk' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'replacement-disk' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'disk-replace-stop' => {
        'category' => 'disk',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'disk' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'disk-sanown-assign' => {
        'category' => 'disk',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'all' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'auto' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'checksum' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'disk' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'disk-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'disk-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'node-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'owner' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'owner-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'pool' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'disk-sanown-filer-list-info' => {
        'category' => 'disk',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
        },
        'outputs' => {
            'disk-sanown-filer-details' => {
                'type' => 'disk-sanown-filer-detail-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'disk-sanown-list-info' => {
        'category' => 'disk',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'disk' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'ownership-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'disk-sanown-details' => {
                'type' => 'disk-sanown-detail-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'disk-sanown-reassign' => {
        'category' => 'disk',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'new-owner' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'new-owner-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'old-owner' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'old-owner-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'disk-sanown-remove-ownership' => {
        'category' => 'disk',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'all' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'disk-list' => {
                'type' => 'disk-name',
                'flags' => 6,
                'scope' => [],
            },
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'owner' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'owner-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'disk-swap' => {
        'category' => 'disk',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'disk-unfail' => {
        'category' => 'disk',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'disk' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'make-spare' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'disk-unswap' => {
        'category' => 'disk',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'disk-update-disk-fw' => {
        'category' => 'disk',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'disk-list' => {
                'type' => 'disk-name',
                'flags' => 6,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'disk-zero-spares' => {
        'category' => 'disk',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'ems-autosupport-log' => {
        'category' => 'ems',
        'family' => ['ontap-c', 'ontap-d', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'app-version' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'auto-support' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'category' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'computer-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'event-description' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'event-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'event-source' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'log-level' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'ems-invoke' => {
        'category' => 'ems',
        'family' => [],
        'inputs' => {
            'event-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'event-version' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'params' => {
                'type' => 'param',
                'flags' => 6,
                'scope' => [],
            },
            'severity' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'snmp' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'syslog' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fc-config-adapter-disable' => {
        'category' => 'fc',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'adapter-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fc-config-adapter-enable' => {
        'category' => 'fc',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'adapter-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fc-config-list-iter-end' => {
        'category' => 'fc',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fc-config-list-iter-next' => {
        'category' => 'fc',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'maximum' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'adapter-info' => {
                'type' => 'fc-config-info',
                'flags' => 3,
                'scope' => [],
            },
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'fc-config-list-iter-start' => {
        'category' => 'fc',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
        },
        'outputs' => {
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'fc-config-set-adapter-fc-type' => {
        'category' => 'fc',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'adapter-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'fc-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fcp-adapter-clear-partner' => {
        'category' => 'fcp',
        'family' => ['ontap-c'],
        'inputs' => {
            'fcp-adapter' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fcp-adapter-config-down' => {
        'category' => 'fcp',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'fcp-adapter' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fcp-adapter-config-media-type' => {
        'category' => 'fcp',
        'family' => ['ontap-c'],
        'inputs' => {
            'fcp-adapter' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'media-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fcp-adapter-config-up' => {
        'category' => 'fcp',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'fcp-adapter' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fcp-adapter-initiators-list-info' => {
        'category' => 'fcp',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'fcp-adapter' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'fcp-adapters' => {
                'type' => 'fcp-adapter-initiators-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'fcp-adapter-list-info' => {
        'category' => 'fcp',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'fcp-adapter' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'partner-only' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'verbose' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'fcp-config-adapters' => {
                'type' => 'fcp-config-adapter-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'fcp-adapter-nameserver-list-iter-end' => {
        'category' => 'fcp',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fcp-adapter-nameserver-list-iter-next' => {
        'category' => 'fcp',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'maximum' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'fcp-adapter-nameserver-objects' => {
                'type' => 'fcp-adapter-nameserver-object-info',
                'flags' => 3,
                'scope' => [],
            },
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'fcp-adapter-nameserver-list-iter-start' => {
        'category' => 'fcp',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'fcp-adapter' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'zoned' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'fcp-adapter-reset-stats' => {
        'category' => 'fcp',
        'family' => ['ontap-c'],
        'inputs' => {
            'fcp-adapter' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fcp-adapter-set-partner' => {
        'category' => 'fcp',
        'family' => ['ontap-c'],
        'inputs' => {
            'fcp-adapter' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'partner-adapter' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fcp-adapter-set-speed' => {
        'category' => 'fcp',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'fcp-adapter' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'speed' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fcp-adapter-stats-list-info' => {
        'category' => 'fcp',
        'family' => ['ontap-c'],
        'inputs' => {
            'fcp-adapter' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'fcp-adapter-stats' => {
                'type' => 'fcp-adapter-stats-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'fcp-adapter-topology-list-iter-end' => {
        'category' => 'fcp',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fcp-adapter-topology-list-iter-next' => {
        'category' => 'fcp',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'maximum' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'fcp-adapter-topology-switches' => {
                'type' => 'fcp-adapter-topology-switch-info',
                'flags' => 3,
                'scope' => [],
            },
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'fcp-adapter-topology-list-iter-start' => {
        'category' => 'fcp',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'fcp-adapter' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'verbose' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'zoned' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'fcp-adapter-zone-list-iter-end' => {
        'category' => 'fcp',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fcp-adapter-zone-list-iter-next' => {
        'category' => 'fcp',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'maximum' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'fcp-adapter-zones' => {
                'type' => 'fcp-adapter-zone-info',
                'flags' => 3,
                'scope' => [],
            },
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'fcp-adapter-zone-list-iter-start' => {
        'category' => 'fcp',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'fcp-adapter' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'fcp-get-cfmode' => {
        'category' => 'fcp',
        'family' => ['ontap-c'],
        'inputs' => {
        },
        'outputs' => {
            'fcp-cfmode' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'fcp-node-get-name' => {
        'category' => 'fcp',
        'family' => ['ontap-c', 'ontap-vserver'],
        'inputs' => {
        },
        'outputs' => {
            'node-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'fcp-node-set-name' => {
        'category' => 'fcp',
        'family' => ['ontap-c', 'ontap-vserver'],
        'inputs' => {
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'node-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fcp-ping' => {
        'category' => 'fcp',
        'family' => ['ontap-c'],
        'inputs' => {
            'fcp-adapter' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'payload' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'port-id-or-wwpn' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fcp-ping-info' => {
        'category' => 'fcp',
        'family' => ['ontap-c'],
        'inputs' => {
            'fcp-adapter' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'payload' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'ping-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'port-id-or-wwpn' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'frames-received' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'frames-transmitted' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'round-trip-maximum-time' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'round-trip-mean-time' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'round-trip-minimum-time' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'fcp-port-name-list-info' => {
        'category' => 'fcp',
        'family' => ['ontap-c'],
        'inputs' => {
            'verbose' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'fcp-port-names' => {
                'type' => 'fcp-port-name-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'fcp-port-name-set' => {
        'category' => 'fcp',
        'family' => ['ontap-c', 'ontap-vserver'],
        'inputs' => {
            'fcp-adapter' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'port-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fcp-port-name-swap' => {
        'category' => 'fcp',
        'family' => ['ontap-c'],
        'inputs' => {
            'fcp-adapter-1' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'fcp-adapter-2' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fcp-service-start' => {
        'category' => 'fcp',
        'family' => ['ontap-c', 'ontap-vserver'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'fcp-service-status' => {
        'category' => 'fcp',
        'family' => ['ontap-c', 'ontap-vserver'],
        'inputs' => {
        },
        'outputs' => {
            'is-available' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'fcp-service-stop' => {
        'category' => 'fcp',
        'family' => ['ontap-c', 'ontap-vserver'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'fcp-set-cfmode' => {
        'category' => 'fcp',
        'family' => ['ontap-c'],
        'inputs' => {
            'fcp-cfmode' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fcp-wwpnalias-get-alias-info' => {
        'category' => 'fcp',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'alias' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'wwpn' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'aliases' => {
                'type' => 'aliases-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'fcp-wwpnalias-remove' => {
        'category' => 'fcp',
        'family' => ['ontap-c', 'ontap-vserver'],
        'inputs' => {
            'alias' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'wwpn' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fcp-wwpnalias-set' => {
        'category' => 'fcp',
        'family' => ['ontap-c', 'ontap-vserver'],
        'inputs' => {
            'alias' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'wwpn' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fcport-get-link-state' => {
        'category' => 'fcport',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'adapter-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'adapter-link-state' => {
                'type' => 'link-state-info',
                'flags' => 3,
                'scope' => [],
            },
            'adapter-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'fcport-reset-dev' => {
        'category' => 'fcport',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'device-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fcport-send-lip' => {
        'category' => 'fcport',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'loop-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fcport-set-offline' => {
        'category' => 'fcport',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'adapter-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fcport-set-online' => {
        'category' => 'fcport',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'adapter-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'feature-status-list-info' => {
        'category' => 'feature',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d', 'ontap-vserver'],
        'inputs' => {
        },
        'outputs' => {
            'managed-feature-status-list' => {
                'type' => 'managed-feature-status-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'file-create-directory' => {
        'category' => 'file',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'perm' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'file-create-symlink' => {
        'category' => 'file',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'symlink' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'file-delete-directory' => {
        'category' => 'file',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'file-delete-file' => {
        'category' => 'file',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'file-get-file-info' => {
        'category' => 'file',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'file-info' => {
                'type' => 'file-info',
                'flags' => 1,
                'scope' => [],
            },
        },
    },
    'file-get-fingerprint' => {
        'category' => 'file',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'fingerprint-algorithm' => {
                'type' => 'digest-algorithm',
                'flags' => 0,
                'scope' => [],
            },
            'fingerprint-scope' => {
                'type' => 'file-scope',
                'flags' => 0,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'fingerprint' => {
                'type' => 'fingerprint-info',
                'flags' => 1,
                'scope' => [],
            },
        },
    },
    'file-get-space-reservation-info' => {
        'category' => 'file',
        'family' => ['ontap-c', 'ontap-d', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'is-fill-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-overwrite-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'file-inode-info' => {
        'category' => 'file',
        'family' => ['ontap-c', 'ontap-d', 'vfiler'],
        'inputs' => {
            'encoded' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'generation' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'inode-number' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'logical-snap-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'report-cifs-paths' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'report-leaf-name' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'report-no-pathname' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'report-other-parents' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'report-parent-data' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'snap-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'snap-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume-dsid' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume-fsid' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'volume-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume-uuid' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'inode-number' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'inode-paths' => {
                'type' => 'inode-parent-info',
                'flags' => 3,
                'scope' => [],
            },
            'logical-snap-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'number-of-parents' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'snapshot-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'snapshot-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume-dsid' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume-fsid' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'volume-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume-uuid' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'file-list-directory-iter-end' => {
        'category' => 'file',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'file-list-directory-iter-next' => {
        'category' => 'file',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'maximum' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'files' => {
                'type' => 'file-info',
                'flags' => 3,
                'scope' => [],
            },
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'file-list-directory-iter-start' => {
        'category' => 'file',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'encoded' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'file-punch-hole' => {
        'category' => 'file',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'hole-info' => {
                'type' => 'hole-range-info',
                'flags' => 3,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'file-read-file' => {
        'category' => 'file',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'length' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'offset' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'data' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'length' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'file-read-symlink' => {
        'category' => 'file',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'symlink' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'file-rename-directory' => {
        'category' => 'file',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'from-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'to-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'file-set-space-reservation-info' => {
        'category' => 'file',
        'family' => ['ontap-c', 'ontap-d', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'is-fill-enabled' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-overwrite-enabled' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'file-truncate-file' => {
        'category' => 'file',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'size' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'file-usage-get' => {
        'category' => 'file',
        'family' => ['ontap-c', 'ontap-d', 'ontap-vserver'],
        'inputs' => {
            'length' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'start-offset' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'total-bytes' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'unique-bytes' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'file-usage-result-get' => {
        'category' => 'file',
        'family' => ['ontap-c', 'ontap-d', 'ontap-vserver'],
        'inputs' => {
            'cookie' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'total-bytes' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'unique-bytes' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'file-usage-start' => {
        'category' => 'file',
        'family' => ['ontap-c', 'ontap-d', 'ontap-vserver'],
        'inputs' => {
            'length' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'start-offset' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'cookie' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'file-write-file' => {
        'category' => 'file',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'data' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'offset' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'overwrite' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'length' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'flash-device-list-info' => {
        'category' => 'flash',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'slot-number' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'flash-device-info' => {
                'type' => 'flash-device-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'flash-get-thresholds' => {
        'category' => 'flash',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'profile' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'flash-threshold-profile' => {
                'type' => 'flash-threshold-profile',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'fpolicy-create-policy' => {
        'category' => 'fpolicy',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'policy-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'policy-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fpolicy-destroy-policy' => {
        'category' => 'fpolicy',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'policy-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fpolicy-disable' => {
        'category' => 'fpolicy',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'fpolicy-disable-policy' => {
        'category' => 'fpolicy',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'policy-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fpolicy-enable' => {
        'category' => 'fpolicy',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'fpolicy-enable-policy' => {
        'category' => 'fpolicy',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'policy-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fpolicy-extensions' => {
        'category' => 'fpolicy',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'command' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'extensions' => {
                'type' => 'extension-list-info',
                'flags' => 7,
                'scope' => [],
            },
            'policy-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'set-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fpolicy-extensions-list-info' => {
        'category' => 'fpolicy',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'policy-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'exclude-extensions' => {
                'type' => 'extension-list-info',
                'flags' => 3,
                'scope' => [],
            },
            'include-extensions' => {
                'type' => 'extension-list-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'fpolicy-get-policy-options' => {
        'category' => 'fpolicy',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'policy-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'is-ads-monitored' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-cifs-disconnect-check-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-cifs-setattr-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-required' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'reqcancel-timeout' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'secondary-servers' => {
                'type' => 'secondary-server-info',
                'flags' => 3,
                'scope' => [],
            },
            'serverprogress-timeout' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'fpolicy-get-required-info' => {
        'category' => 'fpolicy',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'policy-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'is-required' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'fpolicy-get-secondary-servers-info' => {
        'category' => 'fpolicy',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'policy-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'secondary-servers' => {
                'type' => 'secondary-server-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'fpolicy-list-info' => {
        'category' => 'fpolicy',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'policy-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'policies' => {
                'type' => 'policy-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'fpolicy-operations-list-set' => {
        'category' => 'fpolicy',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'monitored-operations' => {
                'type' => 'monitored-operation-info',
                'flags' => 3,
                'scope' => [],
            },
            'monitored-protocols' => {
                'type' => 'monitored-protocol-info',
                'flags' => 3,
                'scope' => [],
            },
            'offline-only' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'policy-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fpolicy-server-list-info' => {
        'category' => 'fpolicy',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'policy-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'servers' => {
                'type' => 'server-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'fpolicy-server-stop' => {
        'category' => 'fpolicy',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'policy-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'server-ip' => {
                'type' => 'ip-address',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fpolicy-set-policy-options' => {
        'category' => 'fpolicy',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'is-ads-monitored' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-cifs-disconnect-check-enabled' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-cifs-setattr-enabled' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-required' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'policy-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'reqcancel-timeout' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'secondary-servers' => {
                'type' => 'secondary-server-info',
                'flags' => 7,
                'scope' => [],
            },
            'serverprogress-timeout' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fpolicy-set-required' => {
        'category' => 'fpolicy',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'policy-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'required' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fpolicy-set-secondary-servers' => {
        'category' => 'fpolicy',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'policy-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'secondary-servers' => {
                'type' => 'secondary-server-info',
                'flags' => 3,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'fpolicy-status' => {
        'category' => 'fpolicy',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'is-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'fpolicy-volume-list-info' => {
        'category' => 'fpolicy',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'policy-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'exclude-volumes' => {
                'type' => 'fpolicy-volumes-list-info',
                'flags' => 3,
                'scope' => [],
            },
            'include-volumes' => {
                'type' => 'fpolicy-volumes-list-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'fpolicy-volume-list-set' => {
        'category' => 'fpolicy',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'list-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'policy-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volumes' => {
                'type' => 'fpolicy-volumes-list-info',
                'flags' => 3,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'ic-config-show' => {
        'category' => 'ic',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
        },
        'outputs' => {
            'ic-config-details' => {
                'type' => 'ic-config-details',
                'flags' => 1,
                'scope' => [],
            },
        },
    },
    'ic-get-error-stats' => {
        'category' => 'ic',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'verbose' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'active-logical-link' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'nvram-hardware-error-stats' => {
                'type' => 'ic-counter',
                'flags' => 7,
                'scope' => [],
            },
            'nvram-hardware-perf-stats' => {
                'type' => 'ic-counter',
                'flags' => 7,
                'scope' => [],
            },
            'nvram-per-port-counters' => {
                'type' => 'nvram-per-port-counters-info',
                'flags' => 7,
                'scope' => [],
            },
            'nvram-software-counters' => {
                'type' => 'ic-counter',
                'flags' => 7,
                'scope' => [],
            },
            'peer-connect-stats' => {
                'type' => 'ic-counter',
                'flags' => 3,
                'scope' => [],
            },
            'per-link-parameters' => {
                'type' => 'per-link-parameters-info',
                'flags' => 7,
                'scope' => [],
            },
            'sfo-connection-state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'sfo-nic-used' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'ic-get-infiniband-hw-stats' => {
        'category' => 'ic',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
        },
        'outputs' => {
            'context-stats' => {
                'type' => 'ic-counter',
                'flags' => 3,
                'scope' => [],
            },
            'doorbell-stats' => {
                'type' => 'ic-counter',
                'flags' => 3,
                'scope' => [],
            },
            'overflow-stats' => {
                'type' => 'ic-counter',
                'flags' => 3,
                'scope' => [],
            },
            'packet-stats' => {
                'type' => 'ic-counter',
                'flags' => 3,
                'scope' => [],
            },
            'remote-abort-stats' => {
                'type' => 'ic-counter',
                'flags' => 3,
                'scope' => [],
            },
            'remote-ops-stats' => {
                'type' => 'ic-counter',
                'flags' => 3,
                'scope' => [],
            },
            'requester-stats' => {
                'type' => 'ic-counter',
                'flags' => 3,
                'scope' => [],
            },
            'responder-stats' => {
                'type' => 'ic-counter',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'ic-get-infiniband-port-stats' => {
        'category' => 'ic',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
        },
        'outputs' => {
            'port1-stats' => {
                'type' => 'ic-counter',
                'flags' => 3,
                'scope' => [],
            },
            'port2-stats' => {
                'type' => 'ic-counter',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'ic-get-perf-stats' => {
        'category' => 'ic',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
        },
        'outputs' => {
            'ic-perf-details' => {
                'type' => 'ic-counter',
                'flags' => 3,
                'scope' => [],
            },
            'virtual-interface-socket-stats' => {
                'type' => 'virtual-interface-socket-stat-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'ic-get-queue-info' => {
        'category' => 'ic',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'virtual-interface' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'recv-queue-info' => {
                'type' => 'queue-info',
                'flags' => 5,
                'scope' => [],
            },
            'send-queue-info' => {
                'type' => 'queue-info',
                'flags' => 5,
                'scope' => [],
            },
        },
    },
    'ic-reset-nic' => {
        'category' => 'ic',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'ic-reset-nic-auto-off' => {
        'category' => 'ic',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'ic-reset-nic-auto-on' => {
        'category' => 'ic',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'ic-zero-error-stats' => {
        'category' => 'ic',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'igroup-add' => {
        'category' => 'igroup',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'initiator' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-group-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'igroup-bind-portset' => {
        'category' => 'igroup',
        'family' => ['ontap-c', 'ontap-vserver'],
        'inputs' => {
            'initiator-group-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'portset-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'igroup-create' => {
        'category' => 'igroup',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'bind-portset' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'initiator-group-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-group-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'os-type' => {
                'type' => 'initiator-group-os-type',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'igroup-destroy' => {
        'category' => 'igroup',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'initiator-group-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'igroup-list-info' => {
        'category' => 'igroup',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'initiator-group-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'initiator-groups' => {
                'type' => 'initiator-group-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'igroup-lookup-lun' => {
        'category' => 'igroup',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'initiator-group-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'lun-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'igroup-remove' => {
        'category' => 'igroup',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'initiator' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-group-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'igroup-rename' => {
        'category' => 'igroup',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'initiator-group-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-group-new-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'igroup-set-attribute' => {
        'category' => 'igroup',
        'family' => ['ontap-c', 'ontap-vserver'],
        'inputs' => {
            'attribute' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'initiator-group-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'value' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'igroup-unbind-portset' => {
        'category' => 'igroup',
        'family' => ['ontap-c', 'ontap-vserver'],
        'inputs' => {
            'initiator-group-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'ipspace-list-info' => {
        'category' => 'ipspace',
        'family' => [],
        'inputs' => {
            'ipspace' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'ipspaces' => {
                'type' => 'ipspace-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'iscsi-adapter-config-down' => {
        'category' => 'iscsi',
        'family' => [],
        'inputs' => {
            'iscsi-adapter' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'iscsi-adapter-config-up' => {
        'category' => 'iscsi',
        'family' => [],
        'inputs' => {
            'iscsi-adapter' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'iscsi-adapter-initiators-list-info' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'iscsi-adapter' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'iscsi-adapters' => {
                'type' => 'iscsi-adapter-initiators-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'iscsi-adapter-list-info' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'iscsi-adapter' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'iscsi-config-adapters' => {
                'type' => 'iscsi-config-adapter-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'iscsi-adapter-reset-stats' => {
        'category' => 'iscsi',
        'family' => [],
        'inputs' => {
            'iscsi-adapter' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'iscsi-adapter-stats-list-info' => {
        'category' => 'iscsi',
        'family' => [],
        'inputs' => {
            'iscsi-adapter' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'iscsi-auth-generate-chap-password' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'secret' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'iscsi-connection-list-info' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'iscsi-connection-list-entries' => {
                'type' => 'iscsi-connection-list-entry-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'iscsi-initiator-add-auth' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'auth-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'initiator' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'outbound-password' => {
                'type' => 'string',
                'flags' => 12,
                'scope' => [],
            },
            'outbound-user-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'password' => {
                'type' => 'string',
                'flags' => 12,
                'scope' => [],
            },
            'radius' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'user-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'iscsi-initiator-auth-list-info' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'initiator' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'iscsi-security-entries' => {
                'type' => 'iscsi-security-entry-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'iscsi-initiator-delete-auth' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'initiator' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'iscsi-initiator-get-auth' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'initiator' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'auth-chap-policy' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'auth-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'outbound-user-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'user-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'iscsi-initiator-get-default-auth' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'auth-chap-policy' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'auth-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'outbound-user-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'user-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'iscsi-initiator-list-info' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'iscsi-initiator-list-entries' => {
                'type' => 'iscsi-initiator-list-entry-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'iscsi-initiator-modify-chap-params' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'initiator' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'outbound-password' => {
                'type' => 'string',
                'flags' => 12,
                'scope' => [],
            },
            'outbound-user-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'password' => {
                'type' => 'string',
                'flags' => 12,
                'scope' => [],
            },
            'radius' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'remove-outbound' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'user-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'iscsi-initiator-set-default-auth' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'auth-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'outbound-password' => {
                'type' => 'string',
                'flags' => 12,
                'scope' => [],
            },
            'outbound-user-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'password' => {
                'type' => 'string',
                'flags' => 12,
                'scope' => [],
            },
            'radius' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'user-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'iscsi-interface-disable' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'interface-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'iscsi-interface-enable' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'interface-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'iscsi-interface-list-info' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'interface-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'iscsi-interface-list-entries' => {
                'type' => 'iscsi-interface-list-entry-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'iscsi-iptpgroup-create' => {
        'category' => 'iscsi',
        'family' => ['vfiler'],
        'inputs' => {
            'iptpgroup-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'iptpgroup-tag' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'iptpgroup-tag' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'iscsi-iptpgroup-destroy' => {
        'category' => 'iscsi',
        'family' => ['vfiler'],
        'inputs' => {
            'iptpgroup-tag' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'iscsi-iptpgroup-ipaddr-add' => {
        'category' => 'iscsi',
        'family' => ['vfiler'],
        'inputs' => {
            'ip-addr' => {
                'type' => 'ip-address',
                'flags' => 0,
                'scope' => [],
            },
            'iptpgroup-tag' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'iscsi-iptpgroup-ipaddr-delete' => {
        'category' => 'iscsi',
        'family' => ['vfiler'],
        'inputs' => {
            'ip-addr' => {
                'type' => 'ip-address',
                'flags' => 0,
                'scope' => [],
            },
            'iptpgroup-tag' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'iscsi-iptpgroup-list-info' => {
        'category' => 'iscsi',
        'family' => ['vfiler'],
        'inputs' => {
            'iptpgroup-tag' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'iscsi-iptpgroup-list-entries' => {
                'type' => 'iscsi-iptpgroup-list-entry-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'iscsi-isns-config' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'isns-ip-addr' => {
                'type' => 'ip-address',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'iscsi-isns-get-info' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'is-isns-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'isns-entity-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'isns-ip-addr' => {
                'type' => 'ip-address',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'iscsi-isns-start' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'iscsi-isns-stop' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'iscsi-isns-update' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'iscsi-node-get-name' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'node-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'iscsi-node-set-name' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'node-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'iscsi-portal-list-info' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'iscsi-portal-list-entries' => {
                'type' => 'iscsi-portal-list-entry-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'iscsi-reset-stats' => {
        'category' => 'iscsi',
        'family' => [],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'iscsi-service-start' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'iscsi-service-status' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'is-available' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'iscsi-service-stop' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'iscsi-session-list-info' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'tsih' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'iscsi-session-list-entries' => {
                'type' => 'iscsi-session-list-entry-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'iscsi-stats-list-info' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'iscsi-stats' => {
                'type' => 'iscsi-stats-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'iscsi-target-alias-clear-alias' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'iscsi-target-alias-get-alias' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'alias-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'is-alias-assigned' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'iscsi-target-alias-set-alias' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'alias-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'iscsi-tpgroup-alua-set' => {
        'category' => 'iscsi',
        'family' => [],
        'inputs' => {
            'tpgroup-alua-preferred' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'tpgroup-alua-state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'tpgroup-tag' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'iscsi-tpgroup-create' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'tpgroup-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'tpgroup-tag' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'tpgroup-tag' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'iscsi-tpgroup-destroy' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'tpgroup-tag' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'iscsi-tpgroup-interface-add' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'interface-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'tpgroup-tag' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'iscsi-tpgroup-interface-delete' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'interface-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'tpgroup-tag' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'iscsi-tpgroup-list-info' => {
        'category' => 'iscsi',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'tpgroup-tag' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'iscsi-tpgroup-list-entries' => {
                'type' => 'iscsi-tpgroup-list-entry-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'license-add' => {
        'category' => 'license',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'code' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'license-delete' => {
        'category' => 'license',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'service' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'license-list-info' => {
        'category' => 'license',
        'family' => ['ontap-c', 'ontap-d', 'vfiler'],
        'inputs' => {
            'hide-code' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'licenses' => {
                'type' => 'license-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'license-v2-add' => {
        'category' => 'license-v2',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'codes' => {
                'type' => 'license-code-v2',
                'flags' => 2,
                'scope' => [],
            },
        },
        'outputs' => {
            'license-v2-failure-list' => {
                'type' => 'license-v2-result',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'license-v2-delete' => {
        'category' => 'license-v2',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'package' => {
                'type' => 'licensed-package',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'license-v2-list-info' => {
        'category' => 'license-v2',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'licenses' => {
                'type' => 'license-v2-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'lock-break' => {
        'category' => 'lock',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'file-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'host' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'owner' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'protocol' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'errors' => {
                'type' => 'break-error',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'lock-status-iter-end' => {
        'category' => 'lock',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'lock-status-iter-next' => {
        'category' => 'lock',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'maximum' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'lock-status' => {
                'type' => 'lock-status-info',
                'flags' => 3,
                'scope' => [],
            },
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'lock-status-iter-start' => {
        'category' => 'lock',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'file-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'host' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'owner' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'protocol' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'lun-clear-persistent-reservation-info' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'lun-clone-list-info' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'snapshot' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'lun-clone-list' => {
                'type' => 'lun-clone-lists-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'lun-clone-split-start' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'space-efficient-split-disabled' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'lun-clone-split-status-list-info' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'clone-status' => {
                'type' => 'clone-status-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'lun-clone-split-stop' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'lun-clone-start' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'lun-clone-status-list-info' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'clone-status' => {
                'type' => 'clone-status-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'lun-clone-stop' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'lun-config-check-alua-conflicts-info' => {
        'category' => 'lun',
        'family' => [],
        'inputs' => {
        },
        'outputs' => {
            'conflicting-luns' => {
                'type' => 'conflicting-luns-list',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'lun-config-check-cfmode-info' => {
        'category' => 'lun',
        'family' => [],
        'inputs' => {
        },
        'outputs' => {
            'fcp-cfmode' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'invalid-cfmode-settings' => {
                'type' => 'invalid-cfmode-setting-info',
                'flags' => 5,
                'scope' => [],
            },
            'invalid-ostype-cfmode-settings' => {
                'type' => 'invalid-ostype-cfmode-setting-info',
                'flags' => 7,
                'scope' => [],
            },
            'invalid-use-partner-cfmode-settings' => {
                'type' => 'invalid-use-partner-cfmode-setting-info',
                'flags' => 7,
                'scope' => [],
            },
            'invalid-use-partner-ostype-settings' => {
                'type' => 'invalid-use-partner-ostype-setting-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'lun-config-check-info' => {
        'category' => 'lun',
        'family' => [],
        'inputs' => {
        },
        'outputs' => {
            'alua-setting-mismatch-info' => {
                'type' => 'alua-setting-mismatch-initiator-group',
                'flags' => 7,
                'scope' => [],
            },
            'alua-setting-mismatch-initiators' => {
                'type' => 'alua-setting-mismatch-initiator-info',
                'flags' => 7,
                'scope' => [],
            },
            'fcp-down-hbas' => {
                'type' => 'fcp-down-hba-info',
                'flags' => 7,
                'scope' => [],
            },
            'invalid-vsa-settings' => {
                'type' => 'invalid-vsa-setting-info',
                'flags' => 7,
                'scope' => [],
            },
            'mixed-ostype-initiators' => {
                'type' => 'mixed-ostype-initiator-info',
                'flags' => 7,
                'scope' => [],
            },
            'mixed-vsa-initiators' => {
                'type' => 'mixed-vsa-initiator-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'lun-config-check-single-image-info' => {
        'category' => 'lun',
        'family' => [],
        'inputs' => {
        },
        'outputs' => {
            'conflicting-initiators' => {
                'type' => 'conflicting-initiator-info',
                'flags' => 7,
                'scope' => [],
            },
            'conflicting-maps' => {
                'type' => 'conflicting-map-info',
                'flags' => 7,
                'scope' => [],
            },
            'invalid-nodename-settings' => {
                'type' => 'invalid-nodename-setting-info',
                'flags' => 5,
                'scope' => [],
            },
        },
    },
    'lun-config-check-wwpn-conflicts-info' => {
        'category' => 'lun',
        'family' => ['ontap-c'],
        'inputs' => {
        },
        'outputs' => {
            'conflicting-wwpns' => {
                'type' => 'conflict-wwpn',
                'flags' => 6,
                'scope' => [],
            },
        },
    },
    'lun-create-by-size' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'ostype' => {
                'type' => 'lun-os-type',
                'flags' => 4,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'prefix-size' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'space-reservation-enabled' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'actual-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'lun-create-clone' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'parent-lun-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'parent-snap' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'space-reservation-enabled' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'lun-create-from-file' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'file-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'ostype' => {
                'type' => 'lun-os-type',
                'flags' => 4,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'space-reservation-enabled' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'actual-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'lun-create-from-snapshot' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'snapshot-lun-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'space-reservation-enabled' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'type' => {
                'type' => 'lun-os-type',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'actual-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'lun-destroy' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'lun-get-attribute' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'value' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'lun-get-comment' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'comment' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'lun-get-geometry' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'bytes-per-sector' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'cylinders' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'max-resize-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'sectors-per-track' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tracks-per-cylinder' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'lun-get-inquiry-info' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'initiator-group-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'firmware-revision' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'product-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'vendor-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'lun-get-maxsize' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'type' => {
                'type' => 'lun-os-type',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'with-complete-snapshot-reserve' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'with-snapshot-reserve' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'without-snapshot-reserve' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'lun-get-minsize' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver'],
        'inputs' => {
            'type' => {
                'type' => 'lun-os-type',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'min-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'lun-get-occupied-size' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'occupied-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'lun-get-persistent-reservation-info' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'persistent-reservation' => {
                'type' => 'persistent-reservation-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'lun-get-select-attribute' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'creation-time' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'creation-timestamp' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'previous-serial' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'select-attribute' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'lun-get-serial-number' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'serial-number' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'lun-get-space-reservation-info' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'is-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'lun-get-target-device-id' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'lun-serial-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'target-device-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'lun-get-vdisk-attributes' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'serial-number' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'filer-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'vdisk-snapshot-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => ['ontap-c', 'vfiler'],
            },
        },
    },
    'lun-has-scsi-reservations' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'is-reservation-held' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'lun-initiator-list-map-info' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'initiator' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'lun-maps' => {
                'type' => 'lun-map-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'lun-initiator-logged-in' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'initiator' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'is-logged-in' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'lun-list-info' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'get-clone-backing-snapshot' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'are-vols-busy' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'are-vols-onlining' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'luns' => {
                'type' => 'lun-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'lun-map' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'initiator-group' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'lun-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'lun-id-assigned' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'lun-map-list-info' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'initiator-groups' => {
                'type' => 'initiator-group-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'lun-move' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'new-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'lun-offline' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'lun-online' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'lun-port-has-scsi-reservations' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'portname' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'is-reservation-held' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'lun-reset-stats' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'lun-resize' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'actual-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'lun-restore-status' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'is-running' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'lun-set-attribute' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'value' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'lun-set-comment' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'comment' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'lun-set-device-id' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'device-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'lun-set-select-attribute' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'select-value' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'lun-set-serial-number' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'serial-number' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'lun-set-share' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'share-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'lun-set-space-reservation-info' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'enable' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'lun-snap-usage-list-info' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'snapshot' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'lun-snap-usage-luns' => {
                'type' => 'lun-snap-usage-lun-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'lun-start' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'lun-stats-list-info' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'lun-stats' => {
                'type' => 'lun-stats-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'lun-unmap' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'initiator-group' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'lun-unset-attribute' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'lun-unset-device-id' => {
        'category' => 'lun',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'nameservice-map-gid-to-group-name' => {
        'category' => 'nameservice',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'gid' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'group' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'nameservice-map-group-name-to-gid' => {
        'category' => 'nameservice',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'group' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'gid' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'nameservice-map-sid-to-uid' => {
        'category' => 'nameservice',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'sid' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'uid' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'nameservice-map-uid-to-user-name' => {
        'category' => 'nameservice',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'uid' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'user' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'nameservice-map-unix-to-windows' => {
        'category' => 'nameservice',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'user' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'domain' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'user' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'nameservice-map-user-name-to-uid' => {
        'category' => 'nameservice',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'user' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'uid' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'nameservice-map-windows-to-unix' => {
        'category' => 'nameservice',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'domain' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'user' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'user' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'net-config-get-active' => {
        'category' => 'net',
        'family' => ['ontap-c'],
        'inputs' => {
        },
        'outputs' => {
            'net-config-info' => {
                'type' => 'net-config-info',
                'flags' => 1,
                'scope' => [],
            },
        },
    },
    'net-config-get-persistent' => {
        'category' => 'net',
        'family' => ['ontap-c'],
        'inputs' => {
        },
        'outputs' => {
            'net-config-info' => {
                'type' => 'net-config-info',
                'flags' => 1,
                'scope' => [],
            },
        },
    },
    'net-config-set-persistent' => {
        'category' => 'net',
        'family' => ['ontap-c'],
        'inputs' => {
            'net-config-info' => {
                'type' => 'net-config-info',
                'flags' => 1,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'net-dcb-list-info' => {
        'category' => 'net',
        'family' => ['ontap-c'],
        'inputs' => {
            'interface-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'priority-group-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'net-dcb-entries' => {
                'type' => 'net-dcb-entry-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'net-dcb-priority-list-info' => {
        'category' => 'net',
        'family' => ['ontap-c'],
        'inputs' => {
            'interface-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'priority' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'net-dcb-priority-entries' => {
                'type' => 'net-dcb-priority-entry-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'net-get-address-info' => {
        'category' => 'net',
        'family' => ['ontap-c', 'ontap-d', 'vfiler'],
        'inputs' => {
            'host-info' => {
                'type' => 'host-info',
                'flags' => 1,
                'scope' => [],
            },
        },
        'outputs' => {
            'host-result' => {
                'type' => 'net-address-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'net-ifconfig-get' => {
        'category' => 'net',
        'family' => ['ontap-c'],
        'inputs' => {
            'interface-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'interface-config-info' => {
                'type' => 'interface-config-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'net-ifconfig-set' => {
        'category' => 'net',
        'family' => ['ontap-c'],
        'inputs' => {
            'interface-config-info' => {
                'type' => 'interface-config-info',
                'flags' => 1,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'net-ipspace-assign' => {
        'category' => 'net',
        'family' => ['ontap-c'],
        'inputs' => {
            'ipspace-config-info' => {
                'type' => 'ipspace-config-info',
                'flags' => 1,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'net-ipspace-create' => {
        'category' => 'net',
        'family' => ['ontap-c'],
        'inputs' => {
            'ipspace-config-info' => {
                'type' => 'ipspace-config-info',
                'flags' => 1,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'net-ipspace-destroy' => {
        'category' => 'net',
        'family' => ['ontap-c'],
        'inputs' => {
            'ipspace-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'net-ipspace-list' => {
        'category' => 'net',
        'family' => ['ontap-c'],
        'inputs' => {
        },
        'outputs' => {
            'ipspace-list' => {
                'type' => 'ipspace-config-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'net-ping' => {
        'category' => 'net',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'host-name-or-ip-address' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'retry-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'net-ping-info' => {
        'category' => 'net',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'host-name-or-ip-address' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'ping-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'packets-received' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'packets-transmitted' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'round-trip-maximum-time' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'round-trip-mean-time' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'round-trip-minimum-time' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'net-resolve' => {
        'category' => 'net',
        'family' => ['ontap-c', 'ontap-d', 'vfiler'],
        'inputs' => {
            'host-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'ip-addresses' => {
                'type' => 'ip-address',
                'flags' => 2,
                'scope' => [],
            },
        },
    },
    'net-reverse-resolve' => {
        'category' => 'net',
        'family' => ['ontap-c', 'ontap-d', 'vfiler'],
        'inputs' => {
            'ip-address' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'alias-names' => {
                'type' => 'host-name',
                'flags' => 6,
                'scope' => [],
            },
            'canonical-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'net-route-add' => {
        'category' => 'net',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'route-info' => {
                'type' => 'route-info',
                'flags' => 1,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'net-route-delete' => {
        'category' => 'net',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'route-info' => {
                'type' => 'route-info',
                'flags' => 1,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'net-vlan-create' => {
        'category' => 'net',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'vlan-info' => {
                'type' => 'vlan-info',
                'flags' => 1,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'net-vlan-delete' => {
        'category' => 'net',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'vlan-info' => {
                'type' => 'vlan-info',
                'flags' => 1,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'nfs-disable' => {
        'category' => 'nfs',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'nfs-enable' => {
        'category' => 'nfs',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'nfs-exportfs-append-rules' => {
        'category' => 'nfs',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'persistent' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'rules' => {
                'type' => 'exports-rule-info',
                'flags' => 3,
                'scope' => [],
            },
            'verbose' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'exported-pathnames' => {
                'type' => 'pathname-info',
                'flags' => 7,
                'scope' => [],
            },
            'loaded-pathnames' => {
                'type' => 'pathname-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'nfs-exportfs-append-rules-2' => {
        'category' => 'nfs',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'persistent' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'rules' => {
                'type' => 'exports-rule-info-2',
                'flags' => 3,
                'scope' => [],
            },
            'verbose' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'exported-pathnames' => {
                'type' => 'pathname-info',
                'flags' => 7,
                'scope' => [],
            },
            'loaded-pathnames' => {
                'type' => 'pathname-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'nfs-exportfs-check-permission' => {
        'category' => 'nfs',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'host' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'pathname' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'permission' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'is-permissible' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'nfs-exportfs-delete-rules' => {
        'category' => 'nfs',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'all-pathnames' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'pathnames' => {
                'type' => 'pathname-info',
                'flags' => 7,
                'scope' => [],
            },
            'persistent' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'verbose' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'deleted-pathnames' => {
                'type' => 'pathname-info',
                'flags' => 7,
                'scope' => [],
            },
            'unexported-pathnames' => {
                'type' => 'pathname-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'nfs-exportfs-fence-disable' => {
        'category' => 'nfs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'all-pathnames' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'fenced-hosts' => {
                'type' => 'exports-hostname-info',
                'flags' => 3,
                'scope' => [],
            },
            'fenced-paths' => {
                'type' => 'pathname-info',
                'flags' => 7,
                'scope' => [],
            },
            'persistent' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'remove-locks' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'nfs-exportfs-fence-enable' => {
        'category' => 'nfs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'all-pathnames' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'fenced-hosts' => {
                'type' => 'exports-hostname-info',
                'flags' => 3,
                'scope' => [],
            },
            'fenced-paths' => {
                'type' => 'pathname-info',
                'flags' => 7,
                'scope' => [],
            },
            'persistent' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'nfs-exportfs-flush-cache' => {
        'category' => 'nfs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'pathname' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'nfs-exportfs-list-rules' => {
        'category' => 'nfs',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'pathname' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'persistent' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'rules' => {
                'type' => 'exports-rule-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'nfs-exportfs-list-rules-2' => {
        'category' => 'nfs',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'pathname' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'persistent' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'rules' => {
                'type' => 'exports-rule-info-2',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'nfs-exportfs-load-exports' => {
        'category' => 'nfs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'persistent-only' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'nfs-exportfs-modify-rule' => {
        'category' => 'nfs',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'persistent' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'rule' => {
                'type' => 'exports-rule-info',
                'flags' => 1,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'nfs-exportfs-modify-rule-2' => {
        'category' => 'nfs',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'persistent' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'rule' => {
                'type' => 'exports-rule-info-2',
                'flags' => 1,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'nfs-exportfs-storage-path' => {
        'category' => 'nfs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'pathname' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'actual-pathname' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'nfs-get-supported-sec-flavors' => {
        'category' => 'nfs',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'sec-flavor' => {
                'type' => 'sec-flavor-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'nfs-monitor-add' => {
        'category' => 'nfs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'hosts' => {
                'type' => 'hostaddr',
                'flags' => 2,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'nfs-monitor-list' => {
        'category' => 'nfs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'hosts' => {
                'type' => 'hostaddr',
                'flags' => 2,
                'scope' => [],
            },
        },
    },
    'nfs-monitor-reclaim' => {
        'category' => 'nfs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'hosts' => {
                'type' => 'hostaddr',
                'flags' => 6,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'nfs-monitor-remove' => {
        'category' => 'nfs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'hosts' => {
                'type' => 'hostaddr',
                'flags' => 2,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'nfs-monitor-remove-locks' => {
        'category' => 'nfs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'owners' => {
                'type' => 'owner-info',
                'flags' => 3,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'nfs-stats-get-client-stats' => {
        'category' => 'nfs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'host' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'client-info' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'nfs-stats' => {
                'type' => 'nfs-stats-info',
                'flags' => 1,
                'scope' => [],
            },
            'rpc-stats' => {
                'type' => 'rpc-stats-info',
                'flags' => 1,
                'scope' => [],
            },
            'tcp-flowcontrol-stats' => {
                'type' => 'tcp-flowcontrol-stats-info',
                'flags' => 1,
                'scope' => [],
            },
        },
    },
    'nfs-stats-top-clients-list-iter-end' => {
        'category' => 'nfs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'nfs-stats-top-clients-list-iter-next' => {
        'category' => 'nfs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'maximum' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'nfs-top' => {
                'type' => 'nfs-top-info',
                'flags' => 3,
                'scope' => [],
            },
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'nfs-stats-top-clients-list-iter-start' => {
        'category' => 'nfs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'maxclients' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'nfs-stats-zero-stats' => {
        'category' => 'nfs',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'nfs-status' => {
        'category' => 'nfs',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'is-drained' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'options-get' => {
        'category' => 'options',
        'family' => ['ontap-c', 'ontap-d', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'cluster-constraint' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'value' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'options-list-info' => {
        'category' => 'options',
        'family' => ['ontap-c', 'ontap-d', 'ontap-vserver', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'options' => {
                'type' => 'option-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'options-set' => {
        'category' => 'options',
        'family' => ['ontap-c', 'ontap-d', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'value' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'cluster-constraint' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'message' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'perf-object-counter-list-info' => {
        'category' => 'perf',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d', 'ontap-vserver'],
        'inputs' => {
            'objectname' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'counters' => {
                'type' => 'counter-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'perf-object-get-instances' => {
        'category' => 'perf',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d', 'ontap-vserver'],
        'inputs' => {
            'counters' => {
                'type' => 'counter',
                'flags' => 6,
                'scope' => [],
            },
            'instances' => {
                'type' => 'instance',
                'flags' => 6,
                'scope' => [],
            },
            'objectname' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'instances' => {
                'type' => 'instance-data',
                'flags' => 3,
                'scope' => [],
            },
            'timestamp' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'perf-object-get-instances-iter-end' => {
        'category' => 'perf',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'perf-object-get-instances-iter-next' => {
        'category' => 'perf',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'maximum' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'instances' => {
                'type' => 'instance-data',
                'flags' => 3,
                'scope' => [],
            },
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'perf-object-get-instances-iter-start' => {
        'category' => 'perf',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'counters' => {
                'type' => 'counter',
                'flags' => 6,
                'scope' => [],
            },
            'instances' => {
                'type' => 'instance',
                'flags' => 6,
                'scope' => [],
            },
            'objectname' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'timestamp' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'perf-object-instance-list-info' => {
        'category' => 'perf',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'objectname' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'instances' => {
                'type' => 'instance-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'perf-object-instance-list-info-iter-end' => {
        'category' => 'perf',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'perf-object-instance-list-info-iter-next' => {
        'category' => 'perf',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'maximum' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'instances' => {
                'type' => 'instance-info',
                'flags' => 3,
                'scope' => [],
            },
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'perf-object-instance-list-info-iter-start' => {
        'category' => 'perf',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'objectname' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'perf-object-list-info' => {
        'category' => 'perf',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d', 'ontap-vserver'],
        'inputs' => {
        },
        'outputs' => {
            'objects' => {
                'type' => 'object-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'portset-add' => {
        'category' => 'portset',
        'family' => ['ontap-c', 'ontap-vserver'],
        'inputs' => {
            'portset-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'portset-port-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'portset-create' => {
        'category' => 'portset',
        'family' => ['ontap-c', 'ontap-vserver'],
        'inputs' => {
            'portset-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'portset-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'portset-destroy' => {
        'category' => 'portset',
        'family' => ['ontap-c', 'ontap-vserver'],
        'inputs' => {
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'portset-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'portset-list-info' => {
        'category' => 'portset',
        'family' => [],
        'inputs' => {
            'portset-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'portset-sets' => {
                'type' => 'portset-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'portset-remove' => {
        'category' => 'portset',
        'family' => ['ontap-c', 'ontap-vserver'],
        'inputs' => {
            'portset-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'portset-port-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'priority-disable' => {
        'category' => 'priority',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'priority-enable' => {
        'category' => 'priority',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'priority-hybridcache-get' => {
        'category' => 'priority',
        'family' => ['ontap-c'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'is-hybrid-cache-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'read-cache' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'write-cache' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'priority-hybridcache-set' => {
        'category' => 'priority',
        'family' => ['ontap-c'],
        'inputs' => {
            'read-cache' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'write-cache' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'priority-list-info' => {
        'category' => 'priority',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
        },
        'outputs' => {
            'enabled-components' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'io-concurrency' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'nvlog-cp-completion' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'nvlog-cp-threshold' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'priority-list-info-default' => {
        'category' => 'priority',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
        },
        'outputs' => {
            'level' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'nvlog-limit' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'system' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'system-read-limit' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'user-read-limit' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'priority-list-info-volume' => {
        'category' => 'priority',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'priority-volume' => {
                'type' => 'priority-volume-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'priority-set' => {
        'category' => 'priority',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'io-concurrency' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'nvlog-cp-completion' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'nvlog-cp-threshold' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'priority-set-default' => {
        'category' => 'priority',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'level' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'nvlog-limit' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'system' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'system-read-limit' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'user-read-limit' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'priority-set-volume' => {
        'category' => 'priority',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'cache-policy' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'level' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'nvlog-limit' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'service' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'system' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'system-read-limit' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'user-read-limit' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'qtree-create' => {
        'category' => 'qtree',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'mode' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'qtree' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'qtree-delete' => {
        'category' => 'qtree',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'qtree' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'qtree-list' => {
        'category' => 'qtree',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'qtrees' => {
                'type' => 'qtree-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'qtree-list-iter-end' => {
        'category' => 'qtree',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'qtree-list-iter-next' => {
        'category' => 'qtree',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'maximum' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'qtrees' => {
                'type' => 'qtree-info',
                'flags' => 3,
                'scope' => [],
            },
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'qtree-list-iter-start' => {
        'category' => 'qtree',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'qtree-rename' => {
        'category' => 'qtree',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'new-qtree-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'qtree' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'quota-add-entry' => {
        'category' => 'quota',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'disk-limit' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'file-limit' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'qtree' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'quota-target' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'quota-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'soft-disk-limit' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'soft-file-limit' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'threshold' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'quota-delete-entry' => {
        'category' => 'quota',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'qtree' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'quota-target' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'quota-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'quota-get-entry' => {
        'category' => 'quota',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'qtree' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'quota-target' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'quota-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'disk-limit' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'file-limit' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'perform-user-mapping' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'quota-error' => {
                'type' => 'quota-error',
                'flags' => 5,
                'scope' => [],
            },
            'soft-disk-limit' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'soft-file-limit' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'threshold' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'quota-list-entries' => {
        'category' => 'quota',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'include-output-entry' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'quota-entries' => {
                'type' => 'quota-entry',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'quota-list-entries-iter-end' => {
        'category' => 'quota',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'quota-list-entries-iter-next' => {
        'category' => 'quota',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'maximum' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'quota-entries' => {
                'type' => 'quota-entry',
                'flags' => 7,
                'scope' => [],
            },
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'quota-list-entries-iter-start' => {
        'category' => 'quota',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'include-output-entry' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'quota-modify-entry' => {
        'category' => 'quota',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'disk-limit' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'file-limit' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'qtree' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'quota-target' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'quota-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'soft-disk-limit' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'soft-file-limit' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'threshold' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'quota-off' => {
        'category' => 'quota',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'result-status' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'quota-on' => {
        'category' => 'quota',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'quota-report' => {
        'category' => 'quota',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'error' => {
                'type' => 'error',
                'flags' => 5,
                'scope' => [],
            },
            'quotas' => {
                'type' => 'quota',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'quota-report-iter-end' => {
        'category' => 'quota',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'quota-report-iter-next' => {
        'category' => 'quota',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'maximum' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'quotas' => {
                'type' => 'quota-info',
                'flags' => 7,
                'scope' => [],
            },
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'quota-report-iter-start' => {
        'category' => 'quota',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'error' => {
                'type' => 'error',
                'flags' => 5,
                'scope' => [],
            },
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'quota-resize' => {
        'category' => 'quota',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'quota-set-entry' => {
        'category' => 'quota',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'disk-limit' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'file-limit' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'qtree' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'quota-target' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'quota-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'soft-disk-limit' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'soft-file-limit' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'threshold' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'quota-status' => {
        'category' => 'quota',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'percent-complete' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'quota-errors' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'reason' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'substatus' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'radius-reset-stats' => {
        'category' => 'radius',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'radius-server-add' => {
        'category' => 'radius',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'is-default-server' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'port' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'radius-ip-addr' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'radius-server-remove' => {
        'category' => 'radius',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'port' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'radius-ip-addr' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'radius-service-start' => {
        'category' => 'radius',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'radius-service-status' => {
        'category' => 'radius',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'is-available' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'radius-service-stop' => {
        'category' => 'radius',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'radius-show-info' => {
        'category' => 'radius',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'is-available' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'radius-server-list-entries' => {
                'type' => 'radius-server-list-entry-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'radius-stats-list-info' => {
        'category' => 'radius',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'radius-stats' => {
                'type' => 'radius-stats-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'reallocate-delete-schedule' => {
        'category' => 'reallocate',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'reallocate-list-info' => {
        'category' => 'reallocate',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'verbose' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'global-status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'reallocate-jobs' => {
                'type' => 'reallocate-job-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'reallocate-measure' => {
        'category' => 'reallocate',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'interval' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'measure-logfile' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'run-once' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'threshold' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'reallocate-off' => {
        'category' => 'reallocate',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
        },
        'outputs' => {
            'detail-status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'reallocate-on' => {
        'category' => 'reallocate',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
        },
        'outputs' => {
            'detail-status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'reallocate-quiesce' => {
        'category' => 'reallocate',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'reallocate-restart' => {
        'category' => 'reallocate',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'ignore-checkpoint' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'reallocate-set-schedule' => {
        'category' => 'reallocate',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'schedule' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'reallocate-start' => {
        'category' => 'reallocate',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'full' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'interval' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'is-aggregate' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'no-check' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'preserve-logical-bno' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'run-once' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'threshold' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'unshare' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'reallocate-stop' => {
        'category' => 'reallocate',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'rsh-get-stats' => {
        'category' => 'rsh',
        'family' => ['ontap-c'],
        'inputs' => {
        },
        'outputs' => {
            'active-high-sessions' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'current-active-sessions' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'max-available-sessions' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'rsh-sessions' => {
                'type' => 'rsh-session-info',
                'flags' => 7,
                'scope' => [],
            },
            'session-invocations' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'rsh-kill' => {
        'category' => 'rsh',
        'family' => ['ontap-c'],
        'inputs' => {
            'session-number' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'storage-shelf-bay-list-info' => {
        'category' => 'ses',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'channel-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'shelf-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'shelf-bay-list' => {
                'type' => 'shelf-bay-list-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'storage-shelf-environment-list-info' => {
        'category' => 'ses',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'channel-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'shelf-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'shelf-environ-channel-list' => {
                'type' => 'shelf-environ-channel-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'storage-shelf-get-shelf-info' => {
        'category' => 'ses',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'channel-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'shelf-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'bay-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'bay-list' => {
                'type' => 'bay-info',
                'flags' => 3,
                'scope' => [],
            },
            'firmware-rev-A' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'firmware-rev-B' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'firmware-revision' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'shelf-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'storage-shelf-list-info' => {
        'category' => 'ses',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'channel-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'shelf-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'shelf-list' => {
                'type' => 'shelf-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'storage-shelf-set-led-state' => {
        'category' => 'ses',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'action' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'channel-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'duration' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'identify' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'lun' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'shelf-bay' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'shelf-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'storage-shelf-update-fw' => {
        'category' => 'ses',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'channel-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'shelf-id' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'sis-disable' => {
        'category' => 'sis',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'sis-enable' => {
        'category' => 'sis',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'sis-set-config' => {
        'category' => 'sis',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'enable-compression' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'enable-idd' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'enable-inline-compression' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'quick-check-fsize' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'schedule' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'sis-start' => {
        'category' => 'sis',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'build-metadata' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'delete-checkpoint' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'qos-policy' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'queue-operation' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'restart-checkpoint' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'scan' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'scan-all' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'sis-status' => {
        'category' => 'sis',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'verbose' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'sis-object' => {
                'type' => 'dense-status',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'sis-stop' => {
        'category' => 'sis',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'all-operations' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'file-get-snaplock-retention-time' => {
        'category' => 'snaplock',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'retention-time' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'file-get-snaplock-retention-time-list-info-max' => {
        'category' => 'snaplock',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'max-list-entries' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'file-set-snaplock-retention-time' => {
        'category' => 'snaplock',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'retention-time' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'set-infinite-retention' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'file-snaplock-retention-time-list-info' => {
        'category' => 'snaplock',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'pathnames' => {
                'type' => 'pathname-info',
                'flags' => 3,
                'scope' => [],
            },
        },
        'outputs' => {
            'file-retention-details' => {
                'type' => 'file-retention-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'snaplock-get-compliance-clock' => {
        'category' => 'snaplock',
        'family' => ['ontap-c'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'snaplock-get-log-volume' => {
        'category' => 'snaplock',
        'family' => [],
        'inputs' => {
        },
        'outputs' => {
            'log-volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'snaplock-get-options' => {
        'category' => 'snaplock',
        'family' => [],
        'inputs' => {
            'option' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'option-value' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'snaplock-get-system-compliance-clock' => {
        'category' => 'snaplock',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'system-compliance-clock' => {
                'type' => 'compliance-clock-info',
                'flags' => 1,
                'scope' => [],
            },
        },
    },
    'snaplock-get-volume-compliance-clock' => {
        'category' => 'snaplock',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'system-compliance-clock' => {
                'type' => 'compliance-clock-info',
                'flags' => 1,
                'scope' => [],
            },
            'volume-compliance-clock' => {
                'type' => 'compliance-clock-info',
                'flags' => 1,
                'scope' => [],
            },
        },
    },
    'snaplock-log-archive' => {
        'category' => 'snaplock',
        'family' => [],
        'inputs' => {
            'log-basename' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'log-volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snaplock-log-status-list-info' => {
        'category' => 'snaplock',
        'family' => [],
        'inputs' => {
            'log-basename' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'log-volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'log-file-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'log-file-details' => {
                'type' => 'log-file-info',
                'flags' => 7,
                'scope' => [],
            },
            'log-volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'snaplock-privileged-delete-file' => {
        'category' => 'snaplock',
        'family' => [],
        'inputs' => {
            'do-it' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snaplock-set-log-volume' => {
        'category' => 'snaplock',
        'family' => [],
        'inputs' => {
            'is-force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'log-volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snaplock-set-options' => {
        'category' => 'snaplock',
        'family' => [],
        'inputs' => {
            'do-it' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'option' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'option-value' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snaplock-set-system-compliance-clock' => {
        'category' => 'snaplock',
        'family' => ['ontap-c'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'snapmirror-abort' => {
        'category' => 'snapmirror',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'clear-checkpoint' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'destination-location' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapmirror-break' => {
        'category' => 'snapmirror',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'destination-location' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapmirror-delete-connection' => {
        'category' => 'snapmirror',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'connection' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapmirror-delete-schedule' => {
        'category' => 'snapmirror',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'destination-location' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapmirror-delete-sync-schedule' => {
        'category' => 'snapmirror',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'destination-location' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapmirror-get-status' => {
        'category' => 'snapmirror',
        'family' => ['ontap-c', 'ontap-d', 'vfiler'],
        'inputs' => {
            'location' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'is-available' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'snapmirror-status' => {
                'type' => 'snapmirror-status-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'snapmirror-get-volume-status' => {
        'category' => 'snapmirror',
        'family' => ['ontap-c', 'ontap-cluster', 'vfiler'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'is-destination' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-source' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-transfer-broken' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-transfer-in-progress' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'snapmirror-initialize' => {
        'category' => 'snapmirror',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'destination-location' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'destination-snapshot' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'max-transfer-rate' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'source-location' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'source-snapshot' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapmirror-list-connections' => {
        'category' => 'snapmirror',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'connection' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'snapmirror-connections' => {
                'type' => 'snapmirror-connection-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'snapmirror-list-destinations' => {
        'category' => 'snapmirror',
        'family' => ['ontap-c', 'ontap-d', 'vfiler'],
        'inputs' => {
            'source-location' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'destinations' => {
                'type' => 'destination-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'snapmirror-list-schedule' => {
        'category' => 'snapmirror',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'destination-location' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'snapmirror-schedules' => {
                'type' => 'snapmirror-schedule-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'snapmirror-list-sync-schedule' => {
        'category' => 'snapmirror',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'destination-location' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'snapmirror-sync-schedules' => {
                'type' => 'snapmirror-sync-schedule-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'snapmirror-off' => {
        'category' => 'snapmirror',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'snapmirror-on' => {
        'category' => 'snapmirror',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'snapmirror-quiesce' => {
        'category' => 'snapmirror',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'destination-location' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapmirror-release' => {
        'category' => 'snapmirror',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'destination-location' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'source-location' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapmirror-resume' => {
        'category' => 'snapmirror',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'destination-location' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapmirror-resync' => {
        'category' => 'snapmirror',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'destination-location' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'destination-snapshot' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'max-transfer-rate' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'source-location' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'source-snapshot' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapmirror-set-connection' => {
        'category' => 'snapmirror',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'address-pair1' => {
                'type' => 'address-pair',
                'flags' => 1,
                'scope' => [],
            },
            'address-pair2' => {
                'type' => 'address-pair',
                'flags' => 5,
                'scope' => [],
            },
            'connection' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'mode' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapmirror-set-schedule' => {
        'category' => 'snapmirror',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'connection-mode' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'days-of-month' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'days-of-week' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'destination-location' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'hours' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'is-compressed' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'max-transfer-rate' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'minutes' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'restart' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'source-location' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'tcp-window-size' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapmirror-set-sync-schedule' => {
        'category' => 'snapmirror',
        'family' => ['ontap-c'],
        'inputs' => {
            'connection-mode' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'destination-location' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'is-compressed' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'ops-throttle' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'source-location' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'sync-mode' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'tcp-window-size' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'visibility-frequency' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapmirror-throttle' => {
        'category' => 'snapmirror',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'destination-location' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'max-transfer-rate' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapmirror-update' => {
        'category' => 'snapmirror',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'destination-location' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'destination-snapshot' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'max-transfer-rate' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'source-location' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'source-snapshot' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapshot-autodelete-list-info' => {
        'category' => 'snapshot',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'options' => {
                'type' => 'snapshot-autodelete-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'snapshot-autodelete-set-option' => {
        'category' => 'snapshot',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'option-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'option-value' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapshot-create' => {
        'category' => 'snapshot',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'async' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-valid-lun-clone-snapshot' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'snapshot' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapshot-delete' => {
        'category' => 'snapshot',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'snapshot' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'snapshot-instance-uuid' => {
                'type' => 'uuid',
                'flags' => 4,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapshot-delta-info' => {
        'category' => 'snapshot',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'snapshot1' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'snapshot2' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'consumed-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'elapsed-time' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'snapshot-get-reserve' => {
        'category' => 'snapshot',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'blocks-reserved' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'percent-reserved' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'snapshot-get-schedule' => {
        'category' => 'snapshot',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'days' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'hours' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'minutes' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'weeks' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'which-hours' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'which-minutes' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'snapshot-list-info' => {
        'category' => 'snapshot',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'is-7-mode-snapshot' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'lun-clone-snapshot' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'snapowners' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'target-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'target-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'terse' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'snapshots' => {
                'type' => 'snapshot-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'snapshot-multicreate' => {
        'category' => 'snapshot',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'cleanup' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'snapshot' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume-names' => {
                'type' => 'volume-name',
                'flags' => 2,
                'scope' => [],
            },
        },
        'outputs' => {
            'volume-is-snapcreated-list' => {
                'type' => 'volume-is-snapcreated',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'snapshot-multicreate-validate' => {
        'category' => 'snapshot',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'snapshot' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume-names' => {
                'type' => 'volume-name',
                'flags' => 2,
                'scope' => [],
            },
        },
        'outputs' => {
            'volume-errors' => {
                'type' => 'volume-error',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'snapshot-multidelete' => {
        'category' => 'snapshot',
        'family' => ['ontap-c', 'ontap-d', 'ontap-vserver'],
        'inputs' => {
            'snapshot' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume-names' => {
                'type' => 'volume-name',
                'flags' => 2,
                'scope' => ['ontap-c', 'ontap-vserver'],
            },
        },
        'outputs' => {
            'volume-errors' => {
                'type' => 'volume-error',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'snapshot-partial-restore-file' => {
        'category' => 'snapshot',
        'family' => ['ontap-c', 'ontap-d', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'byte-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'snapshot' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'snapshot-instance-uuid' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'start-byte' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapshot-partial-restore-file-list-info' => {
        'category' => 'snapshot',
        'family' => ['ontap-c', 'ontap-d', 'ontap-vserver', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'max-byte-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'snapshot-reclaimable-info' => {
        'category' => 'snapshot',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'snapshots' => {
                'type' => 'snapshot-name',
                'flags' => 2,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'reclaimable-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'snapshot-rename' => {
        'category' => 'snapshot',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'current-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'new-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapshot-reserve-list-info' => {
        'category' => 'snapshot',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'snapshot-reserve-details' => {
                'type' => 'snapshot-reserve-detail-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'snapshot-restore-file' => {
        'category' => 'snapshot',
        'family' => ['ontap-c', 'ontap-d', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'restore-path' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'snapshot' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'snapshot-instance-uuid' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'space-efficient-split-disabled' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapshot-restore-file-info' => {
        'category' => 'snapshot',
        'family' => ['ontap-c', 'ontap-d', 'ontap-vserver', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'max-sfsr-limit' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'sfsr-in-progress' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'snapshot-restore-volume' => {
        'category' => 'snapshot',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'snapshot' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'snapshot-instance-uuid' => {
                'type' => 'uuid',
                'flags' => 4,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapshot-set-reserve' => {
        'category' => 'snapshot',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'percentage' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapshot-set-schedule' => {
        'category' => 'snapshot',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'days' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'hours' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'minutes' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'weeks' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'which-hours' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'which-minutes' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapshot-volume-info' => {
        'category' => 'snapshot',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'size-available' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'snapvault-add-softlock' => {
        'category' => 'snapvault',
        'family' => ['ontap-c'],
        'inputs' => {
            'snapshot' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'softlock-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapvault-get-all-softlocked-snapshots' => {
        'category' => 'snapvault',
        'family' => ['ontap-c'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'snapshot-list' => {
                'type' => 'snapshot-name',
                'flags' => 6,
                'scope' => [],
            },
        },
    },
    'snapvault-get-softlocks' => {
        'category' => 'snapvault',
        'family' => ['ontap-c'],
        'inputs' => {
            'snapshot' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'snapvault-softlocks' => {
                'type' => 'snapvault-softlock-info',
                'flags' => 1,
                'scope' => [],
            },
        },
    },
    'snapvault-primary-abort-snapshot-create' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'schedule-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapvault-primary-abort-transfer' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'is-hard-abort' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'system-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'target-system' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapvault-primary-delete-snapshot-schedule' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'schedule-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapvault-primary-destinations-list-info' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'ontap-d', 'vfiler'],
        'inputs' => {
            'source-path' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'destinations' => {
                'type' => 'snapvault-destination-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'snapvault-primary-get-relationship-status' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'system-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'status' => {
                'type' => 'snapvault-status-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'snapvault-primary-initiate-incremental-restore-transfer' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'connection-mode' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'max-transfer-rate' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'no-lun-clone-expansion' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'primary-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'secondary-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'secondary-snapshot' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'secondary-system' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapvault-primary-initiate-restore-transfer' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'connection-mode' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'max-transfer-rate' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'no-lun-clone-expansion' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'overwrite-existing-content' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'primary-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'secondary-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'secondary-snapshot' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'secondary-system' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapvault-primary-initiate-snapshot-create' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'options' => {
                'type' => 'snapvault-snapcreate-options',
                'flags' => 5,
                'scope' => [],
            },
            'schedule-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapvault-primary-relationship-status-list-iter-end' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapvault-primary-relationship-status-list-iter-next' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'ontap-d', 'vfiler'],
        'inputs' => {
            'maximum' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'status-list' => {
                'type' => 'snapvault-status-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'snapvault-primary-relationship-status-list-iter-start' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'ontap-d', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'snapvault-primary-release-relationship' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'primary-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'secondary-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'secondary-system' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapvault-primary-set-snapshot-schedule' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'snapshot-schedule' => {
                'type' => 'snapvault-primary-snapshot-schedule-info',
                'flags' => 1,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapvault-primary-snapshot-schedule-list-info' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'ontap-d', 'vfiler'],
        'inputs' => {
            'volume-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'snapshot-schedules' => {
                'type' => 'snapvault-primary-snapshot-schedule-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'snapvault-primary-snapshot-schedule-status-list-info' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'volume-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'snapshot-schedule-status' => {
                'type' => 'snapvault-snapshot-schedule-status-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'snapvault-remove-softlock' => {
        'category' => 'snapvault',
        'family' => ['ontap-c'],
        'inputs' => {
            'snapshot' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'softlock-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapvault-secondary-abort-snapshot-create' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'schedule-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapvault-secondary-abort-transfer' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'is-hard-abort' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'system-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'target-system' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapvault-secondary-configuration-list-info' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'ontap-d', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'configurations' => {
                'type' => 'snapvault-configuration-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'snapvault-secondary-create-relationship' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'configuration' => {
                'type' => 'snapvault-configuration-info',
                'flags' => 1,
                'scope' => [],
            },
            'no-lun-clone-expansion' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapvault-secondary-delete-relationship' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'secondary-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapvault-secondary-delete-snapshot-schedule' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'delete-schedule-softlock' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'schedule-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapvault-secondary-destinations-list-info' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'source-path' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'destinations' => {
                'type' => 'snapvault-destination-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'snapvault-secondary-get-configuration' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'secondary-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'configuration' => {
                'type' => 'snapvault-configuration-info',
                'flags' => 5,
                'scope' => [],
            },
        },
    },
    'snapvault-secondary-get-relationship-status' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'system-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'status' => {
                'type' => 'snapvault-status-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'snapvault-secondary-initiate-incremental-transfer' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'max-transfer-rate' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'no-lun-clone-expansion' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'primary-snapshot' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'secondary-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapvault-secondary-initiate-snapshot-create' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'lock-backing-snapshot' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'options' => {
                'type' => 'snapvault-snapcreate-options',
                'flags' => 5,
                'scope' => [],
            },
            'schedule-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapvault-secondary-modify-configuration' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'configuration' => {
                'type' => 'snapvault-configuration-info',
                'flags' => 1,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapvault-secondary-relationship-status-list-iter-end' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapvault-secondary-relationship-status-list-iter-next' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'maximum' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'status-list' => {
                'type' => 'snapvault-status-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'snapvault-secondary-relationship-status-list-iter-start' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'snapvault-secondary-release-relationship' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'primary-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'primary-system' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'secondary-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapvault-secondary-resync-relationship' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'configuration' => {
                'type' => 'snapvault-configuration-info',
                'flags' => 1,
                'scope' => [],
            },
            'no-lun-clone-expansion' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapvault-secondary-set-snapshot-schedule' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'snapshot-schedule' => {
                'type' => 'snapvault-secondary-snapshot-schedule-info',
                'flags' => 1,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snapvault-secondary-snapshot-schedule-list-info' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'ontap-d', 'vfiler'],
        'inputs' => {
            'volume-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'snapshot-schedules' => {
                'type' => 'snapvault-secondary-snapshot-schedule-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'snapvault-secondary-snapshot-schedule-status-list-info' => {
        'category' => 'snapvault',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'volume-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'snapshot-schedule-status' => {
                'type' => 'snapvault-snapshot-schedule-status-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'snmp-community-add' => {
        'category' => 'snmp',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-vserver'],
        'inputs' => {
            'access-control' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'community' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snmp-community-delete' => {
        'category' => 'snmp',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-vserver'],
        'inputs' => {
            'access-control' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'community' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snmp-community-delete-all' => {
        'category' => 'snmp',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-vserver'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'snmp-disable' => {
        'category' => 'snmp',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'snmp-enable' => {
        'category' => 'snmp',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'snmp-get' => {
        'category' => 'snmp',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'object-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'is-value-hexadecimal' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'value' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'snmp-get-next' => {
        'category' => 'snmp',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'object-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'is-value-hexadecimal' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'next-object-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'value' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'snmp-status' => {
        'category' => 'snmp',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
        },
        'outputs' => {
            'communities' => {
                'type' => 'community-info',
                'flags' => 7,
                'scope' => [],
            },
            'contact' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'is-trap-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'location' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'traphosts' => {
                'type' => 'traphost-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'snmp-trap-delete' => {
        'category' => 'snmp',
        'family' => [],
        'inputs' => {
            'trap-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snmp-trap-disable' => {
        'category' => 'snmp',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'snmp-trap-enable' => {
        'category' => 'snmp',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'snmp-trap-list' => {
        'category' => 'snmp',
        'family' => [],
        'inputs' => {
        },
        'outputs' => {
            'trap-list' => {
                'type' => 'trap-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'snmp-trap-load' => {
        'category' => 'snmp',
        'family' => [],
        'inputs' => {
            'filename' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snmp-trap-reset' => {
        'category' => 'snmp',
        'family' => [],
        'inputs' => {
            'trap-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snmp-trap-set' => {
        'category' => 'snmp',
        'family' => [],
        'inputs' => {
            'trap-def' => {
                'type' => 'trap-info',
                'flags' => 1,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snmp-traphost-add' => {
        'category' => 'snmp',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'host' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'snmp-traphost-delete' => {
        'category' => 'snmp',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'host' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'software-extract-metadata' => {
        'category' => 'software',
        'family' => [],
        'inputs' => {
            'package-location' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'package-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'npm-metadata' => {
                'type' => 'npm-meta-elem-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'storage-adapter-enable-adapter' => {
        'category' => 'storage-adapter',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'adapter-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'storage-adapter-get-adapter-info' => {
        'category' => 'storage-adapter',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'adapter-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'adapter-details' => {
                'type' => 'adapter-detail-info',
                'flags' => 1,
                'scope' => [],
            },
        },
    },
    'storage-adapter-get-adapter-list' => {
        'category' => 'storage-adapter',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
        },
        'outputs' => {
            'adapter-list' => {
                'type' => 'adapter-name-elem',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'storage-adapter-modify' => {
        'category' => 'storage-adapter',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'adapter-state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'force-offline' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'port-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'storage-array-get-config-summary' => {
        'category' => 'storage-array',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'ownership-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'config-summary' => {
                'type' => 'storage-array-config-summary',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'storage-array-list-info' => {
        'category' => 'storage-array',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'array-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'array-profiles' => {
                'type' => 'storage-array-profile',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'storage-array-luns-list-info' => {
        'category' => 'storage-array',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'array-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'ownership-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'array-luns' => {
                'type' => 'disk-detail-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'storage-array-ports-list-info' => {
        'category' => 'storage-array',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'array-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'array-ports' => {
                'type' => 'storage-array-port',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'storage-array-update' => {
        'category' => 'storage-array',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'array-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'firmware' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'model' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'network-address' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'new-array-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'options' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'prefix' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'vendor' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'array-profile' => {
                'type' => 'storage-array-profile',
                'flags' => 1,
                'scope' => [],
            },
        },
    },
    'storage-disk-fw-status' => {
        'category' => 'storage-disk',
        'family' => ['ontap-c', 'ontap-d'],
        'inputs' => {
            'status-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'fw-update-status' => {
                'type' => 'fw-update-status-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'storage-disk-get-iter' => {
        'category' => 'storage-disk',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d', 'vfiler'],
        'inputs' => {
            'max-records' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'attributes-list' => {
                'type' => 'storage-disk-info',
                'flags' => 7,
                'scope' => [],
            },
            'next-tag' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'num-records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'storage-initiator-balance' => {
        'category' => 'storage-initiator',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'storage-initiator-disk-path-list-info' => {
        'category' => 'storage-initiator',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'disk-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'disk-path-info' => {
                'type' => 'disk-path-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'storage-initiator-errors-list-info' => {
        'category' => 'storage-initiator',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'array-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'disk-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'errors' => {
                'type' => 'storage-error-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'storage-initiator-get-load' => {
        'category' => 'storage-initiator',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'port' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'load-info' => {
                'type' => 'storage-initiator-load-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'storage-initiator-path-list-info' => {
        'category' => 'storage-initiator',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
        },
        'outputs' => {
            'path-info' => {
                'type' => 'storage-initiator-path-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'storage-initiator-path-quiesce' => {
        'category' => 'storage-initiator',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'initiator' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'lun-number' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'target-wwpn' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'storage-initiator-path-resume' => {
        'category' => 'storage-initiator',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d'],
        'inputs' => {
            'initiator' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'lun-number' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'target-wwpn' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'system-api-get-elements' => {
        'category' => 'system',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'api-list' => {
                'type' => 'api-list-info',
                'flags' => 2,
                'scope' => [],
            },
        },
        'outputs' => {
            'api-entries' => {
                'type' => 'system-api-entry-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'system-api-list' => {
        'category' => 'system',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d', 'ontap-vserver', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'apis' => {
                'type' => 'system-api-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'system-api-list-types' => {
        'category' => 'system',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d', 'ontap-vserver', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'type-entries' => {
                'type' => 'system-api-type-entry-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'system-available-replication-transfers' => {
        'category' => 'system',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'replication-transfer-table' => {
                'type' => 'replication-transfer-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'system-get-info' => {
        'category' => 'system',
        'family' => ['ontap-c', 'ontap-d', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'system-info' => {
                'type' => 'system-info',
                'flags' => 1,
                'scope' => [],
            },
        },
    },
    'system-get-ontapi-version' => {
        'category' => 'system',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d', 'ontap-vserver', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'major-version' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'minor-version' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'system-get-vendor-info' => {
        'category' => 'system',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'autosupport-email' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'autosupport-url' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'complete-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'customer-support-contact' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'customer-support-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'information-url' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'ontap-oid-prefix' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'product-url' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'short-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'system-get-version' => {
        'category' => 'system',
        'family' => ['ontap-c', 'ontap-cluster', 'ontap-d', 'ontap-vserver', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'is-clustered' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'version' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'useradmin-domainuser-add' => {
        'category' => 'useradmin',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'user-identifier' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'useradmin-groups' => {
                'type' => 'useradmin-group-info',
                'flags' => 3,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'useradmin-domainuser-delete' => {
        'category' => 'useradmin',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'user-identifier' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'useradmin-groups' => {
                'type' => 'useradmin-group-info',
                'flags' => 3,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'useradmin-domainuser-list' => {
        'category' => 'useradmin',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'group-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'user-identifiers' => {
                'type' => 'sid',
                'flags' => 2,
                'scope' => [],
            },
        },
    },
    'useradmin-group-add' => {
        'category' => 'useradmin',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'useradmin-group' => {
                'type' => 'useradmin-group-info',
                'flags' => 1,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'useradmin-group-delete' => {
        'category' => 'useradmin',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'group-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'useradmin-group-list' => {
        'category' => 'useradmin',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'group-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'verbose' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'useradmin-groups' => {
                'type' => 'useradmin-group-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'useradmin-group-modify' => {
        'category' => 'useradmin',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'new-group-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'useradmin-group' => {
                'type' => 'useradmin-group-info',
                'flags' => 1,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'useradmin-role-add' => {
        'category' => 'useradmin',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'useradmin-role' => {
                'type' => 'useradmin-role-info',
                'flags' => 1,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'useradmin-role-delete' => {
        'category' => 'useradmin',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'role-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'useradmin-role-list' => {
        'category' => 'useradmin',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'role-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'useradmin-roles' => {
                'type' => 'useradmin-role-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'useradmin-role-modify' => {
        'category' => 'useradmin',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'useradmin-role' => {
                'type' => 'useradmin-role-info',
                'flags' => 1,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'useradmin-user-add' => {
        'category' => 'useradmin',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'password' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'useradmin-user' => {
                'type' => 'useradmin-user-info',
                'flags' => 1,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'useradmin-user-delete' => {
        'category' => 'useradmin',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'user-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'useradmin-user-list' => {
        'category' => 'useradmin',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'group-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'user-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'verbose' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'useradmin-users' => {
                'type' => 'useradmin-user-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'useradmin-user-modify' => {
        'category' => 'useradmin',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'useradmin-user' => {
                'type' => 'useradmin-user-info',
                'flags' => 1,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'useradmin-user-modify-password' => {
        'category' => 'useradmin',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'new-password' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'old-password' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'user-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'vfiler-add-ipaddress' => {
        'category' => 'vfiler',
        'family' => [],
        'inputs' => {
            'ipaddress' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'vfiler' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'vfiler-add-storage' => {
        'category' => 'vfiler',
        'family' => [],
        'inputs' => {
            'storage-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'vfiler' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'vfiler-allow-protocol' => {
        'category' => 'vfiler',
        'family' => [],
        'inputs' => {
            'protocol' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'vfiler' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'vfiler-create' => {
        'category' => 'vfiler',
        'family' => [],
        'inputs' => {
            'ip-addresses' => {
                'type' => 'ip-address',
                'flags' => 2,
                'scope' => [],
            },
            'ipspace' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'storage-units' => {
                'type' => 'storage-unit',
                'flags' => 2,
                'scope' => [],
            },
            'vfiler' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'vfiler-destroy' => {
        'category' => 'vfiler',
        'family' => [],
        'inputs' => {
            'vfiler' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'vfiler-disallow-protocol' => {
        'category' => 'vfiler',
        'family' => [],
        'inputs' => {
            'protocol' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'vfiler' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'vfiler-dr-activate' => {
        'category' => 'vfiler',
        'family' => [],
        'inputs' => {
            'remote-vfiler-location' => {
                'type' => 'vfiler-location',
                'flags' => 1,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'vfiler-dr-configure' => {
        'category' => 'vfiler',
        'family' => [],
        'inputs' => {
            'DNS-server-ipaddrs' => {
                'type' => 'ip-address',
                'flags' => 6,
                'scope' => [],
            },
            'NIS-server-ipaddrs' => {
                'type' => 'ip-address',
                'flags' => 6,
                'scope' => [],
            },
            'alternate-src-dst' => {
                'type' => 'hostname-pair',
                'flags' => 5,
                'scope' => [],
            },
            'ipaddrs' => {
                'type' => 'ipaddr-info',
                'flags' => 3,
                'scope' => [],
            },
            'is-synchronous' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'remote-authentication-info' => {
                'type' => 'authentication-info',
                'flags' => 5,
                'scope' => [],
            },
            'remote-encrypted-authentication-info' => {
                'type' => 'encrypted-authentication-info',
                'flags' => 5,
                'scope' => [],
            },
            'remote-vfiler-location' => {
                'type' => 'vfiler-location',
                'flags' => 1,
                'scope' => [],
            },
            'snapmirror-not-initialize' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'use-secure-command-channel' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'vfiler-dr-delete' => {
        'category' => 'vfiler',
        'family' => [],
        'inputs' => {
            'is-forced' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'remote-vfiler-location' => {
                'type' => 'vfiler-location',
                'flags' => 1,
                'scope' => [],
            },
            'use-secure-command-channel' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'vfiler-dr-get-status' => {
        'category' => 'vfiler',
        'family' => [],
        'inputs' => {
            'remote-vfiler-location' => {
                'type' => 'vfiler-location',
                'flags' => 1,
                'scope' => [],
            },
        },
        'outputs' => {
            'dr-status' => {
                'type' => 'storage-dr-status',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'vfiler-dr-resync' => {
        'category' => 'vfiler',
        'family' => [],
        'inputs' => {
            'alternate-src-dst' => {
                'type' => 'hostname-pair',
                'flags' => 5,
                'scope' => [],
            },
            'is-synchronous' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'remote-authentication-info' => {
                'type' => 'authentication-info',
                'flags' => 5,
                'scope' => [],
            },
            'remote-encrypted-authentication-info' => {
                'type' => 'encrypted-authentication-info',
                'flags' => 5,
                'scope' => [],
            },
            'remote-vfiler-location' => {
                'type' => 'vfiler-location',
                'flags' => 1,
                'scope' => [],
            },
            'use-secure-command-channel' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'vfiler-get-allowed-protocols' => {
        'category' => 'vfiler',
        'family' => [],
        'inputs' => {
            'vfiler' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'allowed-protocols' => {
                'type' => 'protocol-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'vfiler-get-disallowed-protocols' => {
        'category' => 'vfiler',
        'family' => [],
        'inputs' => {
            'vfiler' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'disallowed-protocols' => {
                'type' => 'protocol-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'vfiler-get-status' => {
        'category' => 'vfiler',
        'family' => [],
        'inputs' => {
            'vfiler' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'vfiler-list-info' => {
        'category' => 'vfiler',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'vfiler' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'vfilers' => {
                'type' => 'vfiler-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'vfiler-migrate' => {
        'category' => 'vfiler',
        'family' => [],
        'inputs' => {
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'ipaddrs' => {
                'type' => 'ipaddr-info',
                'flags' => 3,
                'scope' => [],
            },
            'migration-method' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'password' => {
                'type' => 'string',
                'flags' => 8,
                'scope' => [],
            },
            'remote-filer' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'use-secure-command-channel' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'username' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'vfiler' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'vfiler-migrate-cancel' => {
        'category' => 'vfiler',
        'family' => [],
        'inputs' => {
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'remote-vfiler-location' => {
                'type' => 'vfiler-location',
                'flags' => 1,
                'scope' => [],
            },
            'use-secure-command-channel' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'vfiler-migrate-complete' => {
        'category' => 'vfiler',
        'family' => [],
        'inputs' => {
            'migrate-transparent' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'remote-authentication-info' => {
                'type' => 'authentication-info',
                'flags' => 5,
                'scope' => [],
            },
            'remote-vfiler-location' => {
                'type' => 'vfiler-location',
                'flags' => 1,
                'scope' => [],
            },
            'use-secure-command-channel' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'vfiler-migrate-start' => {
        'category' => 'vfiler',
        'family' => [],
        'inputs' => {
            'ipaddrs' => {
                'type' => 'ipaddr-info',
                'flags' => 3,
                'scope' => [],
            },
            'remote-authentication-info' => {
                'type' => 'authentication-info',
                'flags' => 1,
                'scope' => [],
            },
            'remote-vfiler-location' => {
                'type' => 'vfiler-location',
                'flags' => 1,
                'scope' => [],
            },
            'snapmirror-not-initialize' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'vfiler-migrate-status' => {
        'category' => 'vfiler',
        'family' => [],
        'inputs' => {
            'remote-vfiler-location' => {
                'type' => 'vfiler-location',
                'flags' => 1,
                'scope' => [],
            },
        },
        'outputs' => {
            'migrate-status' => {
                'type' => 'storage-mr-status',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'vfiler-remove-ipaddress' => {
        'category' => 'vfiler',
        'family' => [],
        'inputs' => {
            'ipaddress' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'vfiler' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'vfiler-remove-storage' => {
        'category' => 'vfiler',
        'family' => [],
        'inputs' => {
            'storage-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'vfiler' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'vfiler-setup' => {
        'category' => 'vfiler',
        'family' => [],
        'inputs' => {
            'adminhost' => {
                'type' => 'adminhost',
                'flags' => 5,
                'scope' => [],
            },
            'dnsdomain' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'dnsservers' => {
                'type' => 'dnsserver-info',
                'flags' => 7,
                'scope' => [],
            },
            'ipbindings' => {
                'type' => 'ipbinding-info',
                'flags' => 7,
                'scope' => [],
            },
            'nisdomain' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'nisservers' => {
                'type' => 'nisserver-info',
                'flags' => 7,
                'scope' => [],
            },
            'password' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'vfiler' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'vfiler-start' => {
        'category' => 'vfiler',
        'family' => [],
        'inputs' => {
            'vfiler' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'vfiler-stop' => {
        'category' => 'vfiler',
        'family' => [],
        'inputs' => {
            'vfiler' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'vmservices-vsphere-credential-check' => {
        'category' => 'vmservices',
        'family' => ['ontap-c'],
        'inputs' => {
        },
        'outputs' => {
        },
    },
    'vmservices-vsphere-credential-get' => {
        'category' => 'vmservices',
        'family' => ['ontap-c'],
        'inputs' => {
        },
        'outputs' => {
            'server' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'username' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'vmservices-vsphere-credential-modify' => {
        'category' => 'vmservices',
        'family' => ['ontap-c'],
        'inputs' => {
            'password' => {
                'type' => 'string',
                'flags' => 12,
                'scope' => [],
            },
            'server' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'username' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-add' => {
        'category' => 'volume',
        'family' => [],
        'inputs' => {
            'disk-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'disk-size' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'disk-size-with-unit' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'disks' => {
                'type' => 'disk-info',
                'flags' => 7,
                'scope' => [],
            },
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'mirror-disks' => {
                'type' => 'disk-info',
                'flags' => 7,
                'scope' => [],
            },
            'raid-group' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'bad-disks' => {
                'type' => 'disk-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'volume-autosize-get' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'grow-threshold-percent' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'increment-size' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'is-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'maximum-size' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'minimum-size' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'mode' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'shrink-threshold-percent' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'volume-autosize-set' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'ontap-vserver'],
        'inputs' => {
            'grow-threshold-percent' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'increment-size' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'is-enabled' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'maximum-size' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'minimum-size' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'mode' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'reset' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'shrink-threshold-percent' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-charmap-get' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'charmap' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'volume-charmap-set' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'charmap' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-clone-create' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'force-worm-clone' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'parent-snapshot' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'parent-volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'qos-policy-group-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'space-reserve' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-clone-split-estimate' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'clone-split-estimate' => {
                'type' => 'clone-split-estimate-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'volume-clone-split-start' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-clone-split-status' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'clone-split-details' => {
                'type' => 'clone-split-detail-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'volume-clone-split-stop' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-container' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'containing-aggregate' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'volume-create' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'ontap-vserver'],
        'inputs' => {
            'constituent-role' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'containing-aggr-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'disk-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'disk-size' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'disk-size-with-unit' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'disks' => {
                'type' => 'disk-info',
                'flags' => 7,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'is-mirrored' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'is-snaplock' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'language-code' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => ['ontap-c', 'ontap-vserver', 'vfiler'],
            },
            'mirror-disks' => {
                'type' => 'disk-info',
                'flags' => 7,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'qos-policy-group-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'raid-size' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'remote-location' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'size' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'snaplock-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'space-reserve' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'storage-service' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'vm-align-sector' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'vm-align-suffix' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume-raid-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
        },
        'outputs' => {
            'bad-disks' => {
                'type' => 'disk-info',
                'flags' => 7,
                'scope' => ['ontap-c', 'vfiler'],
            },
        },
    },
    'volume-decompress-abort' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-decompress-start' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-destroy' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-footprint-list-info' => {
        'category' => 'volume',
        'family' => ['ontap-c'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'vol-footprint-infos' => {
                'type' => 'vol-footprint-info',
                'flags' => 1,
                'scope' => [],
            },
        },
    },
    'volume-footprint-list-info-iter-end' => {
        'category' => 'volume',
        'family' => ['ontap-c'],
        'inputs' => {
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-footprint-list-info-iter-next' => {
        'category' => 'volume',
        'family' => ['ontap-c'],
        'inputs' => {
            'maximum' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'vol-footprint-infos' => {
                'type' => 'vol-footprint-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'volume-footprint-list-info-iter-start' => {
        'category' => 'volume',
        'family' => ['ontap-c'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'volume-get-filer-info' => {
        'category' => 'volume',
        'family' => [],
        'inputs' => {
        },
        'outputs' => {
            'allowed-raidtypes' => {
                'type' => 'raidtype-info',
                'flags' => 3,
                'scope' => [],
            },
            'checksum-types' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'default-raidtype' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'disk-types' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'raidgroup-size' => {
                'type' => 'raidgroup-size-info',
                'flags' => 3,
                'scope' => [],
            },
            'root-volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'snapshots-max' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'volume-get-language' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'language' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'language-code' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'nfs-character-set' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'oem-character-set' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'volume-get-root-name' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
        },
        'outputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'volume-get-supported-guarantees' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'guarantee-types' => {
                'type' => 'guarantee',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'volume-list-info' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'verbose' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'volumes' => {
                'type' => 'volume-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'volume-list-info-iter-end' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-list-info-iter-next' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'maximum' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'volumes' => {
                'type' => 'volume-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'volume-list-info-iter-start' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'verbose' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'volume-mediascrub-list-info' => {
        'category' => 'volume',
        'family' => [],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'mediascrub-details' => {
                'type' => 'mediascrub-detail-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'volume-mirror' => {
        'category' => 'volume',
        'family' => [],
        'inputs' => {
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'mirror-disks' => {
                'type' => 'disk-info',
                'flags' => 7,
                'scope' => [],
            },
            'victim-volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'bad-disks' => {
                'type' => 'disk-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'volume-move-abort' => {
        'category' => 'volume',
        'family' => ['ontap-c'],
        'inputs' => {
            'source-volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-move-cutover' => {
        'category' => 'volume',
        'family' => ['ontap-c'],
        'inputs' => {
            'cutover-window' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'source-volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-move-pause' => {
        'category' => 'volume',
        'family' => ['ontap-c'],
        'inputs' => {
            'source-volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-move-resume' => {
        'category' => 'volume',
        'family' => ['ontap-c'],
        'inputs' => {
            'cutover-attempts' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'cutover-window' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'is-keep-source' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-manual-cutover' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-override-warnings' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'source-volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'errors-warnings' => {
                'type' => 'errors-warnings-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'volume-move-start' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'ontap-cluster'],
        'inputs' => {
            'cutover-attempts' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'cutover-window' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'dest-aggr' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'is-keep-source' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => ['ontap-c'],
            },
            'is-manual-cutover' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => ['ontap-c'],
            },
            'is-override-warnings' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => ['ontap-c'],
            },
            'perform-validation-only' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'source-volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'errors-warnings' => {
                'type' => 'errors-warnings-info',
                'flags' => 7,
                'scope' => ['ontap-c'],
            },
        },
    },
    'volume-move-status' => {
        'category' => 'volume',
        'family' => ['ontap-c'],
        'inputs' => {
            'is-verbose' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'source-volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'status' => {
                'type' => 'vol-move-status-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'volume-offline' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'cifs-delay' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-online' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-options-list-info' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'options' => {
                'type' => 'volume-option-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'volume-rename' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'new-volume-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-restrict' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'cifs-delay' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-scrub-list-info' => {
        'category' => 'volume',
        'family' => [],
        'inputs' => {
            'name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'verbose' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'scrub-details' => {
                'type' => 'scrub-detail-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'volume-scrub-resume' => {
        'category' => 'volume',
        'family' => [],
        'inputs' => {
            'name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-scrub-start' => {
        'category' => 'volume',
        'family' => [],
        'inputs' => {
            'name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-scrub-stop' => {
        'category' => 'volume',
        'family' => [],
        'inputs' => {
            'name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-scrub-suspend' => {
        'category' => 'volume',
        'family' => [],
        'inputs' => {
            'name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-set-language' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'vfiler'],
        'inputs' => {
            'language-code' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-set-option' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'option-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'option-value' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-set-total-files' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'force' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'requested-total-files' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'resulting-total-files' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'volume-size' => {
        'category' => 'volume',
        'family' => ['ontap-c', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'new-size' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'is-fixed-size-flex-volume' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-readonly-flex-volume' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-replica-flex-volume' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'volume-size' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'volume-space-list-info' => {
        'category' => 'volume',
        'family' => ['ontap-c'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'vol-space-infos' => {
                'type' => 'vol-space-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'volume-space-list-info-iter-end' => {
        'category' => 'volume',
        'family' => ['ontap-c'],
        'inputs' => {
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-space-list-info-iter-next' => {
        'category' => 'volume',
        'family' => ['ontap-c'],
        'inputs' => {
            'maximum' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'vol-space-infos' => {
                'type' => 'vol-space-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'volume-space-list-info-iter-start' => {
        'category' => 'volume',
        'family' => ['ontap-c'],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'records' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tag' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'volume-split' => {
        'category' => 'volume',
        'family' => [],
        'inputs' => {
            'new-volume-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'plex' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-verify-list-info' => {
        'category' => 'volume',
        'family' => [],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
            'verify-details' => {
                'type' => 'verify-detail-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'volume-verify-resume' => {
        'category' => 'volume',
        'family' => [],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-verify-start' => {
        'category' => 'volume',
        'family' => [],
        'inputs' => {
            'fix-plex' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'log-only' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-verify-stop' => {
        'category' => 'volume',
        'family' => [],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-verify-suspend' => {
        'category' => 'volume',
        'family' => [],
        'inputs' => {
            'volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
        'outputs' => {
        },
    },
    'volume-wafl-info' => {
        'category' => 'volume',
        'family' => [],
        'inputs' => {
        },
        'outputs' => {
            'checksum-types' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'disk-types' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'root-volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'snapshots-max' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'wafl-sync' => {
        'category' => 'wafl',
        'family' => ['ontap-c', 'ontap-d', 'ontap-vserver', 'vfiler'],
        'inputs' => {
            'volumes' => {
                'type' => 'volume-name',
                'flags' => 6,
                'scope' => ['ontap-c', 'ontap-vserver', 'vfiler'],
            },
        },
        'outputs' => {
        },
    },
};

my $TYPEDEFS = {
    'aggr-64bit-upgrade-check-info' => {
        'category' => 'aggr',
        'fields' => {
            'added-space' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'cookie' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'last-errno' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'space-estimate-complete' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'aggr-64bit-upgrade-info' => {
        'category' => 'aggr',
        'fields' => {
            'check' => {
                'type' => 'aggr-64bit-upgrade-check-info',
                'flags' => 5,
                'scope' => [],
            },
            'start' => {
                'type' => 'aggr-64bit-upgrade-start-info',
                'flags' => 5,
                'scope' => [],
            },
            'status' => {
                'type' => 'aggr-64bit-upgrade-status-info',
                'flags' => 1,
                'scope' => [],
            },
        },
    },
    'aggr-64bit-upgrade-start-info' => {
        'category' => 'aggr',
        'fields' => {
            'last-errno' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'min-space-for-upgrade' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'aggr-64bit-upgrade-status-info' => {
        'category' => 'aggr',
        'fields' => {
            'block-format' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'aggr-info' => {
        'category' => 'aggr',
        'fields' => {
            'aggr-64bit-upgrade' => {
                'type' => 'aggr-64bit-upgrade-info',
                'flags' => 5,
                'scope' => [],
            },
            'aggregate-space-details' => {
                'type' => 'aggregate-space-info',
                'flags' => 5,
                'scope' => [],
            },
            'block-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'cache-raid-group-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'checksum-status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'checksum-style' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'disk-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'dr-home-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'dr-home-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'files-private-used' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'files-total' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'files-used' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'free-space-realloc' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'fsid' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'ha-policy' => {
                'type' => 'ha-policy-type',
                'flags' => 4,
                'scope' => [],
            },
            'has-local-root' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'has-partner-root' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'home-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'home-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'inodefile-private-capacity' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'inodefile-public-capacity' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'is-checksum-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-hybrid' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-hybrid-enabled' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-inconsistent' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-mirrored' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-snaplock' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'max-write-alloc-blocks' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'mirror-status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'mount-state' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'owner-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'owner-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'plex-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'plexes' => {
                'type' => 'plex-info',
                'flags' => 3,
                'scope' => [],
            },
            'raid-lost-write-state' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'raid-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'raid-status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'size-available' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'size-percentage-used' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'size-total' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'size-used' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'snaplock-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'striping' => {
                'type' => 'striping-type',
                'flags' => 4,
                'scope' => [],
            },
            'type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'uuid' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'volume-count-collective' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'volume-count-mirrors' => {
                'type' => 'mirror-count-info',
                'flags' => 5,
                'scope' => [],
            },
            'volume-count-not-online' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'volume-count-quiesced' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'volume-count-striped' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'volumes' => {
                'type' => 'contained-volume-info',
                'flags' => 3,
                'scope' => [],
            },
            'wafliron' => {
                'type' => 'aggr-wafliron-info',
                'flags' => 5,
                'scope' => [],
            },
        },
    },
    'aggr-option-info' => {
        'category' => 'aggr',
        'fields' => {
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'value' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'aggr-space-info' => {
        'category' => 'aggr',
        'fields' => {
            'aggregate-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'size-asis-used' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'size-bssm-nvlog-used' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'size-free' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'size-image-backup-used' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'size-metadata' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'size-nominal' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'size-snap-used' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'size-used' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'size-volume-allocated' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'size-volume-used' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'volume-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'volumes' => {
                'type' => 'volume-space-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'aggr-wafliron-info' => {
        'category' => 'aggr',
        'fields' => {
            'last-start-errno' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'last-start-error-info' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'scan-percentage' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'summary-scan-percentage' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'aggregate-space-info' => {
        'category' => 'aggr',
        'fields' => {
            'aggregate-space' => {
                'type' => 'fs-space-info',
                'flags' => 1,
                'scope' => [],
            },
            'snapshot-space' => {
                'type' => 'snapshot-space-info',
                'flags' => 1,
                'scope' => [],
            },
        },
    },
    'contained-volume-info' => {
        'category' => 'aggr',
        'fields' => {
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'disk-info' => {
        'category' => 'aggr',
        'fields' => {
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'filter-attrs-info' => {
        'category' => 'aggr',
        'fields' => {
            'all' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-cfo' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-dr-auxiliary' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-dr-partner' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-local' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-partner' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-sfo' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'fs-space-info' => {
        'category' => 'aggr',
        'fields' => {
            'fs-aggregate-metadata' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'fs-files-private-used' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'fs-files-total' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'fs-files-used' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'fs-hybrid-cache-size-total' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'fs-inodefile-private-capacity' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'fs-inodefile-public-capacity' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'fs-maxfiles-available' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'fs-maxfiles-possible' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'fs-maxfiles-used' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'fs-percent-inode-used-capacity' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'fs-percent-used-capacity' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'fs-sis-percent-saved' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'fs-sis-saved-space' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'fs-sis-shared-space' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'fs-size-available' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'fs-size-total' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'fs-size-used' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'fs-total-reserved-space' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'fs-used-including-snapshot-reserve' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'fs-volume-footprints' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'ha-policy-type' => {
        'category' => 'aggr',
        'fields' => {
        },
    },
    'mirror-count-info' => {
        'category' => 'aggr',
        'fields' => {
            'dp-qtree-snapmirror-destinations' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'dp-snapmirror-destinations' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'ls-snapmirror-destinations' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'move-snapmirror-destinations' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'node-name' => {
        'category' => 'aggr',
        'fields' => {
        },
    },
    'plex-info' => {
        'category' => 'aggr',
        'fields' => {
            'is-online' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-resyncing' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'plex-status' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'pool' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'raid-groups' => {
                'type' => 'raid-group-info',
                'flags' => 7,
                'scope' => [],
            },
            'resync-level' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'resyncing-percentage' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'raid-group-info' => {
        'category' => 'aggr',
        'fields' => {
            'checksum-style' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'disks' => {
                'type' => 'disk-info',
                'flags' => 3,
                'scope' => [],
            },
            'is-cache-tier' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-recomputing-parity' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-reconstructing' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-scrub-suspended' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'last-scrub-timestamp' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'recomputing-parity-percentage' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'reconstruction-percentage' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'scrub-percentage-complete' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'snapshot-space-info' => {
        'category' => 'aggr',
        'fields' => {
            'snapshot-files-total' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'snapshot-files-used' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'snapshot-maxfiles-available' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'snapshot-maxfiles-possible' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'snapshot-maxfiles-used' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'snapshot-percent-inode-used-capacity' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'snapshot-percent-used-capacity' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'snapshot-sis-percent-saved' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'snapshot-sis-saved-space' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'snapshot-sis-shared-space' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'snapshot-size-available' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'snapshot-size-total' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'snapshot-size-used' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'striping-type' => {
        'category' => 'aggr',
        'fields' => {
        },
    },
    'verify-detail-info' => {
        'category' => 'aggr',
        'fields' => {
            'is-suspended' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'percentage-complete' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'volume-space-info' => {
        'category' => 'aggr',
        'fields' => {
            'guarantee' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume-allocated' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'volume-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume-used' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'warning-code' => {
        'category' => 'aggr',
        'fields' => {
            'code' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'volume-name' => {
        'category' => 'cg',
        'fields' => {
        },
    },
    'access-rights-info' => {
        'category' => 'cifs',
        'fields' => {
            'access-rights' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'unix-group-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'user-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'address-info' => {
        'category' => 'cifs',
        'fields' => {
            'has-nossl' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'hostname' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'ip-address' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'is-broken' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-multihomed' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-primary' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'cifs-functional-level' => {
        'category' => 'cifs',
        'fields' => {
        },
    },
    'cifs-session-info' => {
        'category' => 'cifs',
        'fields' => {
            'change-notifies' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'dirs' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'files' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'host-ip' => {
                'type' => 'ip-address',
                'flags' => 0,
                'scope' => [],
            },
            'host-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'shares' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'user' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volumes-list' => {
                'type' => 'volumes-list-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'cifs-setup-ou' => {
        'category' => 'cifs',
        'fields' => {
        },
    },
    'cifs-setup-site' => {
        'category' => 'cifs',
        'fields' => {
        },
    },
    'cifs-share-acl-info' => {
        'category' => 'cifs',
        'fields' => {
            'share-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'user-acl-info' => {
                'type' => 'access-rights-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'cifs-share-info' => {
        'category' => 'cifs',
        'fields' => {
            'caching' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'description' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'dir-umask' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'file-umask' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'forcegroup' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'is-access-based-enum' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-browse' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-namespace-caching-allowed' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-symlink-strict-security' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-vol-offline' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-vscan' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-vscanread' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-widelink' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'maxusers' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'mount-point' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'share-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'umask' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'cifs-top-info' => {
        'category' => 'cifs',
        'fields' => {
            'ops-per-sec' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'read-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'read-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'suspicious-per-sec' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'user-info' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'write-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'write-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'connection-info' => {
        'category' => 'cifs',
        'fields' => {
            'connected-address' => {
                'type' => 'address-info',
                'flags' => 7,
                'scope' => [],
            },
            'favored-address' => {
                'type' => 'address-info',
                'flags' => 7,
                'scope' => [],
            },
            'other-address' => {
                'type' => 'address-info',
                'flags' => 7,
                'scope' => [],
            },
            'preferred-address' => {
                'type' => 'address-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'homedir-path-info' => {
        'category' => 'cifs',
        'fields' => {
        },
    },
    'nbalias-name-info' => {
        'category' => 'cifs',
        'fields' => {
        },
    },
    'path-error-info' => {
        'category' => 'cifs',
        'fields' => {
            'error-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'error-path-desc' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'volumes-list-info' => {
        'category' => 'cifs',
        'fields' => {
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'block-range' => {
        'category' => 'clone',
        'fields' => {
            'block-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'destination-block-number' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'source-block-number' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'clone-id-info' => {
        'category' => 'clone',
        'fields' => {
            'clone-op-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'volume-uuid' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'ops-info' => {
        'category' => 'clone',
        'fields' => {
            'block-ranges' => {
                'type' => 'block-range',
                'flags' => 7,
                'scope' => [],
            },
            'blocks-copied' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'clone-id' => {
                'type' => 'clone-id-info',
                'flags' => 5,
                'scope' => [],
            },
            'clone-state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'clone-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'destination-file' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'error' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'percent-done' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'reason' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'source-file' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'total-blocks' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'copyoffload-status-info' => {
        'category' => 'copyoffload',
        'fields' => {
            'bytes-copied' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'copy-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'copyoffload-error' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'copyoffload-state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'destination-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'length' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'source-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'datetime' => {
        'category' => 'core-segment',
        'fields' => {
        },
    },
    'date' => {
        'category' => 'diagnosis',
        'fields' => {
        },
    },
    'diagnosis-alert-definition-info' => {
        'category' => 'diagnosis',
        'fields' => {
            'additional-information' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'alert-id' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'alert-type' => {
                'type' => 'hm-alert-type',
                'flags' => 4,
                'scope' => [],
            },
            'corrective-actions' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'monitor' => {
                'type' => 'hm-type',
                'flags' => 4,
                'scope' => [],
            },
            'node' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'perceived-severity' => {
                'type' => 'hm-perceived-sev',
                'flags' => 4,
                'scope' => [],
            },
            'possible-effect' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'probable-cause' => {
                'type' => 'hm-probable-cause',
                'flags' => 4,
                'scope' => [],
            },
            'probable-cause-description' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'subsystem' => {
                'type' => 'hm-subsystem',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'diagnosis-alert-info' => {
        'category' => 'diagnosis',
        'fields' => {
            'acknowledge' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'acknowledger' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'additional-info' => {
                'type' => 'string',
                'flags' => 6,
                'scope' => [],
            },
            'alert-id' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'alerting-resource' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'alerting-resource-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'corrective-actions' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'indication-time' => {
                'type' => 'date',
                'flags' => 4,
                'scope' => [],
            },
            'monitor' => {
                'type' => 'hm-type',
                'flags' => 4,
                'scope' => [],
            },
            'node' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'perceived-severity' => {
                'type' => 'hm-perceived-sev',
                'flags' => 4,
                'scope' => [],
            },
            'policy' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'possible-effect' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'probable-cause' => {
                'type' => 'hm-probable-cause',
                'flags' => 4,
                'scope' => [],
            },
            'probable-cause-description' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'subsystem' => {
                'type' => 'hm-subsystem',
                'flags' => 4,
                'scope' => [],
            },
            'suppress' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'suppressor' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'diagnosis-config-info' => {
        'category' => 'diagnosis',
        'fields' => {
            'aggregator' => {
                'type' => 'hm-type',
                'flags' => 4,
                'scope' => [],
            },
            'context' => {
                'type' => 'hm-scope',
                'flags' => 4,
                'scope' => [],
            },
            'health' => {
                'type' => 'hm-status',
                'flags' => 4,
                'scope' => [],
            },
            'init-state' => {
                'type' => 'hm-subsystem-discovery-state',
                'flags' => 4,
                'scope' => [],
            },
            'mon-version' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'monitor' => {
                'type' => 'hm-type',
                'flags' => 4,
                'scope' => [],
            },
            'node' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'pol-version' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'resources' => {
                'type' => 'string',
                'flags' => 6,
                'scope' => [],
            },
            'sub-pol-versions' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'subsystem' => {
                'type' => 'hm-subsystem',
                'flags' => 6,
                'scope' => [],
            },
        },
    },
    'diagnosis-policy-definition-info' => {
        'category' => 'diagnosis',
        'fields' => {
            'alert-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'alert-id' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'creation-time' => {
                'type' => 'datetime',
                'flags' => 4,
                'scope' => [],
            },
            'enable' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'monitor' => {
                'type' => 'hm-type',
                'flags' => 4,
                'scope' => [],
            },
            'node' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'policy-id' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'responsible-resource-info' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'rule-expression' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'where' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'diagnosis-status' => {
        'category' => 'diagnosis',
        'fields' => {
            'status' => {
                'type' => 'hm-status',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'diagnosis-subscriptions-info' => {
        'category' => 'diagnosis',
        'fields' => {
            'class-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'creation-time' => {
                'type' => 'datetime',
                'flags' => 4,
                'scope' => [],
            },
            'event-type' => {
                'type' => 'hm-event-type',
                'flags' => 4,
                'scope' => [],
            },
            'fail-thresh' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'instance-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'max-notify-period' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'monitor' => {
                'type' => 'hm-type',
                'flags' => 4,
                'scope' => [],
            },
            'node' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'notify-dest-hm' => {
                'type' => 'hm-type',
                'flags' => 4,
                'scope' => [],
            },
            'notify-dest-node' => {
                'type' => 'node-name',
                'flags' => 4,
                'scope' => [],
            },
            'notify-fptr' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'notify-table' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'notify-type' => {
                'type' => 'hm-notify-type',
                'flags' => 4,
                'scope' => [],
            },
            'psc-option' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'subscription-id' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'time-gap-notify' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'diagnosis-subsystem-config-info' => {
        'category' => 'diagnosis',
        'fields' => {
            'health' => {
                'type' => 'hm-status',
                'flags' => 4,
                'scope' => [],
            },
            'init-state' => {
                'type' => 'hm-subsystem-discovery-state',
                'flags' => 4,
                'scope' => [],
            },
            'outstanding-alert-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'subsystem' => {
                'type' => 'hm-subsystem',
                'flags' => 4,
                'scope' => [],
            },
            'suppressed-alert-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'hm-alert-type' => {
        'category' => 'diagnosis',
        'fields' => {
        },
    },
    'hm-event-type' => {
        'category' => 'diagnosis',
        'fields' => {
        },
    },
    'hm-notify-type' => {
        'category' => 'diagnosis',
        'fields' => {
        },
    },
    'hm-perceived-sev' => {
        'category' => 'diagnosis',
        'fields' => {
        },
    },
    'hm-probable-cause' => {
        'category' => 'diagnosis',
        'fields' => {
        },
    },
    'hm-scope' => {
        'category' => 'diagnosis',
        'fields' => {
        },
    },
    'hm-status' => {
        'category' => 'diagnosis',
        'fields' => {
        },
    },
    'hm-subsystem' => {
        'category' => 'diagnosis',
        'fields' => {
        },
    },
    'hm-subsystem-discovery-state' => {
        'category' => 'diagnosis',
        'fields' => {
        },
    },
    'hm-type' => {
        'category' => 'diagnosis',
        'fields' => {
        },
    },
    'disk-detail-info' => {
        'category' => 'disk',
        'fields' => {
            'aggregate' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'bay' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'blocks-read' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'blocks-written' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'broken-details' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'bytes-per-sector' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'checksum-compatibility' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'copy-destination' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'copy-percent' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'disk-model' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'disk-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'disk-uid' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'effective-disk-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'firmware-revision' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'grown-defect-list-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'host-adapter' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'is-dynamically-qualified' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-offline' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-prefailed' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-replacing' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-zeroed' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'node' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'physical-blocks' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'physical-space' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'plex' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'pool' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'port' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'port-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'poweron-hours' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'raid-group' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'raid-state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'raid-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'raw-disk-sectors' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'reconstruction-percent' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'rpm' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'scrub-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'scrub-last-done' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'secondary-host-adapter' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'secondary-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'secondary-port' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'serial-number' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'shelf' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'shm-time-interval' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'ssd-info' => {
                'type' => 'storage-ssd-info',
                'flags' => 5,
                'scope' => [],
            },
            'used-blocks' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'used-space' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'v-series-detail-info' => {
                'type' => 'v-series-detail-info',
                'flags' => 5,
                'scope' => [],
            },
            'vendor-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'zeroing-percent' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'disk-name' => {
        'category' => 'disk',
        'fields' => {
        },
    },
    'disk-sanown-detail-info' => {
        'category' => 'disk',
        'fields' => {
            'checksum' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'home' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'home-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'is-failed' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'owner' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'owner-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'pool' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'reserved-by' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'serial-no' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'disk-sanown-filer-detail-info' => {
        'category' => 'disk',
        'fields' => {
            'filer-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'filer-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'storage-ssd-info' => {
        'category' => 'disk',
        'fields' => {
            'percent-rated-life-used' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'percent-spares-consumed' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'percent-spares-consumed-limit' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'v-series-detail-info' => {
        'category' => 'disk',
        'fields' => {
            'alternate-array-node-wwn' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'alternate-array-port-wwn' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'alternate-array-switch-port-wwn' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'alternate-controller-port-wwn' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'alternate-lun-number' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'alternate-switch-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'alternate-switch-port' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'alternate-vseries-port-wwn' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'primary-array-node-wwn' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'primary-array-port-wwn' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'primary-array-switch-port-wwn' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'primary-controller-port-wwn' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'primary-lun-number' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'primary-switch-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'primary-switch-port' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'primary-vseries-port-wwn' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'product-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'param' => {
        'category' => 'ems',
        'fields' => {
        },
    },
    'fc-config-info' => {
        'category' => 'fc',
        'fields' => {
            'adapter-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'adapter-state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'adapter-status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'adapter-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'pending-fc-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'aliases-info' => {
        'category' => 'fcp',
        'fields' => {
            'aliases-alias' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'aliases-wwpn' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'fcp-adapter-initiators-info' => {
        'category' => 'fcp',
        'fields' => {
            'adapter' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'fcp-connected-initiators' => {
                'type' => 'fcp-connected-initiator-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'fcp-adapter-nameserver-object-info' => {
        'category' => 'fcp',
        'fields' => {
            'adapter' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'class-service' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'fabric-port-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'fc4-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'node-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'port-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'port-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'port-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'symbolic-node-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'symbolic-port-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'fcp-adapter-stats-info' => {
        'category' => 'fcp',
        'fields' => {
            'adapter' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'adapter-resets' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'crc-errors' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'discarded-frames' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'frame-overruns' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'frame-underruns' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'initiators-connected' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'invalid-xmit-words' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'is-sfp-diagnostics-internally-calibrated' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-sfp-optical-transceiver-valid' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-sfp-rx-power-in-range' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-sfp-tx-power-in-range' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'link-breaks' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'lip-resets' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'lr-received' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'lr-sent' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'nos-received' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'ols-received' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'protocol-errors' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'queue-depth' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'scsi-requests-dropped' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'sfp-connector' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'sfp-date-code' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'sfp-encoding' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'sfp-fc-speedcapabilities' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'sfp-formfactor' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'sfp-part-number' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'sfp-rev' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'sfp-rx-power' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'sfp-serial-number' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'sfp-tx-power' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'sfp-vendor-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'sfp-vendor-oui' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'sfp-wavelength' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'spurious-interrupts' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'total-logins' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'total-logouts' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'fcp-adapter-topology-attached-port-info' => {
        'category' => 'fcp',
        'fields' => {
            'is-visible' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'port-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'port-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'fcp-adapter-topology-switch-info' => {
        'category' => 'fcp',
        'fields' => {
            'adapter' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'domain' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'fcp-adapter-topology-switch-ports' => {
                'type' => 'fcp-adapter-topology-switch-port-info',
                'flags' => 7,
                'scope' => [],
            },
            'logical-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'node-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'port-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'release' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'vendor' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'fcp-adapter-topology-switch-port-info' => {
        'category' => 'fcp',
        'fields' => {
            'fcp-adapter-topology-attached-ports' => {
                'type' => 'fcp-adapter-topology-attached-port-info',
                'flags' => 3,
                'scope' => [],
            },
            'port-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'port-number' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'port-state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'port-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'fcp-adapter-zone-info' => {
        'category' => 'fcp',
        'fields' => {
            'adapter' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'fcp-adapter-zone-members' => {
                'type' => 'fcp-adapter-zone-member-info',
                'flags' => 1,
                'scope' => [],
            },
            'zone-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'zone-set-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'fcp-adapter-zone-member-info' => {
        'category' => 'fcp',
        'fields' => {
            'domain-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'fabric-port-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'node-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'port' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'port-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'port-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'zone-member-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'zone-member-value' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'fcp-config-adapter-info' => {
        'category' => 'fcp',
        'fields' => {
            'adapter' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'adapter-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => ['ontap-c'],
            },
            'cache-line-size' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'connection-established' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'data-link-rate' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'error-msg' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'external-gbic-enabled' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'fabric-established' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'firmware-rev' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'hardware-rev' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'info-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'loop-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => ['ontap-c'],
            },
            'media-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'mpi-firmware-rev' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'node-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'packet-size' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'partner-adapter' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => ['ontap-c'],
            },
            'pci-bus-width' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'pci-clock-speed' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'phy-firmware-rev' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'physical-data-link-rate' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'physical-link-state' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'port-address' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'port-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => ['ontap-c'],
            },
            'port-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'preload-table-rev' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'speed' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'sram-parity-enabled' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'standby' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => ['ontap-c'],
            },
            'state' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'switch-port' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'vlan-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'fcp-connected-initiator-info' => {
        'category' => 'fcp',
        'fields' => {
            'initiator-group-list' => {
                'type' => 'initiator-group-list-info',
                'flags' => 7,
                'scope' => [],
            },
            'node-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'port-address' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'port-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'portname-alias-list' => {
                'type' => 'portname-alias-name',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'fcp-port-name-info' => {
        'category' => 'fcp',
        'fields' => {
            'fcp-adapter' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'is-used' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'port-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'portname-alias-name' => {
        'category' => 'fcp',
        'fields' => {
            'portname-alias' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'fc-ports' => {
        'category' => 'fcport',
        'fields' => {
            'port-number' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'port-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'switch-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'switch-wwn' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'link-state-info' => {
        'category' => 'fcport',
        'fields' => {
            'adapter-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'fc-port-info' => {
                'type' => 'fc-ports',
                'flags' => 5,
                'scope' => [],
            },
            'link-state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'managed-feature' => {
        'category' => 'feature',
        'fields' => {
        },
    },
    'managed-feature-status' => {
        'category' => 'feature',
        'fields' => {
        },
    },
    'managed-feature-status-info' => {
        'category' => 'feature',
        'fields' => {
            'feature-name' => {
                'type' => 'managed-feature',
                'flags' => 4,
                'scope' => [],
            },
            'notes' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'status' => {
                'type' => 'managed-feature-status',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'digest-algorithm' => {
        'category' => 'file',
        'fields' => {
        },
    },
    'file-fingerprint-info' => {
        'category' => 'file',
        'fields' => {
            'access-time' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'changed-time' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'creation-time' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'data-fingerprint' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'file-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'file-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'fileid' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'formatted-access-time' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'formatted-changed-time' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'formatted-creation-time' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'formatted-modified-time' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'formatted-retention-time' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'fsid' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'group-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'is-changed-time-wraparound' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-wraparound' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'metadata-fingerprint' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'modified-time' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'owner-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'owner-sid' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'retention-time' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'file-info' => {
        'category' => 'file',
        'fields' => {
            'accessed-timestamp' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'acl-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'bytes-used' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'changed-timestamp' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'creation-timestamp' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'file-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'file-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'group-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'hard-links-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'inode-gen-number' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'inode-number' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'is-empty' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-junction' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-vm-aligned' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'modified-timestamp' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'owner-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'perm' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'file-scope' => {
        'category' => 'file',
        'fields' => {
        },
    },
    'fingerprint-info' => {
        'category' => 'file',
        'fields' => {
            'aggregate-uuid' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'filer-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'filer-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'fingerprint-algorithm' => {
                'type' => 'digest-algorithm',
                'flags' => 0,
                'scope' => [],
            },
            'fingerprint-end-time' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'fingerprint-input-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'fingerprint-scope' => {
                'type' => 'file-scope',
                'flags' => 0,
                'scope' => [],
            },
            'fingerprint-start-time' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'fingerprint-version' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'formatted-fingerprint-end-time' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'formatted-fingerprint-start-time' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'formatted-snaplock-system-compliance-clock' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'formatted-snaplock-volume-compliance-clock' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'formatted-volume-expiry-date' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'is-volume-expiry-date-wraparound' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'metadata-files' => {
                'type' => 'file-fingerprint-info',
                'flags' => 3,
                'scope' => [],
            },
            'snaplock-license' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'snaplock-system-compliance-clock' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'snaplock-volume-compliance-clock' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'volume-containing-aggregate' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume-expiry-date' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'volume-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume-snaplock-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume-uuid' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'hole-range-info' => {
        'category' => 'file',
        'fields' => {
            'hole-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'hole-start' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'inode-parent-info' => {
        'category' => 'file',
        'fields' => {
            'inode-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'inode-parent-cookie' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'inode-parent-inode-number' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'inode-path' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'flash-device-info' => {
        'category' => 'flash',
        'fields' => {
            'average-erase-cycle-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'capacity' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'firmware-revision' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'last-change-time' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'model-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'part-number' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'percent-online' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'serial-number' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'service-time' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'slot-number' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'threshold-profile' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'flash-threshold' => {
        'category' => 'flash',
        'fields' => {
            'action' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'domain' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'threshold-units' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'threshold-value' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'time-slice' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'flash-threshold-profile' => {
        'category' => 'flash',
        'fields' => {
            'flash-threshold' => {
                'type' => 'flash-threshold',
                'flags' => 3,
                'scope' => [],
            },
            'profile' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'extension-list-info' => {
        'category' => 'fpolicy',
        'fields' => {
            'name-spec' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'fpolicy-volumes-list-info' => {
        'category' => 'fpolicy',
        'fields' => {
            'volume-spec' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'monitored-operation-info' => {
        'category' => 'fpolicy',
        'fields' => {
            'operation' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'monitored-protocol-info' => {
        'category' => 'fpolicy',
        'fields' => {
            'protocol' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'policy-info' => {
        'category' => 'fpolicy',
        'fields' => {
            'is-ads-monitored' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-i2p-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-offline-files-only' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'monitored-operations' => {
                'type' => 'monitored-operation-info',
                'flags' => 3,
                'scope' => [],
            },
            'monitored-protocols' => {
                'type' => 'monitored-protocol-info',
                'flags' => 3,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'number-of-requests-blocked-locally' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'number-of-screen-failures' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'number-of-screened-files' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'secondary-server-info' => {
        'category' => 'fpolicy',
        'fields' => {
            'server-ip' => {
                'type' => 'ip-address',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'server-info' => {
        'category' => 'fpolicy',
        'fields' => {
            'idl-version' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'is-asynchronous' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-size-and-owner-required' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-snapid-required' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-version2' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'number-of-screen-failures' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'number-of-screened-files' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'offline-filter-bit' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'server-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'server-ip' => {
                'type' => 'ip-address',
                'flags' => 0,
                'scope' => [],
            },
            'smb-req-pipe-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'ic-config-details' => {
        'category' => 'ic',
        'fields' => {
            'ic-rlib-if' => {
                'type' => 'ic-rlib-if-info',
                'flags' => 7,
                'scope' => [],
            },
            'ic-system-id' => {
                'type' => 'ic-system-id-info',
                'flags' => 3,
                'scope' => [],
            },
            'interconnect-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'interface-config' => {
                'type' => 'interface-config-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'ic-counter' => {
        'category' => 'ic',
        'fields' => {
            'counter-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'counter-value' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'ic-rlib-if-info' => {
        'category' => 'ic',
        'fields' => {
            'interface-ip' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'interface-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'ic-system-id-info' => {
        'category' => 'ic',
        'fields' => {
            'is-connection-initiator' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'node' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'system-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'nvram-per-port-counters-info' => {
        'category' => 'ic',
        'fields' => {
            'counter-list' => {
                'type' => 'ic-counter',
                'flags' => 7,
                'scope' => [],
            },
            'port-number' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'per-link-parameters-info' => {
        'category' => 'ic',
        'fields' => {
            'link-number' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'link-state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'num-mad-received' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'num-mad-sent' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'num-recv-desc' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'port-mtu' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'port-state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'queue-info' => {
        'category' => 'ic',
        'fields' => {
            'id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'last-complete-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'last-polled-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'virtual-interface-socket-stat-info' => {
        'category' => 'ic',
        'fields' => {
            'channel-number' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'per-channel-counters' => {
                'type' => 'ic-counter',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'initiator-group-info' => {
        'category' => 'igroup',
        'fields' => {
            'initiator-group-alua-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-group-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-group-os-type' => {
                'type' => 'initiator-group-os-type',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-group-portset-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'initiator-group-report-scsi-name-enabled' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'initiator-group-throttle-borrow' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-group-throttle-reserve' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-group-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-group-use-partner' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'initiator-group-uuid' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'initiator-group-vsa-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'initiators' => {
                'type' => 'initiator-info',
                'flags' => 7,
                'scope' => [],
            },
            'lun-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'initiator-group-list-info' => {
        'category' => 'igroup',
        'fields' => {
            'initiator-group-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'initiator-group-os-type' => {
        'category' => 'igroup',
        'fields' => {
        },
    },
    'initiator-info' => {
        'category' => 'igroup',
        'fields' => {
            'initiator-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'interface-info' => {
        'category' => 'ipspace',
        'fields' => {
            'interface' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'ipspace-info' => {
        'category' => 'ipspace',
        'fields' => {
            'interfaces' => {
                'type' => 'interface-info',
                'flags' => 3,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'interface-list-entry-info' => {
        'category' => 'iscsi',
        'fields' => {
            'interface-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'ipaddress-list-entry-info' => {
        'category' => 'iscsi',
        'fields' => {
            'ip-address' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'iscsi-adapter-initiators-info' => {
        'category' => 'iscsi',
        'fields' => {
            'iscsi-connected-initiators' => {
                'type' => 'iscsi-connected-initiator-info',
                'flags' => 3,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'iscsi-cdb-stats-info' => {
        'category' => 'iscsi',
        'fields' => {
            'data-in-blocks' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'data-out-blocks' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'error-status' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'success-status' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'total' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'iscsi-config-adapter-info' => {
        'category' => 'iscsi',
        'fields' => {
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'portal-addresses' => {
                'type' => 'iscsi-portal-address-info',
                'flags' => 3,
                'scope' => [],
            },
            'state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'status' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'iscsi-connected-initiator-info' => {
        'category' => 'iscsi',
        'fields' => {
            'initiator-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'isid' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'portal-group-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'iscsi-connection-list-entry-info' => {
        'category' => 'iscsi',
        'fields' => {
            'connection-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'connection-state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'has-session' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'interface-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'local-ip-address' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'local-ip-port' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'remote-ip-address' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'remote-ip-port' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'session-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tpgroup-tag' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'iscsi-error-stats-info' => {
        'category' => 'iscsi',
        'fields' => {
            'data-digest' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'failed-logins' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'failed-logouts' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'failed-task-mgt' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'failed-text-cmd' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'hdr-digest' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'invalid-header' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'outside-cmd-sn-window' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'protocol' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'total' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'iscsi-initiator-list-entry-info' => {
        'category' => 'iscsi',
        'fields' => {
            'initiator-aliasname' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'initiator-group-list' => {
                'type' => 'initiator-group-list-info',
                'flags' => 7,
                'scope' => [],
            },
            'initiator-nodename' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'isid' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'target-session-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tpgroup-tag' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'iscsi-interface-list-entry-info' => {
        'category' => 'iscsi',
        'fields' => {
            'interface-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'is-interface-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'tpgroup-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'tpgroup-tag' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'iscsi-iptpgroup-list-entry-info' => {
        'category' => 'iscsi',
        'fields' => {
            'ipaddress-list-entries' => {
                'type' => 'ipaddress-list-entry-info',
                'flags' => 3,
                'scope' => [],
            },
            'tpgroup-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'tpgroup-tag' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'iscsi-portal-address-info' => {
        'category' => 'iscsi',
        'fields' => {
            'id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'inet-address' => {
                'type' => 'ip-address',
                'flags' => 0,
                'scope' => [],
            },
            'port' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'iscsi-portal-list-entry-info' => {
        'category' => 'iscsi',
        'fields' => {
            'interface-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'ip-address' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'ip-port' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tpgroup-tag' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'iscsi-received-stats-info' => {
        'category' => 'iscsi',
        'fields' => {
            'data-out' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'login-req' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'logout-req' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'nop-out' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'scsi-cmd' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'scsi-task-mgt-cmd' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'snack' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'text-req' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'total' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'unknown' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'iscsi-security-entry-info' => {
        'category' => 'iscsi',
        'fields' => {
            'auth-chap-policy' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'auth-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'initiator' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'outbound-user-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'user-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'iscsi-session-connection-list-entry-info' => {
        'category' => 'iscsi',
        'fields' => {
            'authentication-method' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'connection-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'data-digest-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'header-digest-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-max-rcv-data-segment-length' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'interface-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'local-ip-address' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'local-ip-port' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'rcv-window-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'remote-ip-address' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'remote-ip-port' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'target-max-rcv-data-segment-length' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'iscsi-session-list-entry-info' => {
        'category' => 'iscsi',
        'fields' => {
            'cmd-window-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'data-pdu-in-order' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'data-sequence-in-order' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'default-time-to-retain' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'default-time-to-wait' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'error-recovery-level' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'first-burst-length' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'immediate-data-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'initial-r2t-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-aliasname' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'initiator-nodename' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'iscsi-session-connection-list-entries' => {
                'type' => 'iscsi-session-connection-list-entry-info',
                'flags' => 3,
                'scope' => [],
            },
            'iscsi-sesssion-cmd-list-entries' => {
                'type' => 'iscsi-sesssion-cmd-list-entry-info',
                'flags' => 7,
                'scope' => [],
            },
            'isid' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'max-burst-length' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'max-connections' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'max-outstanding-r2t' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'session-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'target-session-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tpgroup-tag' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'iscsi-sesssion-cmd-list-entry-info' => {
        'category' => 'iscsi',
        'fields' => {
            'cmd-state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'cmd-sub-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'cmd-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'iscsi-stats-info' => {
        'category' => 'iscsi',
        'fields' => {
            'iscsi-cdb-stats' => {
                'type' => 'iscsi-cdb-stats-info',
                'flags' => 1,
                'scope' => [],
            },
            'iscsi-error-stats' => {
                'type' => 'iscsi-error-stats-info',
                'flags' => 1,
                'scope' => [],
            },
            'iscsi-received-stats' => {
                'type' => 'iscsi-received-stats-info',
                'flags' => 1,
                'scope' => [],
            },
            'iscsi-transmitted-stats' => {
                'type' => 'iscsi-transmitted-stats-info',
                'flags' => 1,
                'scope' => [],
            },
        },
    },
    'iscsi-tpgroup-list-entry-info' => {
        'category' => 'iscsi',
        'fields' => {
            'interface-list-entries' => {
                'type' => 'interface-list-entry-info',
                'flags' => 7,
                'scope' => [],
            },
            'tpgroup-alua-preferred' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'tpgroup-alua-state' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'tpgroup-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'tpgroup-tag' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'iscsi-transmitted-stats-info' => {
        'category' => 'iscsi',
        'fields' => {
            'async-msg' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'data-in' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'login-rsp' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'logout-rsp' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'nop-in' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'ready-to-transmit' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'reject' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'scsi-rsp' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'scsi-task-mgt-rsp' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'text-rsp' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'total' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'license-info' => {
        'category' => 'license',
        'fields' => {
            'code' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'expiration-timestamp' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'installation-timestamp' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'is-auto-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-demo' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-expired' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-licensed' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-site' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'length' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'node-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'package-list' => {
                'type' => 'package-master',
                'flags' => 6,
                'scope' => [],
            },
            'platform' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'service' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'storage-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'package-master' => {
        'category' => 'license',
        'fields' => {
        },
    },
    'license-code-v2' => {
        'category' => 'license-v2',
        'fields' => {
        },
    },
    'license-v2-info' => {
        'category' => 'license-v2',
        'fields' => {
            'customer-id' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'description' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'expiration-time' => {
                'type' => 'datetime',
                'flags' => 4,
                'scope' => [],
            },
            'grace-period-expiration' => {
                'type' => 'datetime',
                'flags' => 4,
                'scope' => ['ontap-c'],
            },
            'is-in-grace-period' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => ['ontap-c'],
            },
            'legacy' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'owner' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'package' => {
                'type' => 'licensed-package',
                'flags' => 4,
                'scope' => [],
            },
            'serial-number' => {
                'type' => 'node-serial-number',
                'flags' => 4,
                'scope' => [],
            },
            'type' => {
                'type' => 'license-v2-type',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'license-v2-op-status' => {
        'category' => 'license-v2',
        'fields' => {
        },
    },
    'license-v2-result' => {
        'category' => 'license-v2',
        'fields' => {
            'description' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'entry' => {
                'type' => 'license-code-v2',
                'flags' => 4,
                'scope' => [],
            },
            'errcode' => {
                'type' => 'license-v2-op-status',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'license-v2-type' => {
        'category' => 'license-v2',
        'fields' => {
        },
    },
    'licensed-package' => {
        'category' => 'license-v2',
        'fields' => {
        },
    },
    'node-serial-number' => {
        'category' => 'license-v2',
        'fields' => {
        },
    },
    'break-error' => {
        'category' => 'lock',
        'fields' => {
            'err' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'cifs-lock' => {
        'category' => 'lock',
        'fields' => {
            'absolute-path' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'bytelock-length' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'bytelock-offset' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'dh-state' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'fileid' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'fsid' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'host-ip' => {
                'type' => 'ip-address',
                'flags' => 0,
                'scope' => [],
            },
            'host-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'is-bytelock-exclusive' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'lock-error' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'mode' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'oplock-level' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'owner' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'pid' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'lock-status-info' => {
        'category' => 'lock',
        'fields' => {
            'cifs-lock' => {
                'type' => 'cifs-lock',
                'flags' => 5,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'nfsv4-lock' => {
                'type' => 'nfsv4-lock',
                'flags' => 5,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'nlm-lock' => {
                'type' => 'nlm-lock',
                'flags' => 5,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'pfs-lock' => {
                'type' => 'pfs-lock',
                'flags' => 5,
                'scope' => ['ontap-c', 'vfiler'],
            },
        },
    },
    'nfsv4-lock' => {
        'category' => 'lock',
        'fields' => {
            'bytelock-length' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'bytelock-offset' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'fileid' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'fsid' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'host-ip' => {
                'type' => 'ip-address',
                'flags' => 4,
                'scope' => [],
            },
            'is-bytelock-exclusive' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'lock-error' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'mode' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'owner' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'pid' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'state-index-table' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'nlm-lock' => {
        'category' => 'lock',
        'fields' => {
            'bytelock-length' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'bytelock-offset' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'fileid' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'fsid' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'host' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'is-bytelock-exclusive' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'last-hop-caching-filer' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'lock-error' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'mode' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'owner' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'pfs-lock' => {
        'category' => 'lock',
        'fields' => {
            'fileid' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'fsid' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'host-ip' => {
                'type' => 'ip-address',
                'flags' => 4,
                'scope' => [],
            },
            'host-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'lock-error' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'mode' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'owner' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'alua-setting-mismatch-initiator-group' => {
        'category' => 'lun',
        'fields' => {
            'initiator-group-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'local-alua-is-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'partner-alua-is-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'alua-setting-mismatch-initiator-info' => {
        'category' => 'lun',
        'fields' => {
            'alua-is-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-group-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'clone-status-info' => {
        'category' => 'lun',
        'fields' => {
            'blocks-completed' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'blocks-total' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'conflict-wwpn' => {
        'category' => 'lun',
        'fields' => {
        },
    },
    'conflicting-initiator-info' => {
        'category' => 'lun',
        'fields' => {
            'initiator-local-os-type' => {
                'type' => 'initiator-group-os-type',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-partner-os-type' => {
                'type' => 'initiator-group-os-type',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'conflicting-luns-list' => {
        'category' => 'lun',
        'fields' => {
            'conflict-lun-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'conflicting-map-info' => {
        'category' => 'lun',
        'fields' => {
            'initiator-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'lun-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'fcp-down-hba-info' => {
        'category' => 'lun',
        'fields' => {
            'adapter' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'fcp-pr-nexus' => {
        'category' => 'lun',
        'fields' => {
            'initiator-port' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'target-port' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'invalid-cfmode-setting-info' => {
        'category' => 'lun',
        'fields' => {
            'local-fcp-cfmode' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'partner-fcp-cfmode' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'invalid-nodename-setting-info' => {
        'category' => 'lun',
        'fields' => {
            'local-fcp-node-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'partner-fcp-node-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'invalid-ostype-cfmode-setting-info' => {
        'category' => 'lun',
        'fields' => {
            'initiator-group-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-group-os-type' => {
                'type' => 'initiator-group-os-type',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'invalid-use-partner-cfmode-setting-info' => {
        'category' => 'lun',
        'fields' => {
            'initiator-group-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'is-use-partner-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'invalid-use-partner-ostype-setting-info' => {
        'category' => 'lun',
        'fields' => {
            'initiator-group-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-group-os-type' => {
                'type' => 'initiator-group-os-type',
                'flags' => 0,
                'scope' => [],
            },
            'is-use-partner-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'invalid-vsa-setting-info' => {
        'category' => 'lun',
        'fields' => {
            'initiator-group-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-group-os-type' => {
                'type' => 'initiator-group-os-type',
                'flags' => 0,
                'scope' => [],
            },
            'is-vsa-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'iscsi-pr-nexus' => {
        'category' => 'lun',
        'fields' => {
            'initiator' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'isid' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'tpgtag' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
        },
    },
    'lun-clone-lists-info' => {
        'category' => 'lun',
        'fields' => {
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'lun-info' => {
        'category' => 'lun',
        'fields' => {
            'alignment' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'backing-snapshot' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'block-size' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'clone-backing-snapshot' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'device-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'is-space-reservation-enabled' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'mapped' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'multiprotocol-type' => {
                'type' => 'lun-os-type',
                'flags' => 4,
                'scope' => [],
            },
            'online' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'prefix-size' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'read-only' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'serial-number' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'share-state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'size' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'size-used' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'staging' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'suffix-size' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'uuid' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'lun-map-info' => {
        'category' => 'lun',
        'fields' => {
            'initiator-group' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'lun-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'lun-os-type' => {
        'category' => 'lun',
        'fields' => {
        },
    },
    'lun-snap-usage-lun-info' => {
        'category' => 'lun',
        'fields' => {
            'backing-store' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'snapshot' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'lun-stats-info' => {
        'category' => 'lun',
        'fields' => {
            'block-size' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'last-zeroed' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'other-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'read-blocks' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'read-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'write-blocks' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'write-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'mixed-ostype-initiator-info' => {
        'category' => 'lun',
        'fields' => {
            'initiator-group-name-1' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-group-name-2' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-group-os-type-1' => {
                'type' => 'initiator-group-os-type',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-group-os-type-2' => {
                'type' => 'initiator-group-os-type',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'mixed-vsa-initiator-info' => {
        'category' => 'lun',
        'fields' => {
            'initiator-group-name-1' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-group-name-2' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'is-vsa-enabled-1' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-vsa-enabled-2' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'persistent-reservation-info' => {
        'category' => 'lun',
        'fields' => {
            'fcp-pr-nexus' => {
                'type' => 'fcp-pr-nexus',
                'flags' => 5,
                'scope' => [],
            },
            'iscsi-pr-nexus' => {
                'type' => 'iscsi-pr-nexus',
                'flags' => 5,
                'scope' => [],
            },
            'reservation-key' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'reservation-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'reservation-type-code' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'address-info-family' => {
        'category' => 'net',
        'fields' => {
        },
    },
    'address-info-flag' => {
        'category' => 'net',
        'fields' => {
        },
    },
    'address-info-socket-type' => {
        'category' => 'net',
        'fields' => {
        },
    },
    'address-info-transport-protocol' => {
        'category' => 'net',
        'fields' => {
        },
    },
    'config-status-info' => {
        'category' => 'net',
        'fields' => {
            'operation' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'host-info' => {
        'category' => 'net',
        'fields' => {
            'hints' => {
                'type' => 'net-address-info',
                'flags' => 5,
                'scope' => [],
            },
            'host-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'service-port' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'host-name' => {
        'category' => 'net',
        'fields' => {
        },
    },
    'ifgrp-info' => {
        'category' => 'net',
        'fields' => {
            'favored' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'ifgrp-policy' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'ifgrp-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'interface-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'links' => {
                'type' => 'link',
                'flags' => 6,
                'scope' => [],
            },
            'nofavored' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'interface-config-info' => {
        'category' => 'net',
        'fields' => {
            'aliases' => {
                'type' => 'ip-address-info',
                'flags' => 7,
                'scope' => [],
            },
            'dad-attempts' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'flowcontrol' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'interface-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'ipspace-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'is-enabled' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-nfo-enabled' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-trusted' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-wins-enabled' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'mac-address' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'mediatype' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'mtusize' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'partner' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'port-role' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'v4-primary-address' => {
                'type' => 'ip-address-info',
                'flags' => 5,
                'scope' => [],
            },
            'v6-primary-address' => {
                'type' => 'ip-address-info',
                'flags' => 5,
                'scope' => [],
            },
        },
    },
    'interface-dcb-entry-info' => {
        'category' => 'net',
        'fields' => {
            'application' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'bandwidth-percentage' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'priority-entries' => {
                'type' => 'priority-entry-info',
                'flags' => 3,
                'scope' => [],
            },
            'priority-group-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'interface-dcb-priority-entry-info' => {
        'category' => 'net',
        'fields' => {
            'application' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'is-flow-control-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'priority' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'priority-group-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'ip-address' => {
        'category' => 'net',
        'fields' => {
        },
    },
    'ip-address-info' => {
        'category' => 'net',
        'fields' => {
            'addr-family' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'address' => {
                'type' => 'ip-address-or-hostname',
                'flags' => 0,
                'scope' => [],
            },
            'broadcast' => {
                'type' => 'ip-address',
                'flags' => 4,
                'scope' => [],
            },
            'creator' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'lif-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'netmask-or-prefix' => {
                'type' => 'netmask-or-prefix',
                'flags' => 4,
                'scope' => [],
            },
            'no-ddns' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'ip-address-or-hostname' => {
        'category' => 'net',
        'fields' => {
        },
    },
    'ipspace-config-info' => {
        'category' => 'net',
        'fields' => {
            'interface-list' => {
                'type' => 'string',
                'flags' => 6,
                'scope' => [],
            },
            'ipspace-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'link' => {
        'category' => 'net',
        'fields' => {
        },
    },
    'net-address-info' => {
        'category' => 'net',
        'fields' => {
            'address-info-family' => {
                'type' => 'address-info-family',
                'flags' => 4,
                'scope' => [],
            },
            'address-info-flags' => {
                'type' => 'address-info-flag',
                'flags' => 6,
                'scope' => [],
            },
            'address-info-socket-type' => {
                'type' => 'address-info-socket-type',
                'flags' => 4,
                'scope' => [],
            },
            'address-info-transport-protocol' => {
                'type' => 'address-info-transport-protocol',
                'flags' => 4,
                'scope' => [],
            },
            'canonical-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'ip-address' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'net-config-info' => {
        'category' => 'net',
        'fields' => {
            'config-status' => {
                'type' => 'config-status-info',
                'flags' => 7,
                'scope' => [],
            },
            'ifgrps' => {
                'type' => 'ifgrp-info',
                'flags' => 7,
                'scope' => [],
            },
            'interfaces' => {
                'type' => 'interface-config-info',
                'flags' => 3,
                'scope' => [],
            },
            'routes' => {
                'type' => 'route-info',
                'flags' => 7,
                'scope' => [],
            },
            'vlans' => {
                'type' => 'vlan-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'net-dcb-entry-info' => {
        'category' => 'net',
        'fields' => {
            'interface-dcb-entries' => {
                'type' => 'interface-dcb-entry-info',
                'flags' => 3,
                'scope' => [],
            },
            'interface-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'net-dcb-priority-entry-info' => {
        'category' => 'net',
        'fields' => {
            'interface-dcb-priority-entries' => {
                'type' => 'interface-dcb-priority-entry-info',
                'flags' => 3,
                'scope' => [],
            },
            'interface-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'netmask-or-prefix' => {
        'category' => 'net',
        'fields' => {
        },
    },
    'priority-entry-info' => {
        'category' => 'net',
        'fields' => {
            'priority' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'route-info' => {
        'category' => 'net',
        'fields' => {
            'addr-family' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'creator' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'destination' => {
                'type' => 'ip-address-or-hostname',
                'flags' => 0,
                'scope' => [],
            },
            'ipspace-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'metric' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'next-hop' => {
                'type' => 'ip-address',
                'flags' => 0,
                'scope' => [],
            },
            'prefixlen' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'route-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'vlan-info' => {
        'category' => 'net',
        'fields' => {
            'gvrp-enabled' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'interface-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'parent-interface' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'vlanid' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'exports-hostname-info' => {
        'category' => 'nfs',
        'fields' => {
            'all-hosts' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'negate' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'exports-rule-info' => {
        'category' => 'nfs',
        'fields' => {
            'actual-pathname' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'anon' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'nosuid' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'pathname' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'read-only' => {
                'type' => 'exports-hostname-info',
                'flags' => 7,
                'scope' => [],
            },
            'read-write' => {
                'type' => 'exports-hostname-info',
                'flags' => 7,
                'scope' => [],
            },
            'root' => {
                'type' => 'exports-hostname-info',
                'flags' => 7,
                'scope' => [],
            },
            'sec-flavor' => {
                'type' => 'sec-flavor-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'exports-rule-info-2' => {
        'category' => 'nfs',
        'fields' => {
            'actual-pathname' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'pathname' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'security-rules' => {
                'type' => 'security-rule-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'hostaddr' => {
        'category' => 'nfs',
        'fields' => {
        },
    },
    'nfs-stats-info' => {
        'category' => 'nfs',
        'fields' => {
            'badcalls-total' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'calls-total' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'nfsv2-client-stats' => {
                'type' => 'nfsv2-client-stats-info',
                'flags' => 1,
                'scope' => [],
            },
            'nfsv3-client-stats' => {
                'type' => 'nfsv3-client-stats-info',
                'flags' => 1,
                'scope' => [],
            },
            'nfsv4-client-stats' => {
                'type' => 'nfsv4-client-stats-info',
                'flags' => 1,
                'scope' => [],
            },
        },
    },
    'nfs-top-info' => {
        'category' => 'nfs',
        'fields' => {
            'client-info' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'create-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'getattr-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'lookup-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'read-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'readdir-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'readlink-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'remove-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'total-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'write-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'nfsv2-client-stats-info' => {
        'category' => 'nfs',
        'fields' => {
            'create-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'getattr-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'link-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'lookup-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'mkdir-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'null-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'read-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'readdir-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'readlink-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'remove-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'rename-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'rmdir-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'root-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'setattr-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'statfs-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'symlink-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'wrcache-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'write-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'nfsv3-client-stats-info' => {
        'category' => 'nfs',
        'fields' => {
            'access-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'commit-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'create-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'fsinfo-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'fsstat-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'getattr-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'link-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'lookup-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'mkdir-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'mknod-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'null-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'pathconf-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'read-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'readdir-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'readdirplus-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'readlink-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'remove-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'rename-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'rmdir-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'setattr-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'symlink-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'write-ops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'nfsv4-client-stats-info' => {
        'category' => 'nfs',
        'fields' => {
            'access-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'acls-set-total' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'badproc2-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'close-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'commit-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'compound-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'create-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'delegpurge' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'delegret-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'getattr-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'getfh-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'link-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'lock-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'lockt-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'locku-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'lookup-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'lookupp-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'no-delegation-total' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'null-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'nverify-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'open-confirm-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'open-downgrade-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'open-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'openattr-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'putfh-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'putpubfh-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'putrootfh-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'read-delegation-total' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'read-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'readdir-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'readlink-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'remove-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'rename-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'renew-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'restorefh-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'rlsowner-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'savefh-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'secinfo-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'setattr-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'setclntid-cfm-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'setclntid-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'verify-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'write-delegation-total' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'write-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'owner-info' => {
        'category' => 'nfs',
        'fields' => {
            'client-host' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'client-host-pid' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'pathname-info' => {
        'category' => 'nfs',
        'fields' => {
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'rpc-data-info' => {
        'category' => 'nfs',
        'fields' => {
            'badcalls-total' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'badlen-total' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'calls-total' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'nullrecv-total' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'xdrcall-total' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'rpc-stats-info' => {
        'category' => 'nfs',
        'fields' => {
            'tcp-info' => {
                'type' => 'rpc-data-info',
                'flags' => 1,
                'scope' => [],
            },
            'udp-info' => {
                'type' => 'rpc-data-info',
                'flags' => 1,
                'scope' => [],
            },
        },
    },
    'sec-flavor-info' => {
        'category' => 'nfs',
        'fields' => {
            'flavor' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'security-rule-info' => {
        'category' => 'nfs',
        'fields' => {
            'anon' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'nosuid' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'read-only' => {
                'type' => 'exports-hostname-info',
                'flags' => 7,
                'scope' => [],
            },
            'read-write' => {
                'type' => 'exports-hostname-info',
                'flags' => 7,
                'scope' => [],
            },
            'root' => {
                'type' => 'exports-hostname-info',
                'flags' => 7,
                'scope' => [],
            },
            'sec-flavor' => {
                'type' => 'sec-flavor-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'tcp-flowcontrol-stats-info' => {
        'category' => 'nfs',
        'fields' => {
            'receive-out-total' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'receive-total' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'transmit-out-total' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'transmit-total' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'option-info' => {
        'category' => 'options',
        'fields' => {
            'cluster-constraint' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'value' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'counter' => {
        'category' => 'perf',
        'fields' => {
        },
    },
    'counter-data' => {
        'category' => 'perf',
        'fields' => {
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'value' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'counter-info' => {
        'category' => 'perf',
        'fields' => {
            'base-counter' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'desc' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'is-key' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'labels' => {
                'type' => 'label-info',
                'flags' => 6,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'privilege-level' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'properties' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'unit' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'instance' => {
        'category' => 'perf',
        'fields' => {
        },
    },
    'instance-data' => {
        'category' => 'perf',
        'fields' => {
            'counters' => {
                'type' => 'counter-data',
                'flags' => 3,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'instance-info' => {
        'category' => 'perf',
        'fields' => {
            'name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'label-info' => {
        'category' => 'perf',
        'fields' => {
        },
    },
    'object-info' => {
        'category' => 'perf',
        'fields' => {
            'description' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'get-instances-preferred-counter' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'privilege-level' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'initiator-group-name' => {
        'category' => 'portset',
        'fields' => {
        },
    },
    'portset-info' => {
        'category' => 'portset',
        'fields' => {
            'initiator-group-info' => {
                'type' => 'initiator-group-name',
                'flags' => 6,
                'scope' => [],
            },
            'portset-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'portset-port-info' => {
                'type' => 'portset-port-name',
                'flags' => 6,
                'scope' => [],
            },
            'portset-port-total' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'portset-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'portset-port-name' => {
        'category' => 'portset',
        'fields' => {
        },
    },
    'priority-volume-info' => {
        'category' => 'priority',
        'fields' => {
            'cache-policy' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'level' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'nvlog-limit' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'service' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'system' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'system-read-limit' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'user-read-limit' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'qtree-info' => {
        'category' => 'qtree',
        'fields' => {
            'id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'oplocks' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'owning-vfiler' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'qtree' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'security-style' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'error' => {
        'category' => 'quota',
        'fields' => {
            'errno' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'reason' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'quota' => {
        'category' => 'quota',
        'fields' => {
            'disk-limit' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'disk-used' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'file-limit' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'files-used' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'quota-target' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'quota-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'quota-users' => {
                'type' => 'quota-user',
                'flags' => 7,
                'scope' => [],
            },
            'soft-disk-limit' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'soft-file-limit' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'threshold' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'tree' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'vfiler' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'quota-entry' => {
        'category' => 'quota',
        'fields' => {
            'line' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'qtree' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'quota-error' => {
                'type' => 'quota-error',
                'flags' => 5,
                'scope' => [],
            },
            'quota-target' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'quota-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'quota-error' => {
        'category' => 'quota',
        'fields' => {
            'detail' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'errno' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'reason' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'quota-info' => {
        'category' => 'quota',
        'fields' => {
            'disk-limit' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'disk-used' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'file-limit' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'files-used' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'qtree' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'quota-target' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'quota-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'quota-users' => {
                'type' => 'quota-user',
                'flags' => 3,
                'scope' => [],
            },
            'soft-disk-limit' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'soft-file-limit' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'threshold' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'vfiler' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'quota-user' => {
        'category' => 'quota',
        'fields' => {
            'quota-user-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'quota-user-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'quota-user-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'radius-server-list-entry-info' => {
        'category' => 'radius',
        'fields' => {
            'radius-server-info' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'radius-server-ip' => {
                'type' => 'ip-address',
                'flags' => 0,
                'scope' => [],
            },
            'radius-server-port' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'radius-stats-info' => {
        'category' => 'radius',
        'fields' => {
            'access-accepted-packets' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'access-challenged-packets' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'access-rejected-packets' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'authentication-requests' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'denied-packets' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'late-packets' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'retransmitted-packets' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'short-packets' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'timed-out-packets' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'unknown-packets' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'unknown-server-packets' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'reallocate-job-info' => {
        'category' => 'reallocate',
        'fields' => {
            'flags' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'interval' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'layout-factor' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'measure-logfile' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'measure-only' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'scan-detail' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'schedule' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'threshold' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'rsh-session-info' => {
        'category' => 'rsh',
        'fields' => {
            'audit-log' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'audit-shell' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'command' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'command-time' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'connection-time' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'get-host-time' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'ip-addr' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'session-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'vfiler' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'alternate-control-path-info' => {
        'category' => 'ses',
        'fields' => {
            'acp-element-no' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'controller-acp-connection-status' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'controller-acp-domain' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'controller-acp-ethernet-port' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'controller-acp-ip-address' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'controller-acp-netmask' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'is-acp-element-error' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-acp-element-not-installed' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-controller-acp-active' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-controller-acp-enabled' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'module-firmware-revision' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'module-ip-address' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'module-mac-address' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'module-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'module-reset-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'module-status' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'module-status-time' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'ariodata-specific-info' => {
        'category' => 'ses',
        'fields' => {
            'ariodata-serial-no' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'bay-info' => {
        'category' => 'ses',
        'fields' => {
            'lun' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'shelf-bay' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'connector-info' => {
        'category' => 'ses',
        'fields' => {
            'sas-connector-list' => {
                'type' => 'sas-connector-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'cooling-element-info' => {
        'category' => 'ses',
        'fields' => {
            'cooling-element-is-error' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'cooling-element-is-not-installed' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'cooling-element-number' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'rpm' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'current-sensor-info' => {
        'category' => 'ses',
        'fields' => {
            'current-sensor-no' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'is-sensor-error' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-sensor-not-installed' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'sensor-condition' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'sensor-reading' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'dongle-info' => {
        'category' => 'ses',
        'fields' => {
            'disable-reason' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'dongle-firmware-revision' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'dongle-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'enclosure-info' => {
        'category' => 'ses',
        'fields' => {
            'enclosure-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'module-list' => {
                'type' => 'module-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'es-electronics-info' => {
        'category' => 'ses',
        'fields' => {
            'es-electronics-element-no' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'es-electronics-is-error' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'es-electronics-is-not-installed' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'es-electronics-is-reporting-element' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'es-electronics-serial-no' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'es-part-number' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'es-revision' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'es-swap-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'esh-list' => {
                'type' => 'esh-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'esh-info' => {
        'category' => 'ses',
        'fields' => {
            'esh-element-no' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'esh-is-error' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'eurologic-specific-info' => {
        'category' => 'ses',
        'fields' => {
            'eurologic-application-version' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'eurologic-backplane-byte' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'eurologic-backplane-function' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'eurologic-backplane-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'eurologic-cabinet-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'eurologic-kernel-version' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'eurologic-serial-no' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'module-info' => {
        'category' => 'ses',
        'fields' => {
            'is-module-error' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-sas-expander-master-module' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'module-number' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'phy-expander-info' => {
        'category' => 'ses',
        'fields' => {
            'bay-number' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'crc-error-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'dongle-data' => {
                'type' => 'dongle-info',
                'flags' => 5,
                'scope' => [],
            },
            'invalid-dword-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'link-rate' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'loss-dword-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'pathway-timeout' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'phy-change-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'phy-number' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'phy-power-status' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'phy-reset-problem' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'phy-state' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'phy-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'port-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'port-state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'power-cycle-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'release-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'reserve-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'running-disparity-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'port-hub-info' => {
        'category' => 'ses',
        'fields' => {
            'clock-delta' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'disk-bay' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'insert-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'invalid-crc-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'invalid-word-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'lip-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'loop-up-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'port-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'port-state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'stall-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'utilization-percentage' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'power-supply-info' => {
        'category' => 'ses',
        'fields' => {
            'is-auto-power-reset-enabled' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-power-reset-capable' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'power-supply-element-number' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'power-supply-firmware-revision' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'power-supply-is-error' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'power-supply-is-not-installed' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'power-supply-part-no' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'power-supply-serial-no' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'power-supply-swap-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'power-supply-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'processor-complex-info' => {
        'category' => 'ses',
        'fields' => {
            'is-pcm-element-error' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-pcm-element-not-installed' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'pcm-element-no' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'sas-connector-info' => {
        'category' => 'ses',
        'fields' => {
            'cable-end-identifier' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'cable-length' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'cable-manufacturer' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'cable-part-no' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'cable-serial-no' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'cable-technology' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'cable-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'connector-designator' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'connector-no' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'is-cable-connected' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-connector-error' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'shelf-module' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'swap-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'sas-specific-info' => {
        'category' => 'ses',
        'fields' => {
            'serial-no' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'ses-generic-info' => {
        'category' => 'ses',
        'fields' => {
            'ses-chassis-part-number' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'ses-config-access' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'ses-config-access-controller-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'ses-config-access-shelf-id' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'ses-config-access-source-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'ses-contact-state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'ses-logical-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'ses-product-id' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'ses-product-revision' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'ses-vendor-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'shelf-bay-info' => {
        'category' => 'ses',
        'fields' => {
            'bay-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'bay-list' => {
                'type' => 'bay-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'shelf-bay-list-info' => {
        'category' => 'ses',
        'fields' => {
            'channel-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'module' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'port-list' => {
                'type' => 'shelf-bay-port-info',
                'flags' => 7,
                'scope' => [],
            },
            'shelf-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'shelf-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'shelf-state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'shelf-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'shelf-uid' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'shelf-bay-port-info' => {
        'category' => 'ses',
        'fields' => {
            'bay-no' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'disk-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'disk-uid' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'port-designator' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'port-state' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'shelf-environ-channel-address-map' => {
        'category' => 'ses',
        'fields' => {
            'address-map' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'shelf-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'shelf-environ-channel-info' => {
        'category' => 'ses',
        'fields' => {
            'channel-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'is-channel-monitor-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-shelf-channel-failure' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'shelf-environ-channel-address' => {
                'type' => 'shelf-environ-channel-address-map',
                'flags' => 7,
                'scope' => [],
            },
            'shelf-environ-shelf-list' => {
                'type' => 'shelf-environ-shelf-info',
                'flags' => 3,
                'scope' => [],
            },
            'shelves-present' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'shelf-environ-shelf-info' => {
        'category' => 'ses',
        'fields' => {
            'alternate-control-path-information' => {
                'type' => 'alternate-control-path-info',
                'flags' => 7,
                'scope' => [],
            },
            'ariodata-specific-info' => {
                'type' => 'ariodata-specific-info',
                'flags' => 5,
                'scope' => [],
            },
            'attached-shelf-bay-error-list' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'attached-shelf-bay-list' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'connector-information' => {
                'type' => 'connector-info',
                'flags' => 7,
                'scope' => [],
            },
            'control-writes-attempted' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'control-writes-failed' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'controller-device-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'controller-device-path-port' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'cooling-element-list' => {
                'type' => 'cooling-element-info',
                'flags' => 7,
                'scope' => [],
            },
            'current-sensor-list' => {
                'type' => 'current-sensor-info',
                'flags' => 7,
                'scope' => [],
            },
            'enclosure-information' => {
                'type' => 'enclosure-info',
                'flags' => 5,
                'scope' => [],
            },
            'es-electronics-list' => {
                'type' => 'es-electronics-info',
                'flags' => 7,
                'scope' => [],
            },
            'eurologic-specific-info' => {
                'type' => 'eurologic-specific-info',
                'flags' => 5,
                'scope' => [],
            },
            'is-shelf-monitor-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'power-control-failure-state' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'power-control-status' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'power-supply-list' => {
                'type' => 'power-supply-info',
                'flags' => 7,
                'scope' => [],
            },
            'processor-complex-information' => {
                'type' => 'processor-complex-info',
                'flags' => 7,
                'scope' => [],
            },
            'sas-specific-info' => {
                'type' => 'sas-specific-info',
                'flags' => 5,
                'scope' => [],
            },
            'ses-generic-info' => {
                'type' => 'ses-generic-info',
                'flags' => 1,
                'scope' => [],
            },
            'shelf-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'shelf-status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'shelf-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'status-reads-attempted' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'status-reads-failed' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'temp-sensor-list' => {
                'type' => 'temp-sensor-info',
                'flags' => 7,
                'scope' => [],
            },
            'voltage-sensor-list' => {
                'type' => 'voltage-sensor-info',
                'flags' => 7,
                'scope' => [],
            },
            'xyratex-specific-info' => {
                'type' => 'xyratex-specific-info',
                'flags' => 5,
                'scope' => [],
            },
        },
    },
    'shelf-info' => {
        'category' => 'ses',
        'fields' => {
            'channel-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'firmware-rev-A' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'firmware-rev-B' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'module' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'module-state' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'phy-expander-list' => {
                'type' => 'phy-expander-info',
                'flags' => 7,
                'scope' => [],
            },
            'port-hub-list' => {
                'type' => 'port-hub-info',
                'flags' => 7,
                'scope' => [],
            },
            'shelf-bay-info' => {
                'type' => 'shelf-bay-info',
                'flags' => 5,
                'scope' => [],
            },
            'shelf-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'shelf-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'shelf-state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'shelf-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'shelf-uid' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'termination-switch' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'temp-sensor-info' => {
        'category' => 'ses',
        'fields' => {
            'temp-sensor-current-condition' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'temp-sensor-current-temperature' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'temp-sensor-element-no' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'temp-sensor-hi-critical' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'temp-sensor-hi-warning' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'temp-sensor-is-ambient' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'temp-sensor-is-error' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'temp-sensor-is-not-installed' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'temp-sensor-low-critical' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'temp-sensor-low-warning' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'voltage-sensor-info' => {
        'category' => 'ses',
        'fields' => {
            'is-sensor-error' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-sensor-not-installed' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'sensor-condition' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'sensor-reading' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'voltage-sensor-no' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'xyratex-specific-info' => {
        'category' => 'ses',
        'fields' => {
            'xyratex-option-setting' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'xyratex-serial-no' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'dense-status' => {
        'category' => 'sis',
        'fields' => {
            'blocks-skipped-sharing' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'changelog-used-percent' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'checkpoint-op-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'checkpoint-progress' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'checkpoint-stage' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'checkpoint-sub-stage' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'checkpoint-time' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'is-compression-enabled' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-idd-enabled' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-inline-compression-enabled' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'last-operation-begin-timestamp' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'last-operation-end-timestamp' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'last-operation-error' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'last-operation-size' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => ['ontap-c', 'vfiler'],
            },
            'last-operation-size-bytes' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'last-operation-state' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'last-success-operation-begin-timestamp' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'last-success-operation-end-timestamp' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'logical-data' => {
                'type' => 'sis-logical-data',
                'flags' => 5,
                'scope' => [],
            },
            'minimum-blocks-shared' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'progress' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'queued-job-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'quick-check-fsize' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'schedule' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'stale-fingerprint-percentage' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'sis-logical-data' => {
        'category' => 'sis',
        'fields' => {
            'logical-data-limit' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'logical-data-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'compliance-clock-info' => {
        'category' => 'snaplock',
        'fields' => {
            'formatted-snaplock-compliance-clock' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'snaplock-compliance-clock' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'file-retention-info' => {
        'category' => 'snaplock',
        'fields' => {
            'formatted-retention-time' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'is-wraparound' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'pathname' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'retention-time' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'snaplock-error' => {
                'type' => 'snaplock-error',
                'flags' => 5,
                'scope' => [],
            },
            'snaplock-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'log-file-info' => {
        'category' => 'snaplock',
        'fields' => {
            'file-size' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'formatted-retention-date' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'log-basename' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'log-complete-path' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'snaplock-error' => {
                'type' => 'snaplock-error',
                'flags' => 5,
                'scope' => [],
            },
        },
    },
    'snaplock-error' => {
        'category' => 'snaplock',
        'fields' => {
            'errno' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'reason' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'address-pair' => {
        'category' => 'snapmirror',
        'fields' => {
            'destination-addr' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'source-addr' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'destination-info' => {
        'category' => 'snapmirror',
        'fields' => {
            'destination-location' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'source-location' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'source-snapshot' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'snapmirror-connection-info' => {
        'category' => 'snapmirror',
        'fields' => {
            'address-pair1' => {
                'type' => 'address-pair',
                'flags' => 1,
                'scope' => [],
            },
            'address-pair2' => {
                'type' => 'address-pair',
                'flags' => 5,
                'scope' => [],
            },
            'mode' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'snapmirror-error' => {
                'type' => 'snapmirror-error',
                'flags' => 5,
                'scope' => [],
            },
        },
    },
    'snapmirror-error' => {
        'category' => 'snapmirror',
        'fields' => {
            'errno' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'reason' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'snapmirror-schedule-info' => {
        'category' => 'snapmirror',
        'fields' => {
            'days-of-month' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'days-of-week' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'destination-location' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'hours' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'is-compressed' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'max-transfer-rate' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'minutes' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'snapmirror-error' => {
                'type' => 'snapmirror-error',
                'flags' => 5,
                'scope' => [],
            },
            'source-location' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'tcp-window-size' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'snapmirror-status-info' => {
        'category' => 'snapmirror',
        'fields' => {
            'base-snapshot' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'contents' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'current-transfer-error' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'current-transfer-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'destination-location' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'inodes-replicated' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'lag-time' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'last-transfer-duration' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'last-transfer-from' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'last-transfer-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'last-transfer-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'mirror-timestamp' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'replication-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'source-location' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'transfer-progress' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'snapmirror-sync-schedule-info' => {
        'category' => 'snapmirror',
        'fields' => {
            'destination-location' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'is-compressed' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'max-transfer-rate' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'ops-throttle' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'snapmirror-error' => {
                'type' => 'snapmirror-error',
                'flags' => 5,
                'scope' => [],
            },
            'source-location' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'sync-mode' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'tcp-window-size' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'visibility-frequency' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'snapshot-autodelete-info' => {
        'category' => 'snapshot',
        'fields' => {
            'option-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'option-value' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'snapshot-info' => {
        'category' => 'snapshot',
        'fields' => {
            'access-time' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'busy' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'contains-lun-clones' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'cumulative-percentage-of-total-blocks' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'cumulative-percentage-of-used-blocks' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'cumulative-total' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'dependency' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'is-7-mode-snapshot' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'percentage-of-total-blocks' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'percentage-of-used-blocks' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'snapmirror-label' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'snapshot-instance-uuid' => {
                'type' => 'uuid',
                'flags' => 4,
                'scope' => [],
            },
            'snapshot-owners-list' => {
                'type' => 'snapshot-owner',
                'flags' => 7,
                'scope' => [],
            },
            'snapshot-version-uuid' => {
                'type' => 'uuid',
                'flags' => 4,
                'scope' => [],
            },
            'state' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'total' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'volume-provenance-uuid' => {
                'type' => 'uuid',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'snapshot-name' => {
        'category' => 'snapshot',
        'fields' => {
        },
    },
    'snapshot-owner' => {
        'category' => 'snapshot',
        'fields' => {
            'owner' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'snapshot-reserve-detail-info' => {
        'category' => 'snapshot',
        'fields' => {
            'percentage' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'volume-error' => {
        'category' => 'snapshot',
        'fields' => {
            'errno' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'name' => {
                'type' => 'volume-name',
                'flags' => 0,
                'scope' => [],
            },
            'reason' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'vserver' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'volume-is-snapcreated' => {
        'category' => 'snapshot',
        'fields' => {
            'is-snapcreated' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'name' => {
                'type' => 'volume-name',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'snapvault-chained-destination-info' => {
        'category' => 'snapvault',
        'fields' => {
            'destination-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'destination-system' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'snapvault-configuration-info' => {
        'category' => 'snapvault',
        'fields' => {
            'connection-mode' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'is-access-time-change-ignored' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-open-file-backup-allowed' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-primary-path-utf8-encoded' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'max-transfer-rate' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'primary-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'primary-system' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'secondary-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'tries-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'use-compression' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'snapvault-destination-info' => {
        'category' => 'snapvault',
        'fields' => {
            'chained-destinations' => {
                'type' => 'snapvault-chained-destination-info',
                'flags' => 3,
                'scope' => [],
            },
            'source-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'source-snapshot' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'snapvault-primary-snapshot-schedule-info' => {
        'category' => 'snapvault',
        'fields' => {
            'is-auto-update' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'options' => {
                'type' => 'snapvault-schedule-options',
                'flags' => 5,
                'scope' => [],
            },
            'preserve-snapshots' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'retention-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'schedule' => {
                'type' => 'snapvault-schedule-info',
                'flags' => 5,
                'scope' => [],
            },
            'schedule-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'warn-at-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'snapvault-schedule-info' => {
        'category' => 'snapvault',
        'fields' => {
            'days-of-week' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'hours-of-day' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'snapvault-schedule-options' => {
        'category' => 'snapvault',
        'fields' => {
            'retention-period' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'tries-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'snapvault-secondary-snapshot-schedule-info' => {
        'category' => 'snapvault',
        'fields' => {
            'is-auto-update' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'options' => {
                'type' => 'snapvault-schedule-options',
                'flags' => 5,
                'scope' => [],
            },
            'preserve-snapshots' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'retention-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'schedule' => {
                'type' => 'snapvault-schedule-info',
                'flags' => 5,
                'scope' => [],
            },
            'schedule-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'warn-at-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'snapvault-snapcreate-options' => {
        'category' => 'snapvault',
        'fields' => {
            'tries-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'snapvault-snapshot-schedule-status-info' => {
        'category' => 'snapvault',
        'fields' => {
            'schedule-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'snapvault-softlock-info' => {
        'category' => 'snapvault',
        'fields' => {
            'softlock-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'snapvault-status-info' => {
        'category' => 'snapvault',
        'fields' => {
            'base-snapshot' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'compressed-bytes' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'contents' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'current-transfer-error' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'current-transfer-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'destination-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'destination-system' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'inodes-replicated' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'lag-time' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'last-transfer-duration' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'last-transfer-from-path' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'last-transfer-from-system' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'last-transfer-size' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'last-transfer-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'mirror-timestamp' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'replication-ops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'source-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'source-system' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'transfer-progress' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'uncompressed-bytes' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'community-info' => {
        'category' => 'snmp',
        'fields' => {
            'access-control' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'community' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'trap-info' => {
        'category' => 'snmp',
        'fields' => {
            'OID' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'active' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'backoff-calculator' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'backoff-multiplier' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'backoff-step' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'current-value' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'edge-1' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'edge-1-direction' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'edge-2' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'edge-2-direction' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'interval' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'interval-offset' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'message' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'priority' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'rate-interval' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'trap-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'trigger' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'traphost-info' => {
        'category' => 'snmp',
        'fields' => {
            'host-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'ip-address' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'npm-meta-elem-info' => {
        'category' => 'software',
        'fields' => {
            'npm-meta-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'npm-meta-value' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'adapter-bar-info' => {
        'category' => 'storage-adapter',
        'fields' => {
            'bar-base' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'bar-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'bar-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'adapter-detail-info' => {
        'category' => 'storage-adapter',
        'fields' => {
            'adapter-fc' => {
                'type' => 'adapter-fc-info',
                'flags' => 5,
                'scope' => [],
            },
            'adapter-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'adapter-parallel-scsi' => {
                'type' => 'adapter-parallel-scsi-info',
                'flags' => 5,
                'scope' => [],
            },
            'adapter-sas' => {
                'type' => 'adapter-sas-info',
                'flags' => 5,
                'scope' => [],
            },
            'adapter-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'adapter-fc-info' => {
        'category' => 'storage-adapter',
        'fields' => {
            'adapter-bar' => {
                'type' => 'adapter-bar-info',
                'flags' => 7,
                'scope' => [],
            },
            'adapter-model' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'adapter-sff-info' => {
                'type' => 'adapter-sff-info',
                'flags' => 5,
                'scope' => [],
            },
            'adapter-sfp-info' => {
                'type' => 'adapter-sfp-info',
                'flags' => 5,
                'scope' => [],
            },
            'cache-line-sz' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'fc-link-rate' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'fc-node-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'fc-packet-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'fc-port-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'firmware-rev' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'hardware-rev' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'host-loop-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'host-port-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'is-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-ext-gbic' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-in-use' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-pci-64-capable' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-redundant' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-sram-parity' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'preload-table-rev' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'adapter-name-elem' => {
        'category' => 'storage-adapter',
        'fields' => {
            'adapter-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'adapter-parallel-scsi-info' => {
        'category' => 'storage-adapter',
        'fields' => {
            'adapter-model' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'bus-width' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'firmware-rev' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'hardware-rev' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'is-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'adapter-sas-info' => {
        'category' => 'storage-adapter',
        'fields' => {
            'adapter-board-revision' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'adapter-date-code' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'adapter-family' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'adapter-manufacturer' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'adapter-manufacturer-part-number' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'adapter-model' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'adapter-part-number' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'adapter-serial-number' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'adapter-slot' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'adapter-state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'adapter-vendor' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'base-wwn' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'firmware-rev' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'hardware-rev' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'is-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-in-use' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-redundant' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'sas-adapter-disabled-phy-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'sas-adapter-enabled-phy-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'sas-adapter-expander-phy-states' => {
                'type' => 'sas-adapter-expander-phy-state-info',
                'flags' => 7,
                'scope' => [],
            },
            'sas-phy' => {
                'type' => 'phy-state-info',
                'flags' => 7,
                'scope' => [],
            },
            'sas-qsfp-cable' => {
                'type' => 'sas-qsfp-cable-info',
                'flags' => 5,
                'scope' => [],
            },
        },
    },
    'adapter-sff-info' => {
        'category' => 'storage-adapter',
        'fields' => {
            'part-number' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'serial-number' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'speed-capabilities' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'vendor' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'adapter-sfp-info' => {
        'category' => 'storage-adapter',
        'fields' => {
            'part-number' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'serial-number' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'speed-capabilities' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'vendor' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'expander-phy-state-info' => {
        'category' => 'storage-adapter',
        'fields' => {
            'expander-phy' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'expander-phy-attached-device-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'expander-phy-state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'expander-phy-wwn' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'phy-state-info' => {
        'category' => 'storage-adapter',
        'fields' => {
            'phy' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'phy-state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'phy-wwn' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'sas-adapter-expander-phy-state-info' => {
        'category' => 'storage-adapter',
        'fields' => {
            'adapter-phy' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'expander-phy-states' => {
                'type' => 'expander-phy-state-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'sas-qsfp-cable-info' => {
        'category' => 'storage-adapter',
        'fields' => {
            'cable-end-identifier' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'cable-length' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'cable-manufacturer' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'cable-part-number' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'cable-serial-number' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'cable-technology' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'storage-array-config-summary' => {
        'category' => 'storage-array',
        'fields' => {
            'array-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'device-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'group-number' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-port' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'lun-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'switch-port' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'target-side-switch-port' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'target-wwpn' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'storage-array-port' => {
        'category' => 'storage-array',
        'fields' => {
            'array-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'array-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'wwnn' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'wwpn' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'storage-array-profile' => {
        'category' => 'storage-array',
        'fields' => {
            'array-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'firmware' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'model' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'network-address' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'options' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'port-failover-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'prefix' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'serial-number' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'vendor' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'disk-aggregate-info' => {
        'category' => 'storage-disk',
        'fields' => {
            'aggregate-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'checksum-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'copy-destination-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'copy-percent-complete' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'is-media-scrubbing' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-offline' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-prefailed' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-reconstructing' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-replacing' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-zeroed' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-zeroing' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'plex-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'raid-group-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'reconstruct-percent-complete' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'zeroing-percent-complete' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'disk-inventory-info' => {
        'category' => 'storage-disk',
        'fields' => {
            'bytes-per-sector' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'capacity-sectors' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'carrier-id' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'carrier-serialno' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'checksum-compatibility' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'disk-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'disk-uid' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'firmware-revision' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'grown-defect-list-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'health-monitor-time-interval' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'is-dynamically-qualified' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-foreign' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-multidisk-carrier' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'media-scrub-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'media-scrub-last-done-time-interval' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'model' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'right-size-sectors' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'rpm' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'serial-number' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'shelf' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'shelf-bay' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'storage-ssd-info' => {
                'type' => 'storage-ssd-info',
                'flags' => 5,
                'scope' => [],
            },
            'vendor' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'disk-outage-info' => {
        'category' => 'storage-disk',
        'fields' => {
            'is-in-fdr' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'reason' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'disk-ownership-info' => {
        'category' => 'storage-disk',
        'fields' => {
            'disk-uid' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'home-node-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'home-node-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'is-failed' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'owner-node-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'owner-node-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'pool' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'reserved-by-node-id' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'disk-raid-info' => {
        'category' => 'storage-disk',
        'fields' => {
            'active-node-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'container-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'disk-aggregate-info' => {
                'type' => 'disk-aggregate-info',
                'flags' => 5,
                'scope' => [],
            },
            'disk-outage-info' => {
                'type' => 'disk-outage-info',
                'flags' => 5,
                'scope' => [],
            },
            'disk-spare-info' => {
                'type' => 'disk-spare-info',
                'flags' => 5,
                'scope' => [],
            },
            'disk-uid' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'effective-disk-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'effective-rpm' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'physical-blocks' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'position' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'spare-pool' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'used-blocks' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'disk-spare-info' => {
        'category' => 'storage-disk',
        'fields' => {
            'is-media-scrubbing' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-offline' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-sparecore' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-zeroed' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-zeroing' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'zeroing-percent-complete' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'disk-stats-info' => {
        'category' => 'storage-disk',
        'fields' => {
            'average-latency' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'bytes-per-sector' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'disk-io-kbps' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'disk-iops' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'disk-uid' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'path-error-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'power-on-time-interval' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'sectors-read' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'sectors-written' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'fw-update-status-info' => {
        'category' => 'storage-disk',
        'fields' => {
            'avg-duration' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'update-completion' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'update-unable' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'waiting-disks' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'storage-disk-info' => {
        'category' => 'storage-disk',
        'fields' => {
            'disk-inventory-info' => {
                'type' => 'disk-inventory-info',
                'flags' => 5,
                'scope' => [],
            },
            'disk-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'disk-ownership-info' => {
                'type' => 'disk-ownership-info',
                'flags' => 5,
                'scope' => [],
            },
            'disk-paths' => {
                'type' => 'disk-path-info',
                'flags' => 7,
                'scope' => [],
            },
            'disk-raid-info' => {
                'type' => 'disk-raid-info',
                'flags' => 5,
                'scope' => [],
            },
            'disk-stats-info' => {
                'type' => 'disk-stats-info',
                'flags' => 5,
                'scope' => [],
            },
            'disk-uid' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'disk-path-info' => {
        'category' => 'storage-initiator',
        'fields' => {
            'array-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'disk-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'disk-port' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'disk-port-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'disk-uid' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-io-kbps' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-iops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-lun-in-use-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-port' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-port-speed' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-side-switch-port' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'lun-io-kbps' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'lun-iops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'lun-number' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'lun-path-use-state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'node' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'path-io-kbps' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'path-iops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'path-link-errors' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'path-lun-in-use-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'path-quality' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'preferred-target-port' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'target-io-kbps' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'target-iops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'target-lun-in-use-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'target-port-access-state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'target-side-switch-port' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'target-wwpn' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'tpgn' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'storage-error-info' => {
        'category' => 'storage-initiator',
        'fields' => {
            'array-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'disk-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'disk-uid' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'error-id' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'error-text' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'error-type' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'lun-serial-number' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'node' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'storage-initiator-load-info' => {
        'category' => 'storage-initiator',
        'fields' => {
            'initiator-port' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'io-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'lun-number' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'nodename' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'percent-io' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'serial-number' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'switch-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'target-side-switch-port' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'target-wwpn' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'storage-initiator-path-info' => {
        'category' => 'storage-initiator',
        'fields' => {
            'array-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'device-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'initiator-io-kbps' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-iops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-lun-in-use-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-port' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-port-speed' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'initiator-side-switch-port' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'path-io-kbps' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'path-iops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'path-link-errors' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'path-lun-in-use-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'path-quality' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'target-io-kbps' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'target-iops' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'target-lun-in-use-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'target-side-switch-port' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'target-wwpn' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'tpgn' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'api-list-info' => {
        'category' => 'system',
        'fields' => {
        },
    },
    'replication-transfer-info' => {
        'category' => 'system',
        'fields' => {
            'replication-available-transfers' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'replication-maximum-transfers' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'replication-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'system-api-element-info' => {
        'category' => 'system',
        'fields' => {
            'encrypted' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'is-nonempty' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-optional' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-output' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-validated' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'system-api-entry-info' => {
        'category' => 'system',
        'fields' => {
            'api-elements' => {
                'type' => 'system-api-element-info',
                'flags' => 3,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'system-api-info' => {
        'category' => 'system',
        'fields' => {
            'is-streaming' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'license' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'system-api-type-entry-info' => {
        'category' => 'system',
        'fields' => {
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'type-elements' => {
                'type' => 'system-api-element-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'system-info' => {
        'category' => 'system',
        'fields' => {
            'backplane-part-number' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'backplane-revision' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'backplane-serial-number' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'board-speed' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'board-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'controller-address' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'cpu-ciob-revision-id' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'cpu-firmware-release' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'cpu-microcode-version' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'cpu-part-number' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'cpu-processor-id' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'cpu-processor-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'cpu-revision' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'cpu-serial-number' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'maximum-aggregate-size' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'maximum-flexible-volume-count' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'maximum-flexible-volume-size' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'memory-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'number-of-processors' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'partner-system-id' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'partner-system-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'partner-system-serial-number' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'prod-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'supports-raid-array' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'system-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'system-machine-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'system-model' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'system-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'system-revision' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'system-serial-number' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'vendor-id' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'sid' => {
        'category' => 'useradmin',
        'fields' => {
        },
    },
    'useradmin-capability-info' => {
        'category' => 'useradmin',
        'fields' => {
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'useradmin-group-info' => {
        'category' => 'useradmin',
        'fields' => {
            'allowed-capabilities' => {
                'type' => 'useradmin-capability-info',
                'flags' => 7,
                'scope' => [],
            },
            'comment' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'rid' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'useradmin-roles' => {
                'type' => 'useradmin-role-info',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'useradmin-role-info' => {
        'category' => 'useradmin',
        'fields' => {
            'allowed-capabilities' => {
                'type' => 'useradmin-capability-info',
                'flags' => 7,
                'scope' => [],
            },
            'comment' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'useradmin-user-info' => {
        'category' => 'useradmin',
        'fields' => {
            'allowed-capabilities' => {
                'type' => 'useradmin-capability-info',
                'flags' => 7,
                'scope' => [],
            },
            'comment' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'full-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'password-maximum-age' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'password-minimum-age' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'rid' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'status' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'useradmin-groups' => {
                'type' => 'useradmin-group-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'adminhost' => {
        'category' => 'vfiler',
        'fields' => {
            'ipaddress' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'authentication-info' => {
        'category' => 'vfiler',
        'fields' => {
            'password' => {
                'type' => 'string',
                'flags' => 8,
                'scope' => [],
            },
            'username' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'dns-info' => {
        'category' => 'vfiler',
        'fields' => {
            'dns-domain-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'dns-servers' => {
                'type' => 'server-address',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'dnsserver-info' => {
        'category' => 'vfiler',
        'fields' => {
            'ipaddress' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'encrypted-authentication-info' => {
        'category' => 'vfiler',
        'fields' => {
            'password' => {
                'type' => 'string',
                'flags' => 8,
                'scope' => [],
            },
            'username' => {
                'type' => 'string',
                'flags' => 8,
                'scope' => [],
            },
        },
    },
    'hostname-pair' => {
        'category' => 'vfiler',
        'fields' => {
            'alternate-destination' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'alternate-source' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'ipaddr-info' => {
        'category' => 'vfiler',
        'fields' => {
            'interface' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'ip-address' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'netmask' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'ipbinding-info' => {
        'category' => 'vfiler',
        'fields' => {
            'interface' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'ipaddress' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'netmask' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'nis-info' => {
        'category' => 'vfiler',
        'fields' => {
            'nis-domain-name' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'nis-servers' => {
                'type' => 'server-address',
                'flags' => 7,
                'scope' => [],
            },
        },
    },
    'nisserver-info' => {
        'category' => 'vfiler',
        'fields' => {
            'ipaddress' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'protocol-info' => {
        'category' => 'vfiler',
        'fields' => {
            'protocol' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'server-address' => {
        'category' => 'vfiler',
        'fields' => {
            'ipaddress' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'storage-dr-status' => {
        'category' => 'vfiler',
        'fields' => {
            'status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'storage-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'storage-mr-status' => {
        'category' => 'vfiler',
        'fields' => {
            'error-msg' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'storage-path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'storage-unit' => {
        'category' => 'vfiler',
        'fields' => {
        },
    },
    'vfiler-info' => {
        'category' => 'vfiler',
        'fields' => {
            'admin-host' => {
                'type' => 'adminhost',
                'flags' => 5,
                'scope' => [],
            },
            'dns-info' => {
                'type' => 'dns-info',
                'flags' => 3,
                'scope' => [],
            },
            'ipspace' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'nis-info' => {
                'type' => 'nis-info',
                'flags' => 3,
                'scope' => [],
            },
            'uuid' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'vfnets' => {
                'type' => 'vfnet-info',
                'flags' => 3,
                'scope' => [],
            },
            'vfstores' => {
                'type' => 'vfstore-info',
                'flags' => 3,
                'scope' => [],
            },
        },
    },
    'vfiler-location' => {
        'category' => 'vfiler',
        'fields' => {
            'filer' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'vfiler' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'vfnet-info' => {
        'category' => 'vfiler',
        'fields' => {
            'interface' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'ipaddress' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'netmask' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'vfstore-info' => {
        'category' => 'vfiler',
        'fields' => {
            'is-etc' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'path' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'autosize-info' => {
        'category' => 'volume',
        'fields' => {
            'grow-threshold-percent' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'increment-size' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'is-enabled' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'maximum-size' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'minimum-size' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'mode' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'shrink-threshold-percent' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'clone-child-info' => {
        'category' => 'volume',
        'fields' => {
            'clone-child-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'clone-parent-info' => {
        'category' => 'volume',
        'fields' => {
            'parent-snapshot-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'parent-volume-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'clone-split-detail-info' => {
        'category' => 'volume',
        'fields' => {
            'blocks-scanned' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'blocks-updated' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'inode-percentage-complete' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'inodes-processed' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'inodes-total' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'clone-split-estimate-info' => {
        'category' => 'volume',
        'fields' => {
            'estimate-blocks' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'compression-info' => {
        'category' => 'volume',
        'fields' => {
            'is-compression-enabled' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'errors-warnings-info' => {
        'category' => 'volume',
        'fields' => {
            'error-warning' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'guarantee' => {
        'category' => 'volume',
        'fields' => {
            'type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'mediascrub-detail-info' => {
        'category' => 'volume',
        'fields' => {
            'mediascrub-status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'percentage-complete' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'raid-group' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'raidgroup-size-info' => {
        'category' => 'volume',
        'fields' => {
            'default-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'maximum-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'minimum-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'raidtype' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'raidtype-info' => {
        'category' => 'volume',
        'fields' => {
            'raidtype' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'scrub-detail-info' => {
        'category' => 'volume',
        'fields' => {
            'is-suspended' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'last-scrub-timestamp' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'percentage-complete' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'raid-group' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'sis-info' => {
        'category' => 'volume',
        'fields' => {
            'compress-saved' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'dedup-saved' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'last-operation-begin' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'last-operation-end' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'last-operation-error' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'last-operation-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'percent-compress-saved' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'percent-dedup-saved' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'percent-total-saved' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'percentage-saved' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'progress' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'schedule' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'size-saved' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'size-shared' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'total-saved' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'snap-autodelete-info' => {
        'category' => 'volume',
        'fields' => {
            'commitment' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'defer-delete' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'delete-order' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'destroy-list' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'prefix' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'target-free-space' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'trigger' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'transition-info' => {
        'category' => 'volume',
        'fields' => {
            'transition-state' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'transitioned' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'vm-align-info' => {
        'category' => 'volume',
        'fields' => {
            'vm-align-sector' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'vm-align-suffix' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'vol-footprint-info' => {
        'category' => 'volume',
        'fields' => {
            'aggregate-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'dedupe-metafiles-footprint' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'dedupe-metafiles-temporary-footprint' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'delayed-free-footprint' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'flexvol-metadata-footprint' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'snapmirror-destination-footprint' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'tape-backup-metafiles-footprint' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'total-footprint' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume-data-footprint' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'volume-guarantee-footprint' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'vol-move-status-info' => {
        'category' => 'volume',
        'fields' => {
            'current-transfer' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'cutover-attempts' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'cutover-window' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'dest-aggregate' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'dest-volume' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'error-string' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'last-transfer-duration' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'last-transfer-size' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'move-state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'pause-reason' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'source-volume-name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'vol-space-info' => {
        'category' => 'volume',
        'fields' => {
            'dedupe-metafiles' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'dedupe-metafiles-temporary' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'filesystem-metadata' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'inodes' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'quota-metafiles' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'snapmirror-metadata' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'snapshot-reserve' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'snapshot-spill' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'total-used' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'user-data' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'volume' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'volume-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'volume-64bit-upgrade-check-info' => {
        'category' => 'volume',
        'fields' => {
            'age' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'available-space' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'capacity' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'grow-space' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'last-errno' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'used-space' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
        },
    },
    'volume-64bit-upgrade-info' => {
        'category' => 'volume',
        'fields' => {
            'check' => {
                'type' => 'volume-64bit-upgrade-check-info',
                'flags' => 5,
                'scope' => [],
            },
        },
    },
    'volume-info' => {
        'category' => 'volume',
        'fields' => {
            'autosize' => {
                'type' => 'autosize-info',
                'flags' => 5,
                'scope' => [],
            },
            'block-type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'checksum-style' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'clone-children' => {
                'type' => 'clone-child-info',
                'flags' => 7,
                'scope' => [],
            },
            'clone-parent' => {
                'type' => 'clone-parent-info',
                'flags' => 7,
                'scope' => [],
            },
            'compression' => {
                'type' => 'compression-info',
                'flags' => 1,
                'scope' => [],
            },
            'containing-aggregate' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'disk-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'expiry-date' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'files-private-used' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'files-total' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'files-used' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'filesystem-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'formatted-expiry-date' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'formatted-snaplock-volume-compliance-clock' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'hybrid-cache-eligibility' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'hybrid-cache-write-caching-ineligibility-reason' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'inodefile-private-capacity' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'inodefile-public-capacity' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'is-checksum-enabled' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-in-snapmirror-jumpahead' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-inconsistent' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-invalid' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-snaplock' => {
                'type' => 'boolean',
                'flags' => 0,
                'scope' => [],
            },
            'is-unrecoverable' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'is-wraparound' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'mirror-status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'owning-vfiler' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'percentage-used' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'plex-count' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'plexes' => {
                'type' => 'plex-info',
                'flags' => 3,
                'scope' => [],
            },
            'quota-init' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'raid-size' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'raid-status' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'remote-location' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'reserve' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'reserve-required' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'reserve-used' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'reserve-used-actual' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'sis' => {
                'type' => 'sis-info',
                'flags' => 5,
                'scope' => [],
            },
            'size-available' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'size-total' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'size-used' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'snap-autodelete' => {
                'type' => 'snap-autodelete-info',
                'flags' => 5,
                'scope' => [],
            },
            'snaplock-type' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'snaplock-volume-compliance-clock' => {
                'type' => 'integer',
                'flags' => 4,
                'scope' => [],
            },
            'snapshot-blocks-reserved' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'snapshot-percent-reserved' => {
                'type' => 'integer',
                'flags' => 0,
                'scope' => [],
            },
            'space-reserve' => {
                'type' => 'string',
                'flags' => 4,
                'scope' => [],
            },
            'space-reserve-enabled' => {
                'type' => 'boolean',
                'flags' => 4,
                'scope' => [],
            },
            'state' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'transition' => {
                'type' => 'transition-info',
                'flags' => 5,
                'scope' => [],
            },
            'type' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'uuid' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'vm-align' => {
                'type' => 'vm-align-info',
                'flags' => 5,
                'scope' => [],
            },
            'volume-64bit-upgrade' => {
                'type' => 'volume-64bit-upgrade-info',
                'flags' => 5,
                'scope' => [],
            },
        },
    },
    'volume-option-info' => {
        'category' => 'volume',
        'fields' => {
            'name' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
            'value' => {
                'type' => 'string',
                'flags' => 0,
                'scope' => [],
            },
        },
    },
    'uuid' => {
        'category' => 'wafl',
        'fields' => {
        },
    },
};

sub new {
    my $self = {'apis' => $APIS, 'typedefs' => $TYPEDEFS};
    bless $self;
    return $self;
}
sub GetApi {
    my ($self, $name) = @_;
    my $type = ref($self) || die "$self is not an object";
    my $api = $self->{apis}->{$name} || die "No definition for API $name found";
    return $api;
}
sub GetTypedef {
    my ($self, $name) = @_;
    my $type = ref($self) || die "$self is not an object";
    my $api = $self->{typedefs}->{$name} || die "No definition for typedef $name found";
    return $api;
}
sub IsTypedefFlag {
    my ($self, $flag) = @_;
    return ($flag & FIELD_TYPEDEF) == FIELD_TYPEDEF;
}

sub IsArrayFlag {
    my ($self, $flag) = @_;
    return ($flag & FIELD_ARRAY) == FIELD_ARRAY;
}

sub IsEncryptedFlag {
    my ($self, $flag) = @_;
    return ($flag & FIELD_ENCRYPTED) == FIELD_ENCRYPTED;
}

1;


__END__

=head1 NAME

Ontap7ModeAPI - Contains the definitions and description of API Bindings for 7-Mode/7G Data ONTAP systems

=head1 SYNOPSIS

	 my $s = NaServer->new($server, 1, 0); # create NaServer (server context)
	 $s->set_admin_user('admin', 'password'); # provide username and password
	 $s->set_bindings_family('7-Mode'); # set the bindings family to 7-Mode for bindings validation

	 eval{ 
		 my $output = $s->system_get_version(); # use binding for system-get-version API
		 print "Data ONTAP version: $output->{version}\n"; # extract the required parameter from output

	 };
	 if($@) { # check for any exception
		 my ($error_reason, $error_code) = $@ =~ /(.+)\s\((\d+)\)/;  # parse out error reason and error code
		 print "Error Reason: $error_reason  Code: $error_code\n"
	 }

=head1 DESCRIPTION

NetApp Manageability SDK 5.2 provides support for Perl API bindings for both Data ONTAP APIs and OnCommand Unified Manager APIs.
The Perl API bindings libraries contain interfaces to establish a connection with either the Data ONTAP server or the OnCommand Unified Manager server.
By using these libraries, you can create Perl applications to access and manage the Data ONTAP server or OnCommand Unified Manager server.

NetApp Manageability SDK 5.2 Perl API bindings provide a runtime library NaServer.pm, which is available at <installation_folder>/lib/perl/NetApp.
This library file enables you to establish a server connection, send requests and receive responses, and interpret error messages.
Each binding can be called as a subroutine of NaServer module which in turn invokes the corresponding Data ONTAP or OnCommand Unified Manager API.



=head1 API BINDINGS



=head2 aggr_add

[B<Family:> ontap-classic]


=begin html

Add disks to the specified aggregate, whether it is free-standing or embedded in a traditional volume. The disks to add are specified in the same way as for "aggr-create". Disks cannot be added to a mirrored aggregate if one or more of the plexes is offline. By the time the API returns, the disk(s) may not yet be completely added. Use 'aggr-list-info' to query the aggregate status to determine when it has finished growing due to the added disk(s). Same can be done using 'aggr-get-iter' when requested from Admin Vserver LIF. When the upgrade-64bit-mode input is provided to this API, the API produces a set of results in the background. These results are not available as output from aggr-add. Use the 'aggr-list-info' and 'volume-list-info' APIs to query the results of the 64-bit upgrade process on the aggregate and flexible volumes, respectively.

=end html



B<Inputs>

=over 2

=item * I<aggregate>  =>   B<string>

=begin html

<br>Name or UUID of the aggregate to which the disks will be added. See the synopsis for name/UUID format and restrictions.

=end html

=back



=over 2

=item * I<allow-mixed-rpm>  =>   B<boolean, optional>

=begin html

<br>Disks in an aggregate are normally required to have the same RPM. This behavior is overridden with this option when it is set to true. Default value is false.

=end html

=back



=over 2

=item * I<allow-same-carrier>  =>   B<boolean, optional>

=begin html

<br>Using two disks from one carrier that houses multiple disks in one RAID group is not desirable. If that happens, Data ONTAP initiates a series of disk copy operations to correct that situation. Sometimes, selection of available spare disks makes it impossible to avoid placing two disks from one carrier in one RAID group. Setting this option to true allows placing two disks from one carrier in one RAID group. This option has an effect only when disks to be used are specified in 'disks'. This option is ignored when 'disk-count' is used.

=end html

=back



=over 2

=item * I<cache-raid-type>  =>   B<string, optional>

=begin html

<br>Specifies the raid-type of the new RAID groups being created as part of the disk add operation. This option should be used while adding SSD disks for the first time to a hybrid-enabled aggregate. Possible values: raid4 and raid_dp only. If not specified, the default value is the raid-type of the aggregate.

=end html

=back



=over 2

=item * I<checksum-style>  =>   B<string, optional>

=begin html

<br>Specifies the checksum style for the disks to be added to an aggregate. This input is not allowed if a list of disks to use is specified through the "disks" parameter. The possible values: <ul> <li> "advanced_zoned" - advanced_zoned checksum (azcs), <li> "block" - block. </ul> By default, disks with same checksum style as the aggregate are selected. Use this option to override that behavior and create a mixed checksum aggregate. "zoned" is not supported as one of the possible values as a mixed checksum aggregate can support only block and advanced_zoned checksum styles.

=end html

=back



=over 2

=item * I<disk-count>  =>   B<integer, optional>

=begin html

<br>Number of disks to add, including the parity disks. The disks will come from the pool of spare disks. The smallest disks in this pool join the aggregate first, unless the "disk-size" argument is specified. Either the "disk-count" or "disks" argument must be specified. Range : [0..2^31-1].

=end html

=back



=over 2

=item * I<disk-size>  =>   B<integer, optional>

=begin html

<br>The individual disk size in 4KB blocks. For example, a disk-size of 131072000 represents a 500GB drive (131072000 * 4 * 1024 = 500 * 1024 * 1024 * 1024). Disks that are within approximately 20% of the specified size will be selected. If neither the "disk-size" nor the "disk-size-with-unit" argument is specified, existing groups are appended with disks that are the best match by size for the largest disk in the group. When starting new groups, disks that are the best match by size for the largest disk in the last raidgroup are selected first, then smaller disks, and finally larger disks. This "disk-size" option is ignored if a specific list of disks is specified through the "disks" parameter. Range : [0..2^31-1]. You must only use one of either "disk-size" or "disk-size-with-unit" parameters. If both appear, an error message will be returned.

=end html

=back



=over 2

=item * I<disk-size-with-unit>  =>   B<string, optional>

=begin html

<br>This parameter accepts a disk size in the specified unit. It is a positive integer number followed by unit of "T", "G", "M" or "K". For example, these are accepted: 72G, 36G, 1T and 32M. But "72" will not be accepted. This "disk-size-with-unit" option is ignored if a specific list of disks is specified through the "disks" parameter. You must only use one of either "disk-size" or "disk-size-with-unit" parameters. If both appear, an error message will be returned.

=end html

=back



=over 2

=item * I<disk-type>  =>   B<string, optional>

=begin html

<br>Type of disks to use : ATA, BSAS, EATA, FCAL, FSAS, LUN, MSATA, SAS, SATA, SCSI, XATA, XSAS, or SSD. This option is required when converting an existing aggregate to a hybrid one, or when operating on a hybrid aggregate. Otherwise, the option is not required.

=end html

=back



=over 2

=item * I<disks>  =>   B<L<"disk-info">[], optional>

=begin html

<br>Specific list of disks to add to the aggregate. If the aggregate is mirrored and a specific list of disks is supplied, another list ("mirror-disks") must also be supplied with the same number of disks. Either the "disks" or "disk-count" argument must be specified.

=end html

=back



=over 2

=item * I<force-cache-size>  =>   B<boolean, optional>

=begin html

<br>When set to true this parameter forces the addition of SSD disks to hybrid enabled aggregate by skipping the check for total (local + partner) hybrid SSD capacity. This can be used when the partner's cache capacity cannot be retrieved. Default value is false. Warning: If force-cache-size is set to true, the administrator is responsible to ensure that the total limit will not be exceeded.

=end html

=back



=over 2

=item * I<force-spare-pool>  =>   B<boolean, optional>

=begin html

<br>Disks in a plex are not normally permitted to span spare pools. This behavior is overridden with this option when it is set to true. This is a deprecated parameter. Use the allow-mixed-rpm and ignore-pool-checks parameters instead.

=end html

=back



=over 2

=item * I<group-selection-mode>  =>   B<string, optional>

=begin html

<br>Specifies how DATA ONTAP adds the specified disks to raidgroups. Legitimate values are "last", "one", "new" or "all". group-selection-mode is an optional argument, and the behavior when it is not used is selected by value of raid-group. If raid-group is used, the behavior is the same as for group-selection-mode "one". If raid-group is not used, the behavior is the same as for group-selection-mode "last". The raid-group option must be used with group-selection-mode value "one", and it cannnot be used with others. If the string value is "last", Data ONTAP adds the specified disks to the existing last RAID group first. After the last RAID group is full, it creates one or more new RAID groups and adds the remaining disks to the new groups. If the string value is "one", Data ONTAP adds the specified disks to the existing RAID group specified by raid-group option until this specified RAID group is full. If the string value is "new", Data ONTAP creates one or more new RAID groups and adds the specified disks to the new groups, even if they would fit into an existing RAID group. The name of new RAID groups are selected automatically. It is not possible to specify the name for the new RAID groups. If the string value is "all", Data ONTAP adds the specified disks to existing RAID groups first. Only after all existing RAID groups are full, it creates one or more new RAID groups and adds the remaining disks to the new groups.

=end html

=back



=over 2

=item * I<ignore-pool-checks>  =>   B<boolean, optional>

=begin html

<br>Disks in a plex are normally required to come from the same spare pool. Similarly, disks in different plexes of a mirrored aggregate are required to come from different spare pools. This behavior is overridden with this option when it is set to true. Default value is false.

=end html

=back



=over 2

=item * I<mirror-disks>  =>   B<L<"disk-info">[], optional>

=begin html

<br>Specific list of mirror disks needed to accompany the list in the "disks" parameter. This list must contain the same number of disks as specified in "disks".

=end html

=back



=over 2

=item * I<pre-check>  =>   B<boolean, optional>

=begin html

<br>Only check for the warnings without actually adding the disks. This option cannot be used when "simulate" is specified or "upgrade-64bit-mode" is set to "check". Default value is false.

=end html

=back



=over 2

=item * I<raid-group>  =>   B<string, optional>

=begin html

<br>Specifies the RAID group (for example rg0) to which the indicated disks are to be added. When a RAID group other than the last RAID group is specified, the aggregate can no longer be reverted to a version of Data ONTAP prior to 6.2. In such a case, the "force-spare-pool" option must be specified as well. By default, the filer fills up one RAID group with disks before starting another RAID group. Suppose an aggregate currently has one RAID group of 12 disks and its RAID group size is 14. If you add 5 disks to this aggregate, it will have one RAID group with 14 disks and another RAID group with 3 disks. The filer does not evenly distribute disks among RAID groups.

=end html

=back



=over 2

=item * I<simulate>  =>   B<boolean, optional>

=begin html

<br>Simulates the addition of disks to the given aggregate or UUID of the aggregate. If set to "true", addition of disks won't happen but returns the list of disks that would be automatically selected for the addition of the aggregate. By default, simulate option is set to false.

=end html

=back



=over 2

=item * I<upgrade-64bit-mode>  =>   B<string, optional>

=begin html

<br>Allows the aggregate to grow past 16 TB and begin 64-bit upgrade. If not supplied, adding disks past 16 TB to a 32-bit aggregate will fail. Legitimate values are "check", "grow_all", "grow_none", and "grow_reserved". If the "check" value is specified, aggr-add produces a summary of the space impact which would result from upgrading the aggregate to 64-bit. This summary includes the space usage of each contained volume after the volume is upgraded to 64-bit and the amount of space that must be added to the volume to successfully complete the 64-bit upgrade. The summary can be obtained by querying the 'aggr-list-info' and 'volume-list-info' APIs. The aggregate's summary is made available in the 'check' element that is part of the 'aggr-64bit-upgrade-info' typedef. The flexible volumes' summary is made available in the 'check' element that is part of the 'volume-64bit-upgrade-info' typedef. This option does not result in an upgrade to 64-bit or addition of disks. If the "grow_all" value is specified, "aggr-add" upgrades the aggregate to 64-bit if the total aggregate size after adding the specified disks exceeds 16TB. This option allows "aggr-add" to automatically grow volumes as needed if they run out of space due to the 64-bit upgrade. The volumes will be grown to accommodate all the files within these volumes. This option does not affect volumes which have autosize enabled. If the "grow_none" value is specified, "aggr-add" upgrades the aggregate to 64-bit if the total aggregate size after adding the specified disks exceeds 16TB. This option does not allow "aggr-add" to automatically grow volumes if they run out of space due to the 64-bit upgrade. If the "grow_reserved" value is specified, "aggr-add" upgrades the aggregate to 64-bit if the total aggregate size after adding the specified disks exceeds 16TB. This option allows "aggr-add" to automatically grow volumes if they run out of space due to the 64-bit upgrade, but only to accommodate the space reserved files within these volumes. This option does not affect volumes which have autosize enabled.

=end html

=back



B<Outputs>

=over 2

=item * I<bad-disks>  =>   B<L<"disk-info">[], optional>

=begin html

<br>List of disks that were not added. This is only returned if there are bad disks.

=end html

=back



=over 2

=item * I<pre-check-results>  =>   B<L<"warning-code">[], optional>

=begin html

<br>Result of the pre-check for possible warnings. Possible warning codes are: <ul> <li> E_WARN_NEW_RAID_GROUP <li> E_WARN_EXCEEDS_HALF_CLUSTER_SIZE <li> E_WARN_DISK_DOWNSIZE <li> E_WARN_LOW_SPARE </ul>

=end html

=back



=over 2

=item * I<selected-disks>  =>   B<L<"disk-info">[], optional>

=begin html

<br>List of disks that would be used for the addition of disks to the given aggregate. This is only returned if the simulate option is set to true.

=end html

=back



=over 2

=item * I<selected-mirror-disks>  =>   B<L<"disk-info">[], optional>

=begin html

<br>List of mirror disks that would be used for the addition of disks to the given aggregate. This is only returned if the simulate option is set to true on the mirrored aggregate.

=end html

=back



=over 2

=item * I<upgrade-64bit-cookie>  =>   B<integer, optional>

=begin html

<br>The opaque cookie to uniquely identify this 64-bit upgrade transaction. This cookie can be compared against the cookie returned by aggr-list-info to ensure that the output produced by aggr-list-info corresponds to this 64-bit upgrade transaction. Range: [0..2^64-1].

=end html

=back



=head2 aggr_check_spare_low

[B<Family:> ontap-classic]


=begin html

Return true if there is no suitable spare disk available for any filesystem (parity or data) disk.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<is-spare-low>  =>   B<boolean>

=begin html

<br>"true", if system has insufficient spare disk, "false" otherwise. When requested from Admin Vserver LIF, "true" is returned if one or more nodes in the cluster have spare low condition, "false" otherwise.

=end html

=back



=head2 aggr_create

[B<Family:> ontap-classic]


=begin html

Create a new aggregate with the given name. The maximum number of aggregates that can be created on a filer varies by the type of configuration. In a standalone configuration, up to 200 aggregates can be created on a filer (including the aggregates that are "embedded" in traditional volumes, which must be created as a side effect of a traditional volume creation). In an HA configuration, this number drops to 100 and to 50 in a C-mode MetroCluster configuration. The aggregate may not yet be operational immediately after the API returns. Use 'aggr-list-info' to query the status of the newly-created aggregate to determine when it is fully operational. Same can be done using 'aggr-get-iter' when requested from Admin Vserver LIF. NOTE: If ECANT_USE_ALL_DISKS is returned, then the requested aggregate was indeed created, just not with all the disks that were specified.

=end html



B<Inputs>

=over 2

=item * I<aggregate>  =>   B<string>

=begin html

<br>Name of the aggregate to create. The aggregate name can contain letters, numbers, and the underscore character(_), but the first character must be a letter or underscore. The maximum length of the aggregate name is 255.

=end html

=back



=over 2

=item * I<allow-mixed-rpm>  =>   B<boolean, optional>

=begin html

<br>Disks in an aggregate are normally required to have the same RPM. This behavior is overridden with this option when it is set to true. Default value is false.

=end html

=back



=over 2

=item * I<allow-same-carrier>  =>   B<boolean, optional>

=begin html

<br>Using two disks from one carrier that houses multiple disks in one RAID group is not desirable. If that happens, Data ONTAP initiates a series of disk copy operations to correct that situation. Sometimes, selection of available spare disks makes it impossible to avoid placing two disks from one carrier in one RAID group. Setting this option to true allows placing two disks from one carrier in one RAID group. This option has an effect only when disks to be used are specified in 'disks'. This option is ignored when 'disk-count' is used.

=end html

=back



=over 2

=item * I<block-type>  =>   B<string, optional>

=begin html

<br>The indirect block format that the aggregate can have. It can be either 32_bit or 64_bit. Specifying 64_bit allows creation of aggregates that can be larger than 16TB. The default is 64_bit. Possible values: 32_bit, 64_bit

=end html

=back



=over 2

=item * I<checksum-style>  =>   B<string, optional>

=begin html

<br>Specifies the checksum style for the aggregate. This input is not allowed if a list of disks to use is specified through the "disks" parameter. The possible values: <ul> <li> "advanced_zoned" - advanced_zoned checksum (azcs), <li> "block" - block, </ul>

=end html

=back



=over 2

=item * I<disk-count>  =>   B<integer, optional>

=begin html

<br>Number of disks to place into the aggregate, including parity disks. The disks in this newly- created aggregate come from the spare disk pool. The smallest disks in this pool join the aggregate first, unless the "disk-size" argument is provided. Either "disk-count" or "disks" must be supplied. Range [0..2^31-1].

=end html

=back



=over 2

=item * I<disk-size>  =>   B<integer, optional>

=begin html

<br>Disk size in 4KB blocks. Disks that are within 10% of the specified size will be selected for use in the aggregate. If neither "disk-size" nor "disk-size-with-unit" is specified, existing groups are appended with disks that are the best match for the largest disk in the group. When starting new groups, the smallest disks are selected first. This option is ignored if a specific list of disks to use is specified through the "disks" parameter. Range [0..2^31-1]. You must only use one of either "disk-size" or "disk-size-with-unit" parameters. If both appear, an error message will be returned.

=end html

=back



=over 2

=item * I<disk-size-with-unit>  =>   B<string, optional>

=begin html

<br>Disk size in the specified unit. It is a positive integer number followed by unit of "T", "G", "M" or "K". This "disk-size-with-unit" option is ignored if a specific list of disks is specified through the "disks" parameter. You must only use one of either "disk-size" or "disk-size-with-unit" parameters. If both appear, an error message will be returned.

=end html

=back



=over 2

=item * I<disk-type>  =>   B<string, optional>

=begin html

<br>Type of disks to use: ATA, BSAS, EATA, FCAL, FSAS, LUN, MSATA, SAS, SATA, SCSI, SSD, XATA, or XSAS. This option is needed only when disks of different types are connected to the filer. It is not allowed if a list of disks to use is specified through the "disks" parameter. The ability to mix compatible disk types in one aggregate is controlled by the system option 'raid.disktype.enable'.

=end html

=back



=over 2

=item * I<disks>  =>   B<L<"disk-info">[], optional>

=begin html

<br>Specific list of disks to use for the new aggregate. If "mirrored" is set to true and a specific list of disks is supplied, the "mirror-disks" list with the same number of disks must also be supplied. Either "disk-count" or "disks" must be supplied.

=end html

=back



=over 2

=item * I<force-spare-pool>  =>   B<boolean, optional>

=begin html

<br>Disks in a plex are not normally permitted to span spare pools. This behavior is overridden with this option when it is set to true. This is a deprecated parameter. Use the allow-mixed-rpm and ignore-pool-checks parameters instead.

=end html

=back



=over 2

=item * I<ha-policy>  =>   B<ha-policy-type, optional>

=begin html

<br>Aggregate's HA policy. The only allowed values are "cfo" and "sfo". In clustered environments default value is 'sfo' if not specified. In unclustered environments, it is not allowed to specify this attribute as it is always be 'cfo' internally. EINVALIDINPUTERROR is returned if value is other than "cfo" and "sfo". EOP_CLUSTER_ATTR_DISALLOWED is returned if this attribute is used in unclustered environments.

=end html

=back



=over 2

=item * I<ignore-pool-checks>  =>   B<boolean, optional>

=begin html

<br>Disks in a plex are normally required to come from the same spare pool. Similarly, disks in different plexes of a mirrored aggregate are required to come from different spare pools. This behavior is overridden with this option when it is set to true. Default value is false.

=end html

=back



=over 2

=item * I<is-mirrored>  =>   B<boolean, optional>

=begin html

<br>Specifies that the new aggregate be mirrored (have two plexes). If set to true, then the indicated disks will be split across the two plexes. By default, the new aggregate will not be mirrored.

=end html

=back



=over 2

=item * I<is-snaplock>  =>   B<boolean, optional>

=begin html

<br>Specifies the creation of a SnapLock aggregate. By default, is-snaplock is not specified. When is-snaplock is "true" the type of snaplock aggregate is determined in the following way - 1> If snaplock-type is set, create the type specified in snaplock-type (see snaplock-type for more details) 2> Otherwise, create a Snaplock enterprise aggregate if a Snaplock enterprise license has been installed. 3> Otherwise, create a Snaplock compliance aggregate. ESERVICENOTLICENSED is returned if the required Snaplock Compliance or Enterprise license is not installed. EONTAPI_EWORMNOCLOCK is returned if SnapLock Compliance Clock is not running. If you need to create a snaplock aggregate, the suggested method is to specify snaplock-type as "compliance" or "enterprise" and not specify is-snaplock at all. If you want to create a non-snaplock aggregate, the suggested method is to specify neither snaplock-type nor is-snaplock.

=end html

=back



=over 2

=item * I<language-code>  =>   B<string, optional>

=begin html

<br>Specifies the language to use for the new traditional volume via a language code. The default language is the one used by the filer's root volume. This option may be used only when creating a traditional volume, i.e. when "type" is "trad." <p> For the full list of available language codes, see 'volume-create'.

=end html

=back



=over 2

=item * I<mirror-disks>  =>   B<L<"disk-info">[], optional>

=begin html

<br>List of mirror disks to use. It must contain the same number of disks specified in "disks".

=end html

=back



=over 2

=item * I<pre-check>  =>   B<boolean, optional>

=begin html

<br>Only check for the warnings without actually creating the aggregate. This option cannot be used when "simulate" is specified. Default value is false.

=end html

=back



=over 2

=item * I<raid-size>  =>   B<integer, optional>

=begin html

<br>Specifies the maximum number of disks in each RAID group in the aggregate. The maximum value for this parameter is 28. The default value is platform- dependent. The valid range of values is also platform-dependent, but never wider than [2..28].

=end html

=back



=over 2

=item * I<raid-type>  =>   B<string, optional>

=begin html

<br>Specifies the type of RAID groups to use in the new aggregate. Possible values: raid4, raid_dp. The default value is raid4 on most platforms.

=end html

=back



=over 2

=item * I<rpm>  =>   B<integer, optional>

=begin html

<br>Rotational speed of disks in revolutions per minute. Possible values are: 5400, 7200, 10000, and 15000. This option is needed only when disks with different rotational speeds are connected to the filer. It is not allowed if a list of disks to use is specified through the "disks" parameter.

=end html

=back



=over 2

=item * I<simulate>  =>   B<boolean, optional>

=begin html

<br>Specifies to return the list of disks getting used to create the new aggregate. If set to "true", new aggregate won't be created but returns the disks that would be automatically selected for the creation of the aggregate. By default, simulate option is set to false.

=end html

=back



=over 2

=item * I<snaplock-type>  =>   B<string, optional>

=begin html

<br>Specifies the type of Snaplock aggregate to be created. Possible values - "compliance" or "enterprise" ESERVICENOTLICENSED is returned if the necessary Snaplock compliance or enterprise license has not been installed. EINVALIDINPUTERROR is returned if snaplock-type has an illegal value or if is-snaplock has been set to "false". EONTAPI_EWORMNOCLOCK is returned if SnapLock Compliance Clock is not running.

=end html

=back



=over 2

=item * I<spare-pool>  =>   B<string, optional>

=begin html

<br>Specifies the spare pool from which to select spare disks to use in creation of a new aggregate. This option is not allowed if a list of disks specified through the "disks" parameter. This option cannot be used when "is-mirrored" is set to true. Possible values: <ul> <li> "Pool0" - Disks associated with spare Pool0. <li> "Pool1" - Disks associated with spare Pool1. </ul>

=end html

=back



=over 2

=item * I<striping>  =>   B<striping-type, optional>

=begin html

<br>Specifies the striping information about new aggregate. The only allowed values are "striped" and "not_striped". Default value is "not_striped". "striped" value creates striped aggregate on node. This attribute is not allowed in unclustered environments. EINVALIDINPUTERROR is returned if value is other than "striped" and "not_striped". EOP_CLUSTER_ATTR_DISALLOWED is returned if this attribute is used in unclustered environments. EOP_DISALLOWED_ON_CFO_AGGR is returned if this attribute is set to "striped" when aggregate being created with 'cfo' HA policy.

=end html

=back



=over 2

=item * I<type>  =>   B<string, optional>

=begin html

<br>The type of the aggregate. Possible values: aggr, trad. - "aggr" (aggregate contains flexible volumes) - "trad" (aggregate contains exactly one traditional volume) If not specified, the default is "aggr." The value "trad" is invalid when the request is sent to the Admin Vserver LIF.

=end html

=back



B<Outputs>

=over 2

=item * I<bad-disks>  =>   B<L<"disk-info">[], optional>

=begin html

<br>List of disks that were not added. This is only returned if there are bad disks.

=end html

=back



=over 2

=item * I<pre-check-results>  =>   B<L<"warning-code">[], optional>

=begin html

<br>Result of the pre-check for possible warnings. Possible warning codes are: <ul> <li> E_WARN_EXCEEDS_HALF_CLUSTER_SIZE <li> E_WARN_DISK_DOWNSIZE <li> E_WARN_LOW_SPARE </ul>

=end html

=back



=over 2

=item * I<selected-disks>  =>   B<L<"disk-info">[], optional>

=begin html

<br>List of disks that would be used for the creation of the new aggregate. This is only returned if the simulate option is set to true.

=end html

=back



=over 2

=item * I<selected-mirror-disks>  =>   B<L<"disk-info">[], optional>

=begin html

<br>List of mirror disks that would be used for the creation of the new aggregate. This is only returned if both the simulate option and the is-mirrored option are set to true.

=end html

=back



=head2 aggr_destroy

[B<Family:> ontap-classic]


=begin html

Destroys the specified aggregate or plex. If an aggregate is specified, all plexes in the aggregate are destroyed. If the aggregate is embedded in a traditional volume, then the entire traditional volume is destroyed. If a plex is specified, only that plex is destroyed, leaving an unmirrored aggregate containing the remaining plex. The disks in the destroyed object become spare disks. Only offline aggregates and plexes can be destroyed. Note: Offline aggregates will be destroyed even if they contain one or more flexible volumes, which should not typically be the case. From cluster interface only aggregates are supported and plexes are not supported.

=end html



B<Inputs>

=over 2

=item * I<aggregate>  =>   B<string>

=begin html

<br>Name of the existing aggregate or plex to be destroyed, using the following format: [/vol/]<aggrname>[<plexinfo>] UUID can be specified instead of aggregate name. See the synopsis for name/UUID format and restrictions.

=end html

=back



=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>When using "aggr-destroy" on a traditional volume, force the destruction of the volume even if a non-default vfiler has storage on it. Normally, the system will not destroy such a volume and will instead return EVOLUME_HAS_VFILER_STORAGE.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 aggr_get_filer_info

[B<Family:> ontap-classic]


=begin html

Get information on what possibilities and parameters exist for aggregates on a given filer.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<allowed-raidtypes>  =>   B<L<"raidtype-info">[]>

=begin html

<br>List of RAID types allowed for aggregates on this filer.

=end html

=back



=over 2

=item * I<checksum-types>  =>   B<string>

=begin html

<br>Checksum types supported by this filer. The possible values: <ul> <li> "zoned" - if all aggregates are Fixed VBN, <li> "block" - if all aggregates are Block Appended, <li> "mixed" - if aggregates are mixed (Fixed VBN, Block Appended and Advanced Zoned), <li> "none" - if no aggregates have zoned or advanced_zoned checksum (azcs) or block checksums, <li> "advanced_zoned" - if all aggregates have Advanced Zoned Checksum scheme. </ul>

=end html

=back



=over 2

=item * I<default-raidtype>  =>   B<string>

=begin html

<br>Default type of RAID used to protect against disk failure in aggregates on this filer. Possible values: "raid0", "raid4", "raid_dp", "mixed_raid_type".

=end html

=back



=over 2

=item * I<disk-types>  =>   B<string>

=begin html

<br>Type of disks supported by this filer. Possible values: "512", "520", "4096", "mixed", "none". "512" if all disks are 512 BPS, "520" if all disks are 520 BPS, "4096" if all disks are 4096 BPS, "mixed" if disks are mixed 512, 520 and 4096 BPS, "none" if no disks have 512 or 520 or 4096 BPS.

=end html

=back



=over 2

=item * I<max-named-disks-per-request>  =>   B<integer>

=begin html

<br>The maximum number of named disks which can be specified to 'aggr add', 'aggr create', or 'agg mirror' operation. Disk addition process may fail if the specified number of named disk is more than this limit. This value is the maximum number of disk entries which can be specified in 'disks' or 'mirror-disks' argument of 'aggr-create' and 'aggr-add' api. Range : [0..2^31-1].

=end html

=back



=over 2

=item * I<raidgroup-size>  =>   B<L<"raidgroup-size-info">[]>

=begin html

<br>List of the RAID group sizing parameters for each RAID type supported on this filer.

=end html

=back



=over 2

=item * I<root-volume>  =>   B<string>

=begin html

<br>Current root volume on the filer.

=end html

=back



=over 2

=item * I<snapshots-max>  =>   B<integer>

=begin html

<br>Maximum number of snapshots available per aggregate on the filer. Range : [0..2^31-1].

=end html

=back



=head2 aggr_get_root_name

[B<Family:> ontap-classic, vfiler]


=begin html

Return the name of the "root" volume on the filer.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<root-volume>  =>   B<string>

=begin html

<br>Name of the root volume for the filer.

=end html

=back



=head2 aggr_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Get aggregate status.

=end html



B<Inputs>

=over 2

=item * I<aggregate>  =>   B<string, optional>

=begin html

<br>The aggregate name or UUID to get status for. See the synopsis for name/UUID format. If not supplied, get status of all aggregates owned by the local node.

=end html

=back



=over 2

=item * I<filter-attrs>  =>   B<L<"filter-attrs-info">, optional>

=begin html

<br>This input is used as a discriminant when status is required for one or more aggregates. This option will be ignored when an aggregate name is specified. If no argument is supplied, default value is NULL. If this is NULL or all of its elements are not supplied, then this filter has no effect and the behavior is the same as described in the 'aggregate' input description.

=end html

=back



=over 2

=item * I<verbose>  =>   B<boolean, optional>

=begin html

<br>If set to "true", detailed volume and plex information (including all the RAID group and disk information) is returned. If not supplied or set to "false", this extra information is not returned.

=end html

=back



B<Outputs>

=over 2

=item * I<aggregates>  =>   B<L<"aggr-info">[]>

=begin html

<br>List of aggregates and their status.

=end html

=back



=head2 aggr_mediascrub_list_info

[B<Family:> ontap-classic]


=begin html

Get the status of media scrubbing on the named aggregate, plex, or RAID group. Status includes percentage complete and the media scrub's status.

=end html



B<Inputs>

=over 2

=item * I<aggregate>  =>   B<string, optional>

=begin html

<br>Name of an existing aggregate, plex, or RAID group, using the following format: [/vol/]<aggrname>[<plexinfo>][<groupinfo>] If no name is given, then status is generated for all RAID groups currently being media-scrubbed.

=end html

=back



B<Outputs>

=over 2

=item * I<mediascrub-details>  =>   B<L<"mediascrub-detail-info">[]>

=begin html

<br>List of RAID groups and their media scrub status.

=end html

=back



=head2 aggr_mirror

[B<Family:> ontap-classic]


=begin html

Turns an unmirrored aggregate into a mirrored aggregate by adding a plex to it. The plex is either newly formed from disks chosen from a spare pool or, if the "victim-aggregate" option is specified, taken from another existing unmirrored aggregate. The named aggregate must currently be unmirrored. Disks may be specified explicitly using the "mirror-disks" list option in the same way as with the "aggr-create" and "aggr-add" commands. The number of disks indicated must match the number present in the existing aggregate. If disks are not specified explicitly, then disks are automatically selected to match those in the aggregate's existing plex.

=end html



B<Inputs>

=over 2

=item * I<aggregate>  =>   B<string>

=begin html

<br>Name of the existing aggregate to be mirrored. UUID can be specified instead of aggregate name. See the synopsis for name/UUID format and restrictions.

=end html

=back



=over 2

=item * I<allow-mixed-rpm>  =>   B<boolean, optional>

=begin html

<br>Disks in an aggregate are normally required to have the same RPM. This behavior is overridden with this option when it is set to true. Default value is false.

=end html

=back



=over 2

=item * I<allow-same-carrier>  =>   B<boolean, optional>

=begin html

<br>Using two disks from one carrier that houses multiple disks in one RAID group is not desirable. If that happens, Data ONTAP initiates a series of disk copy operations to correct that situation. Sometimes, selection of available spare disks makes it impossible to avoid placing two disks from one carrier in one RAID group. Setting this option to true allows placing two disks from one carrier in one RAID group. This option has an effect only when disks to be used are specified in 'disks'. This option is ignored when 'disk-count' is used.

=end html

=back



=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>Force the mirroring operation through, past the normal roadblocks that would otherwise cause it to be aborted. For example, disks in a plex are not normally permitted to span spare pools. Also, the victim cannot normally be accepted when it is owned by one or more vfilers. All these safety-driven behaviors are overridden when this option is set to true. This is a deprecated parameter. Use the allow-mixed-rpm and ignore-pool-checks parameters instead.

=end html

=back



=over 2

=item * I<ignore-pool-checks>  =>   B<boolean, optional>

=begin html

<br>Disks in a plex are normally required to come from the same spare pool. Similarly, disks in different plexes of a mirrored aggregate are required to come from different spare pools. This behavior is overridden with this option when it is set to true. Default value is false.

=end html

=back



=over 2

=item * I<mirror-disks>  =>   B<L<"disk-info">[], optional>

=begin html

<br>Specific list of mirror disks to add. This list must match the number of disks present on the existing aggregate. The specified disks are not permitted to span disk pools unless overridden with the "force-spare-pool" option.

=end html

=back



=over 2

=item * I<override-vfiler-ownership>  =>   B<boolean, optional>

=begin html

<br>The victim aggregate cannot normally be accepted when it is owned by one or more vfilers. This option may be set to true in order to override that restriction. The option is ignored if 'victim-aggregate' is not specified.

=end html

=back



=over 2

=item * I<pre-check>  =>   B<boolean, optional>

=begin html

<br>Only check for the warnings without actually mirroring the aggregate. Default value is false.

=end html

=back



=over 2

=item * I<victim-aggregate>  =>   B<string, optional>

=begin html

<br>The "victim" aggregate to cannibalize in order to mirror the named aggregate. The "victim-aggregate" must have been previously joined with the aggregate to be mirrored and then split from it. The resulting mirrored aggregate is otherwise identical to the original aggregate before the operation. The "victim-aggregate" (and all its volumes) is effec- tively destroyed. "victim-aggregate" (and all its volumes) must be offline.

=end html

=back



B<Outputs>

=over 2

=item * I<bad-disks>  =>   B<L<"disk-info">[], optional>

=begin html

<br>List of disks that were not added. This is only returned if there are bad disks.

=end html

=back



=over 2

=item * I<pre-check-results>  =>   B<L<"warning-code">[], optional>

=begin html

<br>Result of the pre-check for possible warnings. <ul> <li> E_WARN_DISK_DOWNSIZE <li> E_WARN_LOW_SPARE </ul>

=end html

=back



=head2 aggr_modify_raid_type

[B<Family:> ontap-classic]


=begin html

Modify the RAID type for the given aggregate to the specified "raid-type". This API can also selectively change the RAID type of specific raid groups in the aggregate based on the specified "disk-type". The change remains effective even if the filer is rebooted. This API does not support modifying options of a striped aggregate.

=end html



B<Inputs>

=over 2

=item * I<aggregate>  =>   B<string>

=begin html

<br>Name or UUID of the aggregate whose option is to be set. See the synopsis for name/UUID format and restrictions.

=end html

=back



=over 2

=item * I<disk-type>  =>   B<string, optional>

=begin html

<br>Type of disks to use : ATA, BSAS, FCAL, FSAS, LUN, SAS, SATA, or SSD. This option is required if we want to change the raid type of raid groups created out of the specified disks only. Otherwise, if this is not specified then the raid type for all raid groups in the aggregate would change.

=end html

=back



=over 2

=item * I<raid-type>  =>   B<string>

=begin html

<br>possible values: "raid4","raid_dp" The type of RAID group used for this aggregate. The "raid4" setting provides one parity disk per RAID group, while "raid_dp" provides two. Changing this option immediately changes the RAID group type for the RAID groups in the aggregate. When upgrading RAID groups from "raid4" to "raid_dp", each RAID group begins a reconstruction onto a spare disk allocated for the second "dparity" parity disk.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 aggr_offline

[B<Family:> ontap-classic]


=begin html

Take the specified aggregate or plex offline. The operation takes effect before the API returns. Except in maintenance mode, the current root aggregate may not be taken offline. An aggregate marked to become the root aggregate cannot be taken offline. An aggregate containing one or more flexible volumes cannot be taken offline; its contained volumes must first be destroyed. A number of operations being performed on the given aggregate can prevent this operation from succeeding, either at all or for various lengths of time. If such operations are found, the system waits up to one second for them to finish. If they don't, the command is aborted. A check is also made for files in the aggregate opened by internal Data ONTAP processes. The command is aborted if any are found.

=end html



B<Inputs>

=over 2

=item * I<aggregate>  =>   B<string>

=begin html

<br>Name of the existing aggregate or plex to offline, using the following format: [[/vol]/]<aggrname>[<plexinfo>] UUID can be specified instead of aggregate name. See the synopsis for name/UUID format and restrictions. If the aggregate hosts any online volumes, then the offline request will fail unless the optional "unmount-volumes" argument (see below) appears and is set to TRUE. If we've been cleared to unmount any such online volumes hosted by the aggregate, the caller may also specify the number of seconds to wait should any of those volumes have active CIFS shares through the optional "cifs-delay-seconds" argument (see below). If a plex name is specified, the plex must be part of a mirrored aggregate, and both plexes must be online. Prior to offlining a plex, the system will flush all internally-buffered data associated with the plex and create a snapshot that is written out to both plexes. The snapshot allows for efficient resynchronization when the plex is subsequently brought back online. For ontap-cluster, plexinfo is being deprecated in lieu of the plex parameter.

=end html

=back



=over 2

=item * I<cifs-delay-seconds>  =>   B<integer, optional>

=begin html

<br>The number of seconds to wait before offlining any volumes that are hosted in the given aggregate that have active CIFS shares (if any). A value of 0 means that all such volumes are to be offlined immediately with no warning. CIFS users can lose data if they aren't given a chance to terminate applications gracefully. By default, "cifs-delay-seconds" is 0. NOTE: This argument may ONLY appear if the "unmount-volumes" argument (see above) also appears and is set to "TRUE".

=end html

=back



=over 2

=item * I<unmount-volumes>  =>   B<boolean, optional>

=begin html

<br>If set to "TRUE", this option specifies that all of the volumes hosted by the given aggregate are to be unmounted before the offline operation is executed. By default, the system will reject any attempt to offline an aggregate that hosts one or more online volumes.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 aggr_online

[B<Family:> ontap-classic]


=begin html

Bring the specified aggregate or plex online. This command takes effect immediately. All volumes on the aggregate are brought to whatever state they were in before the aggregate was restricted or taken offline. If there are CIFS shares associated with the any of the aggregate's volumes that were also onlined, they are enabled.

=end html



B<Inputs>

=over 2

=item * I<aggregate>  =>   B<string>

=begin html

<br>Name of the existing aggregate or plex to online, using the following format: [/vol/]<aggrname>[<plexinfo>] UUID can be specified instead of aggregate name. See the synopsis for name/UUID format and restrictions. If an aggregate is specified, it must currently be offline, restricted, or foreign (consisting of disks moved from another filer, and never having been brought online on the current filer). If the aggregate is foreign, it will be made native before being brought online on the current filer. Aggregates that aren't foreign are termed "native". If the aggregate is inconsistent but has not lost data, it is advisable to run WAFL_check or wafliron (or do a "snapmirror initialize" in case of a replica aggregate) prior to bringing it online. Bringing an inconsistent aggregate online increases the risk of further file system corruption. If the aggregate is inconsistent and has experienced possible loss of data, it can't be brought online unless WAFL_check or wafliron (or snapmirror initialize) is run on it. If a plex is specified, it must be part of an online mirrored aggregate. The system initiates resynchro- nization of the plex as part of online processing. For ontap-cluster, plexinfo is being deprecated in lieu of the plex parameter.

=end html

=back



=over 2

=item * I<force-online>  =>   B<boolean, optional>

=begin html

<br>An aggregate can not normally be brought online under the following conditions: 1. It has only 1 plex that is offline and not up-to-date. 2. It is an unmirrored or CFO aggregate that has been switched over to its DR partner as part of an MCC configuration. This behavior is overridden when this option is set "true". By default, "force-online" is "false".

=end html

=back



=over 2

=item * I<keep-same-uuid>  =>   B<boolean, optional>

=begin html

<br>Keep existing foreign raidtree id (aggregate uuid). Normally when a foreign raidtree is onlined, the raidtree rtid (aggregate uuid) is changed to guarantee uniqueness. The behavior is overridden when this option is set "true." By default, "keep-same-uuid" is "false."

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 aggr_options_list_info

[B<Family:> ontap-classic]


=begin html

Get the options that have been set for the specified aggregate. This API does not support listing options of striped aggregate.

=end html



B<Inputs>

=over 2

=item * I<aggregate>  =>   B<string>

=begin html

<br>Name or UUID of the aggregate whose options to retrieve. See the synopsis for name/UUID format and restrictions.

=end html

=back



B<Outputs>

=over 2

=item * I<options>  =>   B<L<"aggr-option-info">[]>

=begin html

<br>List of options set for this aggregate.

=end html

=back



=head2 aggr_rename

[B<Family:> ontap-classic]


=begin html

Rename the specified aggregate.

=end html



B<Inputs>

=over 2

=item * I<aggregate>  =>   B<string>

=begin html

<br>Name or UUID of the aggregate to rename. See the synopsis for name/UUID format and restrictions.

=end html

=back



=over 2

=item * I<new-aggregate-name>  =>   B<string>

=begin html

<br>The new name desired for the aggregate.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 aggr_restrict

[B<Family:> ontap-classic]


=begin html

Restrict the specified aggregate. If the aggregate is embedded in a traditional volume, the entire traditional volume will be restricted. An aggregate with one or more flexible volumes cannot be restricted; all of its contained volumes must first be destroyed.

=end html



B<Inputs>

=over 2

=item * I<aggregate>  =>   B<string>

=begin html

<br>Name or UUID of the aggregate to restrict. See the synopsis for name/UUID format and restrictions.

=end html

=back



=over 2

=item * I<cifs-delay-seconds>  =>   B<integer, optional>

=begin html

<br>The number of seconds to wait before restricting any volumes that are hosted in the given aggregate that have active CIFS shares (if any). A value of 0 means that all such volumes are to be offlined immediately with no warning. CIFS users can lose data if they aren't given a chance to terminate applications gracefully. By default, "cifs-delay-seconds" is 0. NOTE: This argument may ONLY appear if the "unmount-volumes" argument (see above) also appears and is set to "true".

=end html

=back



=over 2

=item * I<unmount-volumes>  =>   B<boolean, optional>

=begin html

<br>If set to "TRUE", this option specifies that all of the volumes hosted by the given aggregate are to be unmounted before the restrict operation is executed. By default, the system will reject any attempt to restrict an aggregate that hosts one or more online volumes.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 aggr_scrub_list_info

[B<Family:> ontap-classic]


=begin html

Get the status of parity scrubbing on the named aggregate. Status includes percentage complete and the scrub's suspended status (if appropriate). If no name is given, then status is generated for all RAID groups.

=end html



B<Inputs>

=over 2

=item * I<aggregate>  =>   B<string, optional>

=begin html

<br>Name or UUID of the entity to show scrubbing status for. See the synopsis for name/UUID format and restrictions.

=end html

=back



=over 2

=item * I<verbose>  =>   B<boolean, optional>

=begin html

<br>If set to "true", this operation will be verbose. If not supplied or set to false, normal output levels will be used.

=end html

=back



B<Outputs>

=over 2

=item * I<scrub-details>  =>   B<L<"scrub-detail-info">[], optional>

=begin html

<br>List of RAID groups and their scrub status.

=end html

=back



=head2 aggr_scrub_resume

[B<Family:> ontap-classic]


=begin html

Resume parity scrubbing on the named aggregate, plex, or RAID group. If no name is given, then resume parity scrubbing on all RAID groups for which it has been suspended. Use "aggr-scrub-list-info" to check scrubbing status.

=end html



B<Inputs>

=over 2

=item * I<aggregate>  =>   B<string, optional>

=begin html

<br>Name or UUID of the entity for which scrubbing is to resume. See the synopsis for name/UUID format and restrictions.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 aggr_scrub_start

[B<Family:> ontap-classic]


=begin html

Start parity scrubbing on the named aggregate, plex, or RAID group. Parity scrubbing compares the data disks to the parity disk in a RAID group, correcting the parity disk's contents as necessary. If no name is given, then parity scrubbing is started on all online aggregates. If an aggregate name is given, scrubbing is started on all RAID groups in the aggregate. If a plex name is given, scrubbing is started on all RAID groups contained in the plex. If a RAID group name is given, scrubbing is started only on that group. Use "aggr-scrub-list-info" to check scrubbing status.

=end html



B<Inputs>

=over 2

=item * I<aggregate>  =>   B<string, optional>

=begin html

<br>Name or UUID of the entity for which scrubbing is to start. See the synopsis for name/UUID format and restrictions.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 aggr_scrub_stop

[B<Family:> ontap-classic]


=begin html

Stop parity scrubbing on the named aggregate, plex, or RAID group. If no name is given, scrubbing will stop on all RAID groups currently being scrubbed. Use "aggr-scrub-list-info" to check scrubbing status.

=end html



B<Inputs>

=over 2

=item * I<aggregate>  =>   B<string, optional>

=begin html

<br>Name or UUID of the entity for which scrubbing is to stop. See the synopsis for name/UUID format and restrictions.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 aggr_scrub_suspend

[B<Family:> ontap-classic]


=begin html

Suspend parity scrubbing on the named aggregate, plex, or RAID group. If no name is given, suspend scrubbing on all RAID groups currently being scrubbed. Use "aggr-scrub-list-info" to check scrubbing status.

=end html



B<Inputs>

=over 2

=item * I<aggregate>  =>   B<string, optional>

=begin html

<br>Name or UUID of the entity for which scrubbing is to suspend. See the synopsis for name/UUID format and restrictions.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 aggr_set_option

[B<Family:> ontap-classic]


=begin html

Set the specified option for the given aggregate to "option-value". The change remains effective even if the filer is rebooted. Some options have values that are numbers, and some have values that are "on" (also expressible as "yes", "true", or "1" ) or "off" (also expressible as "no", "false", or "0"). A mixture of uppercase and lowercase characters may be used when typing an option's value. Note that the "root" option is special in that it doesn't have a corresponding value. This API does not support modifying options of striped aggregate.

=end html



B<Inputs>

=over 2

=item * I<aggregate>  =>   B<string>

=begin html

<br>Name or UUID of the aggregate whose option to be set. See the synopsis for name/UUID format and restrictions.

=end html

=back



=over 2

=item * I<option-name>  =>   B<string>

=begin html

<br>Option name. Possible values: <dl> <dt>"free_space_realloc" (value: "on" | "off" | "no_redirect")</dt> <dd> Setting this option to "on" enables free space reallocation (continuous segment cleaning) on a block checksum aggregate. Possible values : on, off, no_redirect "on" : Free space reallocation enabled with automatically starting the redirect scanner "off": Free space reallocate disabled "no_redirect": Free space reallocation enabled without running the redirect scanner The default value for this option is "off" </dd><br> <dt>"fs_size_fixed" (value: "on" | "off")</dt> <dd> Setting this option to "on" causes the file system to remain the same size (and not grow) when the mirror is broken on a SnapMirrored aggregate (which MUST be embedded in a traditional volume), or when an "aggr add" is performed on it. This option is automatically set to be "on" when an aggregate becomes SnapMirrored. It remains "on" after the "snapmirror break" command is issued for an aggregate embedded in a traditional volume. This option allows an embedded aggregate to be SnapMirrored back to the source without needing to add disks to the source aggregate. If the aggregate size is larger than the file system size, turning off this option forces the file system to grow to the size of the aggregate. This option is not supported when the request is sent to the Admin Vserver LIF. </dd><br> <dt>"ha_policy" (value: "cfo" | "sfo")</dt> <dd> This option is used to change the HA policy of given aggregate and restricted to clustered environments. It is not allowed in unclustered environments. Also this option does not apply to traditional volume. Changing the HA policy of an aggregate from SFO to CFO is allowed only in Maintenance mode. HA policy can not be changed if: 1. aggregate is striped. 2. aggregate contains node volumes. 3. aggregate is root. 4. aggregate is partner aggregate during takeover i.e. when it is not home to local node. EOP_CLUSTER_ATTR_DISALLOWED is returned if this option is used in unclustered environments. EOP_DISALLOWED_ON_STRIPED_AGGR is returned if this option is used with striped aggregate. EOP_DISALLOWED_ON_AGGR_WITH_NODE_VOLS is returned if this option is used on aggregate which contains node volumes. EOP_DISALLOWED_ON_ROOT_AGGR is returned if this option is used on root aggregate. EOP_DISALLOWED_ON_NOT_HOME_AGGR is returned if this option is used on partner aggregate during takeover. </dd><br> <dt>"ignore_inconsistent" (value: "on" | "off")</dt> <dd> This command can only be used in maintenance mode. If this option is set to "on", then the root aggregate may be brought online when booting even if it is marked as inconsistent. The user is cautioned that bringing it online prior to running WAFL_check or wafliron may result in further file system inconsistency. This option is not supported when the request is sent to the Admin Vserver LIF. </dd><br> <dt>"lost_write_protect" (value: "on" | "off")</dt> <dd> Setting this option to "off" disables lost write protection on the aggregate. The default is "on". The user is cautioned that turning off this option may expose the filesystem(s) contained in the aggregate to data loss and data corruption. This option should not be disabled, unless directed to do so by support personnel. </dd><br> <dt>"max_write_alloc_blocks" (value: value: &lt number &gt)</dt> <dd> The maximum number of blocks used for write allocation. Some sequential read workloads may benefit from increasing this value. Default value is 0 which uses the controller-wide default value of 64. The default is optimal for most users. The controller-wide default can be adjusted with the bootarg "wafl-max-write-alloc-blocks" </dd><br> <dt>"striping" (value: "striped" | "not_striped")</dt> <dd> This option sets the striping information of given aggregate. It is restricted to clustered environments and not allowed in unclustered environments. When set to true, it marks given aggregate as member of stripe. This option is not allowed if given aggregate is of 'cfo' HA policy. Also this option does not apply to traditional volume. EOP_CLUSTER_ATTR_DISALLOWED is returned if this option is used in unclustered environments. EOP_DISALLOWED_ON_CFO_AGGR is returned if given aggregate is of 'cfo' HA policy. This option is not supported when the request is sent to the Admin Vserver LIF. </dd><br> <dt>"nosnap" (value: "on" | "off")</dt> <dd> Setting this option to "on" disables automatic snapshots on the aggregate. </dd><br> <dt>"raid_cv" (value: "on" | "off")</dt> <dd> Setting this option to "off" disables block or advanced_zoned checksum (azcs) protection on the aggregate. The default is "on". The user is cautioned that turning off this option exposes the filesystems contained in the aggregate to inconsistency that could be caused by a misbehaving hardware component in the system. </dd><br> <dt>"raid_lost_write" (value: "on" | "off")</dt> <dd> Setting this option to "off" disables RAID Lost Write protection on the aggregate. The default is "on". The user is cautioned that turning off this option may expose the filesystem(s) contained in the aggregate to data loss and data corruption. The option should not be disabled, unless directed to do so by support personnel. </dd><br> <dt>"raid_zoned" (value: "on" | "off")</dt> <dd> Setting this option to "off" disables zoned checksum protection on the aggregate. The default is "on". The user is cautioned that turning off this option exposes the filesystems contained in the aggregate to inconsistency that could be caused by a misbehaving hardware component in the system. </dd><br> <dt>"raidsize" (value: &lt number &gt>)</dt> <dd> The maximum size of a RAID group within the aggregate. Changing this option doesn't cause existing RAID groups to grow or shrink. Rather, it only affects whether more disks will be added to the last existing RAID group in the future, and how large new RAID groups will be. </dd><br> <dt>"cache_raid_group_size" (value: &lt number &gt>)</dt> <dd> The current maximum size of a SSD RAID group within the hybrid aggregate. This option can only be modified for hybrid aggregate. Changing this option doesn't cause existing RAID groups to grow or shrink. Rather, it only affects whether more disks will be added to the existing SSD RAID group in the future, and how large new SSD RAID groups will be. </dd><br> <dt>"raidtype" (value: "raid4" | "raid_dp" | "raid0")</dt> <dd> The type of RAID group used for this aggregate. The "raid4" setting provides one parity disk per RAID group, while "raid_dp" provides two. Changing this option immediately changes the RAID group type for all RAID groups in the aggregate. When upgrading RAID groups from "raid4" to "raid_dp", each RAID group begins a reconstruction onto a spare disk allocated for the second "dparity" parity disk. </dd><br> <dt>"resyncsnaptime" (value: &lt number &gt)</dt> <dd> Sets the mirror resynchronization snapshot frequency to be the given number of minutes. The default value is 60 (minutes). </dd><br> <dt>"root" (value: &lt none &gt)</dt> <dd> The specified aggregate is to become the root aggregate for the filer on the next reboot. This option can be used only in maintenance mode and on only one aggregate at any given time. The existing root aggregate will become a non-root aggregate after the reboot. Until the system is rebooted, the original aggregate will continue to show root as an option, and the new root aggregate will show diskroot as an option. In general, the aggregate that has the diskroot option is the one that becomes the root aggregate following the next reboot. The only way to remove the root status of an aggregate is to set it on another aggregate. In clustered environments, this option is not allowed with aggregates with 'sfo' HA policy as root has to be an aggregate with 'cfo' HA policy. EOP_DISALLOWED_ON_SFO_AGGR is returned if given aggregate is of 'sfo' HA policy. </dd><br> <dt>"snapmirrored" (value : "off")</dt> <dd> If SnapMirror is enabled, the filer auto- matically sets this option to "on". Set this option to "off" with the "snapmirror" command if SnapMirror should no longer be used to update the mirror. After setting this option to "off", the mirror becomes a regular writable aggregate, and all its volumes are restored to whatever state they were last in. Note that it is not possible to set this option directly through this interface. Rather, it is automatically changed as a side effect of running the appropriate "snapmirror" commands. This option is not supported when the request is sent to the Admin Vserver LIF. </dd><br> <dt>"snapshot_autodelete" (value: "on" | "off")</dt> <dd> Setting this option to "off" disables automatic snapshot deletion on the aggregate. </dd><br> <dt>"thorough_scrub" (value: "on" | "off")</dt> <dd> Setting this option to "on" enables thorough scrub on a block checksum aggregate. That means that a scrub will initialize any zeroed checksum entries that it finds. If there are any checksum entries to be initialized, scrub will run slower than normal. </dd><br> <dt>"percent_snapshot_space" (value: &lt number &gt)</dt> <dd> Percentage of total blocks in the aggregate reserved for snapshots. </dd><br> <dt>"hybrid_enabled" (value: "true" | "false")</dt> <dd> Setting this option to "true" would mark the aggregate as hybrid_enabled. That means the aggregate can contain a mix of SSDs and HDDs(Hard Disk Drives, e.g., SAS, SATA, and/or FC). The operation can be forced by using the hybrid_enabled_force option for the aggregates having flexvols which cannot be write cached. EAGGR_CANT_UNDO_HYBRID is returned when we are trying to set the option hybrid_enabled to false on an aggregate that already contains a mix of HDDs and SSDs. EAGGR_HYBRID is returned when we are trying to set option hybrid_enabled to true on an aggregate which is already hybrid. EOP_DISALLOWED_WORM_HYBRID_AGGR is returned when we are trying to set option hybrid_enabled to true on an snaplock aggregate. ERAID_HYA_SUPPORT_DISABLED is returned when the partner node in HA pair is running a version of Data ONTAP which does not support hybrid aggregates. EOP_DISALLOWED_ON_SSD_AGGR is returned if this option is used on aggregates created out of SSD disks. EOP_DISALLOWED_HYA_ON_RAID0_AGGR is returned if this option is used on raid0 aggregates. EOP_DISALLOWED_HYA_ON_ZONED_AGGR is returned if this option is used on aggregates with zoned checksums. EOP_DISALLOWED_HYA_ON_LUNS_AGGR is returned if this option used on aggregates created out of LUNs. </dd><br> <dt>"hybrid_enabled_force" (value: "true" | "false")</dt> <dd> Setting this option to "true" would mark the aggregate as hybrid_enabled. That means the aggregate can contain a mix of SSDs and HDDs(Hard Disk Drives, e.g., SAS, SATA, and/or FC). This option is used for force marking of aggregates having flexvols which cannot be write cached as hybrid enabled. FlexVols in the aggregate marked as hybrid enabled using this option which cannot participate in write-caching only have read-caching enabled. All other flexvols in the aggregate can participate in both read and write caching. EAGGR_CANT_UNDO_HYBRID is returned when we are trying to set the option hybrid_enabled_force to false on an aggregate that already contains a mix of HDDs and SSDs. EAGGR_HYBRID is returned when we are trying to set option hybrid_enabled_force to true on an aggregate which is already hybrid. EOP_DISALLOWED_WORM_HYBRID_AGGR is returned when we are trying to set option hybrid_enabled_force to true on an snaplock aggregate. ERAID_HYA_SUPPORT_DISABLED is returned when the partner node in HA pair is running a version of Data ONTAP which does not support hybrid aggregates. EOP_DISALLOWED_ON_SSD_AGGR is returned if this option is used on aggregates created out of SSD disks. EOP_DISALLOWED_HYA_ON_RAID0_AGGR is returned if this option is used on raid0 aggregates. EOP_DISALLOWED_HYA_ON_ZONED_AGGR is returned if this option is used on aggregates with zoned checksums. </dd><br> </dl>

=end html

=back



=over 2

=item * I<option-value>  =>   B<string>

=begin html

<br>The value to set the named option. It may be the NULL/empty value only in the case of the "root" option.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 aggr_space_list_info

[B<Family:> ontap-classic]


=begin html

Show the space usage of the aggregate on a per flexible volume basis. This API is deprecated in Data ONTAP 8.2 and later. Use the aggr-space-info attributes in the aggr-list-info API for details related to aggregate space usage. Use volume-space-list-info and volume-footprint-list-info APIs for details related to volume space usage.

=end html



B<Inputs>

=over 2

=item * I<aggregate>  =>   B<string, optional>

=begin html

<br>The aggregate to get the space information for. If not specified the space information for all aggregates is obtained.

=end html

=back



B<Outputs>

=over 2

=item * I<aggregates>  =>   B<L<"aggr-space-info">[]>

=begin html

<br>Various counts describing space usage in the aggregate.

=end html

=back



=head2 aggr_split

[B<Family:> ontap-classic]


=begin html

Remove the specified plex from a mirrored aggregate and create a new unmirrored aggregate with the specified name that contains the plex. The original mirrored aggregate thus becomes unmirrored. The plex to be split from the original aggregate must be functional (not partial), but it can otherwise be inactive, resyncing, or out-of-date. "Aggr split" can therefore be used to gain access to a plex that isn't up to date with respect to its partner plex if its partner plex is currently failed. If the plex is offline at the time of the split, the resulting aggregate will be offline. Otherwise, the resulting aggregate will be in the same online/offline/restricted state as the original aggregate. A split mirror can be joined back together via the "victim-aggregate" option to "aggr-mirror".

=end html



B<Inputs>

=over 2

=item * I<aggregate>  =>   B<string>

=begin html

<br>Name of the plex to split out of its aggregate, using the following format: [/vol/]<aggrname>[<plexinfo>][<groupinfo>]

=end html

=back



=over 2

=item * I<new-aggr-name>  =>   B<string>

=begin html

<br>Name of the new aggregate to create from the split plex.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 aggr_verify_list_info

[B<Family:> ontap-classic]


=begin html

Get the status of RAID mirror verification on the named aggregate. Status includes percentage complete and whether it's currently suspended.

=end html



B<Inputs>

=over 2

=item * I<aggregate>  =>   B<string, optional>

=begin html

<br>Name of an existing aggregate. If no name is given, then mirror verification status is generated for all aggregates currently being verified. UUID can be specified instead of aggregate name. See the synopsis for name/UUID format and restrictions.

=end html

=back



B<Outputs>

=over 2

=item * I<verify-details>  =>   B<L<"verify-detail-info">[], optional>

=begin html

<br>List of aggregates and their mirror verification status.

=end html

=back



=head2 aggr_verify_resume

[B<Family:> ontap-classic]


=begin html

Resume RAID mirror verification on the named aggregate. If no name is given, then resume mirror verification on all aggregates that have been suspended.

=end html



B<Inputs>

=over 2

=item * I<aggregate>  =>   B<string, optional>

=begin html

<br>Name of the existing aggregate for which mirror verification is to resume. UUID can be specified instead of aggregate name. See the synopsis for name/UUID format and restrictions.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 aggr_verify_start

[B<Family:> ontap-classic]


=begin html

Start RAID mirror verification on the named aggregate. Verification compares the data in both plexes of a mirrored aggregate. In the default case, any blocks that differ are logged and no changes are made. The fix-plex option is used to fix any mismatches. It specifies which plex to fix. If no name is given, then mirror verification is started on all online aggregates. Use the "aggr-verify-list-info" API to check mirror verification status. If the fix-plex option is used, then a name must be specified.

=end html



B<Inputs>

=over 2

=item * I<aggregate>  =>   B<string, optional>

=begin html

<br>Name of the mirrored aggregate to verify. UUID can be specified instead of aggregate name. See the synopsis for name/UUID format and restrictions.

=end html

=back



=over 2

=item * I<fix-plex>  =>   B<integer, optional>

=begin html

<br>If provided, this specifies the plex to fix in case the two plexes do not match. The default is to log any discrepancies instead of fixing them.

=end html

=back



=over 2

=item * I<log-only>  =>   B<boolean, optional>

=begin html

<br>If provided, and if the value is "true", then simply log any discrepancies instead of fixing them. The default value is "true". If log-only is "false", then the fix-plex option must also be specified. If log-only is "true" and fix-plex is also specified, then the log-only option will be ignored.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 aggr_verify_stop

[B<Family:> ontap-classic]


=begin html

Stop RAID mirror verification on the named aggregate. If no name is given, stop mirror verification on all aggregates currently being verified.

=end html



B<Inputs>

=over 2

=item * I<aggregate>  =>   B<string, optional>

=begin html

<br>Name of the aggregate for which we are to stop mirror verification. UUID can be specified instead of aggregate name. See the synopsis for name/UUID format and restrictions.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 aggr_verify_suspend

[B<Family:> ontap-classic]


=begin html

Suspend RAID mirror verification on the named aggregate. If no name is given, suspend mirror verification on all aggregates currently being verified.

=end html



B<Inputs>

=over 2

=item * I<aggregate>  =>   B<string, optional>

=begin html

<br>Name of the aggregate for which we are to suspend mirror verification. UUID can be specified instead of aggregate name. See the synopsis for name/UUID format and restrictions.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 cf_force_takeover

[B<Family:> ontap-classic]


=begin html

Forces one filer to take over its partner even though the filer detects an error that would otherwise prevent a takeover. For example, normally, if a detached or faulty interconnect cable between the filers causes the filers' NVRAM contents to be unsynchronized, takeover is disabled. However, this will allow the filer to take over its partner despite the unsynchronized NVRAM contents. cf-force-takeover is dangerous and can lead to data corruption; in almost all cases, use cf-takeover instead.

=end html



B<Inputs>

=over 2

=item * I<disaster>  =>   B<boolean, optional>

=begin html

<br>When set to true, forces a filer to take over its partner in all cases where a force-takeover would. In addition it will force a takeover even if some partner mailbox disks are inaccessible. It can only be used when remotesyncmirror is licensed. This option is very dangerous. Not only can it cause data corruption, if not used carefully, it can also lead to a situation where both the filer and it's partner are operational (split brain). As such, it should only be used as a means of last resort when the takeover and force-takeover operations are unsuccessful in achieving a takeover. The operator must ensure that the partner filer does not become operational at any time while a filer is in a takeover mode initiated by the use of this operation. In conjunction with RAID mirroring, it can allow recovery from a disaster when the two filers are setup in a MetroCluster configuration.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 cf_get_partner

[B<Family:> ontap-classic, vfiler]


=begin html

Get the host name of the partner. If the name is unknown, It will return partner-unknown.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<partner>  =>   B<string>

=begin html

<br>Host name of the partner or partner-unknown, if the host name is not known.

=end html

=back



=head2 cf_giveback

[B<Family:> ontap-classic]


=begin html

Initiates a giveback of partner resources. Once the giveback is complete, the automatic takeover capability is disabled until the partner is rebooted. A giveback fails if outstanding CIFS sessions, active system dump processes, or other filer operations makes a giveback dangerous or disruptive.

=end html



B<Inputs>

=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>When set to true, this allows a giveback to proceed even if there are outstanding CIFS sessions, active system dump processes, or other filer operations which makes a giveback dangerous or disruptive as long as it would not result in data corruption or filer error. When set to false, this does not allow a giveback to proceed if there are outstanding CIFS sessions, active system dump processes, or other filer operations which makes a giveback dangerous or disruptive. The default value is false.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 cf_hwassist_stats

[B<Family:> ontap-classic]


=begin html

Get useful information about statistics of hardware assisted takeover functionality.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<hwassist-stats-abnormal-reboot>  =>   B<string, optional>

=begin html

<br>Number of abnormal_reboot alerts received

=end html

=back



=over 2

=item * I<hwassist-stats-bad-nvram-id>  =>   B<string, optional>

=begin html

<br>Number of bad NVRAM id alerts received

=end html

=back



=over 2

=item * I<hwassist-stats-keep-alive>  =>   B<string, optional>

=begin html

<br>Number of keep_alive alerts received

=end html

=back



=over 2

=item * I<hwassist-stats-loss-of-heartbeat>  =>   B<string, optional>

=begin html

<br>Number of loss_of_heartbeat alerts received

=end html

=back



=over 2

=item * I<hwassist-stats-post-error>  =>   B<string, optional>

=begin html

<br>Number of post_error alerts received

=end html

=back



=over 2

=item * I<hwassist-stats-power-cycle-via-rlm>  =>   B<string, optional>

=begin html

<br>Number of power_cycle_via_rlm alerts received

=end html

=back



=over 2

=item * I<hwassist-stats-power-cycle-via-sp>  =>   B<string, optional>

=begin html

<br>Number of power_cycle_via_sp alerts received

=end html

=back



=over 2

=item * I<hwassist-stats-power-loss>  =>   B<string, optional>

=begin html

<br>Number of power_loss alerts received

=end html

=back



=over 2

=item * I<hwassist-stats-power-off-via-rlm>  =>   B<string, optional>

=begin html

<br>Number of power_off_via_rlm alerts received

=end html

=back



=over 2

=item * I<hwassist-stats-power-off-via-sp>  =>   B<string, optional>

=begin html

<br>Number of power off alerts received from service processor (power_off_via_sp alert).

=end html

=back



=over 2

=item * I<hwassist-stats-reset-via-rlm>  =>   B<string, optional>

=begin html

<br>Number of reset_via_rlm alerts received

=end html

=back



=over 2

=item * I<hwassist-stats-reset-via-sp>  =>   B<string, optional>

=begin html

<br>Number of reset_via_sp alerts received

=end html

=back



=over 2

=item * I<hwassist-stats-ss-mismatch>  =>   B<string, optional>

=begin html

<br>Number of shared secret key mismatch alerts received

=end html

=back



=over 2

=item * I<hwassist-stats-test>  =>   B<string, optional>

=begin html

<br>Number of test alerts received

=end html

=back



=over 2

=item * I<hwassist-stats-times-throttled>  =>   B<string, optional>

=begin html

<br>Number of times hardware assist alerts were throttled. Alerts are throttled when too many are received in a short interval.

=end html

=back



=over 2

=item * I<hwassist-stats-unknown-alerts>  =>   B<string, optional>

=begin html

<br>Number of unknown alerts received

=end html

=back



=over 2

=item * I<hwassist-stats-watchdog-reset>  =>   B<string, optional>

=begin html

<br>Number of l2_watchdog_reset alerts received

=end html

=back



=over 2

=item * I<no-stats>  =>   B<string, optional>

=begin html

<br>If no hardware assist statistics are available, this is set to "Cannot determine hwassist stats".

=end html

=back



=head2 cf_hwassist_status

[B<Family:> ontap-classic]


=begin html

Get useful information about the status of hw_assist functionality.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<keep-alive-status>  =>   B<string>

=begin html

<br>Possible values are: <ul> <li>healthy <li>missed_keep_alive_alerts </ul>

=end html

=back



=over 2

=item * I<local-hwassist-inactive-corrective-action>  =>   B<string, optional>

=begin html

<br>Indicates the corrective action if status is inactive.

=end html

=back



=over 2

=item * I<local-hwassist-inactive-reason>  =>   B<string, optional>

=begin html

<br>Indicates the reason if status is inactive.

=end html

=back



=over 2

=item * I<local-hwassist-ipaddr>  =>   B<string, optional>

=begin html

<br>If set, Ip address; 0.0.0.0 otherwise

=end html

=back



=over 2

=item * I<local-hwassist-port>  =>   B<integer, optional>

=begin html

<br>If set, port; 0 otherwise

=end html

=back



=over 2

=item * I<local-hwassist-status>  =>   B<string, optional>

=begin html

<br>Local node hw_assist status <p> Possible values are: <ul> <li>active: If functionality is active. <li>inactive: If functionality is inactive </ul>

=end html

=back



=over 2

=item * I<no-status>  =>   B<string, optional>

=begin html

<br>Set if no hw_assist status is avaliable. Either this or the remaining fields will be set,hence they are optional.

=end html

=back



=over 2

=item * I<partner-hwassist-inactive-corrective-action>  =>   B<string, optional>

=begin html

<br>Indicates the corrective action if status is inactive.

=end html

=back



=over 2

=item * I<partner-hwassist-inactive-reason>  =>   B<string, optional>

=begin html

<br>Indicates the reason if status is inactive.

=end html

=back



=over 2

=item * I<partner-hwassist-ipaddr>  =>   B<string, optional>

=begin html

<br>If set, Ip address, 0.0.0.0 otherwise

=end html

=back



=over 2

=item * I<partner-hwassist-port>  =>   B<integer, optional>

=begin html

<br>If set, current port, 0 otherwise

=end html

=back



=over 2

=item * I<partner-hwassist-status>  =>   B<string, optional>

=begin html

<br>partner node hw_assist status <p> Possible values are: <ul> <li>active: If functionality is active. <li>inactive: If functionality is inactive </ul>

=end html

=back



=head2 cf_negotiated_failover_disable

[B<Family:> ontap-classic]


=begin html

Disables negotiated failover. disk_shelf is the negotiated failover module currently supported.

=end html



B<Inputs>

=over 2

=item * I<module>  =>   B<string>

=begin html

<br>Module currently supported is 'disk_shelf'.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 cf_negotiated_failover_enable

[B<Family:> ontap-classic]


=begin html

Enables negotiated failover. disk_shelf is the negotiated failover module currently supported.

=end html



B<Inputs>

=over 2

=item * I<module>  =>   B<string>

=begin html

<br>Module currently supported is 'disk_shelf'.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 cf_negotiated_failover_status

[B<Family:> ontap-classic]


=begin html

Returns the status of the negotiated failover module. Negotiated failover is a general facility which supports negotiated failover on the basis of decisions made by various modules.

=end html



B<Inputs>

=over 2

=item * I<module>  =>   B<string>

=begin html

<br>Module currently supported is 'disk_shelf'

=end html

=back



B<Outputs>

=over 2

=item * I<is-enabled>  =>   B<boolean>

=begin html

<br>True, if clusterfailover for this module is enabled, false otherwise.

=end html

=back



=head2 cf_service_disable

[B<Family:> ontap-classic]


=begin html

Disables the takeover capability of this filer in the cluster.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 cf_service_enable

[B<Family:> ontap-classic]


=begin html

Enables the takeover capability of this filer in the cluster. This spawns a process to enable the service

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 cf_status

[B<Family:> ontap-classic, vfiler]


=begin html

Get useful information about the status of the high availability service. If the monitor is not initialized, this returns an error.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<current-mode>  =>   B<string>

=begin html

<br>Current HA mode

=end html

=back



=over 2

=item * I<current-time>  =>   B<integer>

=begin html

<br>Current time on the filer

=end html

=back



=over 2

=item * I<is-enabled>  =>   B<boolean>

=begin html

<br>True, if the storage failover facility is enabled, false otherwise. Note that the facility can be enabled but takeover may not be possible due to various reason.

=end html

=back



=over 2

=item * I<is-interconnect-up>  =>   B<boolean>

=begin html

<br>True, if high availability interconnect is up

=end html

=back



=over 2

=item * I<local-in-headswap>  =>   B<boolean, optional>

=begin html

<br>True, if the local node is being replaced by a new node.

=end html

=back



=over 2

=item * I<new-partner-sysid>  =>   B<integer, optional>

=begin html

<br>The new partner system ID recieved via HA interconnect. The value is zero if partner is not in headswap.

=end html

=back



=over 2

=item * I<node-state>  =>   B<string, optional>

=begin html

<br>State of the storage failover of the node. Possible values are: <ul> <li>connected - Partner is available for takeover</li> <li>takeover_scheduled - Partner is down and takeover is scheduled</li> <li>takeover_started - Takeover process has begun</li> <li>takeover - Currently controlling partner's resources.</li> <li>takeover_failed - Failed to takeover the partner</li> <li>giveback_partial_waiting - This node controls partner aggregates even though the node is not in takeover. And we're waiting for a connection to the partner.</li> <li>giveback_partial_connected - This node controls partner aggregates even though the node is not in takeover. The partner is available to receive the aggregates.</li> <li>waiting_for_root_aggr - Partner is controlling dblade's root aggregate If we're in this state, many other optional fields are not returned.</li> <li>waiting - Waiting for a connection to partner. Generally happens while partner is rebooting.</li> <li>in_maintenance_mode - node is in maintenance mode. In the mode it is not possible to determine more detailed information (e.g. cluster or not; takeover or not, etc).</li> <li>pending_shutdown - starting a takeover/giveback is inhibited due to a pending system shutdown.</li> <li>relocating_aggrs_before_takeover - node is relocating its SFO aggregates to its partner prior to a negotiated takeover.</li> <li>sfo_takeover_phase_done - Node is done with the SFO phase of takeover.</li> <li>sfo_takenover_phase_done - This node has relocated its SFO aggregates to its partner during an optimized negotiated takeover by its partner.</li> <li>sfo_takeover_phase_aborted - The SFO phase of takeover has been aborted. Refer to takeover-failure-reason field to check the reason.</li> <li>sfo_takenover_phase_aborted - This node has aborted the relocation of its SFO aggregates to its partner, during an optimized negotiated takeover by its partner.</li> <li>in_non_HA_mode - Node is not in HA mode</li> <li>cfo_takeover_failed - CFO phase of takeover failed</li> <li>sfo_takeover_in_progress - SFO phase of takeover of partner is in progress</li> <li>relocated_aggrs_before_takeover - node has relocated its SFO aggregates to its partner prior to a negotiated takeover.</li> <li>giveback_in_progress - Giveback is in progress. Refer to current-giveback-module field to get the current module, the giveback process is in.</li> <li>giveback_failed_autogiveback_disabled - Previous giveback failed and auto giveback is disabled. Refer to current-giveback-module to get the module in which giveback process failed.</li> <li>giveback_failed_autogiveback_scheduled - Previous giveback failed and an auto giveback is scheduled. Refer to current-giveback-module to get the module in which giveback process failed.</li> Refer to time-until-autogiveback field to check time remaining before an auto giveback is initiated.</li> <li>previous_giveback_failed - Previous giveback failed. Refer to current-giveback-module to get the module in which giveback process failed.</li> <li>takeover_no_di - Local node is in takeover. A normal giveback is not possible as disk inventory from partner has not yet been received.</li> <li>takeover_partner_missing_disks - Local node is in takeover. A normal giveback is not possible as the patner is missing some of its file system disks.</li> <li>takeover_autogiveback_scheduled - Local node in takeover. An auto giveback is scheduled. Refer time-until-autogiveback field to check time remaining before an auto giveback is initiated.</li> <li>takeover_network_failure - Local node in takeover. The partner was taken over due to network failure.</li> <li>takeover_autogiveback_deferred - Local node in takeover. Auto giveback is deferred because the partner node was not ready to receive aggregates when the auto giveback timer expired. An auto giveback will be initiated as soon as the partner node is up and ready to receive aggregates.</li> <li>automatic_takeover_disabled_connected - Automatic takeover is disabled. Local node is connected to partner via HA interconnect. This happens only in debug builds when raid.panic.missing.disks is turned on from node CLI.</li> <li>automatic_takeover_disabled_waiting - Automatic takeover is disabled. Local node is waiting for partner node on HA interconnect. This happens only in debug builds when raid.panic.missing.disks is turned on from node CLI.</li> <li>ndo_upgrade_in_progress - Local node owns partner's aggregates as part of node upgrade process.</li> <li>own_aggr_non_local_connected - Local node owns aggregates of some other node in the cluster. Local node is connected to partner via HA interconnect. This is possible only during NDO double hop head upgrade.</li> <li>own_aggr_non_local_waiting - Local node owns aggregates of some other node in the cluster. Local node is waiting for partner on HA interconnect. This is possible only during NDO double hop head upgrade.</li> <li>clusterwait_connected - Connected to partner via HA interconnect. Local node waiting for cluster applications to come online.</li> <li>clusterwait_waiting - Waiting for partner on HA interconnect. Local node waiting for cluster applications to come online.</li> <li>error - There is an error with the system</li> </ul> User have to compare the return values case-insensitively.

=end html

=back



=over 2

=item * I<partner>  =>   B<string>

=begin html

<br>Hostname of the partner. If the partner is unknown, returns an empty string. This is for 7G like output compatibility.

=end html

=back



=over 2

=item * I<partner-in-headswap>  =>   B<boolean, optional>

=begin html

<br>True, if partner node is being replaced by a new node.

=end html

=back



=over 2

=item * I<state>  =>   B<string, optional>

=begin html

<br>connected - Partner is available for takeover takeover_scheduled - Partner is down and takeover is scheduled takeover_started - Takeover process has begun takeover - Currently controlling partner's resources. taken over - Partner is controlling filer's resources takeover_failed - Failed to takeover the partner sfo_takeover_phase - This node has asked its partner to relocate its SFO aggregates in preparation for takeover. This occurs when a user has initiated an optimized negotiated takeover. relocating_aggrs_before_takeover - This node is relocating its SFO aggregates to its partner during an optimized negotiated takeover by its partner. sfo_takeover_phase_done - This node is done with the SFO phase of an optimized negotiated takeover. sfo_takenover_phase_done - This node has relocated its SFO aggregates to its partner during an optimized negotiated takeover by its partner. sfo_takeover_phase_aborted - The SFO phase of takeover is aborted on this node during an optimized negotiated takeover of its partner. sfo_takenover_phase_aborted - This node has aborted the relocation of its SFO aggregates to its partner, during an optimized negotiated takeover by its partner. giving_back - Sendhome process in progress giveback_partial_waiting - This node controls partner aggregates even though the node is not in takeover. And we're waiting for a connection to the partner. giveback_partial_connected - This node controls partner aggregates even though the node is not in takeover. The partner is available to receive the aggregates. waiting_for_root_aggr - Partner is controlling dblade's root aggregate If we're in this state, many other optional fields are not returned. waiting - Waiting for a connection to partner. Generally happens while partner is rebooting. in_maintenance_mode - node is in maintenance mode. In the mode it is not possible to determine more detailed information (e.g. cluster or not; takeover or not, etc). pending_shutdown - starting a takeover/sendhome is inhibited due to a pending system shutdown. error - There is an error with the system User have to compare the return values case-insensitively.

=end html

=back



=over 2

=item * I<takeover-failure-reason>  =>   B<string, optional>

=begin html

<br>if state == takeover_failed, this is the reason for the takeover failure

=end html

=back



=over 2

=item * I<time-until-takeover>  =>   B<integer, optional>

=begin html

<br>if state == takeover_scheduled, this is the countdown time in seconds until state == takeover_started.

=end html

=back



=head2 cf_takeover

[B<Family:> ontap-classic]


=begin html

Initiates a takeover of the storage partner. Takeover is done asynchronously; status may be monitored by calling the cf-status API and examining the state field. If automatic giveback is enabled then control will be returned to storage partner once it boots up.

=end html



B<Inputs>

=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>In Classic mode: This causes takeover to be immediately initiated. The taken over node, if up, does not get to shut things down in an orderly manner so the takeover of the resources takes longer. This is the type of takeover that is done during normal cluster operation when one of the nodes goes away (dies). In Cluster mode: It forces a node to take over its storage partner even though the node detects an error that would otherwise prevent a takeover. For example, normally, if a detached or faulty interconnect cable between the nodes(ha pair) causes the nodes NVRAM contents to be unsynchronized, takeover is disabled. However, this will allow the node to take over its storage partner despite the unsynchronized NVRAM contents. cf-force-takeover is dangerous and can lead to data corruption; in almost all cases, use cf-takeover instead.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 cg_commit

[B<Family:> ontap-classic, vfiler]


=begin html

Commits the snapshots that were started during the preceeding cg-start call that returned the cg-id key, and unfences the volumes that were fenced. If cg-commit API times out, then it means that either too many volumes were specified to the cg-start api or the timeout value for the cg-start api was very small. In this situation, the caller should try to perform the cg-start operation by specifying lesser volumes or by specifying higher timeout value.

=end html



B<Inputs>

=over 2

=item * I<cg-id>  =>   B<integer>

=begin html

<br>Key to identify the ongoing cg operation.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 cg_delete

[B<Family:> ontap-classic]


=begin html

Deletes the snaps associated with a CG checkpoint in this filer. This API is deprecated as of Data ONTAP 8.2. Applications using this API should transition to snapshot-multidelete API as appropriate.

=end html



B<Inputs>

=over 2

=item * I<snapshot>  =>   B<string>

=begin html

<br>The name of the snapshot that is deleted in each volume.

=end html

=back



=over 2

=item * I<volumes>  =>   B<volume-name[]>

=begin html

<br>A list of volumes in this filer that is part of this CG operation.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 cg_start

[B<Family:> ontap-classic, vfiler]


=begin html

Starts the checkpoint cycle for externally synchronized checkpoints in the filer. This operation fences the specified volumes and returns "success" (if successful). If the API returns "success", the call starts a snapshot create operation in these volumes. If the API returns "success", this operation SHOULD be followed by a call to cg-commit (below). <p> This API is not supported on Infinite Volume.

=end html



B<Inputs>

=over 2

=item * I<snapshot>  =>   B<string>

=begin html

<br>The provided name of the snapshot that is created in each volume. This name is the unique identifier by which the calling agent identifies the snapshots that constitute a checkpoint. The maximum length is 255 characters. (= MAXNAMLEN)

=end html

=back



=over 2

=item * I<timeout>  =>   B<string, optional>

=begin html

<br>Timeout selector. Possible vaules are "urgent", "medium" or "relaxed". If no value is specified, the default value is "medium". Following are the timeout values: <p> <dl> <dt><dd>"urgent" : 5 seconds </dd><br></dt> <dt><dd>"medium" : 7 seconds </dd><br></dt> <dt><dd>"relaxed" : 20 seconds </dd><br></dt> </dl> </p>

=end html

=back



=over 2

=item * I<volumes>  =>   B<volume-name[]>

=begin html

<br>A list of volumes in this filer that is part of this CG operation.

=end html

=back



B<Outputs>

=over 2

=item * I<cg-id>  =>   B<integer>

=begin html

<br>Identifier of the started cg-start operation. This identifier is used in the succeeding cg-commit call to identify the operation to be commited.

=end html

=back



=head2 cifs_branchcache_hash_stat

[B<Family:> ontap-classic, vfiler]


=begin html

Display the CIFS BranchCache statistics

=end html



B<Inputs>

=over 2

=item * I<include-filesize-stats>  =>   B<boolean, optional>

=begin html

<br>If true, it shows BranchCache hash stats of file sizes for which hashes were requested for. File sizes are <10K, 11K-100K, 101K-250K, 251K-1M, 1.1M-10M, 11M-100M, >100M. The default value of this is false.

=end html

=back



=over 2

=item * I<include-flush-stats>  =>   B<boolean, optional>

=begin html

<br>If true, returns BranchCache hash stats like how many hashes were flushed in multiples of BranchCache hash timeout duration. The default value of this field is false.

=end html

=back



B<Outputs>

=over 2

=item * I<filesize-more-than-100mb>  =>   B<integer, optional>

=begin html

<br>Number of files of size more than 100mb.

=end html

=back



=over 2

=item * I<filesize-range-0kb-to-10kb>  =>   B<integer, optional>

=begin html

<br>Number of files of size less than equal to 10k for which hashes were asked for.

=end html

=back



=over 2

=item * I<filesize-range-100kb-to-250kb>  =>   B<integer, optional>

=begin html

<br>Number of files of size more than 100kb and less than equal to 250kb for which hashes were asked for.

=end html

=back



=over 2

=item * I<filesize-range-10kb-to-100kb>  =>   B<integer, optional>

=begin html

<br>Number of files of size more than 10kb and less than equal to 100kb for which hashes were asked for.

=end html

=back



=over 2

=item * I<filesize-range-10mb-to-100mb>  =>   B<integer, optional>

=begin html

<br>Number of files of size more than 10mb and less than equal to 100mb for which hashes were asked for.

=end html

=back



=over 2

=item * I<filesize-range-1mb-to-10mb>  =>   B<integer, optional>

=begin html

<br>Number of files of size more than 1mb and less than equal to 10mb for which hashes were asked for.

=end html

=back



=over 2

=item * I<filesize-range-250kb-to-1mb>  =>   B<integer, optional>

=begin html

<br>Number of files of size more than 250kb and less than equal to 1mb for which hashes were asked for.

=end html

=back



=over 2

=item * I<hashes-flashed-post-fifth-timeout>  =>   B<integer, optional>

=begin html

<br>Number of hashes flushed after fifth timeout.

=end html

=back



=over 2

=item * I<hashes-flashed-post-first-timeout>  =>   B<integer, optional>

=begin html

<br>Number of hashes flushed in between first and second timeout.

=end html

=back



=over 2

=item * I<hashes-flashed-post-fourth-timeout>  =>   B<integer, optional>

=begin html

<br>Number of hashes flushed in between fourth and fifth timeout.

=end html

=back



=over 2

=item * I<hashes-flashed-post-second-timeout>  =>   B<integer, optional>

=begin html

<br>Number of hashes flushed in between second and third timeout.

=end html

=back



=over 2

=item * I<hashes-flashed-post-third-timeout>  =>   B<integer, optional>

=begin html

<br>Number of hashes flushed in between third and fourth timeout.

=end html

=back



=head2 cifs_branchcache_set_key

[B<Family:> ontap-classic, vfiler]


=begin html

Sets the server secret for BranchCache.

=end html



B<Inputs>

=over 2

=item * I<server-secret>  =>   B<string>

=begin html

<br>A binary string that provides cryptographic data used by the BranchCache content server to generate hashes. Content servers that are serving the same data and are expected to provide the same hash values must use the same key. After changing this value, any existing cached content will be identified as stale and retrieved from the content server again.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 cifs_homedir_path_get_for_user

[B<Family:> ontap-classic, vfiler]


=begin html

Return path to the user's CIFS home directory if it exists.

=end html



B<Inputs>

=over 2

=item * I<user-name>  =>   B<string>

=begin html

<br>Name of the user. If the filer is using the "mapped" CIFS home directory naming style, then a mapped Unix name is provided. For the domain naming style, a domain/user is provided. Otherwise the filer will expect the NT name for the user. The filer's CIFS home directory naming style can be obtained with the "options-get" api, using input parameter "name cifs.home_dir_namestyle".

=end html

=back



B<Outputs>

=over 2

=item * I<homedir-path-user>  =>   B<string, optional>

=begin html

<br>A Unix-style path to the user's CIFS homedir directory, if it exists, for example: /vol/volName/users/joe.

=end html

=back



=head2 cifs_homedir_paths_get

[B<Family:> ontap-classic, vfiler]


=begin html

Return the current list of paths to users' cifs home directories, if any.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<homedir-paths>  =>   B<homedir-path-info[], optional>

=begin html

<br>An array, one entry per each cifs home directory path.

=end html

=back



=head2 cifs_homedir_paths_set

[B<Family:> ontap-classic, vfiler]


=begin html

Provides a list of CIFS home directory paths for the filer. Replaces the current list of paths in use by the filer. Note that supplying an empty path list causes the filer to delete any current entries.

=end html



B<Inputs>

=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>If true, the new set of homedir paths will be put into use even if some user homedir connections will be broken. This can cause users with open files in their home directories to lose access to the files. A user can lose data if there are updates not yet committed to disk.

=end html

=back



=over 2

=item * I<homedir-paths>  =>   B<homedir-path-info[], optional>

=begin html

<br>An array, one entry per each cifs home directory path. note: homedir-path-info defined above

=end html

=back



B<Outputs>

=over 2

=item * I<path-error>  =>   B<L<"path-error-info">[], optional>

=begin html

<br>An array, one entry for each homedir path error detected. Note that normally the API will complete sucessfully and activate as many paths as possible even if some paths cannot be activated.

=end html

=back



=head2 cifs_list_config

[B<Family:> ontap-classic, vfiler]


=begin html

This ZAPI is used to display the CIFS configuration.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<AD-site>  =>   B<string, optional>

=begin html

<br>Active Directory site that the filer is in.

=end html

=back



=over 2

=item * I<DC-connection>  =>   B<L<"connection-info">[], optional>

=begin html

<br>Information on the Domain Controller's connection.

=end html

=back



=over 2

=item * I<DNS-domainname>  =>   B<string, optional>

=begin html

<br>FQDN of DNS domain.

=end html

=back



=over 2

=item * I<LDAP-connection>  =>   B<L<"connection-info">[], optional>

=begin html

<br>Information on the LDAP connection.

=end html

=back



=over 2

=item * I<NetBIOS-domainname>  =>   B<string, optional>

=begin html

<br>NetBIOS domain name.

=end html

=back



=over 2

=item * I<NetBIOS-servername>  =>   B<string>

=begin html

<br>NetBIOS name of the server

=end html

=back



=over 2

=item * I<Windows-type>  =>   B<string, optional>

=begin html

<br>Windows type: "NT4"

=end html

=back



=over 2

=item * I<auth-type>  =>   B<string>

=begin html

<br>String specifying the type of authentication, such as: "ad" Active Directory "nt4" Windows NT4 "workgroup" Workgroup "passwd" Password file, NIS or LDAP

=end html

=back



=over 2

=item * I<domain-controller-functionality>  =>   B<cifs-functional-level, optional>

=begin html

<br>Domain controller functionality indicates the functional level of the DC.

=end html

=back



=over 2

=item * I<domain-functionality>  =>   B<cifs-functional-level, optional>

=begin html

<br>Domain functionality enables features that will affect the entire domain and that domain only. It indicates the functional level of the domain.

=end html

=back



=over 2

=item * I<forest-functionality>  =>   B<cifs-functional-level, optional>

=begin html

<br>Forest functionality enables features across all the domains within your forest. It indicates the functional level of the forest.

=end html

=back



=over 2

=item * I<security-style>  =>   B<string>

=begin html

<br>String specifying the security style, such as: "ntfs" NTFS "multiprotocol" Multiple Protocol

=end html

=back



=head2 cifs_nbalias_names_get

[B<Family:> ontap-classic, vfiler]


=begin html

Return the current list of NetBIOS alias names for the filer

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<nbalias-names>  =>   B<nbalias-name-info[], optional>

=begin html

<br>An array, one entry for each NetBIOS alias name

=end html

=back



=head2 cifs_nbalias_names_set

[B<Family:> ontap-classic, vfiler]


=begin html

Provides a list of NetBIOS alias names for the filer. The filer replaces the current list of aliases with with this list. Note that supplying an empty name list causes the filer to delete all current entries.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<nbalias-names>  =>   B<nbalias-name-info[], optional>

=begin html

<br>An array, one entry for each NetBIOS alias name note: nbalias-name_info defined above

=end html

=back



=head2 cifs_session_list_iter_end

[B<Family:> ontap-classic, vfiler]


=begin html

Terminate a list iteration and clean up any saved info.

=end html



B<Inputs>

=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous cifs-session-list-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 cifs_session_list_iter_next

[B<Family:> ontap-classic, vfiler]


=begin html

Returns items from a previous call to cifs-session-list-iter-start.

=end html



B<Inputs>

=over 2

=item * I<maximum>  =>   B<integer>

=begin html

<br>The maximum number of entries to retrieve.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous cifs-session-list-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * I<cifs-sessions>  =>   B<L<"cifs-session-info">[]>

=begin html

<br>An array, one entry per each cifs session.

=end html

=back



=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>This tells you how many records are being returned from this particular call to cifs-session-list-iter-next. When this value is 0, you have retrieved everything. Range: [0..2^32-1].

=end html

=back



=head2 cifs_session_list_iter_start

[B<Family:> ontap-classic, vfiler]


=begin html

Gives information on current CIFS activity. Without arguments, it returns a summary of information about the filer and lists the users who are connected to the filer.

=end html



B<Inputs>

=over 2

=item * I<host>  =>   B<string, optional>

=begin html

<br>IP address/machine name of the user's client machine.

=end html

=back



=over 2

=item * I<protocol>  =>   B<string, optional>

=begin html

<br>Filters the information on the basis of protocol version specified. When 'smb' is specified as the argument, this API retrieves information about only SMB 1.0 sessions. When 'smb2' is specified as the argument, this API retrieves information about only SMB 2.0 sessions. If this option is not specified, then information about both SMB 1.0 and SMB 2.0 sessions is retrieved.

=end html

=back



=over 2

=item * I<user>  =>   B<string, optional>

=begin html

<br>User name. If user is specified , this api returns information about the specified user, along with the names and access level of files that the user has opened. This api returns information about all the users, if the user is specified as '*' or is not specified.

=end html

=back



B<Outputs>

=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>Number which tells you how many items have been saved for future retrieval with cifs-session-list-iter-next.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag to be used in subsequent calls to cifs-session-list-iter-next.

=end html

=back



=head2 cifs_setup

[B<Family:> ontap-classic, vfiler]


=begin html

Configures the filer's CIFS service. The CIFS service will start automatically once this call completes successfully.

=end html



B<Inputs>

=over 2

=item * I<auth-type>  =>   B<string>

=begin html

<br>The authentication style that determines the method by which clients will be authenticated when connecting to this CIFS server. These styles are subject to change in a future release. Possible values: ad, nt4, workgroup, passwd Note: The domain-name, login-user and login-password fields are optional unless the auth-type is ad.

=end html

=back



=over 2

=item * I<domain-name>  =>   B<string, optional>

=begin html

<br>The name of the domain that the CIFS server will join. This can be the NetBIOS or fully qualified domain name. Examples: cifsdomain, cifs.domain.com

=end html

=back



=over 2

=item * I<login-password>  =>   B<string, optional, encrypted>

=begin html

<br>The password for login-user.

=end html

=back



=over 2

=item * I<login-user>  =>   B<string, optional>

=begin html

<br>The name of a domain user that has the ability to add the CIFS server to the domain given in domain-name. Examples: username (assumes domain-name is the user's domain), cifsdomain\username, cifs.domain.com\username

=end html

=back



=over 2

=item * I<ou-name>  =>   B<string, optional>

=begin html

<br>The distinguished name of the organizational unit that the CIFS service will become a member of. This value must be one of the cifs-setup-ous retrieved from a call to the cifs-setup-container-list-iter APIs. By default, the filer will join the 'CN=Computers' organizational unit. Note: This information is only used when the auth-type is 'ad'.

=end html

=back



=over 2

=item * I<pdc-ip-address>  =>   B<ip-address, optional>

=begin html

<br>If this value is defined, CIFS will attempt to communicate with the domain controller directly using this address. Note: This information is only used when the auth-type is 'nt4'.

=end html

=back



=over 2

=item * I<security-style>  =>   B<string>

=begin html

<br>The security style determines whether or not the CIFS service will support multiprotocol access. These styles are subject to change in a future release. Possible values: ntfs, multiprotocol

=end html

=back



=over 2

=item * I<server-name>  =>   B<string>

=begin html

<br>The resulting CIFS server name.

=end html

=back



=over 2

=item * I<site-name>  =>   B<string, optional>

=begin html

<br>The name of the site that the CIFS service will become a member of. This value must be one of the cifs-setup-sites retrieved from a call to the cifs-setup-container-list-iter APIs. If a default-site was returned, it is the recommended choice. Sites will be ignored if this value is left blank. Note: This information is only used when the auth-type is 'ad'.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 cifs_setup_create_group_file

[B<Family:> ontap-classic, vfiler]


=begin html

Creates a basic /etc/group file. Note: This will overwrite an existing /etc/group file. See cifs-setup-verify-passwd-and-group for more information.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 cifs_setup_create_passwd_file

[B<Family:> ontap-classic, vfiler]


=begin html

Creates a basic /etc/passwd file including a root user with the specified password. Note: This will overwrite an existing /etc/passwd file. See cifs-setup-verify-passwd-and-group for more information.

=end html



B<Inputs>

=over 2

=item * I<default-root-password>  =>   B<string, encrypted>

=begin html

<br>The password given to a locally defined root user which may be used in the event that other authentication services are unavailable. This will be defined in the filer's local /etc/passwd file.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 cifs_setup_ou_list_iter_end

[B<Family:> ontap-classic, vfiler]


=begin html

Terminate a list iteration and clean up any saved info.

=end html



B<Inputs>

=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous cifs-setup-ou-list-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 cifs_setup_ou_list_iter_next

[B<Family:> ontap-classic, vfiler]


=begin html

Returns items from a previous call to cifs-setup-ou-list-iter-start

=end html



B<Inputs>

=over 2

=item * I<maximum>  =>   B<integer>

=begin html

<br>The maximum number of entries to retrieve.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous cifs-setup-ou-list-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * I<cifs-setup-ous>  =>   B<cifs-setup-ou[]>

=begin html

<br>An array, one entry per each joinable organizational unit.

=end html

=back



=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>This tells you how many records are being returned from this particular call to cifs-setup-ou-list-iter-next. When this value is 0, you have retrieved everything.

=end html

=back



=head2 cifs_setup_ou_list_iter_start

[B<Family:> ontap-classic, vfiler]


=begin html

Gathers a list of joinable sites and organizational units from Active Directory for the login-user specified, which is retrieved by using cifs-setup-ou-list-iter-next. For more information regarding Active Directory organizational units and their use, please reference Microsoft's Active Directory documentation.

=end html



B<Inputs>

=over 2

=item * I<domain-name>  =>   B<string>

=begin html

<br>The name of the domain that the CIFS server will join. Examples: cifsdomain, cifs.domain.com

=end html

=back



=over 2

=item * I<login-password>  =>   B<string, encrypted>

=begin html

<br>The password for login-user.

=end html

=back



=over 2

=item * I<login-user>  =>   B<string>

=begin html

<br>The name of a domain user that has the ability to add the CIFS server to the domain given in domain-name. Examples: username (assumes domain-name is the user's domain), cifsdomain\username, cifs.domain.com\username

=end html

=back



B<Outputs>

=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>Number which tells you how many items have been saved for future retrieval with cifs-setup-ou-list-iter-next.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag to be used in subsequent calls to cifs-setup-ou-list-iter-next.

=end html

=back



=head2 cifs_setup_site_list_iter_end

[B<Family:> ontap-classic, vfiler]


=begin html

Terminate a list iteration and clean up any saved info.

=end html



B<Inputs>

=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous cifs-setup-site-list-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 cifs_setup_site_list_iter_next

[B<Family:> ontap-classic, vfiler]


=begin html

Returns items from a previous call to cifs-setup-site-list-iter-start

=end html



B<Inputs>

=over 2

=item * I<maximum>  =>   B<integer>

=begin html

<br>The maximum number of entries to retrieve.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous cifs-setup-site-list-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * I<cifs-setup-sites>  =>   B<cifs-setup-site[]>

=begin html

<br>An array, one entry per each joinable organizational unit.

=end html

=back



=over 2

=item * I<default-site>  =>   B<string, optional>

=begin html

<br>If this subnet is part of a pre-defined site in Active Directory, this is the site name that would be used by default unless one of the other sites in cifs-setup-sites are specified instead.

=end html

=back



=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>This tells you how many records are being returned from this particular call to cifs-setup-site-list-iter-next. When this value is 0, you have retrieved everything.

=end html

=back



=head2 cifs_setup_site_list_iter_start

[B<Family:> ontap-classic, vfiler]


=begin html

Gathers a list of joinable sites and organizational units from Active Directory for the login-user specified, which is retrieved by using cifs-setup-site-list-iter-next. For more information regarding Active Directory sites and their use, please reference Microsoft's Active Directory documentation.

=end html



B<Inputs>

=over 2

=item * I<domain-name>  =>   B<string>

=begin html

<br>The name of the domain that the CIFS server will join. Examples: cifsdomain, cifs.domain.com

=end html

=back



=over 2

=item * I<login-password>  =>   B<string, encrypted>

=begin html

<br>The password for login-user.

=end html

=back



=over 2

=item * I<login-user>  =>   B<string>

=begin html

<br>The name of a domain user that has the ability to add the CIFS server to the domain given in domain-name. Examples: username (assumes domain-name is the user's domain), cifsdomain\username, cifs.domain.com\username

=end html

=back



B<Outputs>

=over 2

=item * I<default-site>  =>   B<string, optional>

=begin html

<br>If this subnet is part of a pre-defined site in Active Directory, this is the site name that would be used by default unless one of the other sites in cifs-setup-sites are specified instead.

=end html

=back



=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>Number which tells you how many items have been saved for future retrieval with cifs-setup-site-list-iter-next.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag to be used in subsequent calls to cifs-setup-site-list-iter-next.

=end html

=back



=head2 cifs_setup_verify_name

[B<Family:> ontap-classic, vfiler]


=begin html

Determines whether or not a particular CIFS server name is already in use on the network and a specified domain.

=end html



B<Inputs>

=over 2

=item * I<auth-type>  =>   B<string>

=begin html

<br>The authentication style that will be used in a subsequent call to cifs-setup. These styles are subject to change in a future release. Possible values: ad, nt4, workgroup, passwd Note: The domain-name, login-user and login-password fields are optional unless the auth-type is ad.

=end html

=back



=over 2

=item * I<domain-name>  =>   B<string>

=begin html

<br>The name of the domain that the CIFS server will join. Examples: cifsdomain, cifs.domain.com

=end html

=back



=over 2

=item * I<login-password>  =>   B<string, optional, encrypted>

=begin html

<br>The password for login-user.

=end html

=back



=over 2

=item * I<login-user>  =>   B<string, optional>

=begin html

<br>The name of a domain user that has the ability to add the CIFS server to the domain given in domain-name. Examples: username (assumes domain-name is the user's domain), cifsdomain\username, cifs.domain.com\username

=end html

=back



=over 2

=item * I<pdc-ip-address>  =>   B<ip-address, optional>

=begin html

<br>If this value is defined, CIFS will attempt to communicate with the domain controller directly using this address. Note: This information is only used when the auth-type is 'nt4'.

=end html

=back



=over 2

=item * I<server-name>  =>   B<string>

=begin html

<br>The NetBIOS CIFS server name that will be verified. Example: cifsserver

=end html

=back



B<Outputs>

=over 2

=item * I<is-in-domain>  =>   B<boolean>

=begin html

<br>Returns 'true' if the name exists in the domain, otherwise returns 'false'. For 'ad'-style domains, if an entry exists a warning should be provided. For 'nt4'-style domains, an entry must exist or cifs-setup will fail.

=end html

=back



=over 2

=item * I<is-in-use>  =>   B<boolean>

=begin html

<br>Returns 'true' if the name is in use on the network, otherwise returns 'false'.

=end html

=back



=head2 cifs_setup_verify_passwd_and_group

[B<Family:> ontap-classic, vfiler]


=begin html

Determines whether or not the /etc/passwd and /etc/group files exist, which would be used in the event that the configured CIFS authentication method fails.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<group-file-exists>  =>   B<boolean>

=begin html

<br>Returns 'true' if the /etc/group file exists, otherwise returns 'false'.

=end html

=back



=over 2

=item * I<passwd-file-exists>  =>   B<boolean>

=begin html

<br>Returns 'true' if the /etc/passwd file exists, otherwise returns 'false'.

=end html

=back



=over 2

=item * I<required>  =>   B<boolean>

=begin html

<br>Returns 'true' if the /etc/passwd and /etc/group files would be required before running the cifs-setup API. cifs-setup will require these files if neither LDAP nor NIS are enabled, as they will be used as a backup authentication method should the primary method (i.e. domain authentication) become unavailable.

=end html

=back



=head2 cifs_share_ace_delete

[B<Family:> ontap-classic, vfiler]


=begin html

Deletes the access control entry of the given share or the unix group. This API is equivalent to "cifs access <share> [-g] <user|group>" CLI.

=end html



B<Inputs>

=over 2

=item * I<is-unixgroup>  =>   B<boolean, optional>

=begin html

<br>This filter is used to tell that the access rights of the unix group have to be deleted. If its value is true, uinx-group-name needs to be provided. Otherwise it fails with the reason "group-name missing". The default value of this is false.

=end html

=back



=over 2

=item * I<share-name>  =>   B<string>

=begin html

<br>CIFS share name. It specifies name of the share of which the access rights have to be deleted. This is a case insensitive field. The maximum size of the share name is 256 characters.

=end html

=back



=over 2

=item * I<unix-group-name>  =>   B<string, optional>

=begin html

<br>Name of the unix group. This field specifies the unix group of which the access rights to be deleted. The format of this field <group-name>. This is a case sensitive field. If the specified group name does not exist, it fails with the reason "Unknown Unix group <group-name>"

=end html

=back



=over 2

=item * I<user-name>  =>   B<string, optional>

=begin html

<br>Name of the user. This API deletes the access rights of the specified user. This is a case sensitive field. The format of the field is <user-name>. If specified user does not exist, It fails with the reason "Unknown user <username>".

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 cifs_share_ace_set

[B<Family:> ontap-classic, vfiler]


=begin html

Sets the ace to the share for the given user or unix group. This API is equivalent to "cifs access <share> [-g] <user|group> <rights>" CLI.

=end html



B<Inputs>

=over 2

=item * I<access-rights>  =>   B<string>

=begin html

<br>Access rights to be set to the above share and user. The format of the rights can be Unix-style combinations of r w x - or NT-style "No Access", "Read", "Change", and "Full Control"

=end html

=back



=over 2

=item * I<is-unixgroup>  =>   B<boolean, optional>

=begin html

<br>This filter is used to tell that the access rights are to be set to the unix group. If its value is true, unix-group-name needs to be provided. Otherwise API fails with the reason "group-name missing". The default value of this is false.

=end html

=back



=over 2

=item * I<share-name>  =>   B<string>

=begin html

<br>CIFS share name. It specifies name of the share to which the access rights have to be set. This is a case insensitive field. The maximum size of the share name is 256 characters.

=end html

=back



=over 2

=item * I<unix-group-name>  =>   B<string, optional>

=begin html

<br>Name of the unix group. This field specifies the unix group to which the access rights are to be set. The format of this field <unix-group-name>. This is a case sensitive field. If the specified group name does not exist, it fails with the reason "Unknown Unix group : <groupname>".

=end html

=back



=over 2

=item * I<user-name>  =>   B<string, optional>

=begin html

<br>Name of the user. This API sets the access rights to the specified user. This is a case sensitive field. The format of the field <user-name>. If specified user does not exist, It fails with the reason "Unknown user: <username>".

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 cifs_share_acl_list_iter_end

[B<Family:> ontap-classic, vfiler]


=begin html

Terminates a list iteration and cleans up any saved info.

=end html



B<Inputs>

=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from the previous cifs-share-acl-list-iter-start

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 cifs_share_acl_list_iter_next

[B<Family:> ontap-classic, vfiler]


=begin html

Returns items from a previous call to cifs-share-acl-list-iter-start.

=end html



B<Inputs>

=over 2

=item * I<maximum>  =>   B<integer>

=begin html

<br>The maximum number of entries to retrieve. Range:[0..2^32-1]

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from the previous cifs-share-acl-list-iter-start

=end html

=back



B<Outputs>

=over 2

=item * I<cifs-share-acls>  =>   B<L<"cifs-share-acl-info">[]>

=begin html

<br>An array, one entry per each cifs share.

=end html

=back



=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>This tells you how many records are being returned from this particular call to cifs-share-acl-list-iter-next. When this value is 0, you have retrieved everything. Range:[0..2^32-1]

=end html

=back



=head2 cifs_share_acl_list_iter_start

[B<Family:> ontap-classic, vfiler]


=begin html

Gives information about one or more shares acl.

=end html



B<Inputs>

=over 2

=item * I<share-name>  =>   B<string, optional>

=begin html

<br>Cifs share name. If share-name is specified, only information about that share is returned. If share-name is not specified, then information about all the shares is returned. If the name contains the wildcard characters * or ?, then all the shares matching the specified pattern are listed.

=end html

=back



B<Outputs>

=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>Number which tells you how many items have been saved for future retrieval with cifs-share-acl-list-iter-next. Range:[0..2^32-1]

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag to be used in subsequent calls to cifs-share-acl-list-iter-next

=end html

=back



=head2 cifs_share_add

[B<Family:> ontap-classic, vfiler]


=begin html

Creates a new CIFS share rooted at the specified path.

=end html



B<Inputs>

=over 2

=item * I<caching>  =>   B<string, optional>

=begin html

<br>If specified, the following is done based on the value of the string: "no_caching": disallow Windows clients from caching any files on this share. This is the default value. "auto_document_caching": allow Windows clients to cache user documents on this share. "auto_program_caching": allow Windows clients to cache programs on this share. The actual caching behavior depends on the Windows client. "branchcache": clients connecting to this share can make requests using BranchCache technology that allows them to cache the content in an attempt to reduce WAN utilization from a remote office.

=end html

=back



=over 2

=item * I<comment>  =>   B<string, optional>

=begin html

<br>If specified, gives description of the new share. CIFS clients see this description when browsing the filer's shares. If not specified, the description is blank.

=end html

=back



=over 2

=item * I<dir-umask>  =>   B<integer, optional>

=begin html

<br>If specified, sets file mode creation mask for a share in qtrees with Unix or mixed security styles. The mask restricts the initial permissions setting of a newly created directory. For directories, this mask overrides one set with "umask".

=end html

=back



=over 2

=item * I<file-umask>  =>   B<integer, optional>

=begin html

<br>If specified, sets file mode creation mask for a share in qtrees with Unix or mixed security styles. The mask restricts the initial permissions setting of a newly created file. For files, this mask overrides one set with "umask".

=end html

=back



=over 2

=item * I<forcegroup>  =>   B<string, optional>

=begin html

<br>If specified, provides name of the group to which files to be created in the share belong. The groupname is the name of a group in the UNIX group database. If it is an empty string or else not specified, then files to be created in the share do not belong to a particular UNIX group. That is, each file belongs to the same group as the owner of the file.

=end html

=back



=over 2

=item * I<is-access-based-enum>  =>   B<boolean, optional>

=begin html

<br>If true Access Based Enumeration (ABE) is enabled, else it is disabled. ABE filtered shared folders are visible to a user based on that individual user's access rights, preventing the display of folders or other shared resources that the user does not have rights to access.

=end html

=back



=over 2

=item * I<is-browse>  =>   B<boolean, optional>

=begin html

<br>If true or not specified, shares are visible to browsing clients and can be enumerated (e.g. "net view", SrvMgr, AD).

=end html

=back



=over 2

=item * I<is-namespace-caching-allowed>  =>   B<boolean, optional>

=begin html

<br>If true, namespace caching is enabled on the share. If namespace caching is enabled on a share, clients are allowed to cache the directory enumeration results for better performance.

=end html

=back



=over 2

=item * I<is-symlink-strict-security>  =>   B<boolean, optional>

=begin html

<br>If true or not specified, strict symlink security is enabled. If false, allows clients to follow symbolic links to destinations on this filer but outside of the current share. It is not checked if the client is authenticated to the symbolic link's destination.

=end html

=back



=over 2

=item * I<is-vscan>  =>   B<boolean, optional>

=begin html

<br>If true or not specified, virus scan is done when clients open files on this share, else no virus scan is done.

=end html

=back



=over 2

=item * I<is-vscanread>  =>   B<boolean, optional>

=begin html

<br>If true or not specified, virus scan is done when clients open files on this share for read access, else no virus scan is done for read access on this share.

=end html

=back



=over 2

=item * I<is-widelink>  =>   B<boolean, optional>

=begin html

<br>If true, allows clients to follow absolute symbolic links outside of this share, subject to NT security. This feature requires an entry in the /etc/symlink.translations file and it requires that the client supports Microsoft's Distributed File System (DFS). If false or not specified, widelinks in the share are disabled.

=end html

=back



=over 2

=item * I<maxusers>  =>   B<integer, optional>

=begin html

<br>If specified, gives the maximum number of simultaneous connections to the new share. It must be a positive number. If not specified, the filer does not impose a limit on the number of connections to the share.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Full path name of the directory on the filer corresponding to the root of the new share.

=end html

=back



=over 2

=item * I<share-name>  =>   B<string>

=begin html

<br>Name of the share to be added. The name cannot exceed 12 characters for DOS-style shares and 256 characters for others.

=end html

=back



=over 2

=item * I<umask>  =>   B<integer, optional>

=begin html

<br>If specified, sets file mode creation mask for a share in qtrees with Unix or mixed security styles. The mask restricts the initial permissions setting of a newly created file or directory. If not specified, the file mode creation mask of the share is 0. This field is ignored when both dir-umask and file-umask are present.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 cifs_share_change

[B<Family:> ontap-classic, vfiler]


=begin html

Changes settings of one or more CIFS shares at any time, even if the shares are in use.

=end html



B<Inputs>

=over 2

=item * I<caching>  =>   B<string, optional>

=begin html

<br>If specified, the following is done based on the value of the string: "no_caching": disallow Windows clients from caching any files on this share. This is the default value. "auto_document_caching": allow Windows clients to cache user documents on this share. "auto_program_caching": allow Windows clients to cache programs on this share. The actual caching behavior depends on the Windows client. "manual_caching": allow users on Windows clients to manually select files to be cached. "branchcache": clients connecting to this share can make requests using BranchCache technology that allows them to cache the content in an attempt to reduce WAN utilization from a remote office.

=end html

=back



=over 2

=item * I<comment>  =>   B<string, optional>

=begin html

<br>If specified, changes description of the share. CIFS clients see this description when browsing the filer's shares. Specifying an empty string clears the previous description.

=end html

=back



=over 2

=item * I<dir-umask>  =>   B<integer, optional>

=begin html

<br>If specified, changes file mode creation mask for a share in qtrees with Unix or mixed security styles. The mask restricts the initial permissions setting of a newly created directory. For directories, this mask overrides one set with "umask". Specifying an empty string resets (removes) this dir-umask.

=end html

=back



=over 2

=item * I<file-umask>  =>   B<integer, optional>

=begin html

<br>If specified, changes file mode creation mask for a share in qtrees with Unix or mixed security styles. The mask restricts the initial permissions setting of a newly created file. For files, this mask overrides one set with "umask". Specifying an empty string resets (removes) this file-umask.

=end html

=back



=over 2

=item * I<forcegroup>  =>   B<string, optional>

=begin html

<br>If specified, changes name of the group to which files to be created in the share belong. The groupname is the name of a group in the UNIX group database. If the string is empty, files to be created in the share do not belong to a particular UNIX group. That is, each file belongs to the same group as the owner of the file.

=end html

=back



=over 2

=item * I<is-access-based-enum>  =>   B<boolean, optional>

=begin html

<br>If true Access Based Enumeration (ABE) is enabled, if false it is disabled. ABE filtered shared folders are visible to a user based on that individual user's access rights, preventing the display of folders or other shared resources that the user does not have rights to access.

=end html

=back



=over 2

=item * I<is-browse>  =>   B<boolean, optional>

=begin html

<br>If true or undefined, share is visible to browsers and can be enumerated.

=end html

=back



=over 2

=item * I<is-namespace-caching-allowed>  =>   B<boolean, optional>

=begin html

<br>If true, namespace caching is enabled on the share. If false, namespace caching is disabled on the share. If namespace caching is enabled on a share, clients are allowed to cache the directory enumeration results for better performance.

=end html

=back



=over 2

=item * I<is-symlink-strict-security>  =>   B<boolean, optional>

=begin html

<br>If true, strict symlink security is enabled. If false, allows clients to follow symbolic links to destinations on this filer but outside of the current share. It is not checked if the client is authenticated to the symbolic link's destination.

=end html

=back



=over 2

=item * I<is-vscan>  =>   B<boolean, optional>

=begin html

<br>If true, virus scan is done when clients open files on this share, else virus scan is not done.

=end html

=back



=over 2

=item * I<is-vscanread>  =>   B<boolean, optional>

=begin html

<br>If true, virus scan is done when clients open files on this share for read access, else virus scan is not done for read access.

=end html

=back



=over 2

=item * I<is-widelink>  =>   B<boolean, optional>

=begin html

<br>If true, allows clients to follow absolute symbolic links outside of this share, subject to NT security. This feature requires an entry in the /etc/symlink.translations file and it requires that the client supports Microsoft's Distributed File System (DFS). If false, widelinks in the share are disabled.

=end html

=back



=over 2

=item * I<maxusers>  =>   B<integer, optional>

=begin html

<br>If specified, changes the maximum number of simultaneous connections to the new share. It must be a positive number or else zero, in which case no limit is imposed on the number of connections to the share.

=end html

=back



=over 2

=item * I<share-name>  =>   B<string>

=begin html

<br>If fully specified, it's the name of the existing share to be changed. If the name contains the wildcard characters * or ?, then all the shares matching the specified name are to be changed.

=end html

=back



=over 2

=item * I<umask>  =>   B<integer, optional>

=begin html

<br>If specified, changes file mode creation mask for a share in qtrees with Unix or mixed security styles. The mask restricts the initial permissions setting of a newly created file or directory. Specifying a zero value resets (removes) the file mode creation mask. This field is ignored when both dir-umask and file-umask are present.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 cifs_share_delete

[B<Family:> ontap-classic, vfiler]


=begin html

Deletes the specified CIFS share.

=end html



B<Inputs>

=over 2

=item * I<share-name>  =>   B<string>

=begin html

<br>The name of the CIFS share. The CIFS share name is a UTF-8 string with the following characters being illegal: control characters from 0x00 to 0x1F, both inclusive, 0x22 (double quotes) and the characters \/[]:|<>+=;,?"*

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 cifs_share_list_iter_end

[B<Family:> ontap-classic, vfiler]


=begin html

Terminate a list iteration and clean up any saved info.

=end html



B<Inputs>

=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous cifs-share-list-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 cifs_share_list_iter_next

[B<Family:> ontap-classic, vfiler]


=begin html

Returns items from a previous call to cifs-share-list-iter-start

=end html



B<Inputs>

=over 2

=item * I<maximum>  =>   B<integer>

=begin html

<br>The maximum number of entries to retrieve.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous cifs-share-list-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * I<cifs-shares>  =>   B<L<"cifs-share-info">[]>

=begin html

<br>An array, one entry per each cifs share.

=end html

=back



=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>This tells you how many records are being returned from this particular call to cifs-share-list-iter-next. When this value is 0, you have retrieved everything. Range:[0..2^32-1]

=end html

=back



=head2 cifs_share_list_iter_start

[B<Family:> ontap-classic, vfiler]


=begin html

Gives information about one or more shares, the results of which are retrieved by using cifs-share-list-iter-next.

=end html



B<Inputs>

=over 2

=item * I<share-name>  =>   B<string, optional>

=begin html

<br>Cifs share name. If share-name is specified, only information about that share is returned. If share-name is not specified, then information about all the shares is returned. If the name contains the wildcard characters * or ?, then all the shares matching the specified name are listed.

=end html

=back



B<Outputs>

=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>Number which tells you how many items have been saved for future retrieval with cifs-share-list-iter-next.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag to be used in subsequent calls to cifs-share-list-iter-next.

=end html

=back



=head2 cifs_start

[B<Family:> ontap-classic, vfiler]


=begin html

Starts the CIFS service, usually after a previous call to cifs-stop as the CIFS service starts automatically when cifs-setup completes successfully or the system reboots.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 cifs_status

[B<Family:> ontap-classic, vfiler]


=begin html

Returns the running state of the CIFS service.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<status>  =>   B<string>

=begin html

<br>The current status of the CIFS service, which will be one of the following: STOPPED, STARTED, STOPPING, STARTING

=end html

=back



=head2 cifs_stop

[B<Family:> ontap-classic, vfiler]


=begin html

Stops the CIFS service for all users or a particular workstation, if specified. Appropriate warning should be given to connected clients before calling this API, as it will immediately terminate those sessions regardless of their current state. See the cifs-sessions API for the list of clients that are currently connected.

=end html



B<Inputs>

=over 2

=item * I<workstation>  =>   B<string, optional>

=begin html

<br>The name or IP address of a workstation that will be disconnected from the CIFS service. Note that the CIFS service does not stop if this value is specified, it simply disconnects related sessions.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 cifs_top_iter_end

[B<Family:> ontap-classic, vfiler]


=begin html

Terminate a list iteration and clean up any saved info.

=end html



B<Inputs>

=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous cifs-top-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 cifs_top_iter_next

[B<Family:> ontap-classic, vfiler]


=begin html

Returns items from a previous call to cifs-top-iter-start.

=end html



B<Inputs>

=over 2

=item * I<maximum>  =>   B<integer>

=begin html

<br>The maximum number of entries to retrieve.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous cifs-top-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * I<cifs-top>  =>   B<L<"cifs-top-info">[]>

=begin html

<br>An array, one entry per cifs top.

=end html

=back



=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>This tells you how many records are being returned from this particular call to cifs-top-iter-next. When this value is 0, you have retrieved everything.

=end html

=back



=head2 cifs_top_iter_start

[B<Family:> ontap-classic, vfiler]


=begin html

Display CIFS client statistics

=end html



B<Inputs>

=over 2

=item * I<avgtype>  =>   B<string, optional>

=begin html

<br>Specifies how the client statistics are to be averaged for display: "smooth": Use a smoothed average which is weighted towards recent behavior but takes into account previous history of the client. "now": Use a one-second sample taken immediately and no history is taken into account. "total": Use the total count of each statistic divided by the total time since sampling started. If the is-verbose option is also set, the totals are given without dividing by the sample time.

=end html

=back



=over 2

=item * I<maxclients>  =>   B<integer, optional>

=begin html

<br>Specifies the maximum number of top clients to display (the default is 20).

=end html

=back



=over 2

=item * I<sortgroup>  =>   B<string, optional>

=begin html

<br>If specified, the client statistics are sorted by the value of the string: "ops": Sort by the number of operations per second of any type. "reads": Sort by kbytes/sec of data in response to read requests. "writes": Sort by kbytes/sec of data written to the filer. "ios": Sort by the combined total of reads plus writes for each client. "suspicious": Sort by the number of "suspicious" events per second by each client.

=end html

=back



B<Outputs>

=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>Number which tells you how many items have been saved for future retrieval with cifs-session-list-iter-next. Range:[0..2^32-1]

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag to be used in subsequent calls to cifs-session-list-iter-next.

=end html

=back



=head2 clock_get_clock

[B<Family:> ontap-classic]


=begin html

gets current date and time from filer.

=end html



B<Inputs>

=over 2

=item * I<is-compliance-clock>  =>   B<boolean, optional>

=begin html

<br>If true, then local-time and utc-time are values for the compliance clock, otherwise they are values for the local clock. Default is false. Note: This field is deprecated in Data ONTAP 8.1 and later. If true, the operation will fail with error EOPNOTSUPPORTED. Clients should use the API snaplock-get-system-compliance-clock or snaplock-get-volume-compliance-clock as applicable to get the compliance clock time.

=end html

=back



B<Outputs>

=over 2

=item * I<local-time>  =>   B<integer>

=begin html

<br>Local date and time of the filer in seconds since Midnight, 1/1/1970. Depending on the time zone and clock settings, this might be negative by up to 12 hours.

=end html

=back



=over 2

=item * I<utc-time>  =>   B<integer>

=begin html

<br>Current date and time of the filer in seconds since Midnight, 1/1/1970.

=end html

=back



=head2 clock_get_timezone

[B<Family:> ontap-classic]


=begin html

Gets current timezone and timezone file version.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<timezone>  =>   B<string>

=begin html

<br>Current timezone name where the storage system is operating. A timezone can have one of the two formats: <ol> <li>"Using a location string specified in Arthur David Olsen's public domain time zone database. For example, "Americas/New_York" represents most of the Eastern Time Zone."; <li>"A traditional time zone abbreviation incorporating default rules for daylight savings time. For example, "EST5EDT" for the US Eastern Time Zone."; </ol>

=end html

=back



=over 2

=item * I<timezone-UTC>  =>   B<string>

=begin html

<br>Current timezone of the storage system in UTC +/-hhmm format. This indicates that the local time zone is hh hours and mm minutes ahead or behind UTC. For example, Central European Time(CET) is +0100 and U.S./Canadian Eastern Standard Time(EST) is -0500.

=end html

=back



=over 2

=item * I<timezone-version>  =>   B<string>

=begin html

<br>Version of the time zone database. "YYYY" is the year the data base was released and "v" is the version within that year. "YYYY" will be four decimal digits and "v" will be an ASCII letter starting with "a" and increasing with each version. For example, the second 2007 version is "2007b".

=end html

=back



=head2 clock_set_clock

[B<Family:> ontap-classic]


=begin html

Set current date and time to the specified date and time.

=end html



B<Inputs>

=over 2

=item * I<is-utc-clock>  =>   B<boolean>

=begin html

<br>If this is true, then clock is given in UTC (universal time) instead of local time.

=end html

=back



=over 2

=item * I<time>  =>   B<integer>

=begin html

<br>Actual value of the date and time which has to be set as the current date and time on filer. Value will be seconds since Midnight, 1/1/1970. Depending on the time zone and clock settings, this might be negative by up to 12 hours.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 clock_set_timezone

[B<Family:> ontap-classic]


=begin html

Set current timezone to the specified timezone.

=end html



B<Inputs>

=over 2

=item * I<timezone>  =>   B<string>

=begin html

<br>Name of the timezone value which has to be set as current timezone value. A timezone can have one of the two formats: <ol> <li>"Using a location string specified in Arthur David Olsen's public domain time zone database. For example, "Americas/New_York" represents most of the Eastern Time Zone."; <li>"A traditional time zone abbreviation incorporating default rules for daylight savings time. For example, "EST5EDT" for the US Eastern Time Zone."; </ol>

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 clone_clear

[B<Family:> ontap-classic, vfiler]


=begin html

Clears information of a failed clone operation. If not successful, the error code will be returned as API error. This API is deprecated in Data ONTAP 8.1 and later, and will always fail with EDENSE_CLONE_NOT_RUNNING.

=end html



B<Inputs>

=over 2

=item * I<clone-id>  =>   B<integer>

=begin html

<br>ID information of the clone operation.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 clone_list_status

[B<Family:> ontap-classic, vfiler]


=begin html

Gets the information of a clone operations identified by clone-id. If clone-id is not specified, then it will get the status of all running and failed clone operation on the filer. It will get the status as 'running', 'failed' or 'completed'. User may see some other transient status for the clone operation, but any other status should be considered for polling clone-list-status again. User should keep polling clone-list-status till status returned is 'failed' or 'completed'. If status is 'completed', the clone operation has been completed successfully. If status is 'failed', then user is responsible for doing clone-clear to clean the status of the clone information. When a clone operation is aborted using clone-stop, it may take some time to stop the clone operation. User should poll clone-list-status till status returned is 'completed'. When status returned is 'completed' after clone-stop, the clone operation has been stopped successfully. This API is deprecated in Data ONTAP 8.1 and later. If a clone-id from a previous successful call to clone-start is provided, the operation will always be in the "completed" state.

=end html



B<Inputs>

=over 2

=item * I<clone-id>  =>   B<L<"clone-id-info">, optional>

=begin html

<br>ID information of the clone operation. If not specified, it will get the status of all running and failed clone operations on the filer.

=end html

=back



B<Outputs>

=over 2

=item * I<status>  =>   B<L<"ops-info">[], optional>

=begin html

<br>List of information of running and failed clone operations on the filer.

=end html

=back



=head2 clone_start

[B<Family:> ontap-classic, vfiler]


=begin html

In Data ONTAP 8.0 and earlier this API starts a file/LUN or sub-file/sub-LUN clone operation asynchronously. If clone operation starts successfully, a unique clone-id is returned. User is supposed to poll clone-list-status specifying clone-id to get the status of the clone operation. When clone-list-status returns status as completed, user can consider that the clone operation has been completed successfully. If user gets status as failed, user is responsible for doing clone-clear which will clean the status of the clone operation. In Data ONTAP 8.1 and later, this API performs a file/LUN or sub-file/sub-LUN clone operation synchronously. When this API returns successfully, the destination file is ready for use.

=end html



B<Inputs>

=over 2

=item * I<block-ranges>  =>   B<L<"block-range">[], optional>

=begin html

<br>List of block ranges for sub-file/sub-LUN cloning. The number of block ranges is limited to 32. For sub-LUN cloning the block range specified will be considered as SCSI LBA range. If only one block range is supplied, the source and destination range must not overlap and both ranges must not extend past the end of the file If multiple block ranges are specified in one operation, the user must ensure all source and destination ranges do not overlap, otherwise the result is undefined. In case of sub-LUN cloning, the API will copy data in case the LBAs are not block aligned. If the user provides LBAs such that actual number of blocks to be cloned is zero, then API will return error. The API will fail if the source range overlaps with the destination range or if the source and the destination ranges overlap amongst themselves. If block range is not provided then the file/LUN cloning is fully cloned.

=end html

=back



=over 2

=item * I<change-log>  =>   B<boolean, optional>

=begin html

<br>If this option is "true", fingerprints of data blocks of the destination file/block ranges created will be change logged to the change log file if A-SIS is enabled on the volume. With change logging clone operation will be slow, as to get fingerprints all the data blocks will be read. Without change logging clone operation deals with only indirect blocks without reading data blocks. Without change logging, fingerprints of the clone blocks are not recorded. The clone blocks are shared with the source blocks, but as later the source blocks are modified, corresponding clone blocks will no longer be shared. If change logging option is not used, clone blocks, which could be involved in sharing with rest of the file system, can not be shared in next sis operation. The only option, in case user had not used change logging while creating clone, will be to start sis from beginning using "sis start -s" to gather fingerprints of clone blocks. In Data ONTAP 8.1 and later, this field is accepted for backwards compatibility and is ignored.

=end html

=back



=over 2

=item * I<destination-path>  =>   B<string, optional>

=begin html

<br>Full path of the Destination file or LUN in /<volume-name>/file-path format. Destination path should be in same flexible volume as "source-path". If not specified, a sub-range clone of the source file or LUN will be performed onto itself. Either "destination-path" or "block-ranges" must be specified.

=end html

=back



=over 2

=item * I<ignore-locks>  =>   B<boolean, optional>

=begin html

<br>Clone even if (advisory/mandatory) byte_range locks or share_mode locks exist on the source or destination. By default value is false.

=end html

=back



=over 2

=item * I<ignore-streams>  =>   B<boolean, optional>

=begin html

<br>Clone only the base file and ignore streams on source or destination. By default value is false so streams are also cloned from source and existing destination streams are deleted.

=end html

=back



=over 2

=item * I<no-snap>  =>   B<boolean, optional>

=begin html

<br>If no-snap is FALSE or unspecified, then a temporary snapshot will be taken and source file locked in snapshot will be considered for cloning. So that the clone operation does not get affected by writes to the source file in parallel to the clone operation. User will get atomic point in time copy of the source. Irrespective of clone operation completes successfully or unsuccessfully, any temporary snapshot taken for cloning will be deleted automatically. If no-snap is "true", then the source file in AFS will be used for cloning. In this case user may get random data in clone if source file is modified while clone operation is in progress. This option should only be used when user is assured that the source file will remain consistent during the clone operation. Destination file is not protected against any modification while clone operation is in progress. User should use the destination file or destination block ranges after clone operation is finished. In Data ONTAP 8.1 and later, this field is accepted for backwards compatibility and is ignored.

=end html

=back



=over 2

=item * I<snapshot-name>  =>   B<string, optional>

=begin html

<br>Snapshot name from which to clone the source file or LUN. If not specified, the contents of in the active filesystem will be used. This field is available in Data ONTAP 8.1 or later

=end html

=back



=over 2

=item * I<source-path>  =>   B<string>

=begin html

<br>Full path of the source file or LUN in /<volume-name>/file-path format.

=end html

=back



=over 2

=item * I<space-reserve>  =>   B<boolean, optional>

=begin html

<br>Set the space reservation of the destination clone. By default space reservation is inherited from source. The API errors out if used in conjunction with block range arguments, since space reservations cannot be set for a block range.

=end html

=back



B<Outputs>

=over 2

=item * I<clone-id>  =>   B<L<"clone-id-info">>

=begin html

<br>Unique ID information for the clone operation returned if clone operation starts successfully. This field is deprecated in Data ONTAP 8.1 and later, the returned value is guaranteed to be a completed clone operation if supplied to clone-list-info.

=end html

=back



=head2 clone_stop

[B<Family:> ontap-classic, vfiler]


=begin html

Stops a running clone operation. If not successful, the error code will be returned as API error. This API is deprecated in Data ONTAP 8.1 and later, and will always fail with EDENSE_CLONE_NOT_RUNNING.

=end html



B<Inputs>

=over 2

=item * I<clone-id>  =>   B<L<"clone-id-info">>

=begin html

<br>ID information of the clone operation.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 copyoffload_copy_abort

[B<Family:> ontap-classic, vfiler]


=begin html

Abort an on-going copyoffload-copy-file request.

=end html



B<Inputs>

=over 2

=item * I<copy-id>  =>   B<string>

=begin html

<br>Unique identifier for an on-going copy operation.

=end html

=back



B<Outputs>

=over 2

=item * I<bytes-copied>  =>   B<integer>

=begin html

<br>Number of bytes that were copied prior to the abort.

=end html

=back



=head2 copyoffload_copy_start

[B<Family:> ontap-classic, vfiler]


=begin html

Copy specified whole/sub source file to specified destination file. This operation is handled asynchronously. Source and destination files must exist. The calling entity must poll for a status indication, via the copyoffload-copy-status, until either a failure or completed state is returned. still have copied some portion of the source to the destination: a copy operation involves multiple iterations of data copy before completing and may fail after some number of sub-copy operations. The caller should reissue the copy operation request to either reattempt the operation or to restore the destination to its previous content. Copy operations are not persistent over reboots or takeover scenarios.

=end html



B<Inputs>

=over 2

=item * I<destination-offset>  =>   B<integer, optional>

=begin html

<br>Byte offset in the destination file to begin copying data into, aligned to a 4,096 byte boundary. If not specified, copy will start at beginning of file.

=end html

=back



=over 2

=item * I<destination-path>  =>   B<string>

=begin html

<br>Full path of the destination file to where the data will be copied, in /vol/<volume-name>/<file-path> format.

=end html

=back



=over 2

=item * I<length>  =>   B<integer, optional>

=begin html

<br>Number of bytes to copy from the source file to the destination file. The byte count must be a multiples of 4,096. If not specified, the source file is copied from the source offset to the end of file. An error of ECOL_COPY_INVALIDINPUTERROR will be returned if length is zero or not a multiple of 4,096.

=end html

=back



=over 2

=item * I<source-offset>  =>   B<integer, optional>

=begin html

<br>Byte offset in source file which to start the copy of data, aligned on a 512 byte boundary. If not specified, copy will start at beginning of file.

=end html

=back



=over 2

=item * I<source-path>  =>   B<string>

=begin html

<br>Full path of the source file from where the data will be copied, in /vol/<volume-name>/<file-path> format.

=end html

=back



B<Outputs>

=over 2

=item * I<copy-id>  =>   B<string>

=begin html

<br>Unique identifier for the copy operation returned if copy operation begins successfully. This copy identifier must be presented in any subsequent request for this on-going copy operation.

=end html

=back



=head2 copyoffload_copy_status

[B<Family:> ontap-classic, vfiler]


=begin html

Provide status on an on-going copyoffload-copy-file request. The response will indicate the state of the on-going operation and the number of bytes copied thus far.

=end html



B<Inputs>

=over 2

=item * I<copy-id>  =>   B<string, optional>

=begin html

<br>Unique identifier for an on-going copy operation.

=end html

=back



B<Outputs>

=over 2

=item * I<copy-status>  =>   B<L<"copyoffload-status-info">[]>

=begin html

<br>Status information for the on-going copy operation. If no copy-id is provided, the list of all on-going copy operations will be returned.

=end html

=back



=head2 copyoffload_modify

[B<Family:> ontap-classic, vfiler]


=begin html

Set copy offload feature state {enable | disable}.

=end html



B<Inputs>

=over 2

=item * I<copyoffload-state>  =>   B<string>

=begin html

<br>Sets Copy Offload feature state. Possible values are: "enable" or "disable".

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 copyoffload_show

[B<Family:> ontap-classic, vfiler]


=begin html

Show current copy offload feature state.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<copyoffload-state>  =>   B<string>

=begin html

<br>Displays current Copy Offload feature state. Possible values are: "enabled" or "disabled".

=end html

=back



=head2 dfm_get_server_info

[B<Family:> ontap-classic, vfiler]


=begin html

Get the DFM server configuration

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<dfm-server>  =>   B<string>

=begin html

<br>DFM server identifier which was previously saved with the API DFM-set-server. If no server has been set, then error EONTAPI_ENOENT is returned.

=end html

=back



=over 2

=item * I<is-dfm-cross-linked>  =>   B<boolean>

=begin html

<br>The previously saved setting for cross-linked status. If DFM has been previously been marked as cross-linked then "true" is returned. If DFM has been previously marked as not cross-linked or is not set then "false" is returned. When this setting is true, FilerView will provide cross-links to the DFM server.

=end html

=back



=over 2

=item * I<port>  =>   B<integer, optional>

=begin html

<br>Port on which DFM requests arrive. Not returned if not previously set. Range : [1..2^16-1]

=end html

=back



=over 2

=item * I<protocol>  =>   B<string, optional>

=begin html

<br>Protocol in use by DFM. Possible values are "http" and "https". Not returned if not previously set.

=end html

=back



=head2 dfm_set_server_info

[B<Family:> ontap-classic, vfiler]


=begin html

Set the DFM server configuration

=end html



B<Inputs>

=over 2

=item * I<dfm-server>  =>   B<string, optional>

=begin html

<br>DFM server identifier. If not supplied then clear the current value.

=end html

=back



=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>If true then overwrite existing settings if they exist. If false, write the new settings only if no DFM server is set, otherwise do not perform any modifications. By default, the value for this parameter is true.

=end html

=back



=over 2

=item * I<is-dfm-cross-linked>  =>   B<boolean, optional>

=begin html

<br>If true then set DFM's cross-linked status. If false or not supplied, set cross-linked status to false. When this setting is true, FilerView provides cross-links to the specified DFM server.

=end html

=back



=over 2

=item * I<port>  =>   B<integer, optional>

=begin html

<br>Port used for DFM requests. If not supplied then clear the current value. Range : [1..2^16-1]

=end html

=back



=over 2

=item * I<protocol>  =>   B<string, optional>

=begin html

<br>Protocol in use by DFM. Possible values are "http" and "https". If not supplied then clear the current value.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 diagnosis_alert_definition_get

[B<Family:> ontap-classic]


=begin html

Return alert definition

=end html



B<Inputs>

=over 2

=item * I<alert-id>  =>   B<string>

=begin html

<br>Alert identification.

=end html

=back



=over 2

=item * I<desired-attributes>  =>   B<L<"diagnosis-alert-definition-info">, optional>

=begin html

<br>Specify the attributes that should be returned. If not present, all attributes for which information is available will be returned. If present, only the desired attributes for which information is available will be returned.

=end html

=back



=over 2

=item * I<monitor>  =>   B<hm-type>

=begin html

<br>Type of health monitor (e.g. node_connect, system_connect, system).

=end html

=back



=over 2

=item * I<node>  =>   B<string>

=begin html

<br>Node hosting this health monitor.

=end html

=back



B<Outputs>

=over 2

=item * I<attributes>  =>   B<L<"diagnosis-alert-definition-info">>

=begin html

<br>The attributes of the Alert Definition.

=end html

=back



=head2 diagnosis_alert_definition_get_iter

[B<Family:> ontap-classic]


=begin html

Iterate over a list of Alert Definition objects.

=end html



B<Inputs>

=over 2

=item * I<desired-attributes>  =>   B<L<"diagnosis-alert-definition-info">, optional>

=begin html

<br>Specify the attributes that should be returned. If not present, all attributes for which information is available will be returned. If present, only the desired attributes for which information is available will be returned.

=end html

=back



=over 2

=item * I<max-records>  =>   B<integer, optional>

=begin html

<br>The maximum number of records to return in this call. Default: 20

=end html

=back



=over 2

=item * I<query>  =>   B<L<"diagnosis-alert-definition-info">, optional>

=begin html

<br>A query that specifies which objects to return. A query could be specified on any number of attributes in the Alert Definition object. All Alert Definition objects matching this query up to 'max-records' will be returned.

=end html

=back



=over 2

=item * I<tag>  =>   B<string, optional>

=begin html

<br>Specify the tag from the last call. It is usually not specified for the first call. For subsequent calls, copy values from the 'next-tag' obtained from the previous call.

=end html

=back



B<Outputs>

=over 2

=item * I<attributes-list>  =>   B<L<"diagnosis-alert-definition-info">[], optional>

=begin html

<br>The list of attributes of Alert Definition objects.

=end html

=back



=over 2

=item * I<next-tag>  =>   B<string, optional>

=begin html

<br>Tag for the next call. Not present when there are no more Alert Definition objects to return.

=end html

=back



=over 2

=item * I<num-records>  =>   B<integer>

=begin html

<br>The number of records returned in this call.

=end html

=back



=head2 diagnosis_alert_get

[B<Family:> ontap-classic]


=begin html

Return a subsystem alert

=end html



B<Inputs>

=over 2

=item * I<alert-id>  =>   B<string>

=begin html

<br>Alert identification.

=end html

=back



=over 2

=item * I<alerting-resource>  =>   B<string>

=begin html

<br>Unique name of resource that generated the alert.

=end html

=back



=over 2

=item * I<desired-attributes>  =>   B<L<"diagnosis-alert-info">, optional>

=begin html

<br>Specify the attributes that should be returned. If not present, all attributes for which information is available will be returned. If present, only the desired attributes for which information is available will be returned.

=end html

=back



=over 2

=item * I<monitor>  =>   B<hm-type>

=begin html

<br>Type of health monitor (e.g. node_connect, system_connect, system).

=end html

=back



=over 2

=item * I<node>  =>   B<string>

=begin html

<br>Node hosting this health monitor.

=end html

=back



B<Outputs>

=over 2

=item * I<attributes>  =>   B<L<"diagnosis-alert-info">>

=begin html

<br>The attributes of the Alert Information.

=end html

=back



=head2 diagnosis_alert_get_iter

[B<Family:> ontap-classic]


=begin html

Iterate over a list of Alert Information objects.

=end html



B<Inputs>

=over 2

=item * I<desired-attributes>  =>   B<L<"diagnosis-alert-info">, optional>

=begin html

<br>Specify the attributes that should be returned. If not present, all attributes for which information is available will be returned. If present, only the desired attributes for which information is available will be returned.

=end html

=back



=over 2

=item * I<max-records>  =>   B<integer, optional>

=begin html

<br>The maximum number of records to return in this call. Default: 20

=end html

=back



=over 2

=item * I<query>  =>   B<L<"diagnosis-alert-info">, optional>

=begin html

<br>A query that specifies which objects to return. A query could be specified on any number of attributes in the Alert Information object. All Alert Information objects matching this query up to 'max-records' will be returned.

=end html

=back



=over 2

=item * I<tag>  =>   B<string, optional>

=begin html

<br>Specify the tag from the last call. It is usually not specified for the first call. For subsequent calls, copy values from the 'next-tag' obtained from the previous call.

=end html

=back



B<Outputs>

=over 2

=item * I<attributes-list>  =>   B<L<"diagnosis-alert-info">[], optional>

=begin html

<br>The list of attributes of Alert Information objects.

=end html

=back



=over 2

=item * I<next-tag>  =>   B<string, optional>

=begin html

<br>Tag for the next call. Not present when there are no more Alert Information objects to return.

=end html

=back



=over 2

=item * I<num-records>  =>   B<integer>

=begin html

<br>The number of records returned in this call.

=end html

=back



=head2 diagnosis_alert_modify

[B<Family:> ontap-classic]


=begin html

Acknowledge/suppress an alert

=end html



B<Inputs>

=over 2

=item * I<acknowledge>  =>   B<boolean, optional>

=begin html

<br>Acknowledge the alert condition.

=end html

=back



=over 2

=item * I<acknowledger>  =>   B<string, optional>

=begin html

<br>Person who acknowledged this alert

=end html

=back



=over 2

=item * I<alert-id>  =>   B<string>

=begin html

<br>Alert identification.

=end html

=back



=over 2

=item * I<alerting-resource>  =>   B<string>

=begin html

<br>Unique name of resource that generated the alert.

=end html

=back



=over 2

=item * I<monitor>  =>   B<hm-type>

=begin html

<br>Type of health monitor (e.g. node_connect, system_connect, system).

=end html

=back



=over 2

=item * I<node>  =>   B<string>

=begin html

<br>Node hosting this health monitor.

=end html

=back



=over 2

=item * I<suppress>  =>   B<boolean, optional>

=begin html

<br>Suppress this alert.

=end html

=back



=over 2

=item * I<suppressor>  =>   B<string, optional>

=begin html

<br>Person who suppressed this alert

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 diagnosis_config_get

[B<Family:> ontap-classic]


=begin html

Return the system health framework configuration

=end html



B<Inputs>

=over 2

=item * I<desired-attributes>  =>   B<L<"diagnosis-config-info">, optional>

=begin html

<br>Specify the attributes that should be returned. If not present, all attributes for which information is available will be returned. If present, only the desired attributes for which information is available will be returned.

=end html

=back



=over 2

=item * I<monitor>  =>   B<hm-type>

=begin html

<br>Type of health monitor (e.g. node_connect, system_connect, system).

=end html

=back



=over 2

=item * I<node>  =>   B<string>

=begin html

<br>Node hosting this health monitor.

=end html

=back



B<Outputs>

=over 2

=item * I<attributes>  =>   B<L<"diagnosis-config-info">>

=begin html

<br>The attributes of the Health Monitor Configuration.

=end html

=back



=head2 diagnosis_config_get_iter

[B<Family:> ontap-classic]


=begin html

Iterate over a list of Health Monitor Configuration objects.

=end html



B<Inputs>

=over 2

=item * I<desired-attributes>  =>   B<L<"diagnosis-config-info">, optional>

=begin html

<br>Specify the attributes that should be returned. If not present, all attributes for which information is available will be returned. If present, only the desired attributes for which information is available will be returned.

=end html

=back



=over 2

=item * I<max-records>  =>   B<integer, optional>

=begin html

<br>The maximum number of records to return in this call. Default: 20

=end html

=back



=over 2

=item * I<query>  =>   B<L<"diagnosis-config-info">, optional>

=begin html

<br>A query that specifies which objects to return. A query could be specified on any number of attributes in the Health Monitor Configuration object. All Health Monitor Configuration objects matching this query up to 'max-records' will be returned.

=end html

=back



=over 2

=item * I<tag>  =>   B<string, optional>

=begin html

<br>Specify the tag from the last call. It is usually not specified for the first call. For subsequent calls, copy values from the 'next-tag' obtained from the previous call.

=end html

=back



B<Outputs>

=over 2

=item * I<attributes-list>  =>   B<L<"diagnosis-config-info">[], optional>

=begin html

<br>The list of attributes of Health Monitor Configuration objects.

=end html

=back



=over 2

=item * I<next-tag>  =>   B<string, optional>

=begin html

<br>Tag for the next call. Not present when there are no more Health Monitor Configuration objects to return.

=end html

=back



=over 2

=item * I<num-records>  =>   B<integer>

=begin html

<br>The number of records returned in this call.

=end html

=back



=head2 diagnosis_delete_alert

[B<Family:> ontap-classic]


=begin html

Delete subsystem alert

=end html



B<Inputs>

=over 2

=item * I<alert-id>  =>   B<string>

=begin html

<br>Alert identification.

=end html

=back



=over 2

=item * I<alerting-resource>  =>   B<string>

=begin html

<br>Unique name of resource that generated the alert.

=end html

=back



=over 2

=item * I<monitor>  =>   B<hm-type>

=begin html

<br>Type of health monitor (e.g. node_connect, system_connect, system).

=end html

=back



=over 2

=item * I<node>  =>   B<string>

=begin html

<br>Node hosting this health monitor.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 diagnosis_policy_definition_get

[B<Family:> ontap-classic]


=begin html

Return policy definition

=end html



B<Inputs>

=over 2

=item * I<desired-attributes>  =>   B<L<"diagnosis-policy-definition-info">, optional>

=begin html

<br>Specify the attributes that should be returned. If not present, all attributes for which information is available will be returned. If present, only the desired attributes for which information is available will be returned.

=end html

=back



=over 2

=item * I<monitor>  =>   B<hm-type>

=begin html

<br>Type of health monitor (e.g. node_connect, system_connect, system).

=end html

=back



=over 2

=item * I<node>  =>   B<string>

=begin html

<br>Node hosting this health monitor.

=end html

=back



=over 2

=item * I<policy-id>  =>   B<string>

=begin html

<br>Policy identifier.

=end html

=back



B<Outputs>

=over 2

=item * I<attributes>  =>   B<L<"diagnosis-policy-definition-info">>

=begin html

<br>The attributes of the Policy Definition.

=end html

=back



=head2 diagnosis_policy_definition_get_iter

[B<Family:> ontap-classic]


=begin html

Iterate over a list of Policy Definition objects.

=end html



B<Inputs>

=over 2

=item * I<desired-attributes>  =>   B<L<"diagnosis-policy-definition-info">, optional>

=begin html

<br>Specify the attributes that should be returned. If not present, all attributes for which information is available will be returned. If present, only the desired attributes for which information is available will be returned.

=end html

=back



=over 2

=item * I<max-records>  =>   B<integer, optional>

=begin html

<br>The maximum number of records to return in this call. Default: 20

=end html

=back



=over 2

=item * I<query>  =>   B<L<"diagnosis-policy-definition-info">, optional>

=begin html

<br>A query that specifies which objects to return. A query could be specified on any number of attributes in the Policy Definition object. All Policy Definition objects matching this query up to 'max-records' will be returned.

=end html

=back



=over 2

=item * I<tag>  =>   B<string, optional>

=begin html

<br>Specify the tag from the last call. It is usually not specified for the first call. For subsequent calls, copy values from the 'next-tag' obtained from the previous call.

=end html

=back



B<Outputs>

=over 2

=item * I<attributes-list>  =>   B<L<"diagnosis-policy-definition-info">[], optional>

=begin html

<br>The list of attributes of Policy Definition objects.

=end html

=back



=over 2

=item * I<next-tag>  =>   B<string, optional>

=begin html

<br>Tag for the next call. Not present when there are no more Policy Definition objects to return.

=end html

=back



=over 2

=item * I<num-records>  =>   B<integer>

=begin html

<br>The number of records returned in this call.

=end html

=back



=head2 diagnosis_policy_modify

[B<Family:> ontap-classic]


=begin html

Enable/disable policy

=end html



B<Inputs>

=over 2

=item * I<enable>  =>   B<boolean, optional>

=begin html

<br>Enable/disable this policy.

=end html

=back



=over 2

=item * I<monitor>  =>   B<hm-type>

=begin html

<br>Type of health monitor (e.g. node_connect, system_connect, system).

=end html

=back



=over 2

=item * I<node>  =>   B<string>

=begin html

<br>Node hosting this health monitor.

=end html

=back



=over 2

=item * I<policy-id>  =>   B<string>

=begin html

<br>Policy identifier.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 diagnosis_status_get

[B<Family:> ontap-classic]


=begin html

Return the overall system health

=end html



B<Inputs>

=over 2

=item * I<desired-attributes>  =>   B<L<"diagnosis-status">, optional>

=begin html

<br>Specify the attributes that should be returned. If not present, all attributes for which information is available will be returned. If present, only the desired attributes for which information is available will be returned.

=end html

=back



B<Outputs>

=over 2

=item * I<attributes>  =>   B<L<"diagnosis-status">>

=begin html

<br>The attributes of the System Health Status.

=end html

=back



=head2 diagnosis_subscriptions_create

[B<Family:> ontap-classic]


=begin html

Create a new Subscriptions for Notifications.

=end html



B<Inputs>

=over 2

=item * I<class-name>  =>   B<string>

=begin html

<br>Class name of changed resource.

=end html

=back



=over 2

=item * I<event-type>  =>   B<hm-event-type>

=begin html

<br>Type of event (rm-add, rm-del, rm-mod) for which notification is to be generated.

=end html

=back



=over 2

=item * I<fail-thresh>  =>   B<integer, optional>

=begin html

<br>Failure threshold for notification.

=end html

=back



=over 2

=item * I<instance-name>  =>   B<string, optional>

=begin html

<br>Instance name of changed resource.

=end html

=back



=over 2

=item * I<max-notify-period>  =>   B<integer, optional>

=begin html

<br>Maximum expected time for Notification to complete.

=end html

=back



=over 2

=item * I<monitor>  =>   B<hm-type>

=begin html

<br>Type of source health monitor (e.g. node_connect, system_connect, system).

=end html

=back



=over 2

=item * I<node>  =>   B<string>

=begin html

<br>Node hosting this health monitor and sends out notifications

=end html

=back



=over 2

=item * I<notify-dest-hm>  =>   B<hm-type>

=begin html

<br>Health monitor subsribing for notification.

=end html

=back



=over 2

=item * I<notify-dest-node>  =>   B<node-name>

=begin html

<br>Node hosting the health monitor that is subscribing for notification.

=end html

=back



=over 2

=item * I<notify-table>  =>   B<string, optional>

=begin html

<br>Table name for DSMF notification.

=end html

=back



=over 2

=item * I<psc-option>  =>   B<boolean, optional>

=begin html

<br>Enable/Disable periodic status confirmation.

=end html

=back



=over 2

=item * I<return-record>  =>   B<boolean, optional>

=begin html

<br>If set to true, returns the Subscriptions for Notifications on successful creation. Default: false

=end html

=back



=over 2

=item * I<subscription-id>  =>   B<string>

=begin html

<br>Subscription identifier.

=end html

=back



=over 2

=item * I<time-gap-notify>  =>   B<integer, optional>

=begin html

<br>Time Period between two notifications.

=end html

=back



B<Outputs>

=over 2

=item * I<result>  =>   B<L<"diagnosis-subscriptions-info">, optional>

=begin html

<br>The Subscriptions for Notifications created (keys or the entire object if requested)

=end html

=back



=head2 diagnosis_subscriptions_get

[B<Family:> ontap-classic]


=begin html

Return system health subscription

=end html



B<Inputs>

=over 2

=item * I<class-name>  =>   B<string>

=begin html

<br>Class name of changed resource.

=end html

=back



=over 2

=item * I<desired-attributes>  =>   B<L<"diagnosis-subscriptions-info">, optional>

=begin html

<br>Specify the attributes that should be returned. If not present, all attributes for which information is available will be returned. If present, only the desired attributes for which information is available will be returned.

=end html

=back



=over 2

=item * I<event-type>  =>   B<hm-event-type>

=begin html

<br>Type of event (rm-add, rm-del, rm-mod) for which notification is to be generated.

=end html

=back



=over 2

=item * I<monitor>  =>   B<hm-type>

=begin html

<br>Type of source health monitor (e.g. node_connect, system_connect, system).

=end html

=back



=over 2

=item * I<node>  =>   B<string>

=begin html

<br>Node hosting this health monitor and sends out notifications

=end html

=back



=over 2

=item * I<notify-dest-hm>  =>   B<hm-type>

=begin html

<br>Health monitor subsribing for notification.

=end html

=back



=over 2

=item * I<notify-dest-node>  =>   B<node-name>

=begin html

<br>Node hosting the health monitor that is subscribing for notification.

=end html

=back



=over 2

=item * I<subscription-id>  =>   B<string>

=begin html

<br>Subscription identifier.

=end html

=back



B<Outputs>

=over 2

=item * I<attributes>  =>   B<L<"diagnosis-subscriptions-info">>

=begin html

<br>The attributes of the Subscriptions for Notifications.

=end html

=back



=head2 diagnosis_subscriptions_get_iter

[B<Family:> ontap-classic]


=begin html

Iterate over a list of Subscriptions for Notifications objects.

=end html



B<Inputs>

=over 2

=item * I<desired-attributes>  =>   B<L<"diagnosis-subscriptions-info">, optional>

=begin html

<br>Specify the attributes that should be returned. If not present, all attributes for which information is available will be returned. If present, only the desired attributes for which information is available will be returned.

=end html

=back



=over 2

=item * I<max-records>  =>   B<integer, optional>

=begin html

<br>The maximum number of records to return in this call. Default: 20

=end html

=back



=over 2

=item * I<query>  =>   B<L<"diagnosis-subscriptions-info">, optional>

=begin html

<br>A query that specifies which objects to return. A query could be specified on any number of attributes in the Subscriptions for Notifications object. All Subscriptions for Notifications objects matching this query up to 'max-records' will be returned.

=end html

=back



=over 2

=item * I<tag>  =>   B<string, optional>

=begin html

<br>Specify the tag from the last call. It is usually not specified for the first call. For subsequent calls, copy values from the 'next-tag' obtained from the previous call.

=end html

=back



B<Outputs>

=over 2

=item * I<attributes-list>  =>   B<L<"diagnosis-subscriptions-info">[], optional>

=begin html

<br>The list of attributes of Subscriptions for Notifications objects.

=end html

=back



=over 2

=item * I<next-tag>  =>   B<string, optional>

=begin html

<br>Tag for the next call. Not present when there are no more Subscriptions for Notifications objects to return.

=end html

=back



=over 2

=item * I<num-records>  =>   B<integer>

=begin html

<br>The number of records returned in this call.

=end html

=back



=head2 diagnosis_subscriptions_modify

[B<Family:> ontap-classic]


=begin html

Modify system health subscription

=end html



B<Inputs>

=over 2

=item * I<class-name>  =>   B<string>

=begin html

<br>Class name of changed resource.

=end html

=back



=over 2

=item * I<event-type>  =>   B<hm-event-type>

=begin html

<br>Type of event (rm-add, rm-del, rm-mod) for which notification is to be generated.

=end html

=back



=over 2

=item * I<fail-thresh>  =>   B<integer, optional>

=begin html

<br>Failure threshold for notification.

=end html

=back



=over 2

=item * I<instance-name>  =>   B<string, optional>

=begin html

<br>Instance name of changed resource.

=end html

=back



=over 2

=item * I<max-notify-period>  =>   B<integer, optional>

=begin html

<br>Maximum expected time for Notification to complete.

=end html

=back



=over 2

=item * I<monitor>  =>   B<hm-type>

=begin html

<br>Type of source health monitor (e.g. node_connect, system_connect, system).

=end html

=back



=over 2

=item * I<node>  =>   B<string>

=begin html

<br>Node hosting this health monitor and sends out notifications

=end html

=back



=over 2

=item * I<notify-dest-hm>  =>   B<hm-type>

=begin html

<br>Health monitor subsribing for notification.

=end html

=back



=over 2

=item * I<notify-dest-node>  =>   B<node-name>

=begin html

<br>Node hosting the health monitor that is subscribing for notification.

=end html

=back



=over 2

=item * I<notify-table>  =>   B<string, optional>

=begin html

<br>Table name for DSMF notification.

=end html

=back



=over 2

=item * I<psc-option>  =>   B<boolean, optional>

=begin html

<br>Enable/Disable periodic status confirmation.

=end html

=back



=over 2

=item * I<subscription-id>  =>   B<string>

=begin html

<br>Subscription identifier.

=end html

=back



=over 2

=item * I<time-gap-notify>  =>   B<integer, optional>

=begin html

<br>Time Period between two notifications.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 diagnosis_subsystem_config_get

[B<Family:> ontap-classic]


=begin html

Get the attributes of the Health Monitor Subsystem Status.

=end html



B<Inputs>

=over 2

=item * I<desired-attributes>  =>   B<L<"diagnosis-subsystem-config-info">, optional>

=begin html

<br>Specify the attributes that should be returned. If not present, all attributes for which information is available will be returned. If present, only the desired attributes for which information is available will be returned.

=end html

=back



=over 2

=item * I<subsystem>  =>   B<hm-subsystem>

=begin html

<br>Type of subsystem being monitored <p> Possible values: <ul> <li> 'sas_connect', <li> 'ha_health', </ul>

=end html

=back



B<Outputs>

=over 2

=item * I<attributes>  =>   B<L<"diagnosis-subsystem-config-info">>

=begin html

<br>The attributes of the Health Monitor Subsystem Status.

=end html

=back



=head2 diagnosis_subsystem_config_get_iter

[B<Family:> ontap-classic]


=begin html

Iterate over a list of Health Monitor Subsystem Status objects.

=end html



B<Inputs>

=over 2

=item * I<desired-attributes>  =>   B<L<"diagnosis-subsystem-config-info">, optional>

=begin html

<br>Specify the attributes that should be returned. If not present, all attributes for which information is available will be returned. If present, only the desired attributes for which information is available will be returned.

=end html

=back



=over 2

=item * I<max-records>  =>   B<integer, optional>

=begin html

<br>The maximum number of records to return in this call. Default: 20

=end html

=back



=over 2

=item * I<query>  =>   B<L<"diagnosis-subsystem-config-info">, optional>

=begin html

<br>A query that specifies which objects to return. A query could be specified on any number of attributes in the Health Monitor Subsystem Status object. All Health Monitor Subsystem Status objects matching this query up to 'max-records' will be returned.

=end html

=back



=over 2

=item * I<tag>  =>   B<string, optional>

=begin html

<br>Specify the tag from the last call. It is usually not specified for the first call. For subsequent calls, copy values from the 'next-tag' obtained from the previous call.

=end html

=back



B<Outputs>

=over 2

=item * I<attributes-list>  =>   B<L<"diagnosis-subsystem-config-info">[], optional>

=begin html

<br>The list of attributes of Health Monitor Subsystem Status objects.

=end html

=back



=over 2

=item * I<next-tag>  =>   B<string, optional>

=begin html

<br>Tag for the next call. Not present when there are no more Health Monitor Subsystem Status objects to return.

=end html

=back



=over 2

=item * I<num-records>  =>   B<integer>

=begin html

<br>The number of records returned in this call.

=end html

=back



=head2 disk_fail

[B<Family:> ontap-classic]


=begin html

Fail a file system disk. Removes the specified file system disk from the RAID configuration, spinning the disk down when removal is complete. disk fail is used to remove a file system disk that may be logging excessive errors and requires replacement. Note that if optional input parameter 'is-immediate' is true, the specified disk will be immediately failed out, and the RAID group to which the disk belongs will enter degraded mode (meaning a disk is missing from the RAID group). If a spare disk at least as large as the disk being removed is available, the contents of the disk being removed will be reconstructed onto that spare disk. If 'is-immediate' options is false or not specified, system will prefail the disk and its content will be copied to a replacement disk if a suitable spare disk is available, and afterwards the prefailed disk will be failed out. This process can be observed by polling disk-list-info for this disk and tracking values of elements copy-destination and copy-percent. Same can be done using 'storage-disk-get-iter' when requested from Admin Vserver LIF. The disk being failed is marked as ``broken'', so that if it remains in the disk shelf, it will not be used by the filer as a spare disk. If the disk is moved to another filer, that filer will use it as a spare. This is not a recommended course of action, as the reason that the disk was failed may have been because it needed to be replaced. NOTE: Data ONTAP 7.0 and earlier releases don't indicate failure code properly.

=end html



B<Inputs>

=over 2

=item * I<disk>  =>   B<string>

=begin html

<br>Name of the disk to fail, e.g. "v0.1". On Admin Vserver LIF, this will be disk path name with format of "<Node Name>:<Disk Name>". e.g. "Filer01:v0.1"

=end html

=back



=over 2

=item * I<is-immediate>  =>   B<boolean, optional>

=begin html

<br>Specify 'true' if disk is to be failed out immediately. If disk is to be prefailed, specify 'false'. Default value is 'false'.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 disk_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Get disk/array LUN status information from RAID. By default, only disks/array LUNs owned by the storage system or its partner are eligible for inclusion in the returned list. Unowned disks/array LUNs may be displayed by using the ownership-type option. To obtain information about disks/array LUNs connected to the storage system, but owned by a system other than the local system or its CFO partner use the disk-sanown-list-info api.

=end html



B<Inputs>

=over 2

=item * I<disk>  =>   B<string, optional>

=begin html

<br>Get status for given disk, if not supplied, get status for all disks owned by the system and its CFO partner.

=end html

=back



=over 2

=item * I<ownership-type>  =>   B<string, optional>

=begin html

<br>This field is used to specify which disks/array LUNs are listed. Valid values are 'assigned', 'unassigned' and 'all'. If ownership-type is set to 'assigned' then only assigned disks/array LUNs are returned. If ownership-type is set to 'unassigned' then only unassigned disks/array LUNs are returned. If ownership-type is set to 'all' then both assigned and unassigned disks/array-LUNs are returned. The default is to return assigned disks/array LUNs. Default: 'assigned'.

=end html

=back



B<Outputs>

=over 2

=item * I<disk-details>  =>   B<L<"disk-detail-info">[]>

=begin html

<br>List of disks and their status.

=end html

=back



=head2 disk_release_all_reservations

[B<Family:> ontap-classic]


=begin html

Release reservations on all reserved disks. When invoked from maintenance mode, all reservations are released on all disks until the system is rebooted. When not in maintenance mode, then the system will automatically re-issue reservations for disks it owns. In sanown environment the system will reserve its disks everu 30 seconds.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 disk_remove

[B<Family:> ontap-classic]


=begin html

Remove a spare disk. Removes the specified spare disk from the RAID configuration, spinning the disk down when removal is complete. You can use disk remove to remove a spare disk so that it can be used by another filer (as a replacement for a failed disk or to expand file system space). NOTE: Data ONTAP 7.0 and earlier releases don't indicate failure code properly.

=end html



B<Inputs>

=over 2

=item * I<disk>  =>   B<string>

=begin html

<br>Name of the disk to remove, e.g. "v0.1". On Admin Vserver LIF, this will be disk path name with format of "<Node Name>:Disk Name". e.g. "Filer01:2a.32"

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 disk_replace_start

[B<Family:> ontap-classic]


=begin html

Initiate replacing a file system disk with an appropriate spare disk. Uses Rapid RAID Recovery to copy data from the source file system disk to the destination spare disk. Roles of disks are reversed at the end of that process. The spare disk will replace the file system disk in the RAID group and the file system disk will become a spare. This interface returns as soon as possible while disk replace starts in the background. This process can be observed by polling disk-list-info for this disk and tracking values of elements copy-destination and copy-percent. Note: The operation performs limited error checking. Disk replace starts asynchronously in the background, and it can fail even if ZAPI reports success.

=end html



B<Inputs>

=over 2

=item * I<allow-same-carrier>  =>   B<boolean, optional>

=begin html

<br>Using two disks from one carrier that houses multiple disks in one RAID group is not desirable. If that happens, Data ONTAP initiates a series of disk copy operations to correct that situation. Sometimes, selection of available spare disks makes it impossible to avoid placing two disks from one carrier in one RAID group. Setting this option to true allows placing two disks from one carrier in one RAID group.

=end html

=back



=over 2

=item * I<disk>  =>   B<string>

=begin html

<br>Name of the file system disk to replace.

=end html

=back



=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>Allow replacement-disk to come from the opposite spare pool. Also allow replacement-disk not matching rotational speed of majority of disks in the aggregate.

=end html

=back



=over 2

=item * I<replacement-disk>  =>   B<string>

=begin html

<br>Name of the spare disk to use as a replacement.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 disk_replace_stop

[B<Family:> ontap-classic]


=begin html

Abort disk replace.

=end html



B<Inputs>

=over 2

=item * I<disk>  =>   B<string>

=begin html

<br>Name of the file system disk being replaced.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 disk_sanown_assign

[B<Family:> ontap-classic]


=begin html

Assigns ownership of a disk. The normal usage is when the disk is unowned, or to assign a disk to a pool.

=end html



B<Inputs>

=over 2

=item * I<all>  =>   B<boolean, optional>

=begin html

<br>Assign all unowned visible disks to the specified node. The node parameter is mandatory. No other parameter is allowed with this option.

=end html

=back



=over 2

=item * I<auto>  =>   B<boolean, optional>

=begin html

<br>Auto-assign unowned disks which are on loops where only 1 filer owns the disks and the pool information is the same, to the specified node. The node parameter is mandatory. No other parameter is allowed with this option.

=end html

=back



=over 2

=item * I<checksum>  =>   B<string, optional>

=begin html

<br>Assign checksum type to disk. Option may only be specified on a RAID array LUNs. Possible values: 'block' or 'zoned'.

=end html

=back



=over 2

=item * I<disk>  =>   B<string, optional>

=begin html

<br>Name of disk to assign. Wildcarding for disk string is supported. Either owner or owner-id is mandatory. The node parameter is not allowed with this option.

=end html

=back



=over 2

=item * I<disk-count>  =>   B<integer, optional>

=begin html

<br>Assign specified count of disks

=end html

=back



=over 2

=item * I<disk-type>  =>   B<string, optional>

=begin html

<br>Assign specified type of disk(or set of disks). The disk-count parameter is mandatory. Type of disk: ATA, BSAS, EATA, FCAL, FSAS, LUN, MSATA, SAS, SATA, SCSI, SSD, BSSD, XATA, XSAS, or unknown.

=end html

=back



=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>Force flag need to be set to 'true' if assigning disks which are already owned a Filer. However, if that Filer is up and has put a reservation on the disk, even the force option won't work.

=end html

=back



=over 2

=item * I<node-name>  =>   B<string, optional>

=begin html

<br>Used only with auto or all parameter. It specifies the node to which autoassignment or assignment of all unowned disks must be done.

=end html

=back



=over 2

=item * I<owner>  =>   B<string, optional>

=begin html

<br>Assign disk to specific owner.Either owner or owner-id is mandatory

=end html

=back



=over 2

=item * I<owner-id>  =>   B<integer, optional>

=begin html

<br>Assign disk to specific owner ID (NVRAM ID or serial number). Either owner or owner-id is mandatory Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<pool>  =>   B<integer, optional>

=begin html

<br>Assign disk to specific pool, e.g. '0' or '1'.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 disk_sanown_filer_list_info

[B<Family:> ontap-classic]


=begin html

Get sanown filer information.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<disk-sanown-filer-details>  =>   B<L<"disk-sanown-filer-detail-info">[]>

=begin html

<br>List of filers and their information.

=end html

=back



=head2 disk_sanown_list_info

[B<Family:> ontap-classic]


=begin html

Get sanown disk information. This API is not supported as of Data ONTAP 8.2. Use storage-disk-get-iter instead.

=end html



B<Inputs>

=over 2

=item * I<disk>  =>   B<string, optional>

=begin html

<br>Get ownership status for given disk, if not supplied, get ownership for all disks or if onership-type is supplied, get ownership info for disks of specific type. '6a*' wildcarding is supported.

=end html

=back



=over 2

=item * I<ownership-type>  =>   B<string, optional>

=begin html

<br>Possible values are 'all' which will list all disks. 'unowned' which will list all disks without owners. 'owned' which will list all disks with owners. 'visible' which will list all disks belonging to the local and partner filer. Default is 'all'. If specific disk is specified, ownership-type will be ignored.

=end html

=back



B<Outputs>

=over 2

=item * I<disk-sanown-details>  =>   B<L<"disk-sanown-detail-info">[]>

=begin html

<br>List of disks and their sanown information.

=end html

=back



=head2 disk_sanown_reassign

[B<Family:> ontap-classic]


=begin html

Changes ownership on disks already belonging to an owner.

=end html



B<Inputs>

=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>Force flag need to be set to 'true' if reassigning disks which are owned by another Filer. However, if that Filer is up and has put a reservation on the disk, even the force option won't work. In this case reassign will need to be run on the Filer which owns the disks.

=end html

=back



=over 2

=item * I<new-owner>  =>   B<string, optional>

=begin html

<br>Name of new owner. This form will assign all the disks belonging to the old owner to the specific owner.

=end html

=back



=over 2

=item * I<new-owner-id>  =>   B<integer, optional>

=begin html

<br>ID of new owner. This form will assign all the disks belonging to the old owner to the specific owner ID. Either new-owner or new-owner-id (or both) must be specified. Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<old-owner>  =>   B<string, optional>

=begin html

<br>Name of old owner. This form takes all disks currently belonging to the specific old owner, and reassigns them to a new owner.

=end html

=back



=over 2

=item * I<old-owner-id>  =>   B<integer, optional>

=begin html

<br>ID of old owner. This form takes all disks currently belonging to the specific old owner ID, and reassign them to a new owner. Either old-owner or old-owner-id must be specified, but not both. Range : [0..2^32-1].

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 disk_sanown_remove_ownership

[B<Family:> ontap-classic]


=begin html

Removes ownership information on a disk. Default usage is to remove ownership information for all disks owned by the local node, in maintenance mode.

=end html



B<Inputs>

=over 2

=item * I<all>  =>   B<boolean, optional>

=begin html

<br>If 'true' remove ownership information from all disks. (maintenance mode only)

=end html

=back



=over 2

=item * I<disk-list>  =>   B<disk-name[], optional>

=begin html

<br>List of disks to remove ownership information from. Example: 4a.18 5b.16 switch1:10.126L4

=end html

=back



=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>If 'true' override the RAID checks. Eg: Disk is part of aggregate. Otherwise defaults to false.

=end html

=back



=over 2

=item * I<owner>  =>   B<string, optional>

=begin html

<br>Remove ownership of all disks owned by owner. Either owner or owner-id is mandatory

=end html

=back



=over 2

=item * I<owner-id>  =>   B<integer, optional>

=begin html

<br>Remove ownership of all disks owned by this owner-id (maintenance mode only). Range [0..2^32-1]

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 disk_swap

[B<Family:> ontap-classic]


=begin html

Prepare (quiet) bus for swap. Applies to SCSI disks only. It stalls all I/O on the filer to allow a disk to be physically added or removed from a disk shelf. Typically, this command would be used to allow removal of a failed disk, or of a file system or spare disk that was prepared for removal using the disk fail or disk remove command. Once a disk is physically added or removed from a disk shelf, system I/O will automatically continue. NOTE: It is important to issue the disk swap command only when you have a disk that you want to physically remove or add to a disk shelf, because all I/O will stall until a disk is added or removed from the shelf. This API is not supported in Data ONTAP 8.0 and later.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 disk_unfail

[B<Family:> ontap-classic]


=begin html

Unfail a disk in the broken pool, by clearing its FDR (Failed Disk Registry) entry and unfailing it at the Storage Layer, as necessary. If the "make-spare" option is set to B_TRUE, the disk is returned to the spare pool. Otherwise, label assimilation will bring the disk back according to its on-disk labels, with one of four possible outcomes. 1. Disk becomes a spare. This is the common case. The disk becomes a spare upon unfail, because its parent volume is complete and online. 2. Disk is assimilated into former volume. This is a recovery scenario. The disk is brought back into an existing volume, which may result in this volume coming back online. 3. Disk is assimilated into a new partial volume. This may occur in the rare case that the disk's former volume was destroyed or moved. 4. Disk returned to broken pool. This is the case if a fatal error occurs in process of unfailing the disk.

=end html



B<Inputs>

=over 2

=item * I<disk>  =>   B<string>

=begin html

<br>Name of the disk, e.g. "v0.1". On Admin Vserver LIF, this will be disk path name with format of "<Node Name>:Disk Name". e.g. "Filer01:2a.32"

=end html

=back



=over 2

=item * I<make-spare>  =>   B<boolean, optional>

=begin html

<br>Specify 'true' to force the disk to become a spare upon unfail. Default value is 'false'.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 disk_unswap

[B<Family:> ontap-classic]


=begin html

Undo disk swap and resume service. This API is not supported in Data ONTAP 8.0 and later.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 disk_update_disk_fw

[B<Family:> ontap-classic]


=begin html

Start disk firmware download process to update firmware on disks. This operation is asynchronous, and therefore returns no errors that might occur during the download process. This operation will only update firmware on disks that do not have the latest firmware revision. The firmware revision on the disk can be monitored via the disk-list-info API.

=end html



B<Inputs>

=over 2

=item * I<disk-list>  =>   B<disk-name[], optional>

=begin html

<br>List of disks to be updated. If not specified, all disks are updated. Example: 4a.18 5b.16 switch1:10.126L4

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 disk_zero_spares

[B<Family:> ontap-classic]


=begin html

Set up all non-zeroed spares owned by the filer to start zeroing. This operation is asynchronous, and therefore returns no errors that might occur when the zeroing operation actually starts, which could be several seconds after this API operation completes. Zeroing progress can be monitored via the disk-list-info API. Same can be done using 'storage-disk-get-iter' when requested from Admin Vserver LIF. The "zeroing-percent" element of disk-detail-info is returned if disk zeroing has started, and "is-zeroed" returns TRUE once the zeroing has completed (or, if zeroing wasn't necessary in the first place).

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 ems_autosupport_log

[B<Family:> ontap-classic, vfiler]


=begin html

This API is used by SnapDrive to log SnapDrive specific events occurring on a host system to the the appliance and optionally use the appliance to generate an autosupport message. This event information will be encapsulated in an app.log.x EMS event based on error level. If auto-support is true, an autosupport message will be sent from the filer.

=end html



B<Inputs>

=over 2

=item * I<app-version>  =>   B<string>

=begin html

<br>Version of application invoking the API.

=end html

=back



=over 2

=item * I<auto-support>  =>   B<boolean>

=begin html

<br>If 'true', an AutoSupport message will be generated.

=end html

=back



=over 2

=item * I<category>  =>   B<string>

=begin html

<br>Application defined category of the event.

=end html

=back



=over 2

=item * I<computer-name>  =>   B<string>

=begin html

<br>Host name invoking the API.

=end html

=back



=over 2

=item * I<event-description>  =>   B<string>

=begin html

<br>Description of event to log. An application defined message to log.

=end html

=back



=over 2

=item * I<event-id>  =>   B<integer>

=begin html

<br>ID of event. A user defined event-id, range [0..2^32-2].

=end html

=back



=over 2

=item * I<event-source>  =>   B<string>

=begin html

<br>Name of the application invoking the API.

=end html

=back



=over 2

=item * I<log-level>  =>   B<integer>

=begin html

<br>Log level. Accepted values are 0 for 'emergency', 1 for 'alert', 2 for 'critical', 3 for 'error', 4 for 'warning', 5 for 'notice', 6 for 'info', and 7 for 'debug'.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 ems_invoke



=begin html

Invoke an ems event. This functionality is intended for use in testing syslog parsers or upper level SNMP management software. The event will be forwarded to the ems log at /etc/log/ems and optionally to the syslog or SNMP trap generator. Invoked events in /etc/log/ems will have the attribute 'inv' set to "1". This is to allow auto-support to differentiate between real and invoked events. Syslog entries resulting from invoked events will contain the text "invoked event:" so that they aren't confused with real events. Invoked events by default are only logged to the /etc/log/ems log. To have an event go to the syslog or generate an snmp trap, the 'syslog' and/or 'snmp' flags need to be set.

=end html



B<Inputs>

=over 2

=item * I<event-id>  =>   B<string>

=begin html

<br>Name of the event to invoke. Each ems event has a unique identifier (event-id) that can be used by this api to 'fake' an event. Example event-id's: kern.syslog.msg kern.uptime.filer raid.cksum.replay.nvram raid.cksum.replay.summary raid.fsm.commitStateTransit

=end html

=back



=over 2

=item * I<event-version>  =>   B<integer, optional>

=begin html

<br>If set, specifies the version of the event to invoke. By default, the latest version is used. Accepted values are [1..n]. Event-version is only used when multiple versions of an event exist simultaneously within a given build of ONTAP. Most events have an event-version of 1.

=end html

=back



=over 2

=item * I<params>  =>   B<param[], optional>

=begin html

<br>null

=end html

=back



=over 2

=item * I<severity>  =>   B<string, optional>

=begin html

<br>For events with variable severity, specfies the severity to invoke the event at. Shouldn't be set for events that don't have variable severity. Possible Values: debug info notice warning svc_error node_error svc_fault node_fault

=end html

=back



=over 2

=item * I<snmp>  =>   B<boolean, optional>

=begin html

<br>If set, and event has an SNMP definition, generate SNMP trap for event. Invoked messages by default do not generate SNMP traps.

=end html

=back



=over 2

=item * I<syslog>  =>   B<boolean, optional>

=begin html

<br>If set, and the event has a syslog format definition, forward invoked message to syslog. Invoked messages are by default not forwarded to syslog

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fc_config_adapter_disable

[B<Family:> ontap-classic]


=begin html

Call the corresponding adapter driver disable function to bring the adapter offline. Under some circumstances an adapter can not be put offline. (e.g. when the adapter is being used by the RAID sub-system to provide disks in a volume). In some cases, manual intervention is required. When this happens, an appropriate error messages is returned.

=end html



B<Inputs>

=over 2

=item * I<adapter-name>  =>   B<string>

=begin html

<br>FC adapter name (e.g. 0a)

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fc_config_adapter_enable

[B<Family:> ontap-classic]


=begin html

Call the corresponding adapter driver enable function to bring the adapter online. Under some circumstances an adapter can not be brought online. (e.g. when that adapter is in the UNCONFIGURED state, or when there is no cable attached to the adapter port). When this happens, an appropriate error messages is returned.

=end html



B<Inputs>

=over 2

=item * I<adapter-name>  =>   B<string>

=begin html

<br>FC adapter name (e.g 0a)

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fc_config_list_iter_end

[B<Family:> ontap-classic]


=begin html

Terminate the fc-config-list iteration

=end html



B<Inputs>

=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous fc-config-list-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fc_config_list_iter_next

[B<Family:> ontap-classic]


=begin html

Obtain a list of FC adapter configuration information. Only provides information for adapters that are configurable.

=end html



B<Inputs>

=over 2

=item * I<maximum>  =>   B<integer>

=begin html

<br>Maximum number of entries to retrieve.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous fc-config-list-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * I<adapter-info>  =>   B<L<"fc-config-info">[]>

=begin html

<br>List of adapter information

=end html

=back



=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>This tells you how many records are being returned. When this value is 0, you have retrieved everything.

=end html

=back



=head2 fc_config_list_iter_start

[B<Family:> ontap-classic]


=begin html

Start iteration through the list of adapter configuration information.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>Number of items that have been saved for future retrieval with fc-config-list-iter-next.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag to be used in subsequent iterations.

=end html

=back



=head2 fc_config_set_adapter_fc_type

[B<Family:> ontap-classic]


=begin html

fc-config-set-adapter-fc-type changes the adapter driver and/or configuration state. Each configurable adapter has an adapter-type and adapter-state. The adapter-type indicates which driver is attached to the adapter, the adapter-state indicates what the configuration state of the adapter is. The fc-type is used to modify both the adapter-type and the adapter-state. After setting the adapter fc-type a filer reboot is sometimes needed to make the change effective. Use fc-config-list-info to determine if a filer reboot is needed.

=end html



B<Inputs>

=over 2

=item * I<adapter-name>  =>   B<string>

=begin html

<br>FC adapter name (e.g 0a)

=end html

=back



=over 2

=item * I<fc-type>  =>   B<string>

=begin html

<br>Sets the type and state of the adapter. Possible inputs:<br> &nbsp; "unconfigured" - set adapter-type to "initiator" and adapter-state to UNCONFIGURED<br> &nbsp; "initiator" - set adapter-type to "initiator" and adapter-state to CONFIGURED<br> &nbsp; "target" - set adapter-type to "target" and adapter-state to CONFIGURED<br> &nbsp; "vi" - set adapter-type to "vi" and adapter-state to CONFIGURED<br>

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fcp_adapter_clear_partner

[B<Family:> ontap-classic]


=begin html

Removes the name of the partner adapter which the local adapter should takeover. Partner adapter setting is obsolete and this operation is no longer supported.

=end html



B<Inputs>

=over 2

=item * I<fcp-adapter>  =>   B<string>

=begin html

<br>Local FC adapter.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fcp_adapter_config_down

[B<Family:> ontap-classic]


=begin html

Bring a Fibre Channel target adapter offline. The adapter may not be offline immediately after the call returns, it may take up to a few seconds for the adapter to change state. In Data ONTAP 7-Mode, if the FCP service is not running then all adapters are automatically offlined. They cannot be brought online again until FCP service is started. adapter to change state. In Data ONTAP Cluster-Mode, offlining an adapter will operationally disable all FCP logical interfaces (LIFs) hosted by the adapter.

=end html



B<Inputs>

=over 2

=item * I<fcp-adapter>  =>   B<string>

=begin html

<br>FC adapter to bring offline.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fcp_adapter_config_media_type

[B<Family:> ontap-classic]


=begin html

Sets the link type on the Fibre Channel target adapter. It can be configured to establish a point-to-point link, a loop configuration or to automatically sense whether the connection type is a point-to-point or loop link. Setting the link to point-to-point in a loop configuration can prevent the loop from coming up properly. If the adapter is online, it must be brought offline and then online in order for a new mediatype to take effect. This may temporarily disrupt fcp service on the target adapter.

=end html



B<Inputs>

=over 2

=item * I<fcp-adapter>  =>   B<string>

=begin html

<br>FC adapter to bring offline.

=end html

=back



=over 2

=item * I<media-type>  =>   B<string>

=begin html

<br>Media type to set. Valid values are point-to-point ("ptp"), loop configuration ("loop"), or automatic ("auto").

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fcp_adapter_config_up

[B<Family:> ontap-classic]


=begin html

Bring a Fibre Channel target adapter online. The adapter may not be online immediately after the call returns, it may take up to a few seconds for the adapter to initialize. In Data ONTAP 7-Mode, if the FCP service is not running then all adapters are automatically offlined. They cannot be brought online again until FCP service is started. In Data ONTAP Cluster-Mode, offlining an adapter will operationally disable all FCP logical interfaces (LIFs) hosted by the adapter.

=end html



B<Inputs>

=over 2

=item * I<fcp-adapter>  =>   B<string>

=begin html

<br>FC adapter to bring online.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fcp_adapter_initiators_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Get the list of initiators currently connected to the specified Fibre Channel target adapter, or if none specified, a list of initiators connected to any FC target adapter. Information returned for each initiator includes the portname of initiators that are currently logged in with the the FC target adapters. If the portname is in an initiator group, then the group name is also included. Also the Fibre Channel host address and the nodename/portname of the initiators are included as well. Connectivity of adapters running on behalf of partners are not included in the list when requesting for all adapters. If listing for all adapters and an error occurred for while retrieving connection status for an adapter, status for that adapter will not be returned, and the API will continue on with the rest of the adapters without erroring out. You can get the error msg for that adapter, by specifically specifying that adapter.

=end html



B<Inputs>

=over 2

=item * I<fcp-adapter>  =>   B<string, optional>

=begin html

<br>Adapter to get initiator list for. If no adapter is specified, information is returned for all initiators connected through any fcp adapter in the system.

=end html

=back



B<Outputs>

=over 2

=item * I<fcp-adapters>  =>   B<L<"fcp-adapter-initiators-info">[]>

=begin html

<br>A list of FC adapters containing list of initiators and their aliases.

=end html

=back



=head2 fcp_adapter_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Gets information such as nodename/portname and link state about the specified Fibre Channel target adapter, or if no adapter is specified, about all the FC target adapters.

=end html



B<Inputs>

=over 2

=item * I<fcp-adapter>  =>   B<string, optional>

=begin html

<br>FC target Adapter to get config information for. If no adapter is specified, information is returned for all FC target Adapters.

=end html

=back



=over 2

=item * I<partner-only>  =>   B<boolean, optional>

=begin html

<br>This field is obsolete and no longer used beginning with Data ONTAP 8.0.

=end html

=back



=over 2

=item * I<verbose>  =>   B<boolean, optional>

=begin html

<br>If specified with "true", additional adapter info is returned. Look at description of output for what additions.

=end html

=back



B<Outputs>

=over 2

=item * I<fcp-config-adapters>  =>   B<L<"fcp-config-adapter-info">[]>

=begin html

<br>List of adapter configuration information.

=end html

=back



=head2 fcp_adapter_nameserver_list_iter_end

[B<Family:> ontap-classic, vfiler]


=begin html

Terminate a list iteration and clean up any saved info.

=end html



B<Inputs>

=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous fcp-adapter-nameserver-list-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fcp_adapter_nameserver_list_iter_next

[B<Family:> ontap-classic, vfiler]


=begin html

Return items from a previous call to fcp-adapter-nameserver-list-iter-start Information returned for each nameserver entry include the port identifier, port type, port name, node name, symbolic port name, symbolic node name, fabric port name, class of service, and registered FC4 types.

=end html



B<Inputs>

=over 2

=item * I<maximum>  =>   B<integer>

=begin html

<br>The maximum number of entries to retrieve.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous fcp-adapter-nameserver-list-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * I<fcp-adapter-nameserver-objects>  =>   B<L<"fcp-adapter-nameserver-object-info">[]>

=begin html

<br>List of nameserver objects.

=end html

=back



=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>This tells you how many records are being returned from this particular call to fcp-adapter-nameserver-list-iter-next When this value is 0, you have retrieved everything.

=end html

=back



=head2 fcp_adapter_nameserver_list_iter_start

[B<Family:> ontap-classic, vfiler]


=begin html

Get the fabric nameserver objects the results of which are retreived by using fcp-adapter-nameserver-list-iter-next. Connectivity of adapters running on behalf of partners are not included in the list when requesting for all adapters. If listing for all adapters and an error occurs while retrieving connection status for an adapter, status for that adapter will not be returned and the API will continue on with the rest of the adapters without erroring out. You can get the error msg for that adapter, by specifically specifying that adapter.

=end html



B<Inputs>

=over 2

=item * I<fcp-adapter>  =>   B<string, optional>

=begin html

<br>Adapter to get nameserver objects for. If no adapter is specified, information is returned for all fcp adapter.

=end html

=back



=over 2

=item * I<zoned>  =>   B<boolean, optional>

=begin html

<br>If true, returns only devices that are zoned to the target adapter. Otherwise, all devices in the fabric are returned. Default is false.

=end html

=back



B<Outputs>

=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>Number which tells you how many items have been saved for future retrieval with fcp-adapter-nameserver-list-iter-next.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag to be used in subsequent calls to fcp-adapter-nameserver-list-iter-next.

=end html

=back



=head2 fcp_adapter_reset_stats

[B<Family:> ontap-classic]


=begin html

Resets the stats for the specified Fibre Channel Target Adapter. If none specified, reset stats for all FC adapters.

=end html



B<Inputs>

=over 2

=item * I<fcp-adapter>  =>   B<string, optional>

=begin html

<br>FC Target adapter.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fcp_adapter_set_partner

[B<Family:> ontap-classic]


=begin html

Sets the name of the partner adapter which the local adapter should takeover. Partner adapter setting is obsolete and this operation is no longer supported.

=end html



B<Inputs>

=over 2

=item * I<fcp-adapter>  =>   B<string>

=begin html

<br>Local FC adapter.

=end html

=back



=over 2

=item * I<partner-adapter>  =>   B<string>

=begin html

<br>Partner FC adapter to takeover.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fcp_adapter_set_speed

[B<Family:> ontap-classic]


=begin html

Sets the speed on the Fibre Channel target adapter. It can be configured to run at 1Gb, 2Gb, 4Gb, or to autonegotiate. Note only 4Gb adapters support the 4Gb speed. If the adapter is online it must be brought offline before setting the speed, and then online in order for a new speed to take effect. This may temporarily disrupt fcp service on the target adapter.

=end html



B<Inputs>

=over 2

=item * I<fcp-adapter>  =>   B<string>

=begin html

<br>FC Target adapter

=end html

=back



=over 2

=item * I<speed>  =>   B<string>

=begin html

<br>Link speed (in Gb). Possible values: "1", "2", "4", or "auto" (autonegotiate speed).

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fcp_adapter_stats_list_info

[B<Family:> ontap-classic]


=begin html

Get statistics about the Fibre Channel target adapters. Statistics of adapters running on behalf of partners are not included in the list when requesting stats for all adapters. If listing stats for all adapters and an error occurred for while retrieving stats for an adapter, stats for that adapter will not be returned, and the API will continue on with the rest of the adapters without erroring out. You can get the error msg for that adapter, by specifically specifying that adapter.

=end html



B<Inputs>

=over 2

=item * I<fcp-adapter>  =>   B<string, optional>

=begin html

<br>FC target Adapter. If no adapter is specified, stats for all adapters are retruned.

=end html

=back



B<Outputs>

=over 2

=item * I<fcp-adapter-stats>  =>   B<L<"fcp-adapter-stats-info">[]>

=begin html

<br>List of statistics for FC adapters.

=end html

=back



=head2 fcp_adapter_topology_list_iter_end

[B<Family:> ontap-classic, vfiler]


=begin html

Terminate a list iteration and clean up any saved info.

=end html



B<Inputs>

=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous fcp-adapter-topology-list-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fcp_adapter_topology_list_iter_next

[B<Family:> ontap-classic, vfiler]


=begin html

Return items from a previous call to fcp-adapter-topology-list-iter-start Information returned for each switch includes the nodename, logical name, domain identifier, vendor, release version, and port information. If a port has devices attached to it, then information about each attached device is included as well.

=end html



B<Inputs>

=over 2

=item * I<maximum>  =>   B<integer>

=begin html

<br>The maximum number of entries to retrieve.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous fcp-adapter-topology-list-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * I<fcp-adapter-topology-switches>  =>   B<L<"fcp-adapter-topology-switch-info">[]>

=begin html

<br>Information about the connected FC switch.

=end html

=back



=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>This tells you how many records are being returned from this particular call to fcp-adapter-topology-list-iter-next When this value is 0, you have retrieved everything.

=end html

=back



=head2 fcp_adapter_topology_list_iter_start

[B<Family:> ontap-classic, vfiler]


=begin html

Get the fabric topology for one or more switches the results of which are retreived by using fcp-adapter-topology-list-iter-next. Connectivity of adapters running on behalf of partners are not included in the list when requesting for all adapters. If listing for all adapters and an error occurrs while retrieving connection status for an adapter, information for that adapter will not be returned and the API will continue on with the rest of the adapters without erroring out. You can get the error msg for that adapter, by specifically specifying that adapter.

=end html



B<Inputs>

=over 2

=item * I<fcp-adapter>  =>   B<string, optional>

=begin html

<br>Adapter to get topology information for. If no adapter is specified, information is returned for all fcp adapter.

=end html

=back



=over 2

=item * I<verbose>  =>   B<boolean, optional>

=begin html

<br>If true, returns verbose information including port information about each switch in the fabric. Default is true.

=end html

=back



=over 2

=item * I<zoned>  =>   B<boolean, optional>

=begin html

<br>If true, returns only devices in the fabric that are zoned to the target adapter. Default is false.

=end html

=back



B<Outputs>

=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>Number which tells you how many items have been saved for future retrieval with fcp-adapter-topology-list-iter-next.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag to be used in subsequent calls to fcp-adapter-topology-list-iter-next.

=end html

=back



=head2 fcp_adapter_zone_list_iter_end

[B<Family:> ontap-classic, vfiler]


=begin html

Terminate a list iteration and clean up any saved info.

=end html



B<Inputs>

=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous fcp-adapter-zone-list-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fcp_adapter_zone_list_iter_next

[B<Family:> ontap-classic, vfiler]


=begin html

Return items from a previous call to fcp-adapter-zone-list-iter-start Information returned for each zone entry include the active zone set name, the zone name, and the zone members.

=end html



B<Inputs>

=over 2

=item * I<maximum>  =>   B<integer>

=begin html

<br>The maximum number of entries to retrieve. Range: [0..2^32-1]

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous fcp-adapter-zone-list-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * I<fcp-adapter-zones>  =>   B<L<"fcp-adapter-zone-info">[]>

=begin html

<br>List of zone entries.

=end html

=back



=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>This tells you how many records are being returned from this particular call to fcp-adapter-zone-list-iter-next When this value is 0, you have retrieved everything. Range: [0..2^32-1]

=end html

=back



=head2 fcp_adapter_zone_list_iter_start

[B<Family:> ontap-classic, vfiler]


=begin html

Get the active zone set information from the zone server. The results can then be retreived by using fcp-adapter-zone-list-iter-next. Connectivity of adapters running on behalf of partners is not included in the list when requesting for all adapters. If listing for all adapters and an error occurs while retrieving connection status for an adapter, status for that adapter will not be returned and the API will continue on with the rest of the adapters without erroring out. You can get the error msg for that adapter, by specifically specifying that adapter.

=end html



B<Inputs>

=over 2

=item * I<fcp-adapter>  =>   B<string, optional>

=begin html

<br>Adapter to get zone information for. If no adapter is specified, information is returned for all fcp adapter.

=end html

=back



B<Outputs>

=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>Number which tells you how many items have been saved for future retrieval with fcp-adapter-zone-list-iter-next. Range: [0..2^32-1]

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag to be used in subsequent calls to fcp-adapter-zone-list-iter-next.

=end html

=back



=head2 fcp_get_cfmode

[B<Family:> ontap-classic]


=begin html

Get the current cfmode setting for the system.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<fcp-cfmode>  =>   B<string>

=begin html

<br>Current FCP cfmode setting. Possible values: single_image, unknown

=end html

=back



=head2 fcp_node_get_name

[B<Family:> ontap-classic]


=begin html

Get the current FCP World Wide Node Name (WWNN). This WWNN name is in the form XX:XX:XX:XX:XX:XX:XX:XX where X is a hexadecimal digit. In Data ONTAP 7-Mode, this is the WWNN of the individual storage system. In "single_image" cfmode, the WWNN of the system and its high availability partner will be the same. In Data ONTAP Cluster-Mode, this is the WWNN of the Vserver FCP Service.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<node-name>  =>   B<string>

=begin html

<br>Current FCP World Wide Node Name (WWNN).

=end html

=back



=head2 fcp_node_set_name

[B<Family:> ontap-classic]


=begin html

Set the current FCP World Wide Node Name (WWNN). This WWNN is in the form XX:XX:XX:XX:XX:XX:XX:XX where X is a hexadecimal digit. The supplied WWNN must also match the vendor's registered namespace unless the force argument is also supplied. In Data ONTAP 7-Mode, the registered namespace is "50:0a:80:8X:XX:XX:XX" and all Fibre Channel adapters must be offline. Changes will take place when the adapters are brought online. In Data ONTAP Cluster-Mode, the registered namespace is "2X:XX:00:a0:98:XX:XX:XX" and the FCP service must be offline. Changes will take place when the service is brought online.

=end html



B<Inputs>

=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>If true, allow setting the WWNN to a value outside the vendor's registered namespace for the current mode. If false or not present, the request will fail unless the supplied WWNN is inside the correct namespace.

=end html

=back



=over 2

=item * I<node-name>  =>   B<string>

=begin html

<br>FCP World Wide Node Name.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fcp_ping

[B<Family:> ontap-classic]


=begin html

Send an ELS ECHO frame to a Fibre Channel address or WWPN. EHOSTNOTFOUND is returned if the WWPN cannot be resolved. EONTAPI_EHOSTDOWN is returned if the address cannot be pinged.

=end html



B<Inputs>

=over 2

=item * I<fcp-adapter>  =>   B<string>

=begin html

<br>Adapter to send the ping request from.

=end html

=back



=over 2

=item * I<payload>  =>   B<string, optional>

=begin html

<br>Additional data to send in the payload of the ELS ECHO frame. The payload can be up to 255 characters long.

=end html

=back



=over 2

=item * I<port-id-or-wwpn>  =>   B<string>

=begin html

<br>The Fibre Channel address or the WWPN to ping. The format of a Fibre channel address is a hexadecimal or numeric value with the range [0..2^24-1]. The format of a WWPN is XX:XX:XX:XX:XX:XX:XX:XX where X is a hexadecimal digit.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fcp_ping_info

[B<Family:> ontap-classic]


=begin html

Send an ELS ECHO frame to a Fibre Channel address or WWPN. The API pings the address or WWPN count times and returns the number of successful pings and times. EHOSTNOTFOUND is returned if the WWPN cannot be resolved. EONTAPI_EHOSTDOWN is returned if the address cannot be pinged. The interval between ping attempts is 1 second.

=end html



B<Inputs>

=over 2

=item * I<fcp-adapter>  =>   B<string>

=begin html

<br>Adapter to send the ping request from.

=end html

=back



=over 2

=item * I<payload>  =>   B<string, optional>

=begin html

<br>Additional data to send in the payload of the ELS ECHO frame. The payload can be up to 255 characters long.

=end html

=back



=over 2

=item * I<ping-count>  =>   B<integer, optional>

=begin html

<br>The number of pings. Default is 3. Range: [1..16]

=end html

=back



=over 2

=item * I<port-id-or-wwpn>  =>   B<string>

=begin html

<br>The Fibre Channel address or the WWPN to ping. The format of a Fibre channel address is a hexadecimal or numeric value with the range [0..2^24-1]. The format of a WWPN is XX:XX:XX:XX:XX:XX:XX:XX where X is a hexadecimal digit.

=end html

=back



B<Outputs>

=over 2

=item * I<frames-received>  =>   B<integer, optional>

=begin html

<br>The number of frames received. The number of frames lost is the frames-transmitted minus frames-received. Range: [0..16]

=end html

=back



=over 2

=item * I<frames-transmitted>  =>   B<integer, optional>

=begin html

<br>Number of frames transmitted. Should be equal to ping-count. Range: [1..16]

=end html

=back



=over 2

=item * I<round-trip-maximum-time>  =>   B<integer, optional>

=begin html

<br>Maximum time in microseconds for a round trip between the target adapter and the destination if frames-received is greater than zero. Range: [0..2^31-1]

=end html

=back



=over 2

=item * I<round-trip-mean-time>  =>   B<integer, optional>

=begin html

<br>Mean time in microseconds for a round trip between the target adapter and the destination if frames-received is greater than zero. Range: [0..2^31-1]

=end html

=back



=over 2

=item * I<round-trip-minimum-time>  =>   B<integer, optional>

=begin html

<br>Minimum time in microseconds for a round trip between the target adapter and the destination if frames-received is greater than zero. Range: [0..2^31-1]

=end html

=back



=head2 fcp_port_name_list_info

[B<Family:> ontap-classic]


=begin html

Get the list of valid Fibre Channel target port names on a filer's local adapters. The filer needs to be in standby or single_image cfmode.

=end html



B<Inputs>

=over 2

=item * I<verbose>  =>   B<boolean, optional>

=begin html

<br>If specified with "true", unused port names are also reported. Default value is "false".

=end html

=back



B<Outputs>

=over 2

=item * I<fcp-port-names>  =>   B<L<"fcp-port-name-info">[]>

=begin html

<br>List of valid local port names and associated adapters.

=end html

=back



=head2 fcp_port_name_set

[B<Family:> ontap-classic]


=begin html

Set a valid but unused port name on a Fibre Channel target interface.

=end html



B<Inputs>

=over 2

=item * I<fcp-adapter>  =>   B<string>

=begin html

<br>FCP target interface to set the WWPN on. In Data ONTAP 7-Mode, the name of a local adapter in standby single_image cfmode. In Data ONTAP Cluster-Mode, the name of an FCP data LIF in the vserver.

=end html

=back



=over 2

=item * I<port-name>  =>   B<string>

=begin html

<br>WWPN to be set on the interface. It has to be a valid and unused one.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fcp_port_name_swap

[B<Family:> ontap-classic]


=begin html

Swap port names of two local Fibre Channel target adapters.

=end html



B<Inputs>

=over 2

=item * I<fcp-adapter-1>  =>   B<string>

=begin html

<br>One of the adapters to swap their port names. It has to be a local adapter in standby or single_image cfmode.

=end html

=back



=over 2

=item * I<fcp-adapter-2>  =>   B<string>

=begin html

<br>One of the adapters to swap their port names. It has to be a local adapter in standby or single_image cfmode.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fcp_service_start

[B<Family:> ontap-classic]


=begin html

Starts FCP service. When FCP service is started, the adapters are brought online. Service will be avaliable once the call returns with success. The adapters however, may not be available immediately after the call, it may take up to a few seconds for the adapters to initialize.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fcp_service_status

[B<Family:> ontap-classic]


=begin html

Get status of the FCP service, whether or not it is running.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<is-available>  =>   B<boolean>

=begin html

<br>"true" if FCP service is running, "false" otherwise.

=end html

=back



=head2 fcp_service_stop

[B<Family:> ontap-classic]


=begin html

Stops FCP service. When FCP service is stopped, the adapters are brought offline. Service will be unavaliable once the call returns with success.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fcp_set_cfmode

[B<Family:> ontap-classic]


=begin html

Set the current cfmode setting for the system. This setting controls how the cluster behaves during a takeover/giveback. It also controls if the filer should use multiple virtual target adapters per physical target adapter. fcp service must be stopped before executing this API. The only valid value for cfmode is 'single_image' If cfmode is set to 'single_image' the filer connects to the FC fabric in ptp mode by default but is configurable, and all luns in the cluster are visible on all FC target ports. In this mode all hosts require multipathing software. When setting the cfmode to 'single_image' configuration checks are performed. If these checks fail an EPERM error will be returned. See the lun-config-check-single-image-info API for more information.

=end html



B<Inputs>

=over 2

=item * I<fcp-cfmode>  =>   B<string>

=begin html

<br>Set current cfmode setting. Possible values: single_image

=end html

=back



=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>Forcibly change the cfmode, overriding cluster partner checks. Obsolete.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fcp_wwpnalias_get_alias_info

[B<Family:> ontap-classic, vfiler]


=begin html

Get the list of WWPN for a given alias or an alias for for a given WWPN or complete list of all current alias- WWPN mappings.

=end html



B<Inputs>

=over 2

=item * I<alias>  =>   B<string, optional>

=begin html

<br>Alias for a WWPN is the 32-character alias that may contain A-Z, a-z, 0-9, _,-,.,{,} and no spaces. When supplied, the alias with the corresponding WWPN will be returned. Otherwise, all aliases with their WWPNs present in the system will be returned.

=end html

=back



=over 2

=item * I<wwpn>  =>   B<string, optional>

=begin html

<br>WWPN for which all aliases will be returned. When supplied all aliases for that WWPN will be returned. Otherwise, all aliases with their WWPNs present in the system will be returned.

=end html

=back



B<Outputs>

=over 2

=item * I<aliases>  =>   B<L<"aliases-info">[]>

=begin html

<br>A list of alias-WWPN mappings

=end html

=back



=head2 fcp_wwpnalias_remove

[B<Family:> ontap-classic]


=begin html

Remove an alias for a World Wide Port Name of an initiator. Either the alias or the wwpn argument must be provided.

=end html



B<Inputs>

=over 2

=item * I<alias>  =>   B<string, optional>

=begin html

<br>WWPN Alias to be removed. Either the alias or the wwpn argument must be provided.

=end html

=back



=over 2

=item * I<wwpn>  =>   B<string, optional>

=begin html

<br>WWPN for which all aliases are to be removed. Either the wwpn or the alias argument must be provided.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fcp_wwpnalias_set

[B<Family:> ontap-classic]


=begin html

Set an alias for a World Wide Port Name of an initiator that might login to the target.

=end html



B<Inputs>

=over 2

=item * I<alias>  =>   B<string>

=begin html

<br>Alias to be set for the given WWPN ("wwpn"); The alias can be 32-characters long and may contain: A-Z, a-z, 0-9, _,-,.,{,} and no spaces

=end html

=back



=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>When set to true, the WWPN associated with the alias will be over-written. Default value is false.

=end html

=back



=over 2

=item * I<wwpn>  =>   B<string>

=begin html

<br>WWPN for which alias is being set

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fcport_get_link_state

[B<Family:> ontap-classic]


=begin html

Get the link state of a specific adapter on this system.

=end html



B<Inputs>

=over 2

=item * I<adapter-name>  =>   B<string>

=begin html

<br>The adapter name is either a slot number, or, if a port letter is also presented, a slot number and port letter concatenated into a single name -- for example, "8a" or "11b". If adapter-name is not supplied, the command will return EAPIMISSINGARGUMENT.

=end html

=back



B<Outputs>

=over 2

=item * I<adapter-link-state>  =>   B<L<"link-state-info">[]>

=begin html

<br>adapter link state info

=end html

=back



=over 2

=item * I<adapter-name>  =>   B<string>

=begin html

<br>The adapter name is either a slot number, or, if a port letter is also presented, a slot number and port letter concatenated into a single name.

=end html

=back



=head2 fcport_reset_dev

[B<Family:> ontap-classic]


=begin html

When invoked the device will be reset. The device will be temporarily suspended while it is reset, after which it will resume processing device operations. This command should be used with care as it can have adverse effects, for instance pending commands to the device will be aborted when issuing this command.

=end html



B<Inputs>

=over 2

=item * I<device-id>  =>   B<string>

=begin html

<br>The device id is presented as a slot number followed by the port letter concatenated with the device-id. These two parts are separated by a period. For example 6b.5 If the device-id is omitted EAPIMISSINGARGUMENT will be returned. If the device-id is invalid EINVALIDINPUTERROR will be returned.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fcport_send_lip

[B<Family:> ontap-classic]


=begin html

This will initiate a loop initialization on the specified fibrechannel loop port. The loop will be temporarily suspended while it is initialized, after which it will resume processing loop operations. This command should be used with care, because it can have adverse effects, like pending commands will be aborted when issuing this command.

=end html



B<Inputs>

=over 2

=item * I<loop-id>  =>   B<string>

=begin html

<br>The loop id is presented as a slot number and port letter concatenated (for example 6a). If the loop-id is omitted EAPIMISSINGARGUMENT will be returned. If the loop-id is invalid EINVALIDINPUTERROR will be returned.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fcport_set_offline

[B<Family:> ontap-classic]


=begin html

Offline a specific adapter on this system. This API should be used with care, as it can have adverse side effects, which you lose access to all devices of that port. The operation of offlining the already offlined adapter will be considered success.

=end html



B<Inputs>

=over 2

=item * I<adapter-name>  =>   B<string>

=begin html

<br>The adapter name is either a slot number, or, if a port letter is also presented, a slot number and port letter concatenated into a single name -- for example, "8a" or "11b". If adapter-name is not supplied, the command will return EAPIMISSINGARGUMENT.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fcport_set_online

[B<Family:> ontap-classic]


=begin html

Online a specific adapter on this system. The operation of onlining the already onlined adapter will be considered success.

=end html



B<Inputs>

=over 2

=item * I<adapter-name>  =>   B<string>

=begin html

<br>The adapter name is either a slot number, or, if a port letter is also presented, a slot number and port letter concatenated into a single name -- for example, "8a" or "11b". If adapter-name is not supplied, the command will return EAPIMISSINGARGUMENT.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 feature_status_list_info

[B<Family:> ontap-classic]


=begin html

Returns status information for managed features.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<managed-feature-status-list>  =>   B<L<"managed-feature-status-info">[]>

=begin html

<br>An array, one entry per each managed feature.

=end html

=back



=head2 file_create_directory

[B<Family:> ontap-classic, vfiler]


=begin html

Create a directory.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the directory to be created. The value is expected to begin with /vol/<volumename>.

=end html

=back



=over 2

=item * I<perm>  =>   B<string>

=begin html

<br>Permission of the directory to be created. It's similar to Unix style permission bits: 0755 gives read/write/execute permissions to owner and read/execute to group and other users. It consists of 4 octal digits derived by adding up bits 4, 2 and 1. Omitted digits are assumed to be zeros. First digit selects the set user ID(4), set group ID (2) and sticky (1) attributes. The second digit selects permission for the owner of the file: read (4), write (2) and execute (1); the third selects permissions for other users in the same group; the fourth for other users not in the group. Note: Prior to Data ONTAP 7.3.1 this value was treated as a base-10 number.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 file_create_symlink

[B<Family:> ontap-classic, vfiler]


=begin html

Create a symlink.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the symlink file to create. The value is expected to begin with /vol/<volumename>.

=end html

=back



=over 2

=item * I<symlink>  =>   B<string>

=begin html

<br>Value of the symlink.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 file_delete_directory

[B<Family:> ontap-classic, vfiler]


=begin html

Delete a directory.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the directory to delete. The value is expected to begin with /vol/<volumename>. The directory must be empty in order for this API to succeed.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 file_delete_file

[B<Family:> ontap-classic, vfiler]


=begin html

Delete a file.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the file or symlink to delete. The value is expected to begin with /vol/<volumename>.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 file_get_file_info

[B<Family:> ontap-classic, vfiler]


=begin html

Obtains the file information or properties.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Pathname of the directory to list. The value is expected to begin with /vol/<volumename>.

=end html

=back



B<Outputs>

=over 2

=item * I<file-info>  =>   B<L<"file-info">>

=begin html

<br>File information from the stat() function.

=end html

=back



=head2 file_get_fingerprint

[B<Family:> ontap-classic, vfiler]


=begin html

Get the fingerprint or digest of a file. Fingerprint is calculated using md5 or sha-256 digest algorithm depending on the algorithm specified. Fingerprint is calculated over the file data or metadata or on both data and metadata depending on the scope selected. Data fingerprint is calculated over file contents. Metadata fingerprint is calculated over the selected attributes of the file. Attributes used for metadata fingerprint calculations are file type (file-type), file size (file-size), file crtime (creation-time), file mtime (modified-time), file ctime (changed-time), file retention time (retention-time, is-wraparound), file uid (owner-id), file gid (group-id). File retention time is applicable to worm protected files only. The fingerprints are base64 encoded.

=end html



B<Inputs>

=over 2

=item * I<fingerprint-algorithm>  =>   B<digest-algorithm>

=begin html

<br>null

=end html

=back



=over 2

=item * I<fingerprint-scope>  =>   B<file-scope>

=begin html

<br>null

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Full path of the file to be fingerprinted. The value is expected to begin with /vol/<volumename>.

=end html

=back



B<Outputs>

=over 2

=item * I<fingerprint>  =>   B<L<"fingerprint-info">>

=begin html

<br>Fingerprint, system, volume and file related information.

=end html

=back



=head2 file_get_space_reservation_info

[B<Family:> ontap-classic, vfiler]


=begin html

Queries the space reservation settings for the named file.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>File to be queried.

=end html

=back



B<Outputs>

=over 2

=item * I<is-fill-enabled>  =>   B<boolean>

=begin html

<br>Whether or not the file is set with fill.

=end html

=back



=over 2

=item * I<is-overwrite-enabled>  =>   B<boolean>

=begin html

<br>Whether or not the file is set with overwrite.

=end html

=back



=head2 file_inode_info

[B<Family:> ontap-classic, vfiler]


=begin html

Get parent information for a given inode. <p> This API corresponds to the "inodepath" diagnostic-level CLI in ONTAP-Classic, and has the same defaults. </p> <p> The input is:<ul> <li>Required, a volume identifier. A volume may be specified by name, fsid, or (in some ONTAP products) UUID/DSID.</li> <li>Required, an inode number.</li> <li>Optional, a snapshot identifier to get information from a snapshot rather than the active volume. A snapshot may be specified by name or by id.</li> <li>Optional, various reporting flags (see below) to enable or disable optional output information.</li></ul> </p> <p> The output is:<ul> <li>All volume identifiers, the one used as input plus the values of the others.</li> <li>Optionally, all snapshot identifiers; the one used as input plus the value of the other.</li> <li>The number of parents for the inode. </li> <li>Optionally, one or more volume relative pathnames to the inode </li> <li>Optionally, one or more leaf names for the inode. </li> <li>Optionally, one or more of the actual parent info stored for the inode, in the form of the parent dir inode number and the parent directory cookie (fbn and offset into the fbn) used to find the dir entry that refers to the inode in the parent directory (ie. the info used to get the leaf name).</li></ul> </p>

=end html



B<Inputs>

=over 2

=item * I<encoded>  =>   B<boolean, optional>

=begin html

<br>Specifies if non ASCII characters present in the filename will be hex encoded or not. If set to true, then all non-ASCII characters present in the filename are transformed to \XX where XX is the hex equivalent of the character. For example, if the filename has a non-ASCII character whose hex equivalent is 0x5C then the character would be encoded as a three byte sequence of '\','5' and 'C' & returned as "\5C". By default, the value is false.

=end html

=back



=over 2

=item * I<generation>  =>   B<integer, optional>

=begin html

<br>The generation number for this inode. <p> Range: [1..2^32-1]

=end html

=back



=over 2

=item * I<inode-number>  =>   B<integer>

=begin html

<br>The inode number for which information is desired.

=end html

=back



=over 2

=item * I<logical-snap-id>  =>   B<integer, optional>

=begin html

<br>All snapshots are associated with an internal index. "logical-snap-id" is the client-visible index that maps the the underlying internal index. <p> Range: [1..255]. <p>

=end html

=back



=over 2

=item * I<report-cifs-paths>  =>   B<boolean, optional>

=begin html

<br>Flag for indicating if the paths returned should be cifs-paths

=end html

=back



=over 2

=item * I<report-leaf-name>  =>   B<boolean, optional>

=begin html

<br>If set to true, report the leaf name of the given inode. The leaf name is equivalent to the final component of a full pathname. For example, the leaf name of: <p> /vol/vol0/foo/bar/baz <br> is: <br> baz <p> By default, the inode's leaf name is not shown.

=end html

=back



=over 2

=item * I<report-no-pathname>  =>   B<boolean, optional>

=begin html

<br>If set to true, do not report on the given inode's full pathname. By default, the inode's full pathname is reported.

=end html

=back



=over 2

=item * I<report-other-parents>  =>   B<boolean, optional>

=begin html

<br>If set to true, report the requested information for all of the parents for the given inode. By default, only information about one of the given inode's parents is reported.

=end html

=back



=over 2

=item * I<report-parent-data>  =>   B<boolean, optional>

=begin html

<br>If set to true, report various other pieces of information about the given inode. This information includes the inode of the parent directory containing the given inode, along with the directory cookie by which the given inode is known in that parent directory inode. By default, this other information is not reported for the given inode.

=end html

=back



=over 2

=item * I<snap-id>  =>   B<integer, optional>

=begin html

<br>The snapshot number within the given volume in which the given inode is to be referenced. At most, one of snap-id or snap-name can be provided. If neither is provided, we reference the given inode within the active file system of the given volume. Valid snapshot ids have a range of 0 to (WAFL_SNAP_CNT - 1) (currently 255). A value of 0 will refer to the active file system of the given volume. This refers to the physical snapshot identifier.

=end html

=back



=over 2

=item * I<snap-name>  =>   B<string, optional>

=begin html

<br>A snapshot name within the given volume in which the given inode is to be referenced. At most, one of snap-id or snap-name can be provided. If neither is provided, we reference the given inode within the active file system of the given volume.

=end html

=back



=over 2

=item * I<volume-dsid>  =>   B<string, optional>

=begin html

<br>The DSID (Data Set IDentifier) of the volume containing the given inode. Exactly one of volume-fsid, volume-name, volume-uuid or volume-dsid must be specified. <p> DSIDs are formatted as 18-character strings composed of 16 hex characters prefixed with '0x'. NOTE: This form of volume identification is only supported in some ONTAP products (ONTAP-NG).

=end html

=back



=over 2

=item * I<volume-fsid>  =>   B<integer, optional>

=begin html

<br>The FSID (file system identifier) of the volume containing the given inode. Exactly one of volume-fsid, volume-name, volume-uuid, or volume-dsid must be specified. An FSID may have any uint32_t value.

=end html

=back



=over 2

=item * I<volume-name>  =>   B<string, optional>

=begin html

<br>The name of the volume containing the given inode. Exactly one of volume-fsid, volume-name, volume-uuid, or volume-dsid must be specified.

=end html

=back



=over 2

=item * I<volume-uuid>  =>   B<string, optional>

=begin html

<br>The UUID (Universally Unique IDentifier) of the volume containing the given inode. Exactly one of volume-fsid, volume-name, volume-uuid or volume-dsid must be specified. <p> UUIDs are formatted as 36-character strings. These strings are composed of 32 hexadecimal characters broken up into five groupings separated by '-'s. The first grouping has 8 hex characters, the second through fourth groupings have four hex characters each, and the fifth and final grouping has 12 hex characters. Note that a leading '0x' is not used. <p> An example UUID is 532ad684-c8ec-11d9-945f-00065b8c8a1e. NOTE: This form of volume identification is only supported in some ONTAP products (ONTAP-NG).

=end html

=back



B<Outputs>

=over 2

=item * I<inode-number>  =>   B<integer>

=begin html

<br>The number identifying the inode.

=end html

=back



=over 2

=item * I<inode-paths>  =>   B<L<"inode-parent-info">[]>

=begin html

<br>List of requested paths and parent information for the given inode.

=end html

=back



=over 2

=item * I<logical-snap-id>  =>   B<integer, optional>

=begin html

<br>Logical snapshot index. This index maps to the above internal index. Logical index allows users to choose the same snapshot index across all members of a striped volume. This index is also useful for logical volume replication. A logical snapshot index of 0 implies that the snapshot is is not client-visible i.e. this is a un-coordinated snapshot. <p> Range: [0..255]. <p>

=end html

=back



=over 2

=item * I<number-of-parents>  =>   B<integer>

=begin html

<br>The number of parents for the inode. For a file, this is the number of links to the file.

=end html

=back



=over 2

=item * I<snapshot-id>  =>   B<integer, optional>

=begin html

<br>The snapshot id, if requested info is from a snapshot. This is the physical snapshot identifier.

=end html

=back



=over 2

=item * I<snapshot-name>  =>   B<string, optional>

=begin html

<br>The name of the snapshot, if requested info is from a snapshot.

=end html

=back



=over 2

=item * I<volume-dsid>  =>   B<string, optional>

=begin html

<br>The volume DSID.

=end html

=back



=over 2

=item * I<volume-fsid>  =>   B<integer>

=begin html

<br>The volume FSID.

=end html

=back



=over 2

=item * I<volume-name>  =>   B<string>

=begin html

<br>The volume name.

=end html

=back



=over 2

=item * I<volume-uuid>  =>   B<string>

=begin html

<br>The volume UUID.

=end html

=back



=head2 file_list_directory_iter_end

[B<Family:> ontap-classic, vfiler]


=begin html

Terminate a directory iteration.

=end html



B<Inputs>

=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous file-list-directory-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 file_list_directory_iter_next

[B<Family:> ontap-classic, vfiler]


=begin html

Obtain a list of files in a given directory.

=end html



B<Inputs>

=over 2

=item * I<maximum>  =>   B<integer>

=begin html

<br>Maximum number of directory entries to retrieve.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous file-list-directory-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * I<files>  =>   B<L<"file-info">[]>

=begin html

<br>Array with information for each file in the named directory.

=end html

=back



=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>This tells you how many records are being returned from this particular call to file-list-directory-iter-next. When this value is 0, you have retrieved everything.

=end html

=back



=head2 file_list_directory_iter_start

[B<Family:> ontap-classic, vfiler]


=begin html

Start in iteration through the list of files in a given directory.

=end html



B<Inputs>

=over 2

=item * I<encoded>  =>   B<boolean, optional>

=begin html

<br>Specifies if non ASCII characters present in the filename will be hex encoded or not. If set to true, then all non-ASCII characters present in the filename are transformed to \XX where XX is the hex equivalent of the character. For example, if the filename has a non-ASCII character whose hex equivalent is 0x5C then the character would be encoded as a three byte sequence of '\','5' and 'C' & returned as "\5C". By default, the value is false.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Pathname of the directory to list. The value is expected to begin with /vol/<volumename>.

=end html

=back



B<Outputs>

=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>Number of items that have been saved for future retrieval with file-list-directory-iter-next.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag to be used in subsequent iterations.

=end html

=back



=head2 file_punch_hole

[B<Family:> ontap-classic, vfiler]


=begin html

Punch hole in the file. Hole punching involves reclaiming of blocks in a file by unallocating them and then direct or indirect blocks can be made to point to 0.

=end html



B<Inputs>

=over 2

=item * I<hole-info>  =>   B<L<"hole-range-info">[]>

=begin html

<br>This is the array containing the ranges that need to be hole punched. Punching up to 16 holes is supported.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the file. Format must be of the following: /vol/my_vol/path-to-file

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 file_read_file

[B<Family:> ontap-classic, vfiler]


=begin html

Read data from a named file. API will fail if length exceeds 1 MB. This API should only be used on normal files or streams associated with files. The results for other file types such as LUNs is undefined.

=end html



B<Inputs>

=over 2

=item * I<length>  =>   B<integer>

=begin html

<br>Number of bytes to read from the file.

=end html

=back



=over 2

=item * I<offset>  =>   B<integer>

=begin html

<br>Offset into file to start reading from. If the value of offset is beyond the eof, the API will fail with EAPIERROR.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Name of the file to read. For example: "/vol/&lt;volume&gt;/&lt;file&gt;".

=end html

=back



B<Outputs>

=over 2

=item * I<data>  =>   B<string>

=begin html

<br>Data read from the file. The format of the data is ASCII hex characters, two characters representing one byte from the file. (This format allows the representation of 0-valued bytes.)

=end html

=back



=over 2

=item * I<length>  =>   B<integer>

=begin html

<br>Number of bytes actually read from the file. If this value is 0, then you have attempted to read at or past the end of the file.

=end html

=back



=head2 file_read_symlink

[B<Family:> ontap-classic, vfiler]


=begin html

Read the contents of a symlink.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the symlink file to read. The value is expected to begin with /vol/<volumename>.

=end html

=back



B<Outputs>

=over 2

=item * I<symlink>  =>   B<string>

=begin html

<br>Value of the symlink. In other words, this is the destination path contained in the symlink.

=end html

=back



=head2 file_rename_directory

[B<Family:> ontap-classic, vfiler]


=begin html

Rename a directory. Note that this API cannot be used to rename a directory to a different volume.

=end html



B<Inputs>

=over 2

=item * I<from-path>  =>   B<string>

=begin html

<br>Original path of the directory. The value must begin with /vol/<volumename>.

=end html

=back



=over 2

=item * I<to-path>  =>   B<string>

=begin html

<br>Final path of the directory. The value must begin with /vol/<volumename>. All path components except the final directory name must already exist.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 file_set_space_reservation_info

[B<Family:> ontap-classic, vfiler]


=begin html

Sets the space reservation settings for the named file. is-overwrite-enabled and is-fill-enabled both must be the same value.

=end html



B<Inputs>

=over 2

=item * I<is-fill-enabled>  =>   B<boolean, optional>

=begin html

<br>Whether or not to set the file with fill.

=end html

=back



=over 2

=item * I<is-overwrite-enabled>  =>   B<boolean, optional>

=begin html

<br>Whether or not to set the file with overwrite.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>File to be queried.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 file_truncate_file

[B<Family:> ontap-classic, vfiler]


=begin html

Truncate a file. Any data past the truncation point will be lost, of course.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the file to truncate. The value is expected to begin with /vol/<volumename>.

=end html

=back



=over 2

=item * I<size>  =>   B<integer, optional>

=begin html

<br>If provided, the file size in bytes is set to this value. The default value is 0.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 file_usage_get

[B<Family:> ontap-classic]


=begin html

Reports unique bytes held in a file.

=end html



B<Inputs>

=over 2

=item * I<length>  =>   B<integer, optional>

=begin html

<br>Length of the range in bytes. If it is not specified, the range that is reported is from start-offset to end-of-file. Range : [0..2^63-1].

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>File name to generate report: E.g., /vol/vol1/file1

=end html

=back



=over 2

=item * I<start-offset>  =>   B<integer, optional>

=begin html

<br>Start range of file in bytes. If this is not specified, it is assumed to be beginning of file (offset 0). Range : [0..2^63-1].

=end html

=back



B<Outputs>

=over 2

=item * I<total-bytes>  =>   B<integer>

=begin html

<br>Number of bytes held by this file. Range : [0..2^63-1].

=end html

=back



=over 2

=item * I<unique-bytes>  =>   B<integer>

=begin html

<br>Number of bytes 'uniquely' held by this file. Range : [0..2^63-1].

=end html

=back



=head2 file_usage_result_get

[B<Family:> ontap-classic]


=begin html

Used to poll and retrieve results for a previous file-usage-start call. EINPROGRESS indicates that the background job has not finished yet.

=end html



B<Inputs>

=over 2

=item * I<cookie>  =>   B<string>

=begin html

<br>Cookie that was returned in an earlier file-usage-start call.

=end html

=back



B<Outputs>

=over 2

=item * I<total-bytes>  =>   B<integer>

=begin html

<br>Number of bytes held by this file. Range : [0..2^63-1].

=end html

=back



=over 2

=item * I<unique-bytes>  =>   B<integer>

=begin html

<br>Number of bytes 'uniquely' held by this file. Range : [0..2^63-1].

=end html

=back



=head2 file_usage_start

[B<Family:> ontap-classic]


=begin html

Starts a background job to compute unique bytes held in a file. The result can be obtained by passing the cookie to file-usage-result-get call.

=end html



B<Inputs>

=over 2

=item * I<length>  =>   B<integer, optional>

=begin html

<br>Length of the range in bytes. If it is not specified, the range that is reported is from start-offset to end-of-file. Range : [0..2^63-1].

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>File name to generate report: E.g., /vol/vol1/file1

=end html

=back



=over 2

=item * I<start-offset>  =>   B<integer, optional>

=begin html

<br>Start range of file in bytes. If this is not specified, it is assumed to be beginning of file (offset 0). Range : [0..2^63-1].

=end html

=back



B<Outputs>

=over 2

=item * I<cookie>  =>   B<string>

=begin html

<br>Cookie to be used with subsequent file-usage-result-get call.

=end html

=back



=head2 file_write_file

[B<Family:> ontap-classic, vfiler]


=begin html

Write data into a named file. If the file/stream does not previously exist, it will be created - the owner of the file will be root and it will not be readable or writable by non-root users. API will fail if data exceeds 1 MB. This API should only be used on normal files or streams associated with files.. The results for other file types such as LUNs is undefined.

=end html



B<Inputs>

=over 2

=item * I<data>  =>   B<string>

=begin html

<br>Data to be written. The format of the data is ASCII hex characters, two characters representing one byte. Whitespace characters, for convenience in formatting, can be present in the value and are ignored.

=end html

=back



=over 2

=item * I<offset>  =>   B<integer>

=begin html

<br>Offset into file at which to start writing. If the offset is -1, the data is appended to the file. The valid maximum value for (offset + data length) is the maximum total file size which is Data ONTAP version and file system dependent. If the value of the (offset + data length) is beyond the maximum total file size, the API will fail with EAPIERROR.

=end html

=back



=over 2

=item * I<overwrite>  =>   B<boolean, optional>

=begin html

<br>If false, and the file already exists, then the API will fail, with an errno of EEXIST. This allows the client to ensure that it was the exclusive creator of the file. The default value is true.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Pathname of the file to write. For example: "/vol/&lt;volume&gt;/&lt;file&gt;".

=end html

=back



B<Outputs>

=over 2

=item * I<length>  =>   B<integer>

=begin html

<br>Number of bytes actually written.

=end html

=back



=head2 flash_device_list_info

[B<Family:> ontap-classic]


=begin html

This API is used to retrieve information about the flash devices in the controller registered with Flash Management Module (FMM).

=end html



B<Inputs>

=over 2

=item * I<slot-number>  =>   B<integer, optional>

=begin html

<br>PCI-e slot number of the flash device. If not provided, information of all the registered devices will be given.

=end html

=back



B<Outputs>

=over 2

=item * I<flash-device-info>  =>   B<L<"flash-device-info">[], optional>

=begin html

<br>List of registered flash devices.

=end html

=back



=head2 flash_get_thresholds

[B<Family:> ontap-classic]


=begin html

Get threshold profiles available in Flash Management Module.

=end html



B<Inputs>

=over 2

=item * I<profile>  =>   B<string, optional>

=begin html

<br>Name of the threshold profile. If not provided, all available profiles will be printed.

=end html

=back



B<Outputs>

=over 2

=item * I<flash-threshold-profile>  =>   B<L<"flash-threshold-profile">[], optional>

=begin html

<br>A collection of failure threshold entries.

=end html

=back



=head2 fpolicy_create_policy

[B<Family:> ontap-classic, vfiler]


=begin html

Creates a new policy.

=end html



B<Inputs>

=over 2

=item * I<policy-name>  =>   B<string>

=begin html

<br>Name of the policy.

=end html

=back



=over 2

=item * I<policy-type>  =>   B<string>

=begin html

<br>Type of the policy. Possible values: "screen".

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fpolicy_destroy_policy

[B<Family:> ontap-classic, vfiler]


=begin html

Destroys existing policy.

=end html



B<Inputs>

=over 2

=item * I<policy-name>  =>   B<string>

=begin html

<br>Name of the policy.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fpolicy_disable

[B<Family:> ontap-classic, vfiler]


=begin html

Sets options fpolicy enable to off.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fpolicy_disable_policy

[B<Family:> ontap-classic, vfiler]


=begin html

Disables a specific named policy.

=end html



B<Inputs>

=over 2

=item * I<policy-name>  =>   B<string>

=begin html

<br>Name of the policy.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fpolicy_enable

[B<Family:> ontap-classic, vfiler]


=begin html

Sets options fpolicy enable to on.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fpolicy_enable_policy

[B<Family:> ontap-classic, vfiler]


=begin html

Enables a specific named policy. The operation will fail if the policy doesn't exist.

=end html



B<Inputs>

=over 2

=item * I<policy-name>  =>   B<string>

=begin html

<br>Name of the policy.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fpolicy_extensions

[B<Family:> ontap-classic, vfiler]


=begin html

Manipulates with list of extensions in exclude or include set. Exlude set defines extension patterns that won't trigger fpolicy processing.

=end html



B<Inputs>

=over 2

=item * I<command>  =>   B<string>

=begin html

<br>Command to be applied on the specified set. Supported values: "add", "remove", "set", "reset".

=end html

=back



=over 2

=item * I<extensions>  =>   B<L<"extension-list-info">[], optional>

=begin html

<br>List of extensions. This element is required if the the command input value is "add", "set" or "remove".

=end html

=back



=over 2

=item * I<policy-name>  =>   B<string>

=begin html

<br>Name of the policy.

=end html

=back



=over 2

=item * I<set-name>  =>   B<string>

=begin html

<br>Defines to which set (exclude or include) a command (add, remove, etc) will be applied to. For instance, command = add, set-name = include will add specified list of extensions to the include set. Possible values: "exclude", "include".

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fpolicy_extensions_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Returns information on existing extension sets.

=end html



B<Inputs>

=over 2

=item * I<policy-name>  =>   B<string>

=begin html

<br>Name of the policy.

=end html

=back



B<Outputs>

=over 2

=item * I<exclude-extensions>  =>   B<L<"extension-list-info">[]>

=begin html

<br>List of file extensions that are excluded from the file policy.

=end html

=back



=over 2

=item * I<include-extensions>  =>   B<L<"extension-list-info">[]>

=begin html

<br>List of file extensions that are included in the file policy.

=end html

=back



=head2 fpolicy_get_policy_options

[B<Family:> ontap-classic, vfiler]


=begin html

Shows value of policy options.

=end html



B<Inputs>

=over 2

=item * I<policy-name>  =>   B<string>

=begin html

<br>Name of the policy.

=end html

=back



B<Outputs>

=over 2

=item * I<is-ads-monitored>  =>   B<boolean, optional>

=begin html

<br>Indicator if the policy monitors the cifs operations on Alternate Data Streams.

=end html

=back



=over 2

=item * I<is-cifs-disconnect-check-enabled>  =>   B<boolean>

=begin html

<br>'true' if requests associated with disconnected CIFS sessions must not be screened, 'false' otherwise.

=end html

=back



=over 2

=item * I<is-cifs-setattr-enabled>  =>   B<boolean>

=begin html

<br>Indicator whether cifs-setattr support is enabled on this policy or not. If set to true, cifs setattr operations will be screened.

=end html

=back



=over 2

=item * I<is-required>  =>   B<boolean>

=begin html

<br>Indicator if the screening with this policy is required, i.e. will it fail if the server is not registered. If set to true, the request will fail if there is no server to evaluate it. If it's false, the request will succeed.

=end html

=back



=over 2

=item * I<reqcancel-timeout>  =>   B<integer>

=begin html

<br>Timeout (in secs) for a screen request to be processed by an FPolicy server. Range : [0..4294967].

=end html

=back



=over 2

=item * I<secondary-servers>  =>   B<L<"secondary-server-info">[]>

=begin html

<br>List of server's IP addresses. Servers registered from these IP will be considered as secondary servers.

=end html

=back



=over 2

=item * I<serverprogress-timeout>  =>   B<integer>

=begin html

<br>Timeout (in secs) in which a throttled FPolicy server must complete at least one screen request. Range : [0..4294967].

=end html

=back



=head2 fpolicy_get_required_info

[B<Family:> ontap-classic, vfiler]


=begin html

Shows current options for the policy.

=end html



B<Inputs>

=over 2

=item * I<policy-name>  =>   B<string>

=begin html

<br>Name of the policy.

=end html

=back



B<Outputs>

=over 2

=item * I<is-required>  =>   B<boolean>

=begin html

<br>Indicator if the policy is required, i.e. will it fail if the server is not responding. If set to true, the request will fail if there is no server to evaluate it. If it's false, the request will succeed.

=end html

=back



=head2 fpolicy_get_secondary_servers_info

[B<Family:> ontap-classic, vfiler]


=begin html

Shows current options for the policy.

=end html



B<Inputs>

=over 2

=item * I<policy-name>  =>   B<string>

=begin html

<br>Name of the policy.

=end html

=back



B<Outputs>

=over 2

=item * I<secondary-servers>  =>   B<L<"secondary-server-info">[]>

=begin html

<br>List of servers' IP addresses.

=end html

=back



=head2 fpolicy_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Returns a list of existing policies.

=end html



B<Inputs>

=over 2

=item * I<policy-name>  =>   B<string, optional>

=begin html

<br>Name of the policy. If this parameter is set, policies will have information pertaining to the policy named. If there is no such a policy, policies will be empty.

=end html

=back



B<Outputs>

=over 2

=item * I<policies>  =>   B<L<"policy-info">[]>

=begin html

<br>List of policies.

=end html

=back



=head2 fpolicy_operations_list_set

[B<Family:> ontap-classic, vfiler]


=begin html

Manipulate a list of operations and network protocols for a policy. This determines which user requests cause the filer to notify fpolicy servers for this policy. The list provided will replace the list currently in place, if any. Note that this can be confusing to a server which has already connected to a policy and provided a list of operations. For example, it may have requested notifications when users open files, but start receiving notifications when users create symlinks. This API is provided in support of "native file blocking" in which there is no server connected to the filer for a policy. Note that it is possible to get the list of operations and protocols currently set for a policy with the fpolicy-list-info API.

=end html



B<Inputs>

=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>If a server is connected to the filer and has already set the list of operations, should this API override the server's setting? If "force" is "true", the policy's set of operations will be dropped and replaced with the values provided by this API. Default value is false.

=end html

=back



=over 2

=item * I<monitored-operations>  =>   B<L<"monitored-operation-info">[]>

=begin html

<br>List of operations related values.

=end html

=back



=over 2

=item * I<monitored-protocols>  =>   B<L<"monitored-protocol-info">[]>

=begin html

<br>List of protocol related values.

=end html

=back



=over 2

=item * I<offline-only>  =>   B<boolean, optional>

=begin html

<br>Sets the state of offline filtering. If offline filtering is set, then only user requests for files which are marked "offline" cause notifications. Default value is false.

=end html

=back



=over 2

=item * I<policy-name>  =>   B<string>

=begin html

<br>Name of the policy.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fpolicy_server_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Shows a list of primary servers serving the policy.

=end html



B<Inputs>

=over 2

=item * I<policy-name>  =>   B<string>

=begin html

<br>Name of the policy.

=end html

=back



B<Outputs>

=over 2

=item * I<servers>  =>   B<L<"server-info">[]>

=begin html

<br>List of the servers' IP addresses.

=end html

=back



=head2 fpolicy_server_stop

[B<Family:> ontap-classic, vfiler]


=begin html

Stops specific primary server serving the policy. Effectively, this will unregister the fpolicy server.

=end html



B<Inputs>

=over 2

=item * I<policy-name>  =>   B<string>

=begin html

<br>Name of the policy.

=end html

=back



=over 2

=item * I<server-ip>  =>   B<ip-address>

=begin html

<br>The ip address, in dotted-decimal format, of the server.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fpolicy_set_policy_options

[B<Family:> ontap-classic, vfiler]


=begin html

Sets policy's options to on/off.

=end html



B<Inputs>

=over 2

=item * I<is-ads-monitored>  =>   B<boolean, optional>

=begin html

<br>Indicates if the policy monitors the cifs operations on Alternate Data Streams. Default is false.

=end html

=back



=over 2

=item * I<is-cifs-disconnect-check-enabled>  =>   B<boolean, optional>

=begin html

<br>'true' if requests associated with disconnected CIFS sessions must not be screened, 'false' otherwise.

=end html

=back



=over 2

=item * I<is-cifs-setattr-enabled>  =>   B<boolean, optional>

=begin html

<br>Indicator whether cifs-setattr support is enabled on this policy or not. If set to true, cifs setattr operations will be screened. Default is false.

=end html

=back



=over 2

=item * I<is-required>  =>   B<boolean, optional>

=begin html

<br>Indicator if the screening with this policy is required, i.e. will it fail if the server is not registered. If set to true, the request will fail if there is no server to evaluate it. If it's false, the request will succeed. Default is false.

=end html

=back



=over 2

=item * I<policy-name>  =>   B<string>

=begin html

<br>Name of the policy.

=end html

=back



=over 2

=item * I<reqcancel-timeout>  =>   B<integer, optional>

=begin html

<br>Timeout (in secs) for a screen request to be processed by an FPolicy server. Range : [0..4294967].

=end html

=back



=over 2

=item * I<secondary-servers>  =>   B<L<"secondary-server-info">[], optional>

=begin html

<br>List of server's IP addresses. Servers registered from these IP will be considered as secondary servers.

=end html

=back



=over 2

=item * I<serverprogress-timeout>  =>   B<integer, optional>

=begin html

<br>Timeout (in secs) in which a throttled FPolicy server must complete at least one screen request. Range : [0..4294967].

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fpolicy_set_required

[B<Family:> ontap-classic, vfiler]


=begin html

Sets policy's "required" option to on/off.

=end html



B<Inputs>

=over 2

=item * I<policy-name>  =>   B<string>

=begin html

<br>Name of the policy.

=end html

=back



=over 2

=item * I<required>  =>   B<boolean>

=begin html

<br>Indicator if the policy is required. If set to true, the request will fail if there is no server to evaluate it. If it's false, the request will succeed.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fpolicy_set_secondary_servers

[B<Family:> ontap-classic, vfiler]


=begin html

Sets secondary servers information in a form of a list of ip addresses. These servers will be used if all primary servers are not available, thus increasing system availabilty.

=end html



B<Inputs>

=over 2

=item * I<policy-name>  =>   B<string>

=begin html

<br>Name of the policy.

=end html

=back



=over 2

=item * I<secondary-servers>  =>   B<L<"secondary-server-info">[]>

=begin html

<br>List of servers' IP addresses.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 fpolicy_status

[B<Family:> ontap-classic, vfiler]


=begin html

Returns status of options fpolicy enable.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<is-enabled>  =>   B<boolean>

=begin html

<br>Shows if the fpolicy mechanism is enabled or not.

=end html

=back



=head2 fpolicy_volume_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Returns a volume-regular-expression list for an exclude or include set. The list describes limits to the set of volumes for which client requests trigger (include) or suppress (exclude) fpolicy processing for the provided policy.

=end html



B<Inputs>

=over 2

=item * I<policy-name>  =>   B<string>

=begin html

<br>Name of the policy.

=end html

=back



B<Outputs>

=over 2

=item * I<exclude-volumes>  =>   B<L<"fpolicy-volumes-list-info">[]>

=begin html

<br>List of volumes that are inactive for the file policy. The list can include items which are regular expressions, such as "vol*" or "user?". Note that if a policy has both an exclude list and an include list, the include list is ignored by the filer when processing user requests.

=end html

=back



=over 2

=item * I<include-volumes>  =>   B<L<"fpolicy-volumes-list-info">[]>

=begin html

<br>List of volumes that are active for the file policy. The list can include items which are regular expressions, such as "vol*" or "user?".

=end html

=back



=head2 fpolicy_volume_list_set

[B<Family:> ontap-classic, vfiler]


=begin html

Manipulate a list of volumes in an exclude or include set. This limits the set of volumes for which client requests trigger (include) or suppress (exclude) fpolicy processing for the provided policy. The list provided will replace the list currently in place, if any. Note that if a policy has both an exclude list and an include list, the include list is ignored by the filer.

=end html



B<Inputs>

=over 2

=item * I<list-type>  =>   B<string>

=begin html

<br>Defines to which set (exclude or include) a list will be applied. Possible values: "exclude", "include".

=end html

=back



=over 2

=item * I<policy-name>  =>   B<string>

=begin html

<br>Name of the policy.

=end html

=back



=over 2

=item * I<volumes>  =>   B<L<"fpolicy-volumes-list-info">[]>

=begin html

<br>List of volume specifications.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 ic_config_show

[B<Family:> ontap-classic]


=begin html

Print HA Interconnect configuration information.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<ic-config-details>  =>   B<L<"ic-config-details">>

=begin html

<br>HA Interconnect configuration information.

=end html

=back



=head2 ic_get_error_stats

[B<Family:> ontap-classic]


=begin html

Get Interconnect and nvram related statistics and device specific counters

=end html



B<Inputs>

=over 2

=item * I<verbose>  =>   B<boolean, optional>

=begin html

<br>If set to true the output is detailed.

=end html

=back



B<Outputs>

=over 2

=item * I<active-logical-link>  =>   B<integer, optional>

=begin html

<br>The current logical link Possilbe values: -1, 0, 1 Range : [0..2^32-1]

=end html

=back



=over 2

=item * I<nvram-hardware-error-stats>  =>   B<L<"ic-counter">[], optional>

=begin html

<br>List of nvram hardware error counters

=end html

=back



=over 2

=item * I<nvram-hardware-perf-stats>  =>   B<L<"ic-counter">[], optional>

=begin html

<br>List of nvram hardware performance counters

=end html

=back



=over 2

=item * I<nvram-per-port-counters>  =>   B<L<"nvram-per-port-counters-info">[], optional>

=begin html

<br>Port counters list for all available ports

=end html

=back



=over 2

=item * I<nvram-software-counters>  =>   B<L<"ic-counter">[], optional>

=begin html

<br>List of basic nvram counters

=end html

=back



=over 2

=item * I<peer-connect-stats>  =>   B<L<"ic-counter">[]>

=begin html

<br>List of basic Rendezvous counters

=end html

=back



=over 2

=item * I<per-link-parameters>  =>   B<L<"per-link-parameters-info">[], optional>

=begin html

<br>Link Parameters list for all available ports

=end html

=back



=over 2

=item * I<sfo-connection-state>  =>   B<string>

=begin html

<br>Connection state with peer. Possible value: "not connected", "waiting for connected", "waiting for not connected", "connected", "waiting for teardown", "unknown".

=end html

=back



=over 2

=item * I<sfo-nic-used>  =>   B<integer>

=begin html

<br>The interconnect adapter in use Range : [0..2^32-1]

=end html

=back



=head2 ic_get_infiniband_hw_stats

[B<Family:> ontap-classic]


=begin html

Retrieve Infiniband hardware health and status statistics

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<context-stats>  =>   B<L<"ic-counter">[]>

=begin html

<br>End to end connection error counters. Counter names: <ul> <li>invalid_ee_errors</li> <li>invalid_ee_state_errors</li> </ul>

=end html

=back



=over 2

=item * I<doorbell-stats>  =>   B<L<"ic-counter">[]>

=begin html

<br>Number of errors relating to ringing the doorbell on a RDMA transfer to notify that a new work entry has been added to a queue. Counter name: <ul> <li>bad_doorbells</li> </ul>

=end html

=back



=over 2

=item * I<overflow-stats>  =>   B<L<"ic-counter">[]>

=begin html

<br>List of overflow counters. Counter names: <ul> <li>cq</li> <li>eq</li> </ul>

=end html

=back



=over 2

=item * I<packet-stats>  =>   B<L<"ic-counter">[]>

=begin html

<br>List of packet discarded counters. Counter names: <ul> <li>ud_discarded</li> <li>uc_discarded</li> </ul>

=end html

=back



=over 2

=item * I<remote-abort-stats>  =>   B<L<"ic-counter">[]>

=begin html

<br>Remote Aborted error counters. Counter name: <ul> <li>remote_aborted_errors</li> </ul>

=end html

=back



=over 2

=item * I<remote-ops-stats>  =>   B<L<"ic-counter">[]>

=begin html

<br>Remote operations error counters. Counter name: <ul> <li>remote_opperations_errors</li> </ul>

=end html

=back



=over 2

=item * I<requester-stats>  =>   B<L<"ic-counter">[]>

=begin html

<br>List of Basic IC performance and error counters for the side of the infiniband connection initiating the data transfer. Counter names: <ul> <li>local_lenth_errors</li> <li>local_qp_operation_errors</li> <li>local_protection_errors</li> <li>wr_flushed_errors</li> <li>memory_window_bind_errors</li> <li>bad_response_errors</li> <li>remote_invalid_request_errors</li> <li>remote_access_errors</li> <li>transport_retries_exceeded_errors</li> <li>rnr_nak_retries_exceded_errors</li> <li>rnr_naks_received</li> <li>out_of_sequence_naks_received</li> <li>local_ee_operation_errors</li> <li>resync_operations</li> </ul>

=end html

=back



=over 2

=item * I<responder-stats>  =>   B<L<"ic-counter">[]>

=begin html

<br>List of Basic IC performance and error counters for the side of the infiniband connection that is receiving the data. Counter names: <ul> <li>local_length_errors</li> <li>local_qp_operation_errors</li> <li>local_protection_errors</li> <li>wr_flushed_errors</li> <li>local_access_errors</li> <li>remote_invalid_request_errors</li> <li>remote_access_errors</li> <li>rnr_naks_sent</li> <li>out_of_sequence_requests_received</li> <li>bad_multicast_packets_received</li> <li>local_ee_operation_error</li> <li>resync_operations</li> </ul>

=end html

=back



=head2 ic_get_infiniband_port_stats

[B<Family:> ontap-classic]


=begin html

Retrieve Infiniband port health and status statistics

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<port1-stats>  =>   B<L<"ic-counter">[]>

=begin html

<br>MLX4 port 1 Stats including: <ul> <li>packets_tx</li> <li>packets_rx</li> <li>data_tx</li> <li>data_rx</li> <li>wait_tx</li> <li>symbol_error</li> <li>link_error_recovery</li> <li>link_down</li> <li>error_rx</li> <li>remote_physical_error</li> <li>switch_relay_error_rx</li> <li>discard_tx</li> <li>constraint_error_tx</li> <li>constraint_error_rx</li> <li>local_link_integrity_error</li> <li>excessive_buffer_overrun_error</li> <li>vl15_dropped</li> </ul>

=end html

=back



=over 2

=item * I<port2-stats>  =>   B<L<"ic-counter">[]>

=begin html

<br>MLX4 port 2 Stats including: <ul> <li>packets_tx</li> <li>packets_rx</li> <li>data_tx</li> <li>data_rx</li> <li>wait_tx</li> <li>symbol_error</li> <li>link_error_recovery</li> <li>link_down</li> <li>error_rx</li> <li>remote_physical_error</li> <li>switch_relay_error_rx</li> <li>discard_tx</li> <li>constraint_error_tx</li> <li>constraint_error_rx</li> <li>local_link_integrity_error</li> <li>excessive_buffer_overrun_error</li> <li>vl15_dropped</li> </ul>

=end html

=back



=head2 ic_get_perf_stats

[B<Family:> ontap-classic]


=begin html

Get Interconnect related performance statistics

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<ic-perf-details>  =>   B<L<"ic-counter">[]>

=begin html

<br>List of Basic IC performance counters

=end html

=back



=over 2

=item * I<virtual-interface-socket-stats>  =>   B<L<"virtual-interface-socket-stat-info">[]>

=begin html

<br>Virtual Interface socket statistics

=end html

=back



=head2 ic_get_queue_info

[B<Family:> ontap-classic]


=begin html

Print information about the pending descriptors on the send queue and recvQ, if any, for the specified Virtual Interface.

=end html



B<Inputs>

=over 2

=item * I<virtual-interface>  =>   B<integer>

=begin html

<br>The Virtual Interface number for which we need the information. Range : [0..2^32-1]

=end html

=back



B<Outputs>

=over 2

=item * I<recv-queue-info>  =>   B<L<"queue-info">, optional>

=begin html

<br>Last descriptor posted, completed and polled on the receive queue. No recvq-info element means either there are no descriptors queued on the receive queue, or the Virtual Interface doesn't exist or hasn't connected successfully.

=end html

=back



=over 2

=item * I<send-queue-info>  =>   B<L<"queue-info">, optional>

=begin html

<br>Last descriptor posted, completed and polled on the send queue. No sendq-info element means either there are no descriptors queued on the send queue, or the Virtual Interface doesn't exist or hasn't connected successfully.

=end html

=back



=head2 ic_reset_nic

[B<Family:> ontap-classic]


=begin html

Reset the interconnect device if the device is determined to be in an unstable state by the administrator or NetApp Global Support. An unstable state can consist of unsynchronized NVRAM logs causing failover functionality to be disabled, RDMA connection being reported as down, EMS is reporting loss of heartbeat between nodes, or the QP is in a disconnected state. Upon execution the interconnect device will be reset and reprogrammed to restore the High Availability (HA) interface.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 ic_reset_nic_auto_off

[B<Family:> ontap-classic]


=begin html

Disable auto reset functionality for the interconnect device when an unstable state is detected. An unstable state can consist of unsynchronized NVRAM logs causing failover functionality to be disabled, RDMA connection being reported as down, EMS is reporting loss of heartbeat between nodes, or the message transport mechanism is in a disconnected state. Upon execution the automatic reset detection logic will be disabled.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 ic_reset_nic_auto_on

[B<Family:> ontap-classic]


=begin html

Enable auto reset functionality for the interconnect device when an unstable state is detected. An unstable state can consist of unsynchronized NVRAM logs causing failover functionality to be disabled, RDMA connection being reported as down, EMS is reporting loss of heartbeat between nodes, or the message transport mechanism is in a disconnected state. Upon execution the automatic reset detection logic will be disabled.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 ic_zero_error_stats

[B<Family:> ontap-classic]


=begin html

Zeroes out the interconnect error stats

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 igroup_add

[B<Family:> ontap-classic, vfiler]


=begin html

Adds initiator to an existing initiator group.

=end html



B<Inputs>

=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>Forcibly add the initiator, disabling mapping and type conflict checks with the high-availability partner. If not specified all conflict checks are performed. In Data ONTAP Cluster-Mode, this field is accepted for backwards compatibility and is ignored.

=end html

=back



=over 2

=item * I<initiator>  =>   B<string>

=begin html

<br>WWPN or Alias of Initiator to add.

=end html

=back



=over 2

=item * I<initiator-group-name>  =>   B<string>

=begin html

<br>Name of initiator group.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 igroup_bind_portset

[B<Family:> ontap-classic]


=begin html

Bind an existing igroup to a given portset.

=end html



B<Inputs>

=over 2

=item * I<initiator-group-name>  =>   B<string>

=begin html

<br>Name of initiator group to bind the portset to.

=end html

=back



=over 2

=item * I<portset-name>  =>   B<string>

=begin html

<br>Name of portset.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 igroup_create

[B<Family:> ontap-classic, vfiler]


=begin html

Creates a new initiator group. In Data ONTAP 7.3 and upto ONTAP 8.0, the ALUA (Asymmetiric Logical Unit Access) attribute will be enabled by default if initiator-group-type is "fcp" and os-type is "aix", "hpux", or "linux. In Data ONTAP 7-mode 8.1 and later, the ALUA attribute is enabled by default for all os-type if initiator-group-type is "fcp". In Data ONTAP Cluster-Mode 8.1 and later, the ALUA attribute is enabled by default on all initiator groups.

=end html



B<Inputs>

=over 2

=item * I<bind-portset>  =>   B<string, optional>

=begin html

<br>Name of a current portset to bind to the newly created igroup.

=end html

=back



=over 2

=item * I<initiator-group-name>  =>   B<string>

=begin html

<br>Name of initiator group.

=end html

=back



=over 2

=item * I<initiator-group-type>  =>   B<string>

=begin html

<br>Type of the initiator group. Possible values: "fcp", "iscsi", "mixed". "mixed" is available in Data ONTAP Cluster-Mode 8.1 or later only.

=end html

=back



=over 2

=item * I<os-type>  =>   B<initiator-group-os-type, optional>

=begin html

<br>OS type of the initiators within the group. The default value if not specified is "default". The os type applies to all initiators within the group and governs the finer details of SCSI protocol interaction with these initiators. It is strongly recommended for the caller of this API to specify an OS type that is not "default". Some host OSes require this type field be set correctly in order to function properly.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 igroup_destroy

[B<Family:> ontap-classic, vfiler]


=begin html

Destroys an existing initiator group. By default a group cannot be destroyed if there are existing lun maps defined for that group. This behaviour can be overridden with the use of force option set to "true" which will destroy the initiator group and any associated lun maps.

=end html



B<Inputs>

=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>Forcibly destroy the initiator group, even if there are existing lun maps. Best practice is to attempt to unmap all the luns associated with a group before destroying it.

=end html

=back



=over 2

=item * I<initiator-group-name>  =>   B<string>

=begin html

<br>Name of initiator group.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 igroup_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Get information for initiator group(s).

=end html



B<Inputs>

=over 2

=item * I<initiator-group-name>  =>   B<string, optional>

=begin html

<br>Name of initiator group. If specified, only information for that group is returned. If not specified, information for all inititor groups are returned.

=end html

=back



B<Outputs>

=over 2

=item * I<initiator-groups>  =>   B<L<"initiator-group-info">[]>

=begin html

<br>List of initiator groups.

=end html

=back



=head2 igroup_lookup_lun

[B<Family:> ontap-classic, vfiler]


=begin html

Find the path to the lun mapped at a given lun-id for a given initiator group.

=end html



B<Inputs>

=over 2

=item * I<initiator-group-name>  =>   B<string>

=begin html

<br>Name of initiator group to search.

=end html

=back



=over 2

=item * I<lun-id>  =>   B<integer>

=begin html

<br>Lun-id (Logical Unit Number) to search for.

=end html

=back



B<Outputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path to the lun.

=end html

=back



=head2 igroup_remove

[B<Family:> ontap-classic, vfiler]


=begin html

Removes node(s) from an initiator group. The operation is prohibited if there are existing lun maps defined for that group. The force option set to "true" can be used to forcibly remove the node regardless of mappings.

=end html



B<Inputs>

=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>Forcibly remove the initiator even if there are existing LUNs mapped to this initiator group. Best practice is to attempt to unmap all the luns associated with a group before removing the initiator.

=end html

=back



=over 2

=item * I<initiator>  =>   B<string>

=begin html

<br>WWPN or WWPN Alias of Initiator to remove.

=end html

=back



=over 2

=item * I<initiator-group-name>  =>   B<string>

=begin html

<br>Name of initiator group.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 igroup_rename

[B<Family:> ontap-classic, vfiler]


=begin html

Rename an existing initiator group. The rename operation is non-disruptive.

=end html



B<Inputs>

=over 2

=item * I<initiator-group-name>  =>   B<string>

=begin html

<br>Name of initiator group to be renamed.

=end html

=back



=over 2

=item * I<initiator-group-new-name>  =>   B<string>

=begin html

<br>New name to be given to initiator group.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 igroup_set_attribute

[B<Family:> ontap-classic]


=begin html

Sets an attribute for an initiator group.

=end html



B<Inputs>

=over 2

=item * I<attribute>  =>   B<string>

=begin html

<br>Name of the attribute to change. Possible values: "alua", "os-type", "throttle_borrow", "throttle_reserve", "report_scsi_name". "alua" is available in Data ONTAP 7.2 or later. "report_scsi_name" is available in Data ONTAP 8.1.0 or later. "throttle_reserve","throttle_borrow" and "report_scsi_name" are not available in Data ONTAP Cluster-Mode.

=end html

=back



=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>If the requested attribute is "os-type", forcibly set the attribute, disabling conflict checks with the high-availability partner where and when applicable. If not specified all conflict checks are performed. This field is ignored in Data ONTAP Cluster-Mode or if the requested attribute is not "os-type".

=end html

=back



=over 2

=item * I<initiator-group-name>  =>   B<string>

=begin html

<br>Name of initiator group.

=end html

=back



=over 2

=item * I<value>  =>   B<string>

=begin html

<br>Value for the attribute. The valid values for "os-type" are the supported os-types listed in the igroup-create API. In Data ONTAP 7-Mode, setting the "os-type" attribute will perform checks with the high-availability partner if this filer is running in the 'single_image' fcp cfmode and this igroup is an FCP igroup. The optional force argument can be used to override these checks if the high-availability partner can not be reached. It is also strongly recommended the "default" os-type not be used. Using "default" may cause problems with LUN access. API to always require the proper OS type information The valid values for "throttle_reserve" are 0-99 The valid values for "throttle_borrow" are true or false The valid values for "alua" are true or false The valid values for "report_scsi_name" are true or false

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 igroup_unbind_portset

[B<Family:> ontap-classic]


=begin html

Unbind an existing igroup from a portset.

=end html



B<Inputs>

=over 2

=item * I<initiator-group-name>  =>   B<string>

=begin html

<br>Name of initiator group to unbind from the portset.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 ipspace_list_info



=begin html

Retrieve information about ipspaces. An optional ipspace parameter lets you retrive information about a single ipspace.

=end html



B<Inputs>

=over 2

=item * I<ipspace>  =>   B<string, optional>

=begin html

<br>Name of the ipspace whose information you want to retrieve. If this parameter is not provided, information about all ipspaces will be returned.

=end html

=back



B<Outputs>

=over 2

=item * I<ipspaces>  =>   B<L<"ipspace-info">[]>

=begin html

<br>Contains a list of all the ipspaces.

=end html

=back



=head2 iscsi_adapter_config_down



=begin html

Configures the specified adapter down. This API is obsolete beginning with ONTAP 7.1 and will always return the error EOPNOTSUPPORTED. There is no equivalent API to replace it.

=end html



B<Inputs>

=over 2

=item * I<iscsi-adapter>  =>   B<string>

=begin html

<br>iscsi adapter.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 iscsi_adapter_config_up



=begin html

Configures the specified adapter up. This API is obsolete beginning with ONTAP 7.1 and will always return the error EOPNOTSUPPORTED. There is no equivalent API to replace it.

=end html



B<Inputs>

=over 2

=item * I<iscsi-adapter>  =>   B<string>

=begin html

<br>iscsi adapter.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 iscsi_adapter_initiators_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Get the list of initiators currently connected to any of the portal groups associated with specified adapter. Information returned for each initiator includes the target portal group number to which the initiator is connected, as well as the iSCSI initiator nodename and ISID. If no adapter is specified, information is returned for all initiators connected through any adapter in the system. NOTE: Beginning with ONTAP 7.1 this API is only intended for use by legacy applications that are already coded to this API. New applications should use iscsi-portal-list-info to get the list of iSCSI portals. associated with this filer. Complete removal of this ZAPI may occur in any release after 7.1.

=end html



B<Inputs>

=over 2

=item * I<iscsi-adapter>  =>   B<string, optional>

=begin html

<br>Adapter to get initiator list for. If no adapter is specified, information is returned for all initiators connected through any iscsi adapter in the system.

=end html

=back



B<Outputs>

=over 2

=item * I<iscsi-adapters>  =>   B<L<"iscsi-adapter-initiators-info">[]>

=begin html

<br>A list of iscsi adapters containing list of initiators.

=end html

=back



=head2 iscsi_adapter_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Display the configuration information for iscsi adaptor(s), including the iSCSI portals associated with a virtual adapter. NOTE: Beginning with ONTAP 7.1 this API is only intended for use by legacy applications that are already coded to this API. New applications should use iscsi-portal-list-info to get the list of iSCSI portals. associated with this filer. Complete removal of this ZAPI may occur in any release after 7.1.

=end html



B<Inputs>

=over 2

=item * I<iscsi-adapter>  =>   B<string, optional>

=begin html

<br>Returns configuration information for adapter if specified. If not specified, then configuration information for all adapters are returned.

=end html

=back



B<Outputs>

=over 2

=item * I<iscsi-config-adapters>  =>   B<L<"iscsi-config-adapter-info">[]>

=begin html

<br>A list of iscsi adapter configuration information.

=end html

=back



=head2 iscsi_adapter_reset_stats



=begin html

This API is obsolete beginning with ONTAP 7.1 and will always return the error EOPNOTSUPPORTED. For the equivalent functionality use the ZAPI iscsi-reset-stats

=end html



B<Inputs>

=over 2

=item * I<iscsi-adapter>  =>   B<string, optional>

=begin html

<br>Adapter to reset statistics for.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 iscsi_adapter_stats_list_info



=begin html

This API is obsolete beginning with ONTAP 7.1 and will always return the error EOPNOTSUPPORTED. For the equivalent functionality use the ZAPI iscsi-stats-list-info The fields returned by iscsi-stats-list-info are very slightly different from those previously returned by iscsi-adapter-stats-list-info

=end html



B<Inputs>

=over 2

=item * I<iscsi-adapter>  =>   B<string, optional>

=begin html

<br>Adapter to get statistics for.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 iscsi_auth_generate_chap_password

[B<Family:> ontap-classic, vfiler]


=begin html

Generate a 128 bit random password that can be used as a CHAP secret.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<secret>  =>   B<string>

=begin html

<br>A randomly generated 128 bit password.

=end html

=back



=head2 iscsi_connection_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

list iscsi connections on filer

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<iscsi-connection-list-entries>  =>   B<L<"iscsi-connection-list-entry-info">[]>

=begin html

<br>List of connection

=end html

=back



=head2 iscsi_initiator_add_auth

[B<Family:> ontap-classic, vfiler]


=begin html

Add initiator to the authentication list.

=end html



B<Inputs>

=over 2

=item * I<auth-type>  =>   B<string>

=begin html

<br>Authentication type. Possible values: "CHAP", "none", "deny".

=end html

=back



=over 2

=item * I<initiator>  =>   B<string>

=begin html

<br>Name of initiator. The initiator name must conform to RFC 3720, for example: "iqn.1987-06.com.initvendor1:appsrv.sn.2346".

=end html

=back



=over 2

=item * I<outbound-password>  =>   B<string, optional, encrypted>

=begin html

<br>Outbound CHAP user password. Outbound authentication is optional. If Outbound authentication is not specified, then the initiator can only do inbound traffic.

=end html

=back



=over 2

=item * I<outbound-user-name>  =>   B<string, optional>

=begin html

<br>Outbound CHAP user name. Outbound authentication is optional. If Outbound authentication is not specified, then the initiator can only do inbound traffic.

=end html

=back



=over 2

=item * I<password>  =>   B<string, optional, encrypted>

=begin html

<br>Inbound CHAP user password, required for auth-type equals to CHAP.

=end html

=back



=over 2

=item * I<radius>  =>   B<boolean, optional>

=begin html

<br>"true" if RADIUS is the only forced CHAP authentication policy, Default is "false".

=end html

=back



=over 2

=item * I<user-name>  =>   B<string, optional>

=begin html

<br>Inbound CHAP user name, required for auth-type equals to CHAP.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 iscsi_initiator_auth_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Get authentication information for the specified initiator If no initiator is specified, get authentication infomation for all the known initiators. Password, if present is left out for security purposes.

=end html



B<Inputs>

=over 2

=item * I<initiator>  =>   B<string, optional>

=begin html

<br>Name of initiator. The initiator name must conform to RFC 3720, for example: "iqn.1987-06.com.initvendor1:appsrv.sn.2346". If initiator is not supplied, all initiators are returned.

=end html

=back



B<Outputs>

=over 2

=item * I<iscsi-security-entries>  =>   B<L<"iscsi-security-entry-info">[]>

=begin html

<br>List of authentication entries.

=end html

=back



=head2 iscsi_initiator_delete_auth

[B<Family:> ontap-classic, vfiler]


=begin html

Delete initiator from the authentication list

=end html



B<Inputs>

=over 2

=item * I<initiator>  =>   B<string>

=begin html

<br>Name of initiator. The initiator name must conform to RFC 3720, for example: "iqn.1987-06.com.initvendor1:appsrv.sn.2346".

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 iscsi_initiator_get_auth

[B<Family:> ontap-classic, vfiler]


=begin html

Get the authentication info for an initiator, if auth type is CHAP, only the user-name is returned, password is not returned for security purposes.

=end html



B<Inputs>

=over 2

=item * I<initiator>  =>   B<string>

=begin html

<br>Name of initiator. The initiator name must conform to RFC 3720, for example: "iqn.1987-06.com.initvendor1:appsrv.sn.2346". If initiator is not found, default authentication method is returned

=end html

=back



B<Outputs>

=over 2

=item * I<auth-chap-policy>  =>   B<string, optional>

=begin html

<br>CHAP authentication path. Possible values: "radius", "local".

=end html

=back



=over 2

=item * I<auth-type>  =>   B<string>

=begin html

<br>Authentication type. Possible values: "CHAP", "none", "deny".

=end html

=back



=over 2

=item * I<outbound-user-name>  =>   B<string, optional>

=begin html

<br>Outbound CHAP user name, returned only if auth-type is CHAP and outbound authentication is enabled for this initiator.

=end html

=back



=over 2

=item * I<user-name>  =>   B<string, optional>

=begin html

<br>Inbound CHAP user name, returned only if auth-type is CHAP.

=end html

=back



=head2 iscsi_initiator_get_default_auth

[B<Family:> ontap-classic, vfiler]


=begin html

Get the default auth info for iscsi. If the auth type is CHAP, only the username is retuned, and not the password, for security purposes.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<auth-chap-policy>  =>   B<string, optional>

=begin html

<br>CHAP authentication path. possible values: "radius", "local".

=end html

=back



=over 2

=item * I<auth-type>  =>   B<string>

=begin html

<br>Authentication type Possible values: "CHAP", "none", "deny".

=end html

=back



=over 2

=item * I<outbound-user-name>  =>   B<string, optional>

=begin html

<br>Outbound CHAP user name, returned only if auth-type is CHAP, and outbound authentication is set for initiator.

=end html

=back



=over 2

=item * I<user-name>  =>   B<string, optional>

=begin html

<br>Inbound CHAP user name, returned only if auth-type is CHAP.

=end html

=back



=head2 iscsi_initiator_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Gives list of initiators logged in

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<iscsi-initiator-list-entries>  =>   B<L<"iscsi-initiator-list-entry-info">[]>

=begin html

<br>List of initiators logged in

=end html

=back



=head2 iscsi_initiator_modify_chap_params

[B<Family:> ontap-classic, vfiler]


=begin html

Modify CHAP parameters to an existing per-initiator authentication info whose auth-type equals CHAP.

=end html



B<Inputs>

=over 2

=item * I<initiator>  =>   B<string>

=begin html

<br>Name of initiator. The initiator name must conform to RFC 3720, for example: "iqn.1987-06.com.initvendor1:appsrv.sn.2346". The per-initiator authentication info must have an auth-type equal to CHAP.

=end html

=back



=over 2

=item * I<outbound-password>  =>   B<string, optional, encrypted>

=begin html

<br>Outbound CHAP user password. If Outbound CHAP parameters are specified they will replace existing Outbound CHAP parameters. If no Outbound CHAP parameters were previously specified, then the specified Outbound CHAP parameters will enable mutual CHAP authentication. If no Outbound CHAP parameters are specified and no Outbound CHAP parameters exist, then one-way Inbound CHAP authentication will be continue to be used.

=end html

=back



=over 2

=item * I<outbound-user-name>  =>   B<string, optional>

=begin html

<br>Outbound CHAP user name. If Outbound CHAP parameters are specified they will replace existing Outbound CHAP parameters. If no Outbound CHAP parameters were previously specified, then the specified Outbound CHAP parameters will enable mutual CHAP authentication. If no Outbound CHAP parameters are specified and no Outbound CHAP parameters exist, then one-way Inbound CHAP authentication will be continue to be used.

=end html

=back



=over 2

=item * I<password>  =>   B<string, optional, encrypted>

=begin html

<br>Inbound CHAP user password. If Inbound CHAP parameters are specified they will replace the existing Inbound CHAP parameters. If they are not specified, the existing Inbound CHAP parameters will continue to be used.

=end html

=back



=over 2

=item * I<radius>  =>   B<boolean, optional>

=begin html

<br>"true" if RADIUS is the only forced CHAP authentication policy, Default is "false".

=end html

=back



=over 2

=item * I<remove-outbound>  =>   B<boolean, optional>

=begin html

<br>Flag which indicates that mutual CHAP authentication is to be converted to one-way CHAP authentication. Outbound CHAP parameters must not be specified when remove-outbound is true. The default value is false.

=end html

=back



=over 2

=item * I<user-name>  =>   B<string, optional>

=begin html

<br>Inbound CHAP user name. If Inbound CHAP parameters are specified they will replace the existing Inbound CHAP parameters. If they are not specified, the existing Inbound CHAP parameters will continue to be used.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 iscsi_initiator_set_default_auth

[B<Family:> ontap-classic, vfiler]


=begin html

Configure the default authentication method. If an initiator is not configured with a specific authentication method using iscsi-initiator-add-auth the default authentication method will be applied to it.

=end html



B<Inputs>

=over 2

=item * I<auth-type>  =>   B<string>

=begin html

<br>Possible values: "CHAP", "none", "deny".

=end html

=back



=over 2

=item * I<outbound-password>  =>   B<string, optional, encrypted>

=begin html

<br>Outbound CHAP user password. Outbound authentication is optional. If Outbound authentication is not specified, then the initiator can only do inbound traffic.

=end html

=back



=over 2

=item * I<outbound-user-name>  =>   B<string, optional>

=begin html

<br>Outbound CHAP user name. Outbound authentication is optional. If Outbound authentication is not specified, then the initiator can only do inbound traffic.

=end html

=back



=over 2

=item * I<password>  =>   B<string, optional, encrypted>

=begin html

<br>Inbound CHAP user password, required for auth-type equals to CHAP.

=end html

=back



=over 2

=item * I<radius>  =>   B<boolean, optional>

=begin html

<br>"true" if RADIUS is the only forced CHAP authentication policy, Default is "false".

=end html

=back



=over 2

=item * I<user-name>  =>   B<string, optional>

=begin html

<br>Inbound CHAP user name, required for auth-type equals to CHAP.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 iscsi_interface_disable

[B<Family:> ontap-classic, vfiler]


=begin html

Disables an interface for use by iSCSI

=end html



B<Inputs>

=over 2

=item * I<interface-name>  =>   B<string>

=begin html

<br>Name of interface to disable. In Data ONTAP 7-Mode, this is the name of a physical ethernet interface, for example: "e0c". In Data ONTAP Cluster-Mode, this is the name of an iSCSI data LIF in the Vserver.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 iscsi_interface_enable

[B<Family:> ontap-classic, vfiler]


=begin html

Enables an interface for use by iSCSI

=end html



B<Inputs>

=over 2

=item * I<interface-name>  =>   B<string>

=begin html

<br>Name of interface to enable. In Data ONTAP 7-Mode, this is the name of a physical ethernet interface, for example: "e0c". In Data ONTAP Cluster-Mode, this is the name of an iSCSI data LIF in the Vserver.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 iscsi_interface_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Gives status of interface for iSCSI

=end html



B<Inputs>

=over 2

=item * I<interface-name>  =>   B<string, optional>

=begin html

<br>Name of interface to report; if not supplied, all interfaces are listed. For example: "e0c".

=end html

=back



B<Outputs>

=over 2

=item * I<iscsi-interface-list-entries>  =>   B<L<"iscsi-interface-list-entry-info">[]>

=begin html

<br>List of interfaces and enabled/disabled status

=end html

=back



=head2 iscsi_iptpgroup_create

[B<Family:> vfiler]


=begin html

Create a new IP-based tpgroup

=end html



B<Inputs>

=over 2

=item * I<iptpgroup-name>  =>   B<string>

=begin html

<br>User-defined name of new target portal group; must be <= 60 bytes, and cannot end with "default" as this might conflict with names of default system portal groups (for example, "192.168.11.12_default" is not allowed)

=end html

=back



=over 2

=item * I<iptpgroup-tag>  =>   B<integer, optional>

=begin html

<br>Optional target portal group tag supplied by user; if not supplied, system assigns tag.

=end html

=back



B<Outputs>

=over 2

=item * I<iptpgroup-tag>  =>   B<integer>

=begin html

<br>filer assigned tag value for newly created portal group

=end html

=back



=head2 iscsi_iptpgroup_destroy

[B<Family:> vfiler]


=begin html

Destroy a IP-based tpgroup

=end html



B<Inputs>

=over 2

=item * I<iptpgroup-tag>  =>   B<integer>

=begin html

<br>tag of portal group to destroy

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 iscsi_iptpgroup_ipaddr_add

[B<Family:> vfiler]


=begin html

Add an IP Address to an IP-based target portal group

=end html



B<Inputs>

=over 2

=item * I<ip-addr>  =>   B<ip-address>

=begin html

<br>The ip address, in dotted-decimal format, with which to add. (for example, "192.168.11.12").

=end html

=back



=over 2

=item * I<iptpgroup-tag>  =>   B<integer>

=begin html

<br>portal group tag

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 iscsi_iptpgroup_ipaddr_delete

[B<Family:> vfiler]


=begin html

Delete an IP Address from an IP-based target portal group

=end html



B<Inputs>

=over 2

=item * I<ip-addr>  =>   B<ip-address>

=begin html

<br>The ip address, in dotted-decimal format, with which to add. (for example, "192.168.11.12").

=end html

=back



=over 2

=item * I<iptpgroup-tag>  =>   B<integer>

=begin html

<br>portal group

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 iscsi_iptpgroup_list_info

[B<Family:> vfiler]


=begin html

List information about IP-based target portal groups

=end html



B<Inputs>

=over 2

=item * I<iptpgroup-tag>  =>   B<integer, optional>

=begin html

<br>Portal group being queried; if not supplied, information on all portal groups is returned

=end html

=back



B<Outputs>

=over 2

=item * I<iscsi-iptpgroup-list-entries>  =>   B<L<"iscsi-iptpgroup-list-entry-info">[]>

=begin html

<br>List of iptpgroups

=end html

=back



=head2 iscsi_isns_config

[B<Family:> ontap-classic, vfiler]


=begin html

Configures the iSNS service. In Data ONTAP Cluster-Mode, this this API can only modify the configuration of a Vserver where an iSNS service has already been created. To create an iSNS service in a Vserver where one does not exist, use the iscsi-isns-create API.

=end html



B<Inputs>

=over 2

=item * I<isns-ip-addr>  =>   B<ip-address>

=begin html

<br>The ip address, in dotted-decimal format, of the iSNS server with which to register. (for example, "192.168.11.12").

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 iscsi_isns_get_info

[B<Family:> ontap-classic, vfiler]


=begin html

Gets iSNS service configuration.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<is-isns-enabled>  =>   B<boolean>

=begin html

<br>"true" if iSNS service is running, "false" otherwise.

=end html

=back



=over 2

=item * I<isns-entity-id>  =>   B<string>

=begin html

<br>Name of the entity id existing on the iSNS server in which to register.

=end html

=back



=over 2

=item * I<isns-ip-addr>  =>   B<ip-address>

=begin html

<br>The ip address of the iSNS server in which we register.

=end html

=back



=head2 iscsi_isns_start

[B<Family:> ontap-classic, vfiler]


=begin html

Start iSNS service. Service will be avaliable once the call returns with success.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 iscsi_isns_stop

[B<Family:> ontap-classic, vfiler]


=begin html

Stops iSNS service. Service will not be available once the call returns with success.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 iscsi_isns_update

[B<Family:> ontap-classic, vfiler]


=begin html

Forces iSNS service to update server.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 iscsi_node_get_name

[B<Family:> ontap-classic, vfiler]


=begin html

Return the current iscsi node name.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<node-name>  =>   B<string>

=begin html

<br>Current iscsi node name.

=end html

=back



=head2 iscsi_node_set_name

[B<Family:> ontap-classic, vfiler]


=begin html

Set the current iscsi node name.

=end html



B<Inputs>

=over 2

=item * I<node-name>  =>   B<string>

=begin html

<br>New iscsi node name; must be <= 128 chars, and conform to iSCSI rules

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 iscsi_portal_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

list iscsi portals

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<iscsi-portal-list-entries>  =>   B<L<"iscsi-portal-list-entry-info">[]>

=begin html

<br>List of portals

=end html

=back



=head2 iscsi_reset_stats



=begin html

zero filer iscsi counters

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 iscsi_service_start

[B<Family:> ontap-classic, vfiler]


=begin html

Start iSCSI service. Service will be avaliable once the call returns with success.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 iscsi_service_status

[B<Family:> ontap-classic, vfiler]


=begin html

Get status of the iSCSI service, whether or not it is running.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<is-available>  =>   B<boolean>

=begin html

<br>"true" if iSCSI service is running, "false" otherwise.

=end html

=back



=head2 iscsi_service_stop

[B<Family:> ontap-classic, vfiler]


=begin html

Stops iSCSI service. Service will be not be available once the call returns with success.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 iscsi_session_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Gives list of active sessions

=end html



B<Inputs>

=over 2

=item * I<tsih>  =>   B<integer, optional>

=begin html

<br>target session ID handle for specific session

=end html

=back



B<Outputs>

=over 2

=item * I<iscsi-session-list-entries>  =>   B<L<"iscsi-session-list-entry-info">[]>

=begin html

<br>List of active sessions

=end html

=back



=head2 iscsi_stats_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

return current filer iscsi statistics

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<iscsi-stats>  =>   B<L<"iscsi-stats-info">[]>

=begin html

<br>statistics for iscsi

=end html

=back



=head2 iscsi_target_alias_clear_alias

[B<Family:> ontap-classic, vfiler]


=begin html

Clear the current iscsi target alias

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 iscsi_target_alias_get_alias

[B<Family:> ontap-classic, vfiler]


=begin html

Return the current iscsi target alias

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<alias-name>  =>   B<string, optional>

=begin html

<br>Current iscsi target alias if alias-assigned is true.

=end html

=back



=over 2

=item * I<is-alias-assigned>  =>   B<boolean>

=begin html

<br>True if alias assigned, false otherwise.

=end html

=back



=head2 iscsi_target_alias_set_alias

[B<Family:> ontap-classic, vfiler]


=begin html

Set the current iscsi target alias

=end html



B<Inputs>

=over 2

=item * I<alias-name>  =>   B<string>

=begin html

<br>New iscsi target alias to set; must be 128 bytes or less. Free form format otherwise, although a string of all blanks will be rejected

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 iscsi_tpgroup_alua_set



=begin html

Change the ALUA parameters on a tpgroup Asymmetric Logical Unit Access (ALUA) management Data ONTAP supports SCSI ALUA functionality for managing multi-pathed SCSI devices. ALUA provides a standardized mechanism for path discovery and prioritization. Devices are identified by target port IDs, which are then grouped into target port groups. Each group has a state which, when configured, enables the host multipathing software to select the appropriate path priorities when accessing a LUN. For iSCSI, ALUA settings are controlled at the target portal group level using the "iscsi-tpgroup-alua-set" ZAPI. A target portal group can be configured to be either "optimized" or "non-optimized"; a host typically uses all the optimized paths before using any non-optimized paths it may find. All target portal groups are optimized by default. There is also an optional "preferred" setting that may be used on a target portal group. Check your host's multi-pathing software documentation to see if it supports ALUA and the preferred setting. ALUA is enabled on Initiator Groups using the "igroup-set-attribute" ZAPI. All LUNs mapped to an ALUA enabled Initiator Group will support the ALUA functionality.

=end html



B<Inputs>

=over 2

=item * I<tpgroup-alua-preferred>  =>   B<boolean>

=begin html

<br>If "true", target portal group will be marked as preferred for ALUA enabled Initiator Groups

=end html

=back



=over 2

=item * I<tpgroup-alua-state>  =>   B<string>

=begin html

<br>Possible values: "optimized", "non-optimized"

=end html

=back



=over 2

=item * I<tpgroup-tag>  =>   B<integer>

=begin html

<br>portal group

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 iscsi_tpgroup_create

[B<Family:> ontap-classic, vfiler]


=begin html

Create a new user defined target portal group.

=end html



B<Inputs>

=over 2

=item * I<tpgroup-name>  =>   B<string>

=begin html

<br>Name of new user defined target portal group. Name must be <= 32 characters. In Data ONTAP 7-Mode, user defined target portal group names cannot end with "default" as this would conflict with names of default target portal groups. In Data ONTAP Cluster-Mode, user defined target portal groups cannot use the name of any defined logical interfaces (LIFs) in the vserver as this would conflict with names of default target portal groups.

=end html

=back



=over 2

=item * I<tpgroup-tag>  =>   B<integer, optional>

=begin html

<br>Optional target portal group tag supplied by user. Default value is system generated.

=end html

=back



B<Outputs>

=over 2

=item * I<tpgroup-tag>  =>   B<integer>

=begin html

<br>New target portal group tag.

=end html

=back



=head2 iscsi_tpgroup_destroy

[B<Family:> ontap-classic, vfiler]


=begin html

Destroy a tpgroup. Only user defined target portal groups may be destroyed.

=end html



B<Inputs>

=over 2

=item * I<tpgroup-tag>  =>   B<integer>

=begin html

<br>Tag of portal group to destroy.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 iscsi_tpgroup_interface_add

[B<Family:> ontap-classic, vfiler]


=begin html

Add an interface to a target portal group. Interfaces may only be added to a user defined target portal group.

=end html



B<Inputs>

=over 2

=item * I<interface-name>  =>   B<string>

=begin html

<br>Name of network interface to add. In Data ONTAP 7-Mode, this is the name of a physical or virtual ethernet interface, for example: "e0c" or "vif1". In Data ONTAP Cluster-Mode, this is the name of an iSCSI data LIF in the Vserver.

=end html

=back



=over 2

=item * I<tpgroup-tag>  =>   B<integer>

=begin html

<br>Target portal group tag.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 iscsi_tpgroup_interface_delete

[B<Family:> ontap-classic, vfiler]


=begin html

Remove an interface from a target portal group. Interfaces may only be removed from a user defined target portal group. Removing an interface will return it to the system defined default group for the interface.

=end html



B<Inputs>

=over 2

=item * I<interface-name>  =>   B<string>

=begin html

<br>Name of network interface to remove. In Data ONTAP 7-Mode, this is the name of a physical or virtual ethernet interface, for example: "e0c" or "vif1" In Data ONTAP Cluster-Mode, this is the name of an iSCSI data LIF in the Vserver.

=end html

=back



=over 2

=item * I<tpgroup-tag>  =>   B<integer>

=begin html

<br>Target portal group tag.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 iscsi_tpgroup_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

List information about target portal groups

=end html



B<Inputs>

=over 2

=item * I<tpgroup-tag>  =>   B<integer, optional>

=begin html

<br>Portal group being queried; if not supplied, information on all portal groups is returned

=end html

=back



B<Outputs>

=over 2

=item * I<iscsi-tpgroup-list-entries>  =>   B<L<"iscsi-tpgroup-list-entry-info">[]>

=begin html

<br>List of tpgroups

=end html

=back



=head2 license_add

[B<Family:> ontap-classic]


=begin html

Enable license for a Data ONTAP service. This API is deprecated in Data ONTAP 7-Mode 8.2 and later, and will return EAPINOTIMPLEMENTED. Use license-v2-add instead.

=end html



B<Inputs>

=over 2

=item * I<code>  =>   B<string>

=begin html

<br>license code of a Data ONTAP service to be enabled.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 license_delete

[B<Family:> ontap-classic]


=begin html

Disable license for a Data ONTAP service. This API is deprecated in Data ONTAP 7-Mode 8.2 and later, and will return EAPINOTIMPLEMENTED. Use license-v2-delete instead.

=end html



B<Inputs>

=over 2

=item * I<service>  =>   B<string>

=begin html

<br>Name of the Data ONTAP service to be disabled.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 license_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Returns information about the current list of licensed Data ONTAP services, their codes, the type of license, and, if it is a time limited license, the expiration date. It also tells the services that are not licensed for your appliance, or if a time limited licensed service has expired. This API is deprecated in Data ONTAP 7-Mode 8.2 and later, and will return EAPINOTIMPLEMENTED. Use license-v2-list-info instead.

=end html



B<Inputs>

=over 2

=item * I<hide-code>  =>   B<boolean, optional>

=begin html

<br>If true, prevents the code field from being output Default value is false.

=end html

=back



B<Outputs>

=over 2

=item * I<licenses>  =>   B<L<"license-info">[]>

=begin html

<br>An array, one entry per each licensable service.

=end html

=back



=head2 license_v2_add

[B<Family:> ontap-classic]


=begin html

Add license for a Data ONTAP service.

=end html



B<Inputs>

=over 2

=item * I<codes>  =>   B<license-code-v2[]>

=begin html

<br>Data ONTAP Cluster-Mode service/feature. 24 or 48 uppercase alpha only characters.

=end html

=back



B<Outputs>

=over 2

=item * I<license-v2-failure-list>  =>   B<L<"license-v2-result">[], optional>

=begin html

<br>A list of failed license operations, one entry per license.

=end html

=back



=head2 license_v2_delete

[B<Family:> ontap-classic]


=begin html

Removes license for a Data ONTAP service.

=end html



B<Inputs>

=over 2

=item * I<package>  =>   B<licensed-package>

=begin html

<br>Package Possible values: <ul> <li> "base" - Cluster Base License, <li> "nfs" - NFS License, <li> "cifs" - CIFS License, <li> "iscsi" - iSCSI License, <li> "fcp" - FCP License, <li> "cdmi" - CDMI License, <li> "snaprestore" - SnapRestore License, <li> "snapmirror" - SnapMirror License, <li> "flexclone" - FlexClone License, <li> "snapvault" - SnapVault License, <li> "snaplock" - SnapLock License, <li> "snapmanagersuite" - SnapManagerSuite License, <li> "snapprotectapps" - SnapProtectApp License, <li> "v_storageattach" - Virtual Attached Storage License </ul>

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 license_v2_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Returns infomation for DATA ONTAP licenses.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<licenses>  =>   B<L<"license-v2-info">[]>

=begin html

<br>An array, one entry per license.

=end html

=back



=head2 lock_break

[B<Family:> ontap-classic, vfiler]


=begin html

Breaks all specified locks. At least one input argument needs to be specified.

=end html



B<Inputs>

=over 2

=item * I<file-name>  =>   B<string, optional>

=begin html

<br>File name prefixed by "/vol/volX" style path. Input syntax of file-name is the same for all protocols. NOTE: Currently, breaking all locks of a file is not encouraged, as NFSv4 does not yet implement breaking of locks. If attempted, will lead to an inconsistent NFSv4 lock state. Specifying a protocol will prevent this by limiting the breaking of locks to that particular protocol. Also, breaking locks for proto "nfsv4" is explicitly disallowed.

=end html

=back



=over 2

=item * I<host>  =>   B<string, optional>

=begin html

<br>Identity of a host. It is the NetBIOS name or IP address of a CIFS cient, FQDN of a PFS client, IP address or FQDN of NLM (Nfsv2/Nfsv3) client, and IP address of NFSv4 client. If specified, then locks are printed for that host only. If not specified, then locks across all hosts are printed.<br><br> NOTE: Currently, only CIFS protocol filters lock output by host name.

=end html

=back



=over 2

=item * I<owner>  =>   B<string, optional>

=begin html

<br>Name of the lock owner, viz., a username prefixed by an optional domain (and a backslash) for CIFS protocol ([domain\]username), IP address of caching filer suffixed by a colon and a filesystem ID of origin filer (IP:fsid) for PFS, and process-ID for NLM(Nfsv2/Nfsv3). The concept of an owner for NFSv4 is yet to be defined. If specified, then locks are printed for that owner only. If owner is not specified, locks across all owners are printed.<br><br> NOTE: Currently, only CIFS protocol filters lock output by owner name.

=end html

=back



=over 2

=item * I<protocol>  =>   B<string, optional>

=begin html

<br>Name of the protocol (case-insensitive): "cifs" (CIFS), "nlm" (Nfsv2/Nfsv3), "nfsv4" (NFSv4), and "pfs"(PFS). If not specified, then all protocols are scanned for locks. If in that case, a host and/or owner were specified, then expect input syntax errors in "error" output field for protocols that define syntax of host or owner differently. However, scanning of locks is not aborted due to these syntax errors and instead all protocols are still scanned to completion.

=end html

=back



B<Outputs>

=over 2

=item * I<errors>  =>   B<L<"break-error">[], optional>

=begin html

<br>If a specific protocol encounters an error, e.g., a syntax error, this element is included in the output to indicate it because the error might be for specific protocols but not for other protocols and hence should not fail the entire API. This structure includes the same information (status, reason, errno) that is normally included in the "results" attribute of the API itself.

=end html

=back



=head2 lock_status_iter_end

[B<Family:> ontap-classic, vfiler]


=begin html

Terminate a list iteration and clean up any saved info.

=end html



B<Inputs>

=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous cifs-share-list-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 lock_status_iter_next

[B<Family:> ontap-classic, vfiler]


=begin html

Returns items from a previous call to cifs-lock-status-iter-start. This API actually prints out the required locks.

=end html



B<Inputs>

=over 2

=item * I<maximum>  =>   B<integer>

=begin html

<br>The maximum number of lock entries to retrieve.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous cifs-lock-status-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * I<lock-status>  =>   B<L<"lock-status-info">[]>

=begin html

<br>An array, one entry per each lock.

=end html

=back



=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>This tells you how many locks are being returned from this particular call to lock-status-iter-next. When this value is 0, you have retrieved everything.

=end html

=back



=head2 lock_status_iter_start

[B<Family:> ontap-classic, vfiler]


=begin html

Gives information about one or more locks, the results of which are retrieved by using lock-status-iter-next. One or more of the defined inputs can be specified in tandem to get locks for specific cases. If none of the inputs are specified, then all the locks in the system are printed. If no protocol is specified but one or more of the other inputs are specified, then locks across all protocols, viz., CIFS, PFS, NLM (Nfsv2/Nfsv3), and NFSv4, are printed. In this case, it is possible for protocols that define syntax of specified input differently to generate input syntax errors. However, these errors do not stop scanning of locks for other protocols.

=end html



B<Inputs>

=over 2

=item * I<file-name>  =>   B<string, optional>

=begin html

<br>File name prefixed by "/vol/volX" style path. If not specified, then locks across all files are printed. Input syntax of file-name is the same for all protocols.

=end html

=back



=over 2

=item * I<host>  =>   B<string, optional>

=begin html

<br>Identity of a host. It is the NetBIOS name or IP address of a CIFS client, FQDN of a PFS client, IP address or FQDN of NLM (Nfsv2/Nfsv3) client, and IP address of NFSv4 client. If specified, then locks are printed for that host only. If not specified, then locks across all hosts are printed.<br><br> NOTE: Currently, only CIFS protocol filters lock output by host name.

=end html

=back



=over 2

=item * I<owner>  =>   B<string, optional>

=begin html

<br>Name of the lock owner, viz., a username prefixed by an optional domain (and a backslash) for CIFS protocol ([domain\]username), IP address suffixed by a colon and a filesystem ID of caching filer (IP:fsid) for PFS, and process-ID for NLM(Nfsv2/Nfsv3). The concept of an owner for NFSv4 is yet to be defined. If specified, then locks are printed for that owner only. If owner is not specified, locks across all owners are printed.<br><br> NOTE: Currently, only CIFS protocol filters lock output by owner name.

=end html

=back



=over 2

=item * I<protocol>  =>   B<string, optional>

=begin html

<br>Name of the protocol (case-insensitive): "cifs" (CIFS), "nlm" (Nfsv2/Nfsv3), "nfsv4" (NFSv4), and "pfs"(PFS). If not specified, then all protocols are scanned for locks. If in that case, a host and/or owner were specified, then expect input syntax errors in "error" output field for protocols that define syntax of host or owner differently. However, scanning of locks is not aborted due to these syntax errors and instead all protocols are still scanned to completion.

=end html

=back



B<Outputs>

=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>Number which tells you how many items have been saved for future retrieval with lock-status-iter-next.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag to be used in subsequent calls to lock-status-iter-next.

=end html

=back



=head2 lun_clear_persistent_reservation_info

[B<Family:> ontap-classic, vfiler]


=begin html

Clear the SCSI-2 reservation or SCSI-3 persistent reservation information for a given LUN. Note: In Data ONTAP Cluster-Mode, the LUN must either be offline or not mapped to clear the persistent reservation information.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the lun. The path should start with '/vol/'.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 lun_clone_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Lists all LUN clones with valid backing snapshots in the given snapshot.

=end html



B<Inputs>

=over 2

=item * I<snapshot>  =>   B<string>

=begin html

<br>Name of the snapshot.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume.

=end html

=back



B<Outputs>

=over 2

=item * I<lun-clone-list>  =>   B<L<"lun-clone-lists-info">[]>

=begin html

<br>List of LUN clones with valid backing snapshots in the given snapshot.

=end html

=back



=head2 lun_clone_split_start

[B<Family:> ontap-classic, vfiler]


=begin html

Start the cloning of the given LUN.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the clone to split from the underlying parent.

=end html

=back



=over 2

=item * I<space-efficient-split-disabled>  =>   B<boolean, optional>

=begin html

<br>By default 'false', space-efficient LUN clone splitting is allowed. This parameter, if set to 'true', disables space-efficient splitting for this specific operation.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 lun_clone_split_status_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Get the cloning status of LUN(s).

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN.

=end html

=back



B<Outputs>

=over 2

=item * I<clone-status>  =>   B<L<"clone-status-info">[]>

=begin html

<br>List of cloning statuses.

=end html

=back



=head2 lun_clone_split_stop

[B<Family:> ontap-classic, vfiler]


=begin html

Stop the cloning of the given LUN.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN to stop cloning.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 lun_clone_start

[B<Family:> ontap-classic, vfiler]


=begin html

Start the cloning of the given LUN.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN to clone.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 lun_clone_status_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Get the cloning status of LUN(s).

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string, optional>

=begin html

<br>Path of the LUN. If path is specified, only the status of that clone is retuned. If path is not specified, then all cloning status are returned.

=end html

=back



B<Outputs>

=over 2

=item * I<clone-status>  =>   B<L<"clone-status-info">[]>

=begin html

<br>List of cloning status.

=end html

=back



=head2 lun_clone_stop

[B<Family:> ontap-classic, vfiler]


=begin html

Stop the cloning of the given LUN.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN to stop cloning.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 lun_config_check_alua_conflicts_info



=begin html

Returns a list of luns that have both FCP and ISCSI maps at the same time when ALUA is enabled on atleast one of such FCP or ISCSI igroups. These conflicts must be resolved before any further maps (to those luns) can can take place.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<conflicting-luns>  =>   B<L<"conflicting-luns-list">[], optional>

=begin html

<br>If a lun is mapped to both FCP and iSCSI igroups at at the same time with ALUA enabled on atleast one of those igroups, it leads to a conflict. These conflicts need to be resolved before any further maps can take place to the conflicting lun. Conflicts can either be resolved by unmapping one or more mappings or by disabling ALUA on FCP or iSCSI or both the igroups whichever is applicable.

=end html

=back



=head2 lun_config_check_cfmode_info



=begin html

Returns a list of configuration warnings related to initiator groups and the fcp cfmode setting

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<fcp-cfmode>  =>   B<string, optional>

=begin html

<br>Current FCP cfmode setting. Possible values: dual_fabric, mixed, partner, standby, single_image

=end html

=back



=over 2

=item * I<invalid-cfmode-settings>  =>   B<L<"invalid-cfmode-setting-info">, optional>

=begin html

<br>Local and partner cfmode settings if they do not match. cfmodes need to match on both filers in the cluster or cluster failover will not work properly

=end html

=back



=over 2

=item * I<invalid-ostype-cfmode-settings>  =>   B<L<"invalid-ostype-cfmode-setting-info">[], optional>

=begin html

<br>List of initiator groups with invalid ostypes for the fcp-cfmode. Some host operating systems are only compatible with certain fcp-cfmodes

=end html

=back



=over 2

=item * I<invalid-use-partner-cfmode-settings>  =>   B<L<"invalid-use-partner-cfmode-setting-info">[], optional>

=begin html

<br>List of initiator groups with invalid use_partner settings for the FCP cluster failover mode (fcp-cfmode) Incorrect settings can cause hosts to lose luns during takeover.

=end html

=back



=over 2

=item * I<invalid-use-partner-ostype-settings>  =>   B<L<"invalid-use-partner-ostype-setting-info">[], optional>

=begin html

<br>List of initiator groups with invalid use_partner settings for the initiator group's ostype. Some host operating systems should only have certain use_partner settings to ensure proper behavior during failover.

=end html

=back



=head2 lun_config_check_info



=begin html

Returns a list of lun/fcp configuration warnings. These warnings are not related to filer cluster configuration.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<alua-setting-mismatch-info>  =>   B<L<"alua-setting-mismatch-initiator-group">[], optional>

=begin html

<br>list of initiator groups for which the ALUA (Asymmetric Logical Unit Access) settings do not match between local and partner filers. ALUA is a T10 standard that specifies the access characteristics (in terms of performance and supported SCSI commands) of a Logical Unit that can be accessed through more than one target port. ALUA is typically used by host multi-path software to recognize primary and secondary paths to a Logical Unit when more than one path are available to the Logical Unit. If the ALUA setting does not match between the local and partner filers, it would affect the host multi-path software's ability to distingush primary and secondary paths. This could lead to incorrect system behaviour.

=end html

=back



=over 2

=item * I<alua-setting-mismatch-initiators>  =>   B<L<"alua-setting-mismatch-initiator-info">[], optional>

=begin html

<br>List of initiators which are members of initiator groups of differing alua settings.

=end html

=back



=over 2

=item * I<fcp-down-hbas>  =>   B<L<"fcp-down-hba-info">[], optional>

=begin html

<br>list of HBA names that have no link or are configured down.

=end html

=back



=over 2

=item * I<invalid-vsa-settings>  =>   B<L<"invalid-vsa-setting-info">[], optional>

=begin html

<br>List of initiator groups with invalid Volume Set Addressing (VSA) settings

=end html

=back



=over 2

=item * I<mixed-ostype-initiators>  =>   B<L<"mixed-ostype-initiator-info">[], optional>

=begin html

<br>List of initiators which are members of initiator groups of differing ostypes.

=end html

=back



=over 2

=item * I<mixed-vsa-initiators>  =>   B<L<"mixed-vsa-initiator-info">[], optional>

=begin html

<br>List of initiators which are members of initiator groups with differing Volume Set Addressing (VSA) settings. An initiator can only be a member of initiator groups which have the same VSA setting across all the initiator groups it is a member of.

=end html

=back



=head2 lun_config_check_single_image_info



=begin html

Returns a list of configuration warnings that pertain to problems specific to the 'single_image' fcp cfmode. These errors must befixed prior to upgrading any filer cluster to run in 'single_image' mode.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<conflicting-initiators>  =>   B<L<"conflicting-initiator-info">[], optional>

=begin html

<br>List of initiators which belong to initiator groups on the local filer which have different os type settings from the initiator groups on the partner.

=end html

=back



=over 2

=item * I<conflicting-maps>  =>   B<L<"conflicting-map-info">[], optional>

=begin html

<br>Only one lun in the cluster can be mapped to an initiator at a given lun-id. If a lun on each filer is mapped to the same initiator at the same lun-id there will be a conflict. These conflicts need to be resolved before a filer can be upgraded to run in the 'single_image' fcp cfmode. A conflict can be resolved by unmapping one lun and remapping it to an unused lun-id.

=end html

=back



=over 2

=item * I<invalid-nodename-settings>  =>   B<L<"invalid-nodename-setting-info">, optional>

=begin html

<br>When running in the the single_image cfmode the fcp nodename needs to be same on each filer in the cluster. If the nodenames are different the nodenames will be returned. If the cfmode is not set to single_image, then the nodenames will not be checked

=end html

=back



=head2 lun_config_check_wwpn_conflicts_info

[B<Family:> ontap-classic]


=begin html

Determine if duplicate World Wide Port Names (WWPNs) are present on a cluster pair.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<conflicting-wwpns>  =>   B<conflict-wwpn[], optional>

=begin html

<br>If duplicate World Wide Port Names (WWPNs) are present on the HA pair, it leads to a conflict. This causes incorrect Asymmetric Logical Unit Access (ALUA) states to be advertised for all LUNs. To resolve the conflict use 'lun config set' command to set local.single_image.key and partner.single_image.key on both the nodes of the HA pair.

=end html

=back



=head2 lun_create_by_size

[B<Family:> ontap-classic, vfiler]


=begin html

Create a new lun of given size, with initially zero contents. The lun is created at the path given. No file should already exist at the given path. The directory specified in the path must be a qtree root directory. The size of the created lun could be larger than the size specified, in order to get an integral number of cylinders while reporting the geometry using SAN protocols.

=end html



B<Inputs>

=over 2

=item * I<ostype>  =>   B<lun-os-type, optional>

=begin html

<br>The os type for the LUN. The default type if not specified is "image". It is strongly recommended for the caller of this API to avoid using the "image" type because it could result in misconfigured LUNs. For example, a lun with ostype "image" could suffer major performance penalties when a Windows host is trying to access it.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN.

=end html

=back



=over 2

=item * I<prefix-size>  =>   B<integer, optional>

=begin html

<br>The size of the prefix stream for this lun in bytes. Certain OS types store a small portion of the data corresponding to partition tables (or similar structures) in the prefix stream. This is part of the lun data and is transparent to hosts that access the LUN via block protocols. The default size is based on the ostype. Giving a value here overrides the default, but, it is strongly recommended to avoid changing this default size. The value in this field must be a multiple of 512 bytes. Note that this value has no effect when the lun-os-type is "image". This option is available in Data ONTAP 8.1 and later.

=end html

=back



=over 2

=item * I<size>  =>   B<integer>

=begin html

<br>New size for the LUN in bytes.

=end html

=back



=over 2

=item * I<space-reservation-enabled>  =>   B<boolean, optional>

=begin html

<br>By default, the lun is space-reserved. If it is desired to manage space usage manually instead, this can be set to "false" which will create a LUN without any space being reserved.

=end html

=back



B<Outputs>

=over 2

=item * I<actual-size>  =>   B<integer>

=begin html

<br>The actual size of the LUN that was created, in bytes.

=end html

=back



=head2 lun_create_clone

[B<Family:> ontap-classic, vfiler]


=begin html

Create a LUN clone.

=end html



B<Inputs>

=over 2

=item * I<parent-lun-path>  =>   B<string>

=begin html

<br>Path of original LUN.

=end html

=back



=over 2

=item * I<parent-snap>  =>   B<string>

=begin html

<br>LUN path of the backing snapshot.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN clone.

=end html

=back



=over 2

=item * I<space-reservation-enabled>  =>   B<boolean, optional>

=begin html

<br>By default, the lun is space-reserved. If it is desired to manage space usage manually instead, this can be set to "false" which will create a LUN without any space being reserved.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 lun_create_from_file

[B<Family:> ontap-classic, vfiler]


=begin html

Create a lun from an existing file. A new lun is created, at the given lun path (which must be at a qtree root). A hard link is created to the existing file. The file contents are not copied or changed. The file can be resized to a larger size, rounding up to a cylinder boundary.

=end html



B<Inputs>

=over 2

=item * I<file-name>  =>   B<string>

=begin html

<br>A fully qualified filer path to the file to create the LUN from. This must be in the same qtree as the LUN being created. The file must also be in the root of the volume or in a qtree/regular directory in the root of the volume or in a regular directory in a qtree.

=end html

=back



=over 2

=item * I<ostype>  =>   B<lun-os-type, optional>

=begin html

<br>The os type for the LUN. The default type if not specified is "image". It is strongly recommended for the caller of this API to avoid using the "image" type because it could result in misconfigured LUNs. For example, a lun with ostype "image" could suffer major performance penalties when a Windows host is trying to access it.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Would be Path of the newly created LUN if successful. This Path must not exist already (i.e a file or dir with this same path).

=end html

=back



=over 2

=item * I<space-reservation-enabled>  =>   B<boolean, optional>

=begin html

<br>By default, the lun is space-reserved. If it is desired to manage space usage manually instead, this can be set to "false" which will create a LUN without any space being reserved.

=end html

=back



B<Outputs>

=over 2

=item * I<actual-size>  =>   B<integer>

=begin html

<br>The actual size of the LUN that was created, in bytes.

=end html

=back



=head2 lun_create_from_snapshot

[B<Family:> ontap-classic, vfiler]


=begin html

Creates a LUN in the active file system. The lun has the same initial contents as the referenced snapshot copy of an existing lun. (Note that no copy of the data is made.) Future writes go into the new lun. Reads of unmodified data are satisfied from the snapshot location. Reads of modified data are satisfied by first attempting to find the required buffer in the new lun. If a buffer is not found (buffer corresponds to a hole), it is looked for in the snapshot copy instead.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN.

=end html

=back



=over 2

=item * I<snapshot-lun-path>  =>   B<string>

=begin html

<br>LUN path in the snapshot to be created from.

=end html

=back



=over 2

=item * I<space-reservation-enabled>  =>   B<boolean, optional>

=begin html

<br>By default, the lun is space-reserved. If it is desired to manage space usage manually instead, this can be set to "false" which will create a LUN without any space being reserved.

=end html

=back



=over 2

=item * I<type>  =>   B<lun-os-type, optional>

=begin html

<br>The os type for the LUN. The default type if not specified is "image". It is strongly recommended for the caller of this API to avoid using the "image" type because it could result in misconfigured LUNs. For example, a lun with ostype "image" could suffer major performance penalties when a Windows host is trying to access it.

=end html

=back



B<Outputs>

=over 2

=item * I<actual-size>  =>   B<integer>

=begin html

<br>The actual size of the LUN that was created, in bytes.

=end html

=back



=head2 lun_destroy

[B<Family:> ontap-classic, vfiler]


=begin html

Destroy the specified LUN. This operation will fail if the LUN is currently mapped and is online. The force option can be used to destroy it regardless of being online or mapped.

=end html



B<Inputs>

=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>If "true", override checks that prevent a LUN from being destroyed if it is online and mapped. If "false", destroying an online and mapped LUN will fail. The default if not specified is "false".

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 lun_get_attribute

[B<Family:> ontap-classic, vfiler]


=begin html

Get a named attribute for a given LUN.

=end html



B<Inputs>

=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Attribute to get.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN.

=end html

=back



B<Outputs>

=over 2

=item * I<value>  =>   B<string>

=begin html

<br>Value of the attribute.

=end html

=back



=head2 lun_get_comment

[B<Family:> ontap-classic, vfiler]


=begin html

Get the optional descriptive comment for a LUN.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN.

=end html

=back



B<Outputs>

=over 2

=item * I<comment>  =>   B<string>

=begin html

<br>Comment for given LUN.

=end html

=back



=head2 lun_get_geometry

[B<Family:> ontap-classic, vfiler]


=begin html

Get SCSI disk geometry for a given LUN.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN.

=end html

=back



B<Outputs>

=over 2

=item * I<bytes-per-sector>  =>   B<integer>

=begin html

<br>Sector size in bytes.

=end html

=back



=over 2

=item * I<cylinders>  =>   B<integer>

=begin html

<br>Number of cylinders in the LUN The size of the LUN can be calculated like this: cylinders tracks-per-cylinder sectors-per-track X bytes-per-sector --------------------- size

=end html

=back



=over 2

=item * I<max-resize-size>  =>   B<integer>

=begin html

<br>The maximum size this LUN can be resized to in bytes. LUN resize is limited by the lun cylinder size which can not be increased beyond 65535. This number is calculated using a cylinder count of 65535, in place of the LUNs actual cylinder size.

=end html

=back



=over 2

=item * I<sectors-per-track>  =>   B<integer>

=begin html

<br>Number of sectors in a track.

=end html

=back



=over 2

=item * I<size>  =>   B<integer>

=begin html

<br>LUN size in bytes.

=end html

=back



=over 2

=item * I<tracks-per-cylinder>  =>   B<integer>

=begin html

<br>Number of tracks in a cylinder. This is also commonly referred to as the number of heads.

=end html

=back



=head2 lun_get_inquiry_info

[B<Family:> ontap-classic, vfiler]


=begin html

Get the SCSI INQUIRY response data for vendor id (vid), product id (pid), and firmware revision (rev) based on the igroup that the lun in question is mapped to.

=end html



B<Inputs>

=over 2

=item * I<initiator-group-name>  =>   B<string>

=begin html

<br>The initiator group for which the vid/pid/rev information is to be returned.

=end html

=back



B<Outputs>

=over 2

=item * I<firmware-revision>  =>   B<string>

=begin html

<br>SCSI INQUIRY response revision (padded with spaces to 4-characters).

=end html

=back



=over 2

=item * I<product-id>  =>   B<string>

=begin html

<br>SCSI INQUIRY response product id (padded with spaces to 16-characters).

=end html

=back



=over 2

=item * I<vendor-id>  =>   B<string>

=begin html

<br>SCSI INQUIRY response vendor id (padded with spaces to 8-characters).

=end html

=back



=head2 lun_get_maxsize

[B<Family:> ontap-classic, vfiler]


=begin html

Returns the maximum possible size in bytes of a lun on a given volume or qtree. The user can pass the path to a volume or qtree in which the lun is to be created. This returns the maximum size for different types of luns and the possible maximum size with or without snapshot reserves.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the volume or qtree.

=end html

=back



=over 2

=item * I<type>  =>   B<lun-os-type>

=begin html

<br>OS type of the LUN.

=end html

=back



B<Outputs>

=over 2

=item * I<with-complete-snapshot-reserve>  =>   B<integer>

=begin html

<br>Maximum possible size for LUN with snapshot reserve assuming 100% fractional reserve

=end html

=back



=over 2

=item * I<with-snapshot-reserve>  =>   B<integer>

=begin html

<br>Maximum possible size for LUN with snapshot reserve.

=end html

=back



=over 2

=item * I<without-snapshot-reserve>  =>   B<integer>

=begin html

<br>Maximum possible size for LUN without snapshot reserve.

=end html

=back



=head2 lun_get_minsize

[B<Family:> ontap-classic]


=begin html

Returns the minimum possible size in bytes. This returns the minimum size for different types of luns (based on the specified OS type). Space reservation does not affect the minimum lun size, thus only a single minimum size is returned.

=end html



B<Inputs>

=over 2

=item * I<type>  =>   B<lun-os-type>

=begin html

<br>OS type of the LUN.

=end html

=back



B<Outputs>

=over 2

=item * I<min-size>  =>   B<integer>

=begin html

<br>Minimum possible size for LUN.

=end html

=back



=head2 lun_get_occupied_size

[B<Family:> ontap-classic, vfiler]


=begin html

Get the size occupied by the LUN in the active FS.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN.

=end html

=back



B<Outputs>

=over 2

=item * I<occupied-size>  =>   B<integer>

=begin html

<br>Size occupied by the LUN in the Active FS in bytes.

=end html

=back



=head2 lun_get_persistent_reservation_info

[B<Family:> ontap-classic, vfiler]


=begin html

Get the persistent reservation information for a given LUN.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the lun. The path should start with '/vol/'.

=end html

=back



B<Outputs>

=over 2

=item * I<persistent-reservation>  =>   B<L<"persistent-reservation-info">[], optional>

=begin html

<br>This is the persistent reservation information for a given I_T nexus if any exist for the given lun. The communication path and state between an initiator and a target is called an Initiator_Target Nexus, or I_T Nexus. The I_T Nexus is the owner of the persistent reservation information. There can be several I_T Nexus that have registered per lun. Each I_T Nexus can only register one time per lun.

=end html

=back



=head2 lun_get_select_attribute

[B<Family:> ontap-classic, vfiler]


=begin html

Get the select attribute for the specified LUN.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN.

=end html

=back



B<Outputs>

=over 2

=item * I<creation-time>  =>   B<string>

=begin html

<br>The time this lun was created, in human readable format. This field is deprecated in Data ONTAP 8.1. Instead, use creation-timestamp.

=end html

=back



=over 2

=item * I<creation-timestamp>  =>   B<integer>

=begin html

<br>The time this lun was created, in seconds since January 1, 1970. This field is available in Data ONTAP 8.1 and later.

=end html

=back



=over 2

=item * I<previous-serial>  =>   B<string, optional>

=begin html

<br>The serial number of the previous lun. If this lun is not a clone or copy, no previous-serial number exists.

=end html

=back



=over 2

=item * I<select-attribute>  =>   B<string>

=begin html

<br>The select attribute for the lun. Possible values: <ul> <li> "active" - this is an active lun, <li> "copy" - this is a clone or copy of an active lun, <li> "mirror" - this is a mirror of an active lun. </ul>

=end html

=back



=head2 lun_get_serial_number

[B<Family:> ontap-classic, vfiler]


=begin html

Get the serial number for the specified LUN. Prior to Data ONTAP 8.1 release, the serial number is a 12-character string formed of upper and lower-case letters, numbers, and slash (/) and hyphen (-) characters. Starting Data ONTAP 8.1 release, the serial number is a 12-character string formed of upper and lower-case letters, numbers, and the characters /-#$%&*+<=>?[!]^~@ .

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN.

=end html

=back



B<Outputs>

=over 2

=item * I<serial-number>  =>   B<string>

=begin html

<br>Serial number for the LUN.

=end html

=back



=head2 lun_get_space_reservation_info

[B<Family:> ontap-classic, vfiler]


=begin html

Queries the space reservation settings for the named LUN.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Name of the LUN to be queried.

=end html

=back



B<Outputs>

=over 2

=item * I<is-enabled>  =>   B<boolean>

=begin html

<br>Whether or not the LUN has space reservation enabled.

=end html

=back



=head2 lun_get_target_device_id

[B<Family:> ontap-classic, vfiler]


=begin html

Returns the SCSI Target Device Id.

=end html



B<Inputs>

=over 2

=item * I<lun-serial-id>  =>   B<string>

=begin html

<br>Serial number of the lun.

=end html

=back



B<Outputs>

=over 2

=item * I<target-device-id>  =>   B<string>

=begin html

<br>SCSI Target Device Id. This is defined by Network Appliance. Currently a string of numbers preceded by "naa.600A098".

=end html

=back



=head2 lun_get_vdisk_attributes

[B<Family:> ontap-classic, vfiler]


=begin html

Lookup a LUN path and storage system by serial number.

=end html



B<Inputs>

=over 2

=item * I<serial-number>  =>   B<string>

=begin html

<br>Serial number for the LUN.

=end html

=back



B<Outputs>

=over 2

=item * I<filer-name>  =>   B<string>

=begin html

<br>In Data ONTAP 7-Mode, this is the name of the storage system or vfiler containing the LUN. In Data ONTAP Cluster-Mode, this is the name of the Vserver containing the LUN.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path for the specified LUN, for example: "/vol/vol0/lun1".

=end html

=back



=over 2

=item * I<vdisk-snapshot-name>  =>   B<string>

=begin html

<br>Path to the backing snapshot file for the LUN, for example: "/vol/vol1/.snapshot/snapshot/lun". This field will be empty if the LUN is not backed by a snapshot file.

=end html

=back



=head2 lun_has_scsi_reservations

[B<Family:> ontap-classic, vfiler]


=begin html

Queries for all types of scsi reservations covering both iSCSI and FCP.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the lun. The path should start with '/vol/'.

=end html

=back



B<Outputs>

=over 2

=item * I<is-reservation-held>  =>   B<boolean>

=begin html

<br>'true' if given LUN has a scsi-2 or scsi-3 style reservation held, 'false' otherwise.

=end html

=back



=head2 lun_initiator_list_map_info

[B<Family:> ontap-classic, vfiler]


=begin html

List all the luns mapped to an initiator

=end html



B<Inputs>

=over 2

=item * I<initiator>  =>   B<string>

=begin html

<br>initiator to check

=end html

=back



B<Outputs>

=over 2

=item * I<lun-maps>  =>   B<L<"lun-map-info">[], optional>

=begin html

<br>List of lun maps for the given initiator.

=end html

=back



=head2 lun_initiator_logged_in

[B<Family:> ontap-classic, vfiler]


=begin html

Determine if an initiator is logged in via FCP or iSCSI.

=end html



B<Inputs>

=over 2

=item * I<initiator>  =>   B<string>

=begin html

<br>Name of FCP or iSCSI initiator to check.

=end html

=back



B<Outputs>

=over 2

=item * I<is-logged-in>  =>   B<boolean>

=begin html

<br>true if initiator is logged into the filer, false otherwise.

=end html

=back



=head2 lun_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Get the status (size, online/offline state, shared state, comment string, serial number, LUN mapping) of the given LUN, or all LUNs.

=end html



B<Inputs>

=over 2

=item * I<get-clone-backing-snapshot>  =>   B<boolean, optional>

=begin html

<br>If specified, the name of the backing snapshot for a LUN clone is returned. The default value is false.

=end html

=back



=over 2

=item * I<path>  =>   B<string, optional>

=begin html

<br>Path of LUN. If specified, only the information of that LUN is returned. This option can only be used if volume-name is not used.

=end html

=back



=over 2

=item * I<volume-name>  =>   B<string, optional>

=begin html

<br>Name of a volume. If specified, only the information of the LUNs in that volume is returned. This option can only be used if path is not specified.

=end html

=back



B<Outputs>

=over 2

=item * I<are-vols-busy>  =>   B<boolean>

=begin html

<br>Indicates whether any volumes are moving. If true, the output of this command cannot be considered authoritative. Users needing authoritative data should retry until this output parameter is false.

=end html

=back



=over 2

=item * I<are-vols-onlining>  =>   B<boolean>

=begin html

<br>Indicates whether any volumes are still in the process of onlining. If true, the output of this command cannot be considered authoritative. Users needing authoritative data should retry until this output parameter is false.

=end html

=back



=over 2

=item * I<luns>  =>   B<L<"lun-info">[]>

=begin html

<br>Information of a list of LUNs.

=end html

=back



=head2 lun_map

[B<Family:> ontap-classic, vfiler]


=begin html

Maps the LUN to all the initiators in the specified initiator group.

=end html



B<Inputs>

=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>Forcibly map the lun, disabling mapping conflict checks with the high-availability partner. If not specified all conflict checks are performed. In Data ONTAP Cluster-Mode, this field is accepted for backwards compatibilty and is ignored.

=end html

=back



=over 2

=item * I<initiator-group>  =>   B<string>

=begin html

<br>Initiator group to map to the given LUN.

=end html

=back



=over 2

=item * I<lun-id>  =>   B<integer, optional>

=begin html

<br>If the lun-id is not specified, the smallest number that can be used for the various initiators in the group is automatically picked.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN.

=end html

=back



B<Outputs>

=over 2

=item * I<lun-id-assigned>  =>   B<integer>

=begin html

<br>LUN ID assigned for this map. If lun-id is not supplied, this will be an auto-assigned LUN ID, otherwise it will be the same as the supplied LUN ID if map is successful.

=end html

=back



=head2 lun_map_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Returns a list of initiator groups and their members (the initiators) mapped to the given LUN.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>LUN for which the initiator group list is requested.

=end html

=back



B<Outputs>

=over 2

=item * I<initiator-groups>  =>   B<L<"initiator-group-info">[], optional>

=begin html

<br>List of initiator groups that are mapped to the given LUN.

=end html

=back



=head2 lun_move

[B<Family:> ontap-classic, vfiler]


=begin html

Move (rename) a LUN.

=end html



B<Inputs>

=over 2

=item * I<new-path>  =>   B<string>

=begin html

<br>New path of the LUN being moved to.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN to be moved.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 lun_offline

[B<Family:> ontap-classic, vfiler]


=begin html

Disables block-protocol accesses to the LUN. Mappings, if any, configured for the lun are not altered. Note that unless explicitly offlined, a lun is online.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 lun_online

[B<Family:> ontap-classic, vfiler]


=begin html

Re-enables block-protocol accesses to the lun.

=end html



B<Inputs>

=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>Forcibly online the lun, disabling mapping onflict checks with the high-availability partner. If not specified all conflict checks are performed. In Data ONTAP Cluster-Mode, this field is accepted for backwards compatibility and is ignored.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 lun_port_has_scsi_reservations

[B<Family:> ontap-classic, vfiler]


=begin html

Queries for all types of scsi reservations covering both iSCSI and FCP for a given initiator name. Initiator name can be FCP portname in case of FCP or ISCSI nodename for ISCSI.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the lun. The path should start with '/vol/'.

=end html

=back



=over 2

=item * I<portname>  =>   B<string>

=begin html

<br>Initiator FCP portname or ISCSI nodename .

=end html

=back



B<Outputs>

=over 2

=item * I<is-reservation-held>  =>   B<boolean>

=begin html

<br>'true' if given LUN has a scsi-2 or scsi-3 style reservation held, 'false' otherwise.

=end html

=back



=head2 lun_reset_stats

[B<Family:> ontap-classic, vfiler]


=begin html

Resets (zeroes) block-protocol access statistics for LUN(s).

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string, optional>

=begin html

<br>Path of the LUN. If path is specified, the stats of that LUN will be reset. If path is not specified, stats of all LUNs are reset.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 lun_resize

[B<Family:> ontap-classic, vfiler]


=begin html

Changes the size of the lun. Note that client-side operations may be needed to ensure that client software recognizes the changed size.

=end html



B<Inputs>

=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>Forcibly reduce the size. This is required for reducing the size of the LUN to avoid accidentally reducing the LUN size.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN.

=end html

=back



=over 2

=item * I<size>  =>   B<integer>

=begin html

<br>New size for the LUN.

=end html

=back



B<Outputs>

=over 2

=item * I<actual-size>  =>   B<integer>

=begin html

<br>Actual new size. This may be different from the specified size due to the requested size not fitting on a cylinder boundary.

=end html

=back



=head2 lun_restore_status

[B<Family:> ontap-classic, vfiler]


=begin html

Get state of LUN restore.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN.

=end html

=back



B<Outputs>

=over 2

=item * I<is-running>  =>   B<boolean>

=begin html

<br>'true' if file restore is currently running for this vdisk, 'false' otherwise.

=end html

=back



=head2 lun_set_attribute

[B<Family:> ontap-classic, vfiler]


=begin html

Set a named attribute for a given LUN. Attributes are arbitrary key/value pairs for application-defined use.

=end html



B<Inputs>

=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Application-defined attribute to set. In order to prevent conflicts between separate applications, it is recommended that applications prefix attribute names with their registered Internet domain name reversed component by component, and an application identifier. For example: "com.example.widgetapp.attribute". The following attributes are reserved by the system and may not be set: "custom", "cylinder_size", "dev_id", "enabled", "extent_size", "host_stamp", "path_last", "pserial", "pSerial", "serial", "snapshot", "snapshot_path_last", "type". In older versions of Data ONTAP, attempting to set a system-reserved attribute may adversely affect data integrity and availability of the storage system. Clients of this API must therefore take special care to not use any system-reserved attribute names.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN.

=end html

=back



=over 2

=item * I<value>  =>   B<string>

=begin html

<br>Value to set the attribute to. In Data ONTAP Cluster-mode, the combined size of "name" and "value" must not exceed 4092 bytes.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 lun_set_comment

[B<Family:> ontap-classic, vfiler]


=begin html

Set the optional descriptive comment for a LUN.

=end html



B<Inputs>

=over 2

=item * I<comment>  =>   B<string>

=begin html

<br>Comment to set for given LUN.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 lun_set_device_id

[B<Family:> ontap-classic, vfiler]


=begin html

Set a SCSI peripheral device identifying information value on a LUN. In Data ONTAP 7-Mode, the value set will be returned in response to the vendor unique SCSI command GET DEV ID. In Data ONTAP Cluster-Mode, the value set will be returned in response to the SCSI command REPORT IDENTIFYING INFORMATION for the appropriate INFORMATION TYPE: <ul> <li> 0000000b - Peripheral Device Identifying Information, a binary string 1 to 64 bytes long. In addition, if the Peripheral Device Identifying Information is between 00000001h (1d) and 0000270Fh (9999d), it will be returned in response to the vendor unique SCSI command GET DEV ID. <li> 0000010b - Peripheral Device Text Identifying Information, a UTF-8 string 1 to 255 bytes long. </ul> Either or both peripheral device identifying information values may be set or cleared independently.

=end html



B<Inputs>

=over 2

=item * I<device-id>  =>   B<string>

=begin html

<br>SCSI Peripheral Device Identifying Information. In Data ONTAP 7-Mode or if device-id-type is "legacy", the value must be an integer in the range [1..9999]. If device-id-type is "binary", the value must be a 1 to 64 byte value encoded as a hexadecimal string, for example "0000270F". If device-id-type is "text", the value is a free-form UTF-8 string between 1 and 255 bytes in length.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 lun_set_select_attribute

[B<Family:> ontap-classic, vfiler]


=begin html

Set the select attribute for the specified LUN. The select attribute is used by mult-pathing software to discriminate between luns when mirrored or cloned copies of a vdisk are mapped to the same host.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN.

=end html

=back



=over 2

=item * I<select-value>  =>   B<string>

=begin html

<br>Sets the select attribute for the lun. Possible values: <ul> <li> "active" - this is an active lun, <li> "copy" - this is a clone or copy of an active lun, <li> "mirror" - this is a mirror of an active lun. </ul>

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 lun_set_serial_number

[B<Family:> ontap-classic, vfiler]


=begin html

Set the serial number for the specified LUN. The lun must first be made offline before changing the serial number. Prior to Data ONTAP 8.1 release, the serial number is a 12-character string formed of upper and lower-case letters, numbers, and slash (/) and hyphen (-) characters. Starting Data ONTAP 8.1 release, the serial number is a 12-character string formed of upper and lower-case letters, numbers, and the characters /-#$%&*+<=>?[!]^~@ .

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN.

=end html

=back



=over 2

=item * I<serial-number>  =>   B<string>

=begin html

<br>Serial number for the LUN.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 lun_set_share

[B<Family:> ontap-classic, vfiler]


=begin html

Enables file system protocol-based access to a lun. By default, all accesses are disallowed. Note that file permissions and ACL entries still apply.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN.

=end html

=back



=over 2

=item * I<share-type>  =>   B<string>

=begin html

<br>Possible values: all, none, read, write

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 lun_set_space_reservation_info

[B<Family:> ontap-classic, vfiler]


=begin html

Sets the space reservation settings for the named LUN.

=end html



B<Inputs>

=over 2

=item * I<enable>  =>   B<boolean>

=begin html

<br>Enable or disable space reservation on this LUN.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path to the LUN for which the space reservations need to be set.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 lun_snap_usage_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Lists all LUNs backed by data in the specified snapshot. It also lists the corresponding snapshots in which these LUNs exist.

=end html



B<Inputs>

=over 2

=item * I<snapshot>  =>   B<string>

=begin html

<br>Name of the snapshot.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume.

=end html

=back



B<Outputs>

=over 2

=item * I<lun-snap-usage-luns>  =>   B<L<"lun-snap-usage-lun-info">[]>

=begin html

<br>List of LUNs backed by data in the specified snapshot.

=end html

=back



=head2 lun_start

[B<Family:> ontap-classic, vfiler]


=begin html

Starts block-protocol accesses to the lun.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN. The path should start with '/vol/' (for example, "/vol/vol0/lun1").

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 lun_stats_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Get block-protocol access statistics (in bytes) for LUN(s).

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string, optional>

=begin html

<br>Path of the LUN. If path is specified, only the stats of that LUN is returned. If path is not specified, stats of all LUNs are returned.

=end html

=back



B<Outputs>

=over 2

=item * I<lun-stats>  =>   B<L<"lun-stats-info">[]>

=begin html

<br>List of LUN stats.

=end html

=back



=head2 lun_unmap

[B<Family:> ontap-classic, vfiler]


=begin html

Reverses the effect of lun-map on the specified LUN for the specified group.

=end html



B<Inputs>

=over 2

=item * I<initiator-group>  =>   B<string>

=begin html

<br>Initiator group to unmap from.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 lun_unset_attribute

[B<Family:> ontap-classic, vfiler]


=begin html

Clear a named attribute for a given LUN.

=end html



B<Inputs>

=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Name of attribute to unset. The following attributes are reserved by the system and may not be unset: "custom", "cylinder_size", "dev_id", "enabled", "extent_size", "host_stamp", "path_last", "pserial", "pSerial", "serial", "snapshot", "snapshot_path_last", "type". In older versions of Data ONTAP, attempting to unset a system-reserved attribute may adversely affect data integrity and availability of the storage system. Clients of this API must therefore take special care to not use any system-reserved attribute names.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 lun_unset_device_id

[B<Family:> ontap-classic, vfiler]


=begin html

Remove a SCSI peripheral device identifying information value from a LUN.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 nameservice_map_gid_to_group_name

[B<Family:> ontap-classic, vfiler]


=begin html

Obtain a group name from a Unix GID, using whatever mechanism the filer nameservice is currently using.

=end html



B<Inputs>

=over 2

=item * I<gid>  =>   B<integer>

=begin html

<br>Unix GID.

=end html

=back



B<Outputs>

=over 2

=item * I<group>  =>   B<string>

=begin html

<br>Name of the group corresponding to that GID.

=end html

=back



=head2 nameservice_map_group_name_to_gid

[B<Family:> ontap-classic, vfiler]


=begin html

Obtain the Unix GID for a given group name, using whatever mechanism the filer nameservice is currently using.

=end html



B<Inputs>

=over 2

=item * I<group>  =>   B<string>

=begin html

<br>Name of an NFS group.

=end html

=back



B<Outputs>

=over 2

=item * I<gid>  =>   B<integer>

=begin html

<br>Unix GID corresponding to that group.

=end html

=back



=head2 nameservice_map_sid_to_uid

[B<Family:> ontap-classic, vfiler]


=begin html

Obtain a Unix UID from a Windows SID.

=end html



B<Inputs>

=over 2

=item * I<sid>  =>   B<string>

=begin html

<br>A Windows SID.

=end html

=back



B<Outputs>

=over 2

=item * I<uid>  =>   B<integer>

=begin html

<br>Unix UID.

=end html

=back



=head2 nameservice_map_uid_to_user_name

[B<Family:> ontap-classic, vfiler]


=begin html

Obtain a user name from a Unix UID, using whatever mechanism the filer nameservice is currently using.

=end html



B<Inputs>

=over 2

=item * I<uid>  =>   B<integer>

=begin html

<br>A Unix UID.

=end html

=back



B<Outputs>

=over 2

=item * I<user>  =>   B<string>

=begin html

<br>Name of user corresponding to the UID.

=end html

=back



=head2 nameservice_map_unix_to_windows

[B<Family:> ontap-classic, vfiler]


=begin html

Obtain windows user information for a given unix user name.

=end html



B<Inputs>

=over 2

=item * I<user>  =>   B<string>

=begin html

<br>A Unix user name.

=end html

=back



B<Outputs>

=over 2

=item * I<domain>  =>   B<string>

=begin html

<br>Windows domain of the mapped user.

=end html

=back



=over 2

=item * I<user>  =>   B<string>

=begin html

<br>Windows username in that domain.

=end html

=back



=head2 nameservice_map_user_name_to_uid

[B<Family:> ontap-classic, vfiler]


=begin html

Obtain the Unix UID for a given user name, using whatever mechanism the filer nameservice is currently using.

=end html



B<Inputs>

=over 2

=item * I<user>  =>   B<string>

=begin html

<br>Name of user.

=end html

=back



B<Outputs>

=over 2

=item * I<uid>  =>   B<integer>

=begin html

<br>Unix UID corresponding to that user.

=end html

=back



=head2 nameservice_map_windows_to_unix

[B<Family:> ontap-classic, vfiler]


=begin html

Obtain a unix user name from windows user information.

=end html



B<Inputs>

=over 2

=item * I<domain>  =>   B<string>

=begin html

<br>Windows domain of the user.

=end html

=back



=over 2

=item * I<user>  =>   B<string>

=begin html

<br>A Windows user name.

=end html

=back



B<Outputs>

=over 2

=item * I<user>  =>   B<string>

=begin html

<br>Unix name corresponding to that user.

=end html

=back



=head2 net_config_get_active

[B<Family:> ontap-classic]


=begin html

Output the current network config Output includes vlans, ifgrps and static routes with information from vlan, ifgrp, route & ifconfig commands

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<net-config-info>  =>   B<L<"net-config-info">>

=begin html

<br>Active network configuration.

=end html

=back



=head2 net_config_get_persistent

[B<Family:> ontap-classic]


=begin html

Reads filer's /etc/rc and outputs contents.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<net-config-info>  =>   B<L<"net-config-info">>

=begin html

<br>Persistent network configuration (/etc/rc).

=end html

=back



=head2 net_config_set_persistent

[B<Family:> ontap-classic]


=begin html

Writes filer's persistent network config.

=end html



B<Inputs>

=over 2

=item * I<net-config-info>  =>   B<L<"net-config-info">>

=begin html

<br>Persistent network configuration (/etc/rc).

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 net_dcb_list_info

[B<Family:> ontap-classic]


=begin html

Returns the current Data Center Bridging (DCB) configuration for a specified network interface or all network interfaces indexed by the priority group id.

=end html



B<Inputs>

=over 2

=item * I<interface-name>  =>   B<string, optional>

=begin html

<br>The network interface name. If not specified, the priority group associated DCB configuration for all DCB-capable network interfaces will be displayed.

=end html

=back



=over 2

=item * I<priority-group-id>  =>   B<integer, optional>

=begin html

<br>The Priority Group ID. Range: [0..15] If not specified, the DCB configuration for all assigned priority groups will be displayed.

=end html

=back



B<Outputs>

=over 2

=item * I<net-dcb-entries>  =>   B<L<"net-dcb-entry-info">[]>

=begin html

<br>A list of DCB configuration entries for each network interface.

=end html

=back



=head2 net_dcb_priority_list_info

[B<Family:> ontap-classic]


=begin html

Returns the current Data Center Bridging (DCB) configuration for a specified network interface or all network interfaces indexed by the DCB priority.

=end html



B<Inputs>

=over 2

=item * I<interface-name>  =>   B<string, optional>

=begin html

<br>The interface name. If not specified, the priority associated DCB configuration for all DCB-capable network interfaces will be displayed.

=end html

=back



=over 2

=item * I<priority>  =>   B<integer, optional>

=begin html

<br>The priority. Range: [0..7] If not specified, the priority associated DCB configuration for all DCB priorities will be displayed.

=end html

=back



B<Outputs>

=over 2

=item * I<net-dcb-priority-entries>  =>   B<L<"net-dcb-priority-entry-info">[]>

=begin html

<br>A list of DCB configuration entries indexed by the priority.

=end html

=back



=head2 net_get_address_info

[B<Family:> ontap-classic, vfiler]


=begin html

Resolves a host name to one or more IPv4 or IPv6 addresses. Returns appropriate errorcode if the host name cannot be resolved.

=end html



B<Inputs>

=over 2

=item * I<host-info>  =>   B<L<"host-info">>

=begin html

<br>Contains name of the host to be resolved, hints will be provided in order to return the appropriate type of addresses, service name for which the address will be used.

=end html

=back



B<Outputs>

=over 2

=item * I<host-result>  =>   B<L<"net-address-info">[]>

=begin html

<br>Contains a list of IPv4 and/or IPv6 addresses corresponding to the hostname.

=end html

=back



=head2 net_ifconfig_get

[B<Family:> ontap-classic]


=begin html

Output the current configuration for one interface.

=end html



B<Inputs>

=over 2

=item * I<interface-name>  =>   B<string, optional>

=begin html

<br>This is the name of the interface to display. If not provided, all interfaces will be displayed.

=end html

=back



B<Outputs>

=over 2

=item * I<interface-config-info>  =>   B<L<"interface-config-info">[]>

=begin html

<br>configuration of interface

=end html

=back



=head2 net_ifconfig_set

[B<Family:> ontap-classic]


=begin html

Configure network interface. Does not modify persistent config.

=end html



B<Inputs>

=over 2

=item * I<interface-config-info>  =>   B<L<"interface-config-info">>

=begin html

<br>Interface configuration.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 net_ipspace_assign

[B<Family:> ontap-classic]


=begin html

Assign a list of interfaces to an ipspace. Modifies persistent config.

=end html



B<Inputs>

=over 2

=item * I<ipspace-config-info>  =>   B<L<"ipspace-config-info">>

=begin html

<br>Ipspace to create.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 net_ipspace_create

[B<Family:> ontap-classic]


=begin html

Create a new ipspace. Modifies persistent config.

=end html



B<Inputs>

=over 2

=item * I<ipspace-config-info>  =>   B<L<"ipspace-config-info">>

=begin html

<br>Ipspace to create.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 net_ipspace_destroy

[B<Family:> ontap-classic]


=begin html

Destroy an ipspace. Modifies persistent config.

=end html



B<Inputs>

=over 2

=item * I<ipspace-name>  =>   B<string>

=begin html

<br>IPSpace name.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 net_ipspace_list

[B<Family:> ontap-classic]


=begin html

List ipspaces.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<ipspace-list>  =>   B<L<"ipspace-config-info">[]>

=begin html

<br>List of ipspaces.

=end html

=back



=head2 net_ping

[B<Family:> ontap-classic, vfiler]


=begin html

Ping a host. The API returns on the first successful ping of retry-count attempts. EHOSTNOTFOUND is returned if the host cannot be resolved. EONTAPI_EHOSTDOWN is returned if the host cannot be pinged. The interval between retries is 1 second. IPv6 is not supported at this time.

=end html



B<Inputs>

=over 2

=item * I<host-name-or-ip-address>  =>   B<string>

=begin html

<br>The name or the IP address of the host to ping. The format is an IPv4 host name or an IP address.

=end html

=back



=over 2

=item * I<retry-count>  =>   B<integer, optional>

=begin html

<br>The number of pings to try before giving up. Default is 3. Range: [1..5]

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 net_ping_info

[B<Family:> ontap-classic, vfiler]


=begin html

Ping a host. The API pings the host count times, and returns the number of successful pings and times. EHOSTNOTFOUND is returned if the host cannot be resolved. EHOSTNOCONTACT is returned if the host cannot be pinged. The interval between ping attempts is 1 second. IPv6 is not supported at this time.

=end html



B<Inputs>

=over 2

=item * I<host-name-or-ip-address>  =>   B<string>

=begin html

<br>The name or the IP address of the host to ping. The format is an IPv4 host name or IP address.

=end html

=back



=over 2

=item * I<ping-count>  =>   B<integer, optional>

=begin html

<br>The number of pings. Default is 3. Range: [1..16]

=end html

=back



B<Outputs>

=over 2

=item * I<packets-received>  =>   B<integer, optional>

=begin html

<br>The number of packets received. The number of packets lost is the packets-transmitted minus packets-received. Range: [0..16]

=end html

=back



=over 2

=item * I<packets-transmitted>  =>   B<integer, optional>

=begin html

<br>Number of packets transmitted. Should be equal to ping-count. Range: [1..16]

=end html

=back



=over 2

=item * I<round-trip-maximum-time>  =>   B<integer, optional>

=begin html

<br>Maximum time in microseconds for a round trip between the filer and the host if packets-recieved is greater than zero. Range: [0..2^31-1]

=end html

=back



=over 2

=item * I<round-trip-mean-time>  =>   B<integer, optional>

=begin html

<br>Mean time in microseconds for a round trip between the filer and the host if packets-recieved is greater than zero. Range: [0..2^31-1]

=end html

=back



=over 2

=item * I<round-trip-minimum-time>  =>   B<integer, optional>

=begin html

<br>Mimumum time in microseconds for a round trip between the filer and the host if packets-recieved is greater than zero. Range: [0..2^31-1]

=end html

=back



=head2 net_resolve

[B<Family:> ontap-classic, vfiler]


=begin html

Resolves a host name to one or more IP addresses. Returns an error code of gethostbyname_r if failed. Does not support IPv6 at this time.

=end html



B<Inputs>

=over 2

=item * I<host-name>  =>   B<string>

=begin html

<br>Name of the host to be resolved.

=end html

=back



B<Outputs>

=over 2

=item * I<ip-addresses>  =>   B<ip-address[]>

=begin html

<br>The IP addresses of the host.

=end html

=back



=head2 net_reverse_resolve

[B<Family:> ontap-classic, vfiler]


=begin html

Resolves an IP address to one or more host names. Returns an error code of gethostbyaddr_r if failed. Does not support IPv6 at this time.

=end html



B<Inputs>

=over 2

=item * I<ip-address>  =>   B<string>

=begin html

<br>IP address of the host to be resolved in dotted notation (for example, 10.56.10.125).

=end html

=back



B<Outputs>

=over 2

=item * I<alias-names>  =>   B<host-name[], optional>

=begin html

<br>The aliases of the host, if any.

=end html

=back



=over 2

=item * I<canonical-name>  =>   B<string, optional>

=begin html

<br>The canonical host name

=end html

=back



=head2 net_route_add

[B<Family:> ontap-classic, vfiler]


=begin html

Create a new kernel route. Does not modify persistent config.

=end html



B<Inputs>

=over 2

=item * I<route-info>  =>   B<L<"route-info">>

=begin html

<br>Route to create.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 net_route_delete

[B<Family:> ontap-classic, vfiler]


=begin html

Delete a kernel route. Does not modify persistent config.

=end html



B<Inputs>

=over 2

=item * I<route-info>  =>   B<L<"route-info">>

=begin html

<br>Route to delete.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 net_vlan_create

[B<Family:> ontap-classic]


=begin html

Create a new vlan interface. In Data ONTAP 7-Mode, changes made by this API are not persisted across system reboots. In Data ONTAP Cluster-Mode, changes made by this API are persisted across system reboots.

=end html



B<Inputs>

=over 2

=item * I<vlan-info>  =>   B<L<"vlan-info">>

=begin html

<br>Vlan to create.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 net_vlan_delete

[B<Family:> ontap-classic]


=begin html

Delete a vlan interface. In Data ONTAP 7-Mode, changes made by this API are not persisted across system reboots. In Data ONTAP Cluster-Mode, changes made by this API are persisted across system reboots.

=end html



B<Inputs>

=over 2

=item * I<vlan-info>  =>   B<L<"vlan-info">>

=begin html

<br>Vlan to delete.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 nfs_disable

[B<Family:> ontap-classic, vfiler]


=begin html

In Data ONTAP 7-Mode, this API will disable NFS server access (effectively same as the CLI command "nfs off") In Data ONTAP Cluster-Mode, this will stop the Vserver's NFS service. If the NFS service was not explicitly created, this API does nothing.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 nfs_enable

[B<Family:> ontap-classic, vfiler]


=begin html

In Data ONTAP 7-Mode, this API will enable NFS server access (effectively same as the CLI command "nfs on") In Data ONTAP Cluster-Mode, this will start the Vserver's NFS service. If the NFS service was not explicitly created, this API will create one with default options.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 nfs_exportfs_append_rules

[B<Family:> ontap-classic, vfiler]


=begin html

Enables pathnames for mounting according to the rules specified. New rules for the pathnames take effect immediately, ignoring previous rules for specified pathnames. In the Data ONTAP 7-Mode, set the persistent option to true to save the rule in the etc/exports file and keep the option persistent upon loading or reboot whereas it must be true in Data ONTAP Cluster-Mode as the export entries are always persistent.

=end html



B<Inputs>

=over 2

=item * I<persistent>  =>   B<boolean, optional>

=begin html

<br>In Data ONTAP 7-Mode, default value is false. If true, modifies the etc/exports file to append the rule for a permanent change. (The new rule still takes effect immediately.) In Data ONTAP Cluster-Mode, the export entries are always persistent. Default value is true. If false, an error will be returned.

=end html

=back



=over 2

=item * I<rules>  =>   B<L<"exports-rule-info">[]>

=begin html

<br>List of rules to add to the exports table.

=end html

=back



=over 2

=item * I<verbose>  =>   B<boolean, optional>

=begin html

<br>If true, returns a list of directories which were appended. Errors during the append are recorded in the 'results' field error and 'loaded-pathnames' will contain which pathnames were successfully appended. Default value is false.

=end html

=back



B<Outputs>

=over 2

=item * I<exported-pathnames>  =>   B<L<"pathname-info">[], optional>

=begin html

<br>In Data ONTAP 7-Mode, this will return verbose output of what pathnames were successfully saved in the etc/exports file. Only returned if verbose and persistent options are set. In Data ONTAP Cluster-Mode, this will return verbose output of what pathnames were successfully appended. Only returned if verbose option is set.

=end html

=back



=over 2

=item * I<loaded-pathnames>  =>   B<L<"pathname-info">[], optional>

=begin html

<br>Verbose output of what pathnames were successfully appended Only returned if verbose option is set.

=end html

=back



=head2 nfs_exportfs_append_rules_2

[B<Family:> ontap-classic, vfiler]


=begin html

Enables pathnames for mounting according to the rules specified. New rules for the pathnames take effect immediately, ignoring previous rules for specified pathnames. In the Data ONTAP 7-Mode, set the persistent option to true to save the rule in the etc/exports file and keep the option persistent upon loading or reboot whereas it must be true in Data ONTAP Cluster-Mode as the export entries are always persistent. The new security-rule-info structure contains finer grained information about security rules than exports-rule-info.

=end html



B<Inputs>

=over 2

=item * I<persistent>  =>   B<boolean, optional>

=begin html

<br>In Data ONTAP 7-Mode, default value is false. If true, modifies the etc/exports file to append the rule for a permanent change. (The new rule still takes effect immediately.) In Data ONTAP Cluster-Mode, the export entries are always persistent. Default value is true. If false, an error will be returned.

=end html

=back



=over 2

=item * I<rules>  =>   B<L<"exports-rule-info-2">[]>

=begin html

<br>List of rules to add to the exports table.

=end html

=back



=over 2

=item * I<verbose>  =>   B<boolean, optional>

=begin html

<br>If true, returns a list of directories which were appended. Errors during the append are recorded in the 'results' field error and 'loaded-pathnames' will contain which pathnames were successfully appended. Default value is false.

=end html

=back



B<Outputs>

=over 2

=item * I<exported-pathnames>  =>   B<L<"pathname-info">[], optional>

=begin html

<br>In Data ONTAP 7-Mode, this will return verbose output of what pathnames were successfully saved in the etc/exports file. Only returned if verbose and persistent options are set. In Data ONTAP Cluster-Mode, this will return verbose output of what pathnames were successfully appended. Only returned if verbose option is set.

=end html

=back



=over 2

=item * I<loaded-pathnames>  =>   B<L<"pathname-info">[], optional>

=begin html

<br>Verbose output of what pathnames were successfully appended Only returned if verbose option is set.

=end html

=back



=head2 nfs_exportfs_check_permission

[B<Family:> ontap-classic, vfiler]


=begin html

Returns true if the host IP has mount permissions for a specified path.

=end html



B<Inputs>

=over 2

=item * I<host>  =>   B<string>

=begin html

<br>IP address of the host to check in dotted decimal format: AAA.BBB.CCC.DDD

=end html

=back



=over 2

=item * I<pathname>  =>   B<string>

=begin html

<br>Returns the permissions for this path.

=end html

=back



=over 2

=item * I<permission>  =>   B<string>

=begin html

<br>Possible values: &quot;read-only&quot;, &quot;read-write&quot;, and &quot;root&quot;.

=end html

=back



B<Outputs>

=over 2

=item * I<is-permissible>  =>   B<boolean>

=begin html

<br>True if host has permission to the path.

=end html

=back



=head2 nfs_exportfs_delete_rules

[B<Family:> ontap-classic, vfiler]


=begin html

Removes the rules for a set of pathnames. This returns an error if any of the pathnames don't have a rule. In the Data ONTAP 7-Mode, set the persistent option to modify the etc/exports file and keep this change persistent upon reboots whereas it must be true in Data ONTAP Cluster-Mode as the export entries are always persistent.

=end html



B<Inputs>

=over 2

=item * I<all-pathnames>  =>   B<boolean, optional>

=begin html

<br>Default value is false. Set to true to delete all rules. 'pathnames' option must be left empty if this option is true.

=end html

=back



=over 2

=item * I<pathnames>  =>   B<L<"pathname-info">[], optional>

=begin html

<br>In the Data ONTAP 7-Mode, these must be the pathnames to be deleted from the exports table. In Data ONTAP Cluster-Mode, the junction paths of the volumes to be unexported must be provided.

=end html

=back



=over 2

=item * I<persistent>  =>   B<boolean, optional>

=begin html

<br>In Data ONTAP 7-Mode, default value is false. Modify the etc/exports file to delete the rules permanently. CAUTION: If 'all-pathnames' and 'persistent' are both true, all exports are removed permanently. In Data ONTAP Cluster-Mode, the export entries are always persistent. Default value is true. If false, an error will be returned.

=end html

=back



=over 2

=item * I<verbose>  =>   B<boolean, optional>

=begin html

<br>Return a verbose output of what occurred. If there is an error after deleting only a few rules, 'deleted-pathnames' will return which rules were deleted. Default value is false.

=end html

=back



B<Outputs>

=over 2

=item * I<deleted-pathnames>  =>   B<L<"pathname-info">[], optional>

=begin html

<br>In Data ONTAP 7-Mode, this will return the list of pathnames deleted from the exports table in memory. Only returned if verbose option is set. In Data ONTAP Cluster-Mode, this will return the list of pathnames unexported.

=end html

=back



=over 2

=item * I<unexported-pathnames>  =>   B<L<"pathname-info">[], optional>

=begin html

<br>In Data ONTAP 7-Mode, this will return the list of pathnames deleted from the exports file. Only returned if verbose and persistent options are set. In Data ONTAP Cluster-Mode, this will return the list of pathnames unexported.

=end html

=back



=head2 nfs_exportfs_fence_disable

[B<Family:> ontap-classic, vfiler]


=begin html

Disables fencing to the given exports for the given entry. This means that the entry will have write permission to the exports. The rule changes take effect immediately. Set the persistent option to true to save the rule in the /etc/exports file and keep the option persistent upon loading or reboot.

=end html



B<Inputs>

=over 2

=item * I<all-pathnames>  =>   B<boolean, optional>

=begin html

<br>Default value is false. Set to true to unfence all rules. 'fenced-paths' option must be left empty if this option is true.

=end html

=back



=over 2

=item * I<fenced-hosts>  =>   B<L<"exports-hostname-info">[]>

=begin html

<br>An array of hostnames which are to be fenced off.

=end html

=back



=over 2

=item * I<fenced-paths>  =>   B<L<"pathname-info">[], optional>

=begin html

<br>An array of paths which are to be fenced off.

=end html

=back



=over 2

=item * I<persistent>  =>   B<boolean, optional>

=begin html

<br>Default value is false. If true, modifies the etc/exports file to append the rule for a permanent change. (The new rule still takes effect immediately.) If false, only change the exports in memory.

=end html

=back



=over 2

=item * I<remove-locks>  =>   B<boolean, optional>

=begin html

<br>Default value is false. Set to true to reclaim locks of the specified fenced-hosts.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 nfs_exportfs_fence_enable

[B<Family:> ontap-classic, vfiler]


=begin html

Enables fencing to the given exports for the given entry. This means that the entry will not have write permission to the exports. The rule changes take effect immediately. Set the persistent option to true to save the rule in the /etc/exports file and keep the option persistent upon loading or reboot.

=end html



B<Inputs>

=over 2

=item * I<all-pathnames>  =>   B<boolean, optional>

=begin html

<br>Default value is false. Set to true to fence all rules. 'fenced-paths' option must be left empty if this option is true.

=end html

=back



=over 2

=item * I<fenced-hosts>  =>   B<L<"exports-hostname-info">[]>

=begin html

<br>An array of hostnames which are to be fenced off.

=end html

=back



=over 2

=item * I<fenced-paths>  =>   B<L<"pathname-info">[], optional>

=begin html

<br>An array of paths which are to be fenced off.

=end html

=back



=over 2

=item * I<persistent>  =>   B<boolean, optional>

=begin html

<br>Default value is false. If true, modifies the etc/exports file to append the rule for a permanent change. (The new rule still takes effect immediately.) If false, only change the exports in memory.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 nfs_exportfs_flush_cache

[B<Family:> ontap-classic, vfiler]


=begin html

For the given path, renew or flush the access cache.

=end html



B<Inputs>

=over 2

=item * I<pathname>  =>   B<string, optional>

=begin html

<br>Pathname to flush. If this input is not provided, all of the paths in the exports table are flushed.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 nfs_exportfs_list_rules

[B<Family:> ontap-classic, vfiler]


=begin html

Returns the rules associated with exports. If a pathname is specified, the rules associated with the export matching that pathname, are returned; otherwise, rules for all exports are returned.

=end html



B<Inputs>

=over 2

=item * I<pathname>  =>   B<string, optional>

=begin html

<br>The pathname, for whose matching export, the client wants a listing of the associated rules. If this parameter is provided, the persistent parameter is ignored.

=end html

=back



=over 2

=item * I<persistent>  =>   B<boolean, optional>

=begin html

<br>In Data ONTAP 7-Mode, default value is false. If true, the export entries that are present in the /etc/exports file are returned; otherwise, those loaded in memory are returned. This parameter is ignored, if the pathname parameter is provided. In Data ONTAP Cluster-Mode, the export entries are always persistent. Default value is true. If false, an empty list will be returned.

=end html

=back



B<Outputs>

=over 2

=item * I<rules>  =>   B<L<"exports-rule-info">[]>

=begin html

<br>Array of exports rules loaded in memory or found in the etc/exports file. If pathname parameter is provided, returns the corresponding rules that are loaded in memory.

=end html

=back



=head2 nfs_exportfs_list_rules_2

[B<Family:> ontap-classic, vfiler]


=begin html

Returns the rules associated with exports, using the new security info structure. If a pathname is specified, the rules associated with the export matching that pathname, are returned; otherwise, rules for all exports are returned.

=end html



B<Inputs>

=over 2

=item * I<pathname>  =>   B<string, optional>

=begin html

<br>The pathname, for whose matching export, the client wants a listing of the associated rules. If this parameter is provided, the persistent parameter is ignored.

=end html

=back



=over 2

=item * I<persistent>  =>   B<boolean, optional>

=begin html

<br>In Data ONTAP 7-Mode, default value is false. If true, the export entries that are present in the /etc/exports file are returned; otherwise, those loaded in memory are returned. This parameter is ignored, if the pathname parameter is provided. In Data ONTAP Cluster-Mode, the export entries are always persistent. Default value is true. If false, an empty list will be returned.

=end html

=back



B<Outputs>

=over 2

=item * I<rules>  =>   B<L<"exports-rule-info-2">[]>

=begin html

<br>Array of exports rules loaded in memory or found in the etc/exports file. If pathname parameter is provided, returns the corresponding rules that are loaded in memory.

=end html

=back



=head2 nfs_exportfs_load_exports

[B<Family:> ontap-classic, vfiler]


=begin html

Loads the etc/exports file into memory. Replaces exports rules already residing in memory.

=end html



B<Inputs>

=over 2

=item * I<persistent-only>  =>   B<boolean, optional>

=begin html

<br>Default value is false. If true, atomically reloads each rule from the exports file and unloads all other rules.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 nfs_exportfs_modify_rule

[B<Family:> ontap-classic, vfiler]


=begin html

Functionally similar to append with the following caveats. Returns an error if the rule does not exist. Only works for one rule at a time.

=end html



B<Inputs>

=over 2

=item * I<persistent>  =>   B<boolean>

=begin html

<br>In Data ONTAP 7-Mode, default value is false. If true, modifies the etc/exports file to append the rule for a permanent change. (The new rule still takes effect immediately.) In Data ONTAP Cluster-Mode, the export entries are always persistent. Default value is true. If false, an error will be returned.

=end html

=back



=over 2

=item * I<rule>  =>   B<L<"exports-rule-info">>

=begin html

<br>The rule to modify. Returns an error if a previous rule with the same pathname is not already loaded into memory.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 nfs_exportfs_modify_rule_2

[B<Family:> ontap-classic, vfiler]


=begin html

Functionally similar to append-2 with the following caveats. Returns an error if the rule does not exist. Only works for one rule at a time.

=end html



B<Inputs>

=over 2

=item * I<persistent>  =>   B<boolean>

=begin html

<br>In Data ONTAP 7-Mode, default value is false. If true, modifies the etc/exports file to append the rule for a permanent change. (The new rule still takes effect immediately.) In Data ONTAP Cluster-Mode, the export entries are always persistent. Default value is true. If false, an error will be returned.

=end html

=back



=over 2

=item * I<rule>  =>   B<L<"exports-rule-info-2">>

=begin html

<br>The rule to modify. Returns an error if a previous rule with the same pathname is not already loaded into memory.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 nfs_exportfs_storage_path

[B<Family:> ontap-classic, vfiler]


=begin html

For the given path, determine the actual storage path. Returns an error if the path does not exist.

=end html



B<Inputs>

=over 2

=item * I<pathname>  =>   B<string>

=begin html

<br>Virtual pathname which has a rule associated with an actual pathname.

=end html

=back



B<Outputs>

=over 2

=item * I<actual-pathname>  =>   B<string>

=begin html

<br>True path name on the filer, which uses a virtual path for interfacing with the NFS.

=end html

=back



=head2 nfs_get_supported_sec_flavors

[B<Family:> ontap-classic, vfiler]


=begin html

Returns a list of currently supported security flavors. Hosts with permmisions and connecting via the proper security flavor have access to directories on the filer. Default security flavor for all exports is &quot;sys&quot;.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<sec-flavor>  =>   B<L<"sec-flavor-info">[]>

=begin html

<br>List of possible security flavors NFS supports.

=end html

=back



=head2 nfs_monitor_add

[B<Family:> ontap-classic, vfiler]


=begin html

starts monitoring the specified hosts for NFS lock recovery purposes. The specified hosts are added to the list of of clients that will be notified of lock recovery in the event of an NFS server crash/reboot. For more information, see the sm_mon(1a) manual page.

=end html



B<Inputs>

=over 2

=item * I<hosts>  =>   B<hostaddr[]>

=begin html

<br>an array of hosts that are to be monitored.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 nfs_monitor_list

[B<Family:> ontap-classic, vfiler]


=begin html

Lists the hosts that are currently being monitored by the NFS status monitor.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<hosts>  =>   B<hostaddr[]>

=begin html

<br>an array of hosts that are currently being monitored.

=end html

=back



=head2 nfs_monitor_reclaim

[B<Family:> ontap-classic, vfiler]


=begin html

reclaims the NFS locks for the specified client hosts. If no hosts are specified, then all the clients locks are removed and are notified about lock recovery, as if an NFS server crash/reboot had happened. If any hosts are specified, then only those client hosts locks are reclaimed For more information, see the sm_mon(1a) manual page.

=end html



B<Inputs>

=over 2

=item * I<hosts>  =>   B<hostaddr[], optional>

=begin html

<br>hosts whose locks have to be reclaimed. If no hosts are specified, then all the clients locks are reclaimed.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 nfs_monitor_remove

[B<Family:> ontap-classic, vfiler]


=begin html

Starts unmonitoring the specified hosts for NFS lock recovery purposes. The specified hosts are removed from the list of clients that will be notified of lock recovery in the event of an NFS server crash/reboot. For more information, see the sm_mon(1a) manual page.

=end html



B<Inputs>

=over 2

=item * I<hosts>  =>   B<hostaddr[]>

=begin html

<br>an array of hosts that are to be unmonitored.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 nfs_monitor_remove_locks

[B<Family:> ontap-classic, vfiler]


=begin html

removes the NFS locks of a specfied process of a specified client host.

=end html



B<Inputs>

=over 2

=item * I<owners>  =>   B<L<"owner-info">[]>

=begin html

<br>List of owners whose locks have to be deleted.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 nfs_stats_get_client_stats

[B<Family:> ontap-classic, vfiler]


=begin html

Collects NFS statistics for a specified client

=end html



B<Inputs>

=over 2

=item * I<host>  =>   B<string>

=begin html

<br>Hostname or IP address of client

=end html

=back



B<Outputs>

=over 2

=item * I<client-info>  =>   B<string>

=begin html

<br>Hostname or IP address of client

=end html

=back



=over 2

=item * I<nfs-stats>  =>   B<L<"nfs-stats-info">>

=begin html

<br>detailed statistics for each NFS operation

=end html

=back



=over 2

=item * I<rpc-stats>  =>   B<L<"rpc-stats-info">>

=begin html

<br>detailed statistics for RPC operations

=end html

=back



=over 2

=item * I<tcp-flowcontrol-stats>  =>   B<L<"tcp-flowcontrol-stats-info">>

=begin html

<br>detailed statistics for TCP flowcontrol

=end html

=back



=head2 nfs_stats_top_clients_list_iter_end

[B<Family:> ontap-classic, vfiler]


=begin html

Terminate NFS client statistics iteration and cleanup any saved info.

=end html



B<Inputs>

=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous nfs-stats-top-clients-list-iter-start

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 nfs_stats_top_clients_list_iter_next

[B<Family:> ontap-classic, vfiler]


=begin html

Continues the nfs-stats-top-clients-list-iter-start iteration through the top NFS clients, ordered by total NFS operations.

=end html



B<Inputs>

=over 2

=item * I<maximum>  =>   B<integer>

=begin html

<br>The maximum number of entries to retrieve. Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous nfs-stats-top-iter-start

=end html

=back



B<Outputs>

=over 2

=item * I<nfs-top>  =>   B<L<"nfs-top-info">[]>

=begin html

<br>An array, one entry per nfs top.

=end html

=back



=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>This tells you how many records are being returned from this particular call to nfs-stats-top-client-list-iter-next When this value is 0, you have retrieved everything. Range : [0..2^32-1].

=end html

=back



=head2 nfs_stats_top_clients_list_iter_start

[B<Family:> ontap-classic, vfiler]


=begin html

Starts an iteration through the top NFS clients, ordered by total NFS operations.

=end html



B<Inputs>

=over 2

=item * I<maxclients>  =>   B<integer, optional>

=begin html

<br>Specifies the maximum number of top clients to retrieve (the default is 20) Range : [1..2^32-1].

=end html

=back



B<Outputs>

=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>Number which tells you how many items have been saved for future retrieval with nfs-stats-top-clients-list-iter-next Range : [0..2^32-1]

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag to be used in subsequent calls to nfs-stats-top-clients-list-iter-next

=end html

=back



=head2 nfs_stats_zero_stats

[B<Family:> ontap-classic, vfiler]


=begin html

Set all NFS statistcs to zero

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 nfs_status

[B<Family:> ontap-classic, vfiler]


=begin html

Returns the status of the NFS server.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<is-drained>  =>   B<boolean>

=begin html

<br>If true, then the NFS server has been disabled and all NFS messages have been drained. In Data ONTAP Cluster-Mode, there is no way of finding out if the NFS messages have been drained. Hence this field will always be false.

=end html

=back



=over 2

=item * I<is-enabled>  =>   B<boolean>

=begin html

<br>True if NFS server is running.

=end html

=back



=head2 options_get

[B<Family:> ontap-classic, vfiler]


=begin html

Get the value of a single option.

=end html



B<Inputs>

=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Name of the option.

=end html

=back



B<Outputs>

=over 2

=item * I<cluster-constraint>  =>   B<string>

=begin html

<br>Indicates the cluster-specific constraints of option. <ul> <li> "none" - no constraint. <li> "same_preferred" - same value should be used on both nodes of a HA pair. <li> "same_required" - same value must be used on both nodes of a HA pair. <li> "only_one" - value is used for both nodes of a HA pair, when in takeover mode. <li> "unknown" - value is not valid. </ul> In Data ONTAP Cluster-Mode, this field will always be "none".

=end html

=back



=over 2

=item * I<value>  =>   B<string>

=begin html

<br>Value of the option.

=end html

=back



=head2 options_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Get a list of all options

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<options>  =>   B<L<"option-info">[]>

=begin html

<br>null

=end html

=back



=head2 options_set

[B<Family:> ontap-classic, vfiler]


=begin html

Set the value of a single option. For complete list of names and values of options, please refer to options man pages.

=end html



B<Inputs>

=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Name of the option.

=end html

=back



=over 2

=item * I<value>  =>   B<string>

=begin html

<br>Value of the option.

=end html

=back



B<Outputs>

=over 2

=item * I<cluster-constraint>  =>   B<string>

=begin html

<br>Cluster-specific constraint of the option. <ul> <li> "none" - no constraint. <li> "same_preferred" - same value should be used on both nodes of a HA pair. <li> "same_required" - same value must be used on both nodes of a HA pair. <li> "only_one" - value is used for both nodes of a HA pair, when in takeover mode. <li> "unknown" - value is not valid. </ul> In Data ONTAP Cluster-Mode, this field will always be "none".

=end html

=back



=over 2

=item * I<message>  =>   B<string, optional>

=begin html

<br>Informative message that was issued as a result of setting (or trying to set) the option.

=end html

=back



=head2 perf_object_counter_list_info

[B<Family:> ontap-classic]


=begin html

Get information about the counters of an object. This information is static and independent of any particular instance of the object. It includes counter names and descriptions, as well as properties which are necessary to to interpret counter values.

=end html



B<Inputs>

=over 2

=item * I<objectname>  =>   B<string>

=begin html

<br>Name of the object to get information for.

=end html

=back



B<Outputs>

=over 2

=item * I<counters>  =>   B<L<"counter-info">[]>

=begin html

<br>List of counters available for instances of this object.

=end html

=back



=head2 perf_object_get_instances

[B<Family:> ontap-classic]


=begin html

Get a list of current counter values of instances of an object. This will return the values of all specified counters and instances of the specified object with one call.<p> In Data ONTAP 7-Mode, if the object is expected to have a large number of instances and/or counters, the iterator version of this API should be used.

=end html



B<Inputs>

=over 2

=item * I<counters>  =>   B<counter[], optional>

=begin html

<br>List of counters whose values will be retrieved. This element can be used to limit data collection to a specified subset of the counters of instances of the object. If this element is absent, values of all counters will be retrieved.

=end html

=back



=over 2

=item * I<instances>  =>   B<instance[], optional>

=begin html

<br>List of instance names for which to get counter values. This element can be used to limit data collection to a specified subset of the instances of the object.<p> In Data ONTAP 7-Mode, counter values of all instances of the object will be retrieved when this element is absent.<p> In Data ONTAP Cluster-Mode, either instances or instance-uuids input must be provided. The API errors out if both of these inputs are provided or neither of these inputs is provided, or if more than 500 instances are requested.

=end html

=back



=over 2

=item * I<objectname>  =>   B<string>

=begin html

<br>Name of the object to get counter values for.

=end html

=back



B<Outputs>

=over 2

=item * I<instances>  =>   B<L<"instance-data">[]>

=begin html

<br>List of instances of the object. Each element of this list

=end html

=back



=over 2

=item * I<timestamp>  =>   B<string>

=begin html

<br>Timestamp in seconds since January 1, 1970.

=end html

=back



=head2 perf_object_get_instances_iter_end

[B<Family:> ontap-classic]


=begin html

Terminate a perf-object-get-instances iterator.

=end html



B<Inputs>

=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a pervious perf-object-get-instances-iter-start

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 perf_object_get_instances_iter_next

[B<Family:> ontap-classic]


=begin html

Continue retrieving the values of counters of instances of an object. This call will return a partial list instance names, continued from the previous call with the same tag. When the 'records' output element is 0, all counter values of all instances have been retrieved and the perf-object-instance-list-info-iter-end API should be called.

=end html



B<Inputs>

=over 2

=item * I<maximum>  =>   B<integer>

=begin html

<br>Maximum number of entries to retrieve with this call.<br> Range: [0..2^31-1]

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous perf-object-get-instances-iter-start

=end html

=back



B<Outputs>

=over 2

=item * I<instances>  =>   B<L<"instance-data">[]>

=begin html

<br>Partial list of instances of the object. Each element of this list contains the counter values of a single instance of the object at the time perf-object-get-instances-iter-start was called.

=end html

=back



=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>Number of records returned by this call to perf-object-instance-info-iter-next. A value of 0 indicates all counter values of all instances have been returned.<br> Range: [0..2^31-1]

=end html

=back



=head2 perf_object_get_instances_iter_start

[B<Family:> ontap-classic]


=begin html

Begin retrieving the counter values of instances of an object. This call should be followed with one or more calls to perf-object-get-instances-iter-next

=end html



B<Inputs>

=over 2

=item * I<counters>  =>   B<counter[], optional>

=begin html

<br>List of counters whose values will be retrieved. This element can be used to limit data collection to a specified subset of the counters of instances of the object. If this element is absent, values of all counters will be retrieved.

=end html

=back



=over 2

=item * I<instances>  =>   B<instance[], optional>

=begin html

<br>List of instances to get counter values for. This element can be used to limit data collection to a specified subset of the instances of the object. If this element is absent, counter values of all instances of the object will be retrieved.

=end html

=back



=over 2

=item * I<objectname>  =>   B<string>

=begin html

<br>Name of the object to get counter values for.

=end html

=back



B<Outputs>

=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>Number of items that have been saved for future retrieval with perf-object-instance-list-info-iter-next.<br> Range: [0..2^31-1]

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag to be used in subsequent calls to perf-object-get-instances-iter-next

=end html

=back



=over 2

=item * I<timestamp>  =>   B<string>

=begin html

<br>Timestamp in seconds since January 1, 1970.

=end html

=back



=head2 perf_object_instance_list_info

[B<Family:> ontap-classic]


=begin html

Get the list of names of current instances of an object. This will return the names of all current instances of the specified object with one call. If the object is expected to have a large number of instances, the iterator version of this API should be used.

=end html



B<Inputs>

=over 2

=item * I<objectname>  =>   B<string>

=begin html

<br>Name of the object to get instance information for.

=end html

=back



B<Outputs>

=over 2

=item * I<instances>  =>   B<L<"instance-info">[], optional>

=begin html

<br>Array of names of current instances of the object.

=end html

=back



=head2 perf_object_instance_list_info_iter_end

[B<Family:> ontap-classic]


=begin html

Terminate a perf-object-instance-list-info iterator.

=end html



B<Inputs>

=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous perf-object-instance-list-info-iter-start

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 perf_object_instance_list_info_iter_next

[B<Family:> ontap-classic]


=begin html

Continue retrieving the names of instances of an object. This call will return a partial list instance names, continued from the previous call with the same name. When the 'records' output element is 0, all instance names have been retrieved and the perf-object-instance-list-info-iter-end API should be called.

=end html



B<Inputs>

=over 2

=item * I<maximum>  =>   B<integer>

=begin html

<br>Maximum number of instance names to retrieve with this call.<br> Range: [0..2^31-1]

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from earlier call to perf-object-instance-list-info-iter-start

=end html

=back



B<Outputs>

=over 2

=item * I<instances>  =>   B<L<"instance-info">[]>

=begin html

<br>Partial list of names of instances of the object at the time perf-object-instance-list-info-start was called.

=end html

=back



=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>Number of records returned by this call to perf-object-instance-info-iter-next. A value of 0 indicates all instances have been returned.<br> Range: [0..2^31-1]

=end html

=back



=head2 perf_object_instance_list_info_iter_start

[B<Family:> ontap-classic]


=begin html

Begin retrieving the names of instances of an object. This call should be followed with one or more calls to perf-object-instance-list-info-iter-next

=end html



B<Inputs>

=over 2

=item * I<objectname>  =>   B<string>

=begin html

<br>Name of the object to get instance information for.

=end html

=back



B<Outputs>

=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>Number of items that have been saved for future retrieval with perf-object-instance-list-info-iter-next.<br> Range: [0..2^31-1]

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag to be used in subsequent calls to perf-object-instance-list-info-iter-next

=end html

=back



=head2 perf_object_list_info

[B<Family:> ontap-classic]


=begin html

Get list of performance objects in the system.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<objects>  =>   B<L<"object-info">[]>

=begin html

<br>List of performance objects.

=end html

=back



=head2 portset_add

[B<Family:> ontap-classic]


=begin html

Add a port to an existing port set

=end html



B<Inputs>

=over 2

=item * I<portset-name>  =>   B<string>

=begin html

<br>Name of port set.

=end html

=back



=over 2

=item * I<portset-port-name>  =>   B<string>

=begin html

<br>This is the name of the port that is to be added to the portset. In Data ONTAP 7-Mode, it can be input in two styles. The filername:slotletter format will add the port from a specific filer. For example: "buxton:4a" The slotletter format will add the port from both the local and partner filers. For example: "4a" In Data ONTAP Cluster-Mode, the port name is the name of either an FCP data lif or an iSCSI target portal group.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 portset_create

[B<Family:> ontap-classic]


=begin html

Create a port set

=end html



B<Inputs>

=over 2

=item * I<portset-name>  =>   B<string>

=begin html

<br>Name of the port set to create.

=end html

=back



=over 2

=item * I<portset-type>  =>   B<string>

=begin html

<br>Protocols accepted for this portset. Possible values: "fcp", "iscsi", "mixed". "iscsi" and "mixed" are available in Data ONTAP Cluster-Mode only.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 portset_destroy

[B<Family:> ontap-classic]


=begin html

Destroys an existing port set. By default a set cannot be destroyed if there are existing igroup associated with that portset.

=end html



B<Inputs>

=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>If 'false' or not specified, the request will fail if there are any igroups bound to this portset. If 'true', forcibly destroy the portset, even if there are existing igroup bindings. Best practice is to unbind all the associated igroups before destroying the igroup.

=end html

=back



=over 2

=item * I<portset-name>  =>   B<string>

=begin html

<br>Name of the port set to destroy.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 portset_list_info



=begin html

Get information for port set(s).

=end html



B<Inputs>

=over 2

=item * I<portset-name>  =>   B<string, optional>

=begin html

<br>Name of port set. If specified, only information for that set is returned. If not specified, information for all port sets are returned.

=end html

=back



B<Outputs>

=over 2

=item * I<portset-sets>  =>   B<L<"portset-info">[]>

=begin html

<br>List of port sets.

=end html

=back



=head2 portset_remove

[B<Family:> ontap-classic]


=begin html

Removes a port from a port set.

=end html



B<Inputs>

=over 2

=item * I<portset-name>  =>   B<string>

=begin html

<br>Name of the port set.

=end html

=back



=over 2

=item * I<portset-port-name>  =>   B<string>

=begin html

<br>This is the name of the port that is to be removed from the portset. In Data ONTAP 7-Mode, it can be input in two styles. The filername:slotletter format will remove the port from a specific filer. For example: "buxton:4a" The slotletter format will remove the port from both the local and partner filers. For example: "4a" In Data ONTAP Cluster-Mode, the port name is the name of either an FCP data lif or an iSCSI target portal group.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 priority_disable

[B<Family:> ontap-classic]


=begin html

Globally disable priority scheduling

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 priority_enable

[B<Family:> ontap-classic]


=begin html

Globally enable priority scheduling

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 priority_hybridcache_get

[B<Family:> ontap-classic]


=begin html

Sets caching policies for a volume

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>The volume for which the caching polcies are requested.

=end html

=back



B<Outputs>

=over 2

=item * I<is-hybrid-cache-enabled>  =>   B<boolean>

=begin html

<br>This field shows if hybrid caching is enabled on the volume Possible values are "enabled" or "disabled".

=end html

=back



=over 2

=item * I<read-cache>  =>   B<string>

=begin html

<br>Current read caching policies on the volume. The possible values are - <ul> <li>"meta" - insert only volume metadata buffers into the SSD tier. <li>"random_read" - inserts randomly accessed buffers into the SSD SSD tier. <li>"random_read_write" - inserts buffers as defined by "random-read". In addition, buffers involved in random write operations are cached. </ul>

=end html

=back



=over 2

=item * I<write-cache>  =>   B<string, optional>

=begin html

<br>Current write caching policies on the volume. The possible values are - <ul> <li>"random_write" - randomly accessed buffers are write cached. <li>"none" - no buffers will be write cached. <li>"not_supported" - write caching cannot be configured on this volume. </ul>

=end html

=back



=head2 priority_hybridcache_set

[B<Family:> ontap-classic]


=begin html

Sets caching policies for a volume

=end html



B<Inputs>

=over 2

=item * I<read-cache>  =>   B<string, optional>

=begin html

<br>Sets the volume policies for insertion into the SSD tier. The possible values are - <ul> <li>"meta" - insert only volume metadata buffers into the SSD tier. <li>"random_read" - inserts randomly accessed buffers into the SSD SSD tier. <li>"random_read_write" - inserts buffers as defined by "random-read". In addition, buffers involved in random write operations are cached. </ul> Note: either read-cache and/or write-cache must be provided as inputs

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>The volume on which the hybrid caching policy is to be set.

=end html

=back



=over 2

=item * I<write-cache>  =>   B<string, optional>

=begin html

<br>Sets the volume policies for write caching into SSD tier. The possible values are - <ul> <li>"random_write" - randomly accessed buffers are write cached. <li>"none" - no buffers will be write cached. </ul>

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 priority_list_info

[B<Family:> ontap-classic]


=begin html

Get status information for priority scheduler

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<enabled-components>  =>   B<string>

=begin html

<br>A list of enabled priority components, or "all" if all components are enabled.

=end html

=back



=over 2

=item * I<io-concurrency>  =>   B<integer>

=begin html

<br>The value for IO concurrency, as described in priority-set

=end html

=back



=over 2

=item * I<nvlog-cp-completion>  =>   B<string>

=begin html

<br>The method for consistency point (CP) completion when NVLOG limiting is being enforced, as described in priority-set.

=end html

=back



=over 2

=item * I<nvlog-cp-threshold>  =>   B<integer>

=begin html

<br>The threshold for NVLOG limiting during a consistency point (CP), as described in priority-set. Range: [1..100]

=end html

=back



=over 2

=item * I<status>  =>   B<string>

=begin html

<br>Whether priority scheduling is enabled, possible values are 'on' or 'off'

=end html

=back



=head2 priority_list_info_default

[B<Family:> ontap-classic]


=begin html

Get information for the default scheduling policy in the priority scheduler. The default scheduling policy is applied to volumes that do not have an explicit policy set.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<level>  =>   B<integer, optional>

=begin html

<br>The priority level, from 1-10

=end html

=back



=over 2

=item * I<nvlog-limit>  =>   B<integer>

=begin html

<br>The limit on nvlog consumption during a consistency point. 0 means a system-created default is being applied.

=end html

=back



=over 2

=item * I<system>  =>   B<integer>

=begin html

<br>The system/user priority, from 1-10

=end html

=back



=over 2

=item * I<system-read-limit>  =>   B<integer>

=begin html

<br>The limit on system reads, as described in priority-set-default. A value of 0 means a system-created default is used.

=end html

=back



=over 2

=item * I<user-read-limit>  =>   B<integer>

=begin html

<br>The limit on user reads, as described in priority-set-default. A value of 0 means a system-created default is used.

=end html

=back



=head2 priority_list_info_volume

[B<Family:> ontap-classic]


=begin html

Get volume-related priority schedule information.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string, optional>

=begin html

<br>If specified, a specific volume whose priority schedule should be returned. If ommitted, all priority schedules for volumes are returned.

=end html

=back



B<Outputs>

=over 2

=item * I<priority-volume>  =>   B<L<"priority-volume-info">[]>

=begin html

<br>Array of all or specified volume-related priority schedule information.

=end html

=back



=head2 priority_set

[B<Family:> ontap-classic]


=begin html

Sets priority options

=end html



B<Inputs>

=over 2

=item * I<io-concurrency>  =>   B<integer, optional>

=begin html

<br>Sets the io-concurrency value for the appliance. The io-concurrency specifies the average number of concurrent io operations to a disk.

=end html

=back



=over 2

=item * I<nvlog-cp-completion>  =>   B<string, optional>

=begin html

<br>Sets the nvlog-cp-completion value for the appliance The nvlog-cp-completion defines the method of consistency point (CP) completion when one or more volumes are limited by NVLOG usage. Possible values are: "fast", "paced" or "default". A fast CP completion will finish the CP as soon as possible, so allowed resources blocked on NVLOG to be continue. A paced CP completion (the default when no NVLOG limiting occurs) controls the speed of the CP to reduce system impact overall, but may cause resources blocks on NVLOG to delay longer. The default mode is fast.

=end html

=back



=over 2

=item * I<nvlog-cp-threshold>  =>   B<integer, optional>

=begin html

<br>Sets the nvlog-cp-threshold value for the appliance as a percentage. The nvlog-cp-threshold defines the percentage of the system NVLOG that must be used before NVLOG limits are applied during a system consistency point (CP). The default value is 50%. Range: [1..100]

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 priority_set_default

[B<Family:> ontap-classic]


=begin html

Sets priority options for default scheduling. Default scheduling is applied to all volumes that do not have a specific scheduling policy defined.

=end html



B<Inputs>

=over 2

=item * I<level>  =>   B<integer, optional>

=begin html

<br>Sets the priority schedule level for the volume. The possible values are 1 through 10, where 1 means lowest relative priority, and 10 means highest relative priority.

=end html

=back



=over 2

=item * I<nvlog-limit>  =>   B<integer, optional>

=begin html

<br>The maximum number percentage of system NVLOG resources that may be consumed during a consistency point.

=end html

=back



=over 2

=item * I<system>  =>   B<integer, optional>

=begin html

<br>Sets the relative priority system/user scheduling for the volume. The possible value are 1 through 10, where 1 means heavily favor user operations and 10 means heavily favor system operations.

=end html

=back



=over 2

=item * I<system-read-limit>  =>   B<integer, optional>

=begin html

<br>The maximum number of system read operations outstanding, before further operations are queued.

=end html

=back



=over 2

=item * I<user-read-limit>  =>   B<integer, optional>

=begin html

<br>The maximum number of user read operations outstanding, before further operations are queued.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 priority_set_volume

[B<Family:> ontap-classic]


=begin html

Sets priority scheduling for a volume

=end html



B<Inputs>

=over 2

=item * I<cache-policy>  =>   B<string, optional>

=begin html

<br>The buffer cache policy to use for the volume. Possible values are: 'keep' - Try to keep data in the buffer cache. 'reuse' - Reuse blocks, do not try to cache. 'default' - Apply the default policy

=end html

=back



=over 2

=item * I<level>  =>   B<integer, optional>

=begin html

<br>Sets the priority schedule level for the volume. The possible values are 1 through 10, where 1 means lowest relative priority, and 10 means highest relative priority.

=end html

=back



=over 2

=item * I<nvlog-limit>  =>   B<integer, optional>

=begin html

<br>The maximum number percentage of system NVLOG resources that may be consumed. A value of 0 means restore the system-defined limit.

=end html

=back



=over 2

=item * I<service>  =>   B<string, optional>

=begin html

<br>Sets the priority service type for the volume. The possible values are 'on', 'off' or 'default'. 'off' temporarily disables specific priority scheduling for the volume, but preserves the priority schedule so that it can later be enabled. 'default' removes the specific priority scheduling for the volume, which will revert to using the default priority schedule.

=end html

=back



=over 2

=item * I<system>  =>   B<integer, optional>

=begin html

<br>Sets the relative priority system/user scheduling for the volume. The possible value are 1 through 10, where 1 means heavily favor user operations and 10 means heavily favor system operations.

=end html

=back



=over 2

=item * I<system-read-limit>  =>   B<integer, optional>

=begin html

<br>The maximum number of system read operations outstanding, before further operations are queued. A value of 0 means restore the system-defined limit.

=end html

=back



=over 2

=item * I<user-read-limit>  =>   B<integer, optional>

=begin html

<br>The maximum number of user read operations outstanding, before further operations are queued. A value of 0 means restore the system-defined limit.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>The volume whose priority scheduling is to be set.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 qtree_create

[B<Family:> ontap-classic, vfiler]


=begin html

Create a new qtree.

=end html



B<Inputs>

=over 2

=item * I<mode>  =>   B<string, optional>

=begin html

<br>The file permission bits of the qtree. Similar to UNIX permission bits: 0755 gives read/write/execute permissions to owner and read/execute to group and other users. It consists of 4 octal digits derived by adding up bits 4, 2, and 1. Omitted digits are assumed to be zeros. First digit selects the set user ID (4), set group ID (2), and sticky (1) attributes. The second digit selects permissions for the owner of the file: read (4), write (2), and execute (1); the third selects permissions for other users in the same group; the fourth for other users not in the group. <p> For unclustered volumes, if this argument is missing, use the value specified in the option "wafl.default_qtree_mode". <p> For clustered volumes, if this argument is missing, the permissions of the volume is used.

=end html

=back



=over 2

=item * I<qtree>  =>   B<string>

=begin html

<br>The path of the qtree, relative to the volume.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume on which to create the qtree

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 qtree_delete

[B<Family:> ontap-classic, vfiler]


=begin html

Delete the specified qtree. <p> For unclustered volumes, use the quota management APIs to delete the quota rules that reference this qtree in the /etc/quotas file. <p> For clustered volumes, all the quota rules that reference this qtree will be automatically deleted.

=end html



B<Inputs>

=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>Force the deletion of the qtree even if it not empty. On using "force" option, ZAPI may take a long time to complete because the contents of the entire qtree will have to be deleted before it returns. Default: false <p> For clustered volumes, if the qtree has a large number of files, it is recommended that the qtree-delete-async API be used.

=end html

=back



=over 2

=item * I<qtree>  =>   B<string>

=begin html

<br>Path of an existing qtree. The path should be in this format: /vol/< volume name >/< qtree name >.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 qtree_list

[B<Family:> ontap-classic, vfiler]


=begin html

Return list of qtrees

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string, optional>

=begin html

<br>Name of the volume to be queried. Do not include a "/vol/" prefix.

=end html

=back



B<Outputs>

=over 2

=item * I<qtrees>  =>   B<L<"qtree-info">[]>

=begin html

<br>An array, one entry per qtree.

=end html

=back



=head2 qtree_list_iter_end

[B<Family:> ontap-classic, vfiler]


=begin html

Terminate a list iteration and clean up any saved info.

=end html



B<Inputs>

=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous qtree-list-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 qtree_list_iter_next

[B<Family:> ontap-classic, vfiler]


=begin html

Continues an iteration through the list of qtrees

=end html



B<Inputs>

=over 2

=item * I<maximum>  =>   B<integer>

=begin html

<br>The maximum number of qtrees to retrieve.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous qtree-list-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * I<qtrees>  =>   B<L<"qtree-info">[]>

=begin html

<br>An array, one entry per qtree.

=end html

=back



=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>This tells you how many records are being returned from this particular call to qtree-list-iter-next. When this value is 0, you have everything.

=end html

=back



=head2 qtree_list_iter_start

[B<Family:> ontap-classic, vfiler]


=begin html

Starts an iteration through the list of qtrees.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>Number of items that have been saved for future retrieval with qtree-list-iter-next.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag to be used in subsequent iterations.

=end html

=back



=head2 qtree_rename

[B<Family:> ontap-classic, vfiler]


=begin html

Renames the specified qtree to a new name specified by "new-qtree-name". <p> For unclustered volumes, if the qtree is referenced in the file /etc/exportfs, use NFS API nfs-exportfs-append-rules to modify the file so that the affected file system can be exported by the filer immediately. The "qtree-rename" command does not automatically update the /etc/exports file. Also, if the qtree is referenced in the file /etc/quotas, use the quota management APIs to delete and re-create the quota rule with the new qtree name. <p> For clustered volumes, the qtree name in the quota rules will be automatically updated with the new qtree name.

=end html



B<Inputs>

=over 2

=item * I<new-qtree-name>  =>   B<string>

=begin html

<br>Path of new qtree. The path should be in this format: /vol/< volume name >/< dst qtree name >.

=end html

=back



=over 2

=item * I<qtree>  =>   B<string>

=begin html

<br>Path of an existing qtree. The path should be in this format: /vol/< volume name >/< src qtree name >.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 quota_add_entry

[B<Family:> ontap-classic, vfiler]


=begin html

Adds a quota entry. If the type, target, volume, and tree do not exist, a new entry is created. If the type, target, volume, and tree exist, then an error is returned.

=end html



B<Inputs>

=over 2

=item * I<disk-limit>  =>   B<string, optional>

=begin html

<br>This is the amount of disk space that is reserved for the the target. The value is expressed in kilobytes (1024). Set the value to "-" if the limit is to be unlimited. Default is unlimited.

=end html

=back



=over 2

=item * I<file-limit>  =>   B<string, optional>

=begin html

<br>This is the number of files that the target can have. Set the value to "-" if the limit is to be unlimited. Default is unlimited.

=end html

=back



=over 2

=item * I<qtree>  =>   B<string>

=begin html

<br>This is the qtree name that the quota resides on. For user or group rules, it can be the qtree name or "" if no qtree. For tree type rules, this field must be "".

=end html

=back



=over 2

=item * I<quota-target>  =>   B<string>

=begin html

<br>This is the quota target of the type specified. The target can be of the form: &lt;name&gt;, &lt;number&gt;, or &lt;path name&gt;. Multiple targets can be specified by a comma-separated list. Path should be entered in a format that starts with the following "/vol/< volume name >/". For explicit tree rules, the qtree should be specified as "/vol/< volume name >/ < qtree name >"

=end html

=back



=over 2

=item * I<quota-type>  =>   B<string>

=begin html

<br>The type of quota rule. Possible values are "user", "group", or "tree".

=end html

=back



=over 2

=item * I<soft-disk-limit>  =>   B<string, optional>

=begin html

<br>This is the amount of disk space the target would have to exceed before a message is logged and an SNMP trap is generated. The value is expressed in kilobytes (1024). Set the value to "-" if the limit is to be unlimited. Default is unlimited.

=end html

=back



=over 2

=item * I<soft-file-limit>  =>   B<string, optional>

=begin html

<br>This is the number of files the target would have to exceed before a message is logged and an SNMP trap is generated. Set the value to "-" if the limit is to be unlimited. Default is unlimited.

=end html

=back



=over 2

=item * I<threshold>  =>   B<string, optional>

=begin html

<br>This is the amount of disk space the target would have to exceed before a message is logged. The value is expressed in kilobytes (1024). Set the value to "-" if the limit is to be unlimited. Default is unlimited.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>This is the volume name that the quota resides on.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 quota_delete_entry

[B<Family:> ontap-classic, vfiler]


=begin html

Deletes a quota entry specified by type, target, volume, and tree.

=end html



B<Inputs>

=over 2

=item * I<qtree>  =>   B<string>

=begin html

<br>Name of the qtree for the quota. For user or group rules, it can be the qtree name or "" if no qtree. For tree type rules, this field must be "".

=end html

=back



=over 2

=item * I<quota-target>  =>   B<string>

=begin html

<br>The quota target of the type specified. Possible values are: &lt;name&gt;, &lt;number&gt;, or &lt;path name&gt;. Multiple targets can be specified by a comma-separated list. Path should be entered in a format that starts with the following "/vol/< volume name >/". For explicit tree rules, the qtree should be specified as "/vol/< volume name >/ < qtree name >"

=end html

=back



=over 2

=item * I<quota-type>  =>   B<string>

=begin html

<br>The type of quota rule. Possible values are "user", "group", or "tree".

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume for the quota.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 quota_get_entry

[B<Family:> ontap-classic, vfiler]


=begin html

Obtains a quota entry specified by type, target, volume, and tree.

=end html



B<Inputs>

=over 2

=item * I<qtree>  =>   B<string>

=begin html

<br>Name of the qtree for the quota. For user or group rules, it can be the qtree name or "" if no qtree. For tree type rules, this field must be "".

=end html

=back



=over 2

=item * I<quota-target>  =>   B<string>

=begin html

<br>The quota target of the type specified. Possible values are: &lt;name&gt;, &lt;number&gt;, or &lt;path name&gt;. Multiple targets can be specified by a comma-separated list. Path should be entered in a format that starts with the following "/vol/< volume name >/". For explicit tree rules, the qtree should be specified as "/vol/< volume name >/ < qtree name >"

=end html

=back



=over 2

=item * I<quota-type>  =>   B<string>

=begin html

<br>The type of quota rule. Possible values are "user", "group", or "tree".

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume for the quota.

=end html

=back



B<Outputs>

=over 2

=item * I<disk-limit>  =>   B<string>

=begin html

<br>The amount of disk space that is reserved for the the target. The value is expressed in kilobytes (1024). The value is "-" if the limit is unlimited.

=end html

=back



=over 2

=item * I<file-limit>  =>   B<string>

=begin html

<br>The number of files that the target can have. The value is "-" if the limit is unlimited.

=end html

=back



=over 2

=item * I<perform-user-mapping>  =>   B<boolean, optional>

=begin html

<br>If the value is true, quota management will perform user mapping according to /etc/usermap.cfg for unclustered volumes. For clustered volumes, user mapping is performed according to the user mapping configured for the vserver to which the volume belongs.

=end html

=back



=over 2

=item * I<quota-error>  =>   B<L<"quota-error">, optional>

=begin html

<br>This value is only present if there is an error, and gives complete details on the error in a specific quota entry.

=end html

=back



=over 2

=item * I<soft-disk-limit>  =>   B<string>

=begin html

<br>The amount of disk space the target would have to exceed before a message is logged and an SNMP trap is generated. The value is expressed in kilobytes (1024). The value is "-" if the limit is unlimited.

=end html

=back



=over 2

=item * I<soft-file-limit>  =>   B<string>

=begin html

<br>The number of files the target would have to exceed before a message is logged and an SNMP trap is generated. The value is "-" if the limit is unlimited.

=end html

=back



=over 2

=item * I<threshold>  =>   B<string>

=begin html

<br>The amount of disk space the target would have to exceed before a message is logged. The value is expressed in kilobytes (1024). The value is "-" if the limit is unlimited.

=end html

=back



=head2 quota_list_entries

[B<Family:> ontap-classic, vfiler]


=begin html

Returns quota entries from the /etc/quotas file.

=end html



B<Inputs>

=over 2

=item * I<include-output-entry>  =>   B<boolean, optional>

=begin html

<br>If specified and true, the raw quota entry is placed in the <line> output element.

=end html

=back



B<Outputs>

=over 2

=item * I<quota-entries>  =>   B<L<"quota-entry">[]>

=begin html

<br>An array of quota entries.

=end html

=back



=head2 quota_list_entries_iter_end

[B<Family:> ontap-classic, vfiler]


=begin html

Terminate a list iteration and clean up any saved info.

=end html



B<Inputs>

=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous quota-list-entries-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 quota_list_entries_iter_next

[B<Family:> ontap-classic, vfiler]


=begin html

Continues an iteration through the list of quotas.

=end html



B<Inputs>

=over 2

=item * I<maximum>  =>   B<integer>

=begin html

<br>The maximum number of entries to retrieve.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous quota-list-entries-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * I<quota-entries>  =>   B<L<"quota-entry">[], optional>

=begin html

<br>An array of quota information.

=end html

=back



=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>This tells you how many records are being returned from this particular call to quota-list-entries-iter-next. When this value is 0, you have retrieved everything.

=end html

=back



=head2 quota_list_entries_iter_start

[B<Family:> ontap-classic, vfiler]


=begin html

Starts an iteration through the list of quotas entries in /etc/quotas.

=end html



B<Inputs>

=over 2

=item * I<include-output-entry>  =>   B<boolean, optional>

=begin html

<br>If specified and true, the entire quota entry is placed in the <line> ouput elements.

=end html

=back



B<Outputs>

=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>This tells you the number of items that have been saved for future retrieval with quota-list-entries-iter-next.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag to be used in subsequent iterations.

=end html

=back



=head2 quota_modify_entry

[B<Family:> ontap-classic, vfiler]


=begin html

Modifys a quota entry. If the type, target, volume, and tree exist, the entry is modified. If the type, target, volume, and tree do not exist, then an error is returned.

=end html



B<Inputs>

=over 2

=item * I<disk-limit>  =>   B<string, optional>

=begin html

<br>This is the amount of disk space that is reserved for the the target. The value is expressed in kilobytes (1024). Set the value to "-" if the limit is to be unlimited. Default is the current value.

=end html

=back



=over 2

=item * I<file-limit>  =>   B<string, optional>

=begin html

<br>This is the number of files that the target can have. Set the value to "-" if the limit is to be unlimited. Default is the current value.

=end html

=back



=over 2

=item * I<qtree>  =>   B<string>

=begin html

<br>This is the qtree name that the quota resides on. For user or group rules, it can be the qtree name or "" if no qtree. For tree type rules, this field must be "".

=end html

=back



=over 2

=item * I<quota-target>  =>   B<string>

=begin html

<br>This is the quota target of the type specified. The target can be of the form: &lt;name&gt;, &lt;number&gt;, or &lt;path name&gt;. Multiple targets can be specified by a comma-separated list. Path should be entered in a format that starts with the following "/vol/< volume name >/". For explicit tree rules, the qtree should be specified as "/vol/< volume name >/ < qtree name >"

=end html

=back



=over 2

=item * I<quota-type>  =>   B<string>

=begin html

<br>The type of quota rule. Possible values are "user", "group", or "tree".

=end html

=back



=over 2

=item * I<soft-disk-limit>  =>   B<string, optional>

=begin html

<br>This is the amount of disk space the target would have to exceed before a message is logged and an SNMP trap is generated. The value is expressed in kilobytes (1024). Set the value to "-" if the limit is to be unlimited. Default is the current value.

=end html

=back



=over 2

=item * I<soft-file-limit>  =>   B<string, optional>

=begin html

<br>This is the number of files the target would have to exceed before a message is logged and an SNMP trap is generated. Set the value to "-" if the limit is to be unlimited. Default is the current value.

=end html

=back



=over 2

=item * I<threshold>  =>   B<string, optional>

=begin html

<br>This is the amount of disk space the target would have to exceed before a message is logged. The value is expressed in kilobytes (1024). Set the value to "-" if the limit is to be unlimited. Default is the current value.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>This is the volume name that the quota resides on.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 quota_off

[B<Family:> ontap-classic, vfiler]


=begin html

Turns the quota subsystem off for a volume. <p> For clustered volumes, a jobid will also be returned. The progress of the job can be tracked using the job APIs.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume on which to turn quotas off.

=end html

=back



B<Outputs>

=over 2

=item * I<result-status>  =>   B<string, optional>

=begin html

<br>The operation status. Possible values: "succeeded", "in-progress", "failed".

=end html

=back



=head2 quota_on

[B<Family:> ontap-classic, vfiler]


=begin html

Starts to turn quotas on for a volume. A successful return from this API does not mean that quotas are on, merely that an attempt to start it has been triggered. Use the quota-status API to check the status. <p> For clustered volumes, a jobid will also be returned. The progress of the job can be tracked using the job APIs.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume on which to enable quotas.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 quota_report

[B<Family:> ontap-classic, vfiler]


=begin html

Returns a report on all quotas.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string, optional>

=begin html

<br>If specified, the report will contain only quotas that apply to the specified path name. The path should start with "/vol/<volumename>", although paths without the "/vol" prefix will work and will be assumed to be in the root volume.

=end html

=back



=over 2

=item * I<volume>  =>   B<string, optional>

=begin html

<br>If provided, the report will contain only quotas on the specified volume name. The name should not contain a "/vol/" prefix.

=end html

=back



B<Outputs>

=over 2

=item * I<error>  =>   B<L<"error">, optional>

=begin html

<br>If an error occurs in the midst of a report, this element is included in the output to indicate it (because it's too late at that point to include it in the main <results> of the API. This structure includes the same information (status, reason, errno) that is normally included as attributes on the <results> of the API itself. This error output element is also used to report the fact that quotas are off, if they are not currently turned on.

=end html

=back



=over 2

=item * I<quotas>  =>   B<L<"quota">[]>

=begin html

<br>An array of quotas.

=end html

=back



=head2 quota_report_iter_end

[B<Family:> ontap-classic, vfiler]


=begin html

Terminate a list iteration and clean up any saved info.

=end html



B<Inputs>

=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous quota-report-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 quota_report_iter_next

[B<Family:> ontap-classic, vfiler]


=begin html

Returns items from a previous call to quota-report-iter-start

=end html



B<Inputs>

=over 2

=item * I<maximum>  =>   B<integer>

=begin html

<br>The maximum number of entries to retrieve.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous quota-report-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * I<quotas>  =>   B<L<"quota-info">[], optional>

=begin html

<br>An array of quotas.

=end html

=back



=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>This tells you how many records are being returned from this particular call to quota-report-iter-next. When this value is 0, you have retrieved everything.

=end html

=back



=head2 quota_report_iter_start

[B<Family:> ontap-classic, vfiler]


=begin html

Generates a report on quotas, the results of which are retrieved by using quota-report-iter-next.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string, optional>

=begin html

<br>A path (including a /vol/<volumename> prefix). If specified, the report will contain only quotas that apply to the specified path name.

=end html

=back



=over 2

=item * I<volume>  =>   B<string, optional>

=begin html

<br>Name of a volume. If specified, the report will contain only quotas on the specified volume.

=end html

=back



B<Outputs>

=over 2

=item * I<error>  =>   B<L<"error">, optional>

=begin html

<br>If an error occurs in the midst of a report, this element is included to indicate it. It includes the same information that is normally included as attributes on the <results> element.

=end html

=back



=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>Number which tells you how many items have been saved for future retrieval with quota-report-iter-next.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag to be used in subsequent calls to quota-report-iter-next.

=end html

=back



=head2 quota_resize

[B<Family:> ontap-classic, vfiler]


=begin html

Starts an ONTAP operation to resize quotas for a volume. A successful return from this API does not mean that the operation has finished, merely that an attempt to start it been triggered. Use the quota-status API to check the status. <p> For clustered volumes, a jobid will also be returned. The progress of the job can be tracked using the job APIs.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume on which to resize quotas.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 quota_set_entry

[B<Family:> ontap-classic, vfiler]


=begin html

Sets a quota entry. If the type, target, volume, and tree do not exist, a new entry is created. If the type, target, volume, and tree exist, then the entry is modified.

=end html



B<Inputs>

=over 2

=item * I<disk-limit>  =>   B<string, optional>

=begin html

<br>The amount of disk space that is reserved for the the target. The value is expressed in kilobytes (1024). Set the value to "-" if the limit is to be unlimited.

=end html

=back



=over 2

=item * I<file-limit>  =>   B<string, optional>

=begin html

<br>The number of files that the target can have. Set the value to "-" if the limit is to be unlimited.

=end html

=back



=over 2

=item * I<qtree>  =>   B<string>

=begin html

<br>Name of the qtree for the quota. For user or group rules, it can be the qtree name or "" if no qtree. For tree type rules, this field must be "".

=end html

=back



=over 2

=item * I<quota-target>  =>   B<string>

=begin html

<br>The quota target of the type specified. Possible values are &lt;name&gt;, &lt;number&gt;, or &lt;path name&gt;. Multiple targets can be specified by a comma-separated list. Path should be entered in a format that starts with the following "/vol/< volume name >/". For explicit tree rules, the qtree should be specified as "/vol/< volume name >/ < qtree name >"

=end html

=back



=over 2

=item * I<quota-type>  =>   B<string>

=begin html

<br>The type of quota rule. Possible values are "user", "group", or "tree".

=end html

=back



=over 2

=item * I<soft-disk-limit>  =>   B<string, optional>

=begin html

<br>The amount of disk space the target would have to exceed before a message is logged and an SNMP trap is generated. The value is expressed in kilobytes (1024). Set the value to "-" if the limit is to be unlimited.

=end html

=back



=over 2

=item * I<soft-file-limit>  =>   B<string, optional>

=begin html

<br>The number of files the target would have to exceed before a message is logged and an SNMP trap is generated. Set the value to "-" if the limit is to be unlimited.

=end html

=back



=over 2

=item * I<threshold>  =>   B<string, optional>

=begin html

<br>The amount of disk space the target would have to exceed before a message is logged. The value is expressed in kilobytes (1024). Set the value to "-" if the limit is to be unlimited.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume for the quota.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 quota_status

[B<Family:> ontap-classic, vfiler]


=begin html

Obtains the status of quotas

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume whose quota status should be obtained.

=end html

=back



B<Outputs>

=over 2

=item * I<percent-complete>  =>   B<integer, optional>

=begin html

<br>The percentage complete for an "on" or "resize" operation. This is present when the status is "upgrading", "resizing" or "initializing".

=end html

=back



=over 2

=item * I<quota-errors>  =>   B<string, optional>

=begin html

<br>Collection of quota errors including the value of the reason tag above. Each error will be separated by a newline, '\n'. Since the quota parser does not stop when a parsing error occurs, this tag returns all the errors from the quota parser. If not present, there are no errors.

=end html

=back



=over 2

=item * I<reason>  =>   B<string, optional>

=begin html

<br>The last quota error message. If not present, there are no errors.

=end html

=back



=over 2

=item * I<status>  =>   B<string>

=begin html

<br>Primary status of quotas on the indicated volume; Possible values: <ul> <li> "corrupt" </li> <li> "initializing" </li> <li> "off" </li> <li> "on" </li> <li> "resizing" </li> <li> "reverting" </li> <li> "upgrading" </li> </ul>

=end html

=back



=over 2

=item * I<substatus>  =>   B<string>

=begin html

<br>Minor quota status on the indicated volume. This status is only valid when primary status is "resizing" or "initializing". Possible values are: <ul> <li> "done" </li> <li> "etc scanning" </li> <li> "finishing" </li> <li> "none" </li> <li> "queue scan" </li> <li> "scanning" </li> <li> "setup" </li> <li> "transferring rules" </li> <li> "upgrading" </li> </ul>

=end html

=back



=head2 radius_reset_stats

[B<Family:> ontap-classic, vfiler]


=begin html

Zero radius client counters

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 radius_server_add

[B<Family:> ontap-classic, vfiler]


=begin html

Add a radius server to the radius client service

=end html



B<Inputs>

=over 2

=item * I<is-default-server>  =>   B<boolean, optional>

=begin html

<br>Whether or not to set the server as default server.

=end html

=back



=over 2

=item * I<port>  =>   B<integer, optional>

=begin html

<br>The UDP port number of the radius server. The default port number is 1812 if not specified. Range: [1..2^16-1]

=end html

=back



=over 2

=item * I<radius-ip-addr>  =>   B<string>

=begin html

<br>The hostname or IP address (in dotted-decimal format) of the radius server to add. (for example, "192.168.11.12").

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 radius_server_remove

[B<Family:> ontap-classic, vfiler]


=begin html

Remove a radius server from the radius client service

=end html



B<Inputs>

=over 2

=item * I<port>  =>   B<integer, optional>

=begin html

<br>The UDP port number of the radius server. The default port number is 1812 if not specified. Range: [1..2^16-1]

=end html

=back



=over 2

=item * I<radius-ip-addr>  =>   B<string>

=begin html

<br>The hostname or IP address (in dotted-decimal format) of the radius server to remove. (for example, "192.168.11.12").

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 radius_service_start

[B<Family:> ontap-classic, vfiler]


=begin html

Start radius client service. Service will be avaliable once the call returns with success.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 radius_service_status

[B<Family:> ontap-classic, vfiler]


=begin html

Get status of the radius client service, whether or not it is running.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<is-available>  =>   B<boolean>

=begin html

<br>"true" if radius client service is running, "false" otherwise.

=end html

=back



=head2 radius_service_stop

[B<Family:> ontap-classic, vfiler]


=begin html

Stop radius client service. Service will no longer be available once the call returns with success.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 radius_show_info

[B<Family:> ontap-classic, vfiler]


=begin html

Get the information about the radius client service.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<is-available>  =>   B<boolean>

=begin html

<br>"true" if radius client service is running, "false" otherwise.

=end html

=back



=over 2

=item * I<radius-server-list-entries>  =>   B<L<"radius-server-list-entry-info">[]>

=begin html

<br>A list of configured radius servers.

=end html

=back



=head2 radius_stats_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Return radius client statistics

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<radius-stats>  =>   B<L<"radius-stats-info">[]>

=begin html

<br>statistics for radius client

=end html

=back



=head2 reallocate_delete_schedule

[B<Family:> ontap-classic]


=begin html

Delete a schedule for a reallocation job

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path to large file or LUN whose reallocation schedule should be deleted. The path must start with /vol/

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 reallocate_list_info

[B<Family:> ontap-classic]


=begin html

Get status for WAFL reallocation jobs

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string, optional>

=begin html

<br>Name of a path to get status on. If specified only status for that path is returned. If not specified, information for all reallocation jobs is returned. The path must start with /vol/.

=end html

=back



=over 2

=item * I<verbose>  =>   B<boolean, optional>

=begin html

<br>If true, verbose output is returned. Otherwise default output is returned.

=end html

=back



B<Outputs>

=over 2

=item * I<global-status>  =>   B<string>

=begin html

<br>The system-wide status of the reallocation system on the filer. The status is of the format: "Reallocation scans are on" or "Reallocation scans are off".

=end html

=back



=over 2

=item * I<reallocate-jobs>  =>   B<L<"reallocate-job-info">[]>

=begin html

<br>Array of all or specified reallocation jobs.

=end html

=back



=head2 reallocate_measure

[B<Family:> ontap-classic]


=begin html

Starts a new measurement-only reallocate job.

=end html



B<Inputs>

=over 2

=item * I<interval>  =>   B<string, optional>

=begin html

<br>The interval between repeated scans. The format is numX, where X is m, h or d, indicating minutes, hours or days.

=end html

=back



=over 2

=item * I<measure-logfile>  =>   B<string, optional>

=begin html

<br>Path to a full name on the appliance where information about the most recent measurement made will be logged, e.g. "/vol/logvol/measurelog.txt"

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path to large file, LUN or volume to measure optimization on, starting with /vol/.

=end html

=back



=over 2

=item * I<run-once>  =>   B<boolean, optional>

=begin html

<br>If true, run the scan once then exit. Interval and run-one are mutually exclusive

=end html

=back



=over 2

=item * I<threshold>  =>   B<integer, optional>

=begin html

<br>The allocation threshold before path is regarded as needing optimization. A larger value indicates the file or LUN can be more fragmented. Range: [3..10]

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 reallocate_off

[B<Family:> ontap-classic]


=begin html

Globally disables WAFL reallocation jobs

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<detail-status>  =>   B<string>

=begin html

<br>Detailed result status. If reallocation scans are already off the detailed status is "Reallocation scans are off". If reallocation scans will be disabled the detailed status is "Reallocation scans will be disabled."

=end html

=back



=head2 reallocate_on

[B<Family:> ontap-classic]


=begin html

Globally enables WAFL reallocation jobs

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<detail-status>  =>   B<string>

=begin html

<br>Detailed result status. If reallocation scans are already on the detailed status is "Reallocation scans are on". If reallocation scans will be enabled the detailed status is "Reallocation scans will be enabled."

=end html

=back



=head2 reallocate_quiesce

[B<Family:> ontap-classic]


=begin html

Quiesce a reallocation job. When a reallocation job is quiesced it will not be run until restarted, however information about the job is preserved.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path to large file or LUN to quiesce, starting with /vol/

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 reallocate_restart

[B<Family:> ontap-classic]


=begin html

Restart a reallocation job that is quiesced or idle.

=end html



B<Inputs>

=over 2

=item * I<ignore-checkpoint>  =>   B<boolean, optional>

=begin html

<br>Some long-running reallocate functions will checkpoint their progress so that if they are stopped (e.g., via quiesce or a reboot), they will continue from their previous position. This option, if true, ignores the checkpoint and restarts at the beginning.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path to large file or LUN to restart reallocation on, starting with /vol/

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 reallocate_set_schedule

[B<Family:> ontap-classic]


=begin html

Set a schedule for a reallocation job.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path to large file or LUN to reallocate, starting with /vol/

=end html

=back



=over 2

=item * I<schedule>  =>   B<string>

=begin html

<br>Reallocation schedule, in format "<min> <hour> <dom> <dow>", where each field is either a number, a comma-separated range of numbers, or "*", indicating all values.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 reallocate_start

[B<Family:> ontap-classic]


=begin html

Starts a new reallocation job

=end html



B<Inputs>

=over 2

=item * I<full>  =>   B<boolean, optional>

=begin html

<br>If true, perform a once-only full reallocate of the indicated file, LUN or volume (specified as /vol/VOLNAME). This option implies run-once and no-check are true.

=end html

=back



=over 2

=item * I<interval>  =>   B<string, optional>

=begin html

<br>The interval between repeated scans. The format is numX, where X is m, h or d, indicating minutes, hours or days.

=end html

=back



=over 2

=item * I<is-aggregate>  =>   B<boolean, optional>

=begin html

<br>If true, reallocate the aggregate indicated by the path. This performs block reallocation, not file reallocation.

=end html

=back



=over 2

=item * I<no-check>  =>   B<boolean, optional>

=begin html

<br>If true, do not check if the current layout optimization is above the threshold before reallocating.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path to large file or LUN to reallocate, starting with /vol/. If the full option is true then an entire volume may also be specified, as /vol/VOLNAME. If an aggregate, just the aggregate name must be specified.

=end html

=back



=over 2

=item * I<preserve-logical-bno>  =>   B<boolean, optional>

=begin html

<br>If true, reallocate the physical block location in the aggregate, but do not change the logical block number in the flexible volume. This option may only be selected for flexible volumes or files/LUNs within flexible volumes.

=end html

=back



=over 2

=item * I<run-once>  =>   B<boolean, optional>

=begin html

<br>If true, run the scan once then exit.

=end html

=back



=over 2

=item * I<threshold>  =>   B<integer, optional>

=begin html

<br>The allocation threshold before reallocation occurs. A larger value indicates the file or LUN can be more fragmented. Range: [3..10]

=end html

=back



=over 2

=item * I<unshare>  =>   B<boolean, optional>

=begin html

<br>If true, specifies that blocks that are shared by deduplication will be unshared. This may result in increased disk usage, especially for full reallocation.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 reallocate_stop

[B<Family:> ontap-classic]


=begin html

Stops a reallocation job.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path to large file or LUN to stop reallocation on. The path must start with /vol/

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 rsh_get_stats

[B<Family:> ontap-classic]


=begin html

Obtain rsh statistics.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<active-high-sessions>  =>   B<integer>

=begin html

<br>Active session high water mark.

=end html

=back



=over 2

=item * I<current-active-sessions>  =>   B<integer>

=begin html

<br>Current number of active sessions.

=end html

=back



=over 2

=item * I<max-available-sessions>  =>   B<integer>

=begin html

<br>Maximum available sessions.

=end html

=back



=over 2

=item * I<rsh-sessions>  =>   B<L<"rsh-session-info">[], optional>

=begin html

<br>List of active rsh sessions.

=end html

=back



=over 2

=item * I<session-invocations>  =>   B<integer>

=begin html

<br>Total number of rsh invocations since last reboot.

=end html

=back



=head2 rsh_kill

[B<Family:> ontap-classic]


=begin html

Kill a rsh session.

=end html



B<Inputs>

=over 2

=item * I<session-number>  =>   B<integer>

=begin html

<br>rsh session to be killed. This can be obtained from session-id in rsh-session-info by running the 'rsh-get-stats' API. Range : [0..191]

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 storage_shelf_bay_list_info

[B<Family:> ontap-classic]


=begin html

Returns information about storage shelf bays and ports for a selected number of shelves, or optionally all shelves connected to the storage controller.

=end html



B<Inputs>

=over 2

=item * I<channel-name>  =>   B<string, optional>

=begin html

<br>The adapter number or switch name and the port number (together, called the channel). If missing, then information for all shelves on all channels will be presented. If missing, then shelf-id input is not allowed. Examples: 8a, switch:5

=end html

=back



=over 2

=item * I<shelf-id>  =>   B<integer, optional>

=begin html

<br>shelf-id is the shelf number for which shelf data is requested. This input requires that channel-name input also be specified. If a channel-name and shelf-id are both specified then information for the specified shelf will be presented (a single shelf). If channel-name is specified, but shelf-id is missing, then information for all shelves on the channel will be presented. If channel-name is not specified then shelf-id is not supported and an error will be returned.

=end html

=back



B<Outputs>

=over 2

=item * I<shelf-bay-list>  =>   B<L<"shelf-bay-list-info">[]>

=begin html

<br>Each instance of shelf-list contains available bay information on a shelf.

=end html

=back



=head2 storage_shelf_environment_list_info

[B<Family:> ontap-classic]


=begin html

Returns the environmental information for a selected number of shelves, or optionally all shelves connected to the storage controller.

=end html



B<Inputs>

=over 2

=item * I<channel-name>  =>   B<string, optional>

=begin html

<br>Get environment information for shelves on this channel. shelf-id parameter can be specified to request data on a single shelf. If a channel-name is not specified, then data on all shelves on all channels will be returned. If an invalid channel-name is specified, then error code ECHANNELNOTFOUND will be returned.

=end html

=back



=over 2

=item * I<shelf-id>  =>   B<integer, optional>

=begin html

<br>Get environment information for the specified shelf-id on the specified channel-name. This parameter requires channel-name parameter as well. If shelf-id is specified without channel-name then the error code EINVALIDINPUTERROR will be returned. If shelf-id is not specified and a channel-name is specified, then data for all shelves on the channel-name is returned. If an invalid shelf-id is specified, then error code ESHELFNOTFOUND will be returned.

=end html

=back



B<Outputs>

=over 2

=item * I<shelf-environ-channel-list>  =>   B<L<"shelf-environ-channel-info">[]>

=begin html

<br>List of channels and associated environment information on the shelves in the channel. Only on-line channels that have shelves attached will be reported.

=end html

=back



=head2 storage_shelf_get_shelf_info

[B<Family:> ontap-classic]


=begin html

This returns information about an identified shelf. The information is the number of bays present (bay-count), and which shelf bays have drives (bay-list). Shelf bays are numbered from 0 to bay-count minus 1. Shelf bay 0 is always on the right when looking at the front of the shelf. Incidentally, the bay-list may be empty indicating the absence of any drives. However, there are some shelf designs which require a disk drive in bay 0 or 1 for any SES functionality to operate (e.g., DS14 and DS14-Mk2-FC). In these cases, shelves without drives in bay 0 or 1 will not be listed.

=end html



B<Inputs>

=over 2

=item * I<channel-name>  =>   B<string>

=begin html

<br>The adapter number or switch name and theport number (together, called the channel). Examples are 8a and switch:5

=end html

=back



=over 2

=item * I<shelf-id>  =>   B<integer>

=begin html

<br>The shelf id specifies the shelf for which a list of disk bays is desired. Range : [0..2^24-1]

=end html

=back



B<Outputs>

=over 2

=item * I<bay-count>  =>   B<integer>

=begin html

<br>Disk bays are the slots into which disks are placed. The bays are numbered from 0 to bay-count-1. Bay 0 is the right most bay (when looking at the front of the shelf) and bay bay-count-1 is left most. These bay numbers can be used by other commands, including storage-shelf-set-led-state. Range : [0..255]

=end html

=back



=over 2

=item * I<bay-list>  =>   B<L<"bay-info">[]>

=begin html

<br>A list of shelf-bay numbers which have disk drives. The bay-list field is not optional, but it may contain zero bay-info elements.

=end html

=back



=over 2

=item * I<firmware-rev-A>  =>   B<string, optional>

=begin html

<br>Shelf Module A firmware revision.

=end html

=back



=over 2

=item * I<firmware-rev-B>  =>   B<string, optional>

=begin html

<br>Shelf Module B firmware revision.

=end html

=back



=over 2

=item * I<firmware-revision>  =>   B<string>

=begin html

<br>Shelf firmware revision.

=end html

=back



=over 2

=item * I<shelf-type>  =>   B<string, optional>

=begin html

<br>Shelf module type. Some examples are: "ESH2", and "AT-FCX".

=end html

=back



=head2 storage_shelf_list_info

[B<Family:> ontap-classic]


=begin html

This interface returns information about one or more shelves.

=end html



B<Inputs>

=over 2

=item * I<channel-name>  =>   B<string, optional>

=begin html

<br>The adapter number or switch name and the port number (together, called the channel). If missing, then information for all shelves on all channels will be presented. If missing, then shelf-id input is not allowed. Examples are 8a and switch:5

=end html

=back



=over 2

=item * I<shelf-id>  =>   B<integer, optional>

=begin html

<br>shelf-id is the shelf number for which shelf data is requested. This input requires that channel-name input also be specified. If a channel-name and shelf-id are both specified then information for the specified shelf will be presented (a single shelf). If channel-name is specified, but shelf-id is missing, then information for all shelves on the channel will be presented. If channel-name is not specified then shelf-id is not supported. In such case information for all shelves on all channels will be presented.

=end html

=back



B<Outputs>

=over 2

=item * I<shelf-list>  =>   B<L<"shelf-info">[]>

=begin html

<br>Each instance of shelf-list contains all available information on a shelf hub. This can be empty if there are no shelves attached or if shelves do not support hubs. Also a partner shelf can be reported.

=end html

=back



=head2 storage_shelf_set_led_state

[B<Family:> ontap-classic]


=begin html

Set or clear the LED for a disk, shelf of disks or loop of shelves. LEDs to affect can be specified as: {channel-name}, {channel-name, shelf-id}, {channel-name, shelf-id, shelf-bay}, {channel-name, shelf-id, shelf-bay}, {channel-name, shelf-id, shelf-bay, lun}.

=end html



B<Inputs>

=over 2

=item * I<action>  =>   B<string>

=begin html

<br>This specifies the action to apply. Possible values are: on, and off. on: Turn the LED(s) on indefinitely. off: Turn the LED(s) off.

=end html

=back



=over 2

=item * I<channel-name>  =>   B<string>

=begin html

<br>The channel to which the shelf or drive LED to be affected is connected. A channel-name is the adapter number or switch name and the port number (together, called the channel). Examples are 8a and switch:5.

=end html

=back



=over 2

=item * I<duration>  =>   B<integer, optional>

=begin html

<br>This parameter allows the caller to specify the duration (in seconds) that the action will be applied. Note that the action 'on' is indefinite, while 'test' uses duration. 'blink' also uses duration.

=end html

=back



=over 2

=item * I<identify>  =>   B<boolean, optional>

=begin html

<br>This parameter allows the caller to specify the identify LED. The default is for the command to affect the fault LED. Not all disks have identify LEDs. In that case, the identify option is ignored and the fault LED is affected.

=end html

=back



=over 2

=item * I<lun>  =>   B<integer, optional>

=begin html

<br>Some targets have a logical unit number. In that case, the lun will be required to uniquely specify the LED to affect. Range : [0..255]

=end html

=back



=over 2

=item * I<shelf-bay>  =>   B<integer, optional>

=begin html

<br>If present, the shelf-bay indicates the specific drive where the LED affected resides. If shelf-id is supplied but shelf-bay is not, then the LEDs for all drives in the shelf will be affected. Range : [0..255]

=end html

=back



=over 2

=item * I<shelf-id>  =>   B<integer>

=begin html

<br>If present, the shelf-id indicates which shelf has the drive or drives where the LEDs to affect reside. Range : [0..2^24-1]

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 storage_shelf_update_fw

[B<Family:> ontap-classic]


=begin html

Start shelf firmware download process to update firmware on disk shelves. This operation is asynchronous, and therefore returns no errors that might occur during the download process. This operation will only update firmware on shelves that do not have the latest firmware revision. The firmware revision on the shelves can be monitored via the storage-shelf-get-shelf-info API. NOT IMPLEMENTED YET.

=end html



B<Inputs>

=over 2

=item * I<channel-name>  =>   B<string, optional>

=begin html

<br>If present, will only update firmware on all shelves (or a single shlef depending on shelf-id) on the given channel. If not present, then all shelves on all channels are updated. Example: To update firmware on 2a.shelf1, channel should be 2a and shelf should be 1.

=end html

=back



=over 2

=item * I<shelf-id>  =>   B<string, optional>

=begin html

<br>If present, will only update firmware on the given shelf on specified channel. If not present, and a channel-name is specified, then all shelves on the channel will be updated. Example: To update firmware on 2a.shelf1, channel should be 2a and shelf should be 1.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 sis_disable

[B<Family:> ontap-classic, vfiler]


=begin html

Disable sis on a volume. If the sis operation is active on the volume, it needs to be stopped by "sis-stop" API before disabling. <p> This API is not supported for Infinite Volumes.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>The full path of the sis volume, /vol/&lt;vol_name&gt;. Only one path can be specified at a time.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 sis_enable

[B<Family:> ontap-classic, vfiler]


=begin html

Enable sis on a volume. <p> On a non-SnapVault secondary volume, the sis operation will be started periodically according to a per-volume schedule. By default, this schedule is sun-sat&#064;0. (Everyday at 0:00 hours) On a SnapVault secondary volume, the sis operation will be kicked off at the end of the SnapVault transfer. This API does not enable compression on the volume. See the "sis-set-config" API for options to enable compression and for modifying the default schedule set on the volume. A sis operation can also be manually started using the sis-start API. <p> This API is not supported for Infinite Volumes.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>The full path of the sis volume, /vol/&lt;vol_name&gt;. Only one path can be specified at a time. The volume must be online to enable sis on the volume.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 sis_set_config

[B<Family:> ontap-classic, vfiler]


=begin html

Setup or modify sis policy, schedule or options for a volume. <p> This API is not supported for Infinite Volumes.

=end html



B<Inputs>

=over 2

=item * I<enable-compression>  =>   B<boolean, optional>

=begin html

<br>Enable compression on the sis volume. If true, compression will be enabled on the sis volume. If false, compression will be disabled on the volume. If the value is not specified compression state will be unchanged. <p> Enabling compression on a secondary volume is strongly discouraged. If compression is enabled on a secondary volume, storage efficiency present on the source will not be preserved during replication. The destination system needs to run offline storage efficiency scanner (compression and dedupe) to achieve storage savings. Additional compression savings on the destination comes at a cost of extra computation resources. In environments where there is a lot of shared data present on the source, (e.g., virtualized environments employing file clones), data inflation during transfer may lead to failed backups due to lack of space on the secondary volume.

=end html

=back



=over 2

=item * I<enable-idd>  =>   B<boolean, optional>

=begin html

<br>This enables file level incompressible data detection and quick check incompressible data detection for large files. This is per volume option. Once this set to true, inline compression will do a 4k compression quick check for large files before proceeding with full CG compression. If quick check finds a 4k within a CG as incompressible, inline compression won't attempt to compress the CG. And the blocks are written in uncompressed form to disk. Also once this is enabled, if inline compression encounters a incompressible CG within small files, it will mark the file with do not compress flag. As long as this flag is set on a small file, inline compression won't attempt further compression on the file. Default value is 'false'.

=end html

=back



=over 2

=item * I<enable-inline-compression>  =>   B<boolean, optional>

=begin html

<br>Enable inline compression on the sis volume. To enable inline compression, compression must be enabled either in this API call or by a previous call to sis-set-config. If true, inline-compression will be enabled on the sis volume. If false, inline-compression will be disabled on the volume. If the value is not specified, inline-compression state will be unchanged.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>The full path of the sis volume, /vol/&lt;vol_name&gt;.

=end html

=back



=over 2

=item * I<quick-check-fsize>  =>   B<integer, optional>

=begin html

<br>Quick check file size for Incompressible Data Detection. If Incompressible data detection is enabled and if the file size is >= quick-check-fsize, inline compression will do a 4k quick check before doing full CG compression.

=end html

=back



=over 2

=item * I<schedule>  =>   B<string, optional>

=begin html

<br>The schedule string for the sis operation. <p> The format of the schedule: <p> day_list[&#064;hour_list] or hour_list[&#064;day_list] or - or auto or manual <p> The day_list specifies which days of the week the sis operation should run. It is a comma-separated list of the first three letters of the day: sun, mon, tue, wed, thu, fri, sat. The names are not case sensitive. Day ranges such as mon-fri can also be given. The default day_list is sun-sat. <p> The hour_list specifies which hours of the day the sis operation should run on each scheduled day. The hour_list is a comma-separated list of the integers from 0 to 23. Hour ranges such as 8-17 are allowed. Step values can be used in conjunction with ranges. For example, 0-23/2 means "every two hours". The default hour_list is 0, i.e. midnight on the morning of each scheduled day. <p> If "-" is specified, no schedule is set. In Data ONTAP Cluster-Mode, policy-name and schedule must not be specified together in the same API call. If schedule is passed, any previous policy-name set on the volume is automatically reset. <p> The "auto" schedule string means the sis operation will be triggered by the amount of new data written to the volume. The criterion is subject to being changed later. <p> The "manual" schedule string prevents SIS from automatically triggering any operations and disables change-logging. This schedule string can only be used on SnapVault destination volumes. The use of this schedule is mainly desirable when inline compression is enabled on a SnapVault destination volume and background processing is not necessary.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 sis_start

[B<Family:> ontap-classic, vfiler]


=begin html

Start a sis operation on a volume. The volume must have sis enabled, before starting a sis operation. If the sis operation is already active on the volume, this API will fail. <p> This API is not supported for Infinite Volumes.

=end html



B<Inputs>

=over 2

=item * I<build-metadata>  =>   B<boolean, optional>

=begin html

<br>If this argument is "true", scanner will scan the entire volume and generate fingerprint database without attempting the sharing. This argument is valid only if scan argument is set to "true". Look at the documentation for scan parameter for more details. Default value: "false"

=end html

=back



=over 2

=item * I<delete-checkpoint>  =>   B<boolean, optional>

=begin html

<br>If this is "true", the sis operation will delete existing checkpoint and start the sis operation from the beginning. Default value: "false"

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>The full path of the sis volume, /vol/&lt;vol_name&gt;. The volume must be online in order to start the sis operation.

=end html

=back



=over 2

=item * I<qos-policy>  =>   B<string, optional>

=begin html

<br>QoS policy for the sis operation. Possible values are: <ul> <li> "background" - sis operation will run in background with minimal or no impact on data serving client operations, <li> "best-effort" - sis operations may have some impact on data serving client operations. </ul> Default value: "best-effort"

=end html

=back



=over 2

=item * I<queue-operation>  =>   B<boolean, optional>

=begin html

<br>If this is "true", the requested sis operation will be queued if a sis operation is already running on the volume, and the running operation is in the fingerprint verification phase. Default value: "false"

=end html

=back



=over 2

=item * I<restart-checkpoint>  =>   B<boolean, optional>

=begin html

<br>If this is "true", the sis operation will restart from previous checkpoint without checking for validity. This option should be used along with "scan" option. Default value: "false"

=end html

=back



=over 2

=item * I<scan>  =>   B<boolean, optional>

=begin html

<br>If this is "true", the sis operation will scan the file system to process all the existing data. <p> The scan will include whatever is enabled on the volume. For example: If compression is not enabled on the volume, the scan will not include compression. This default behavior can be changed by using the run-dedupe-scan and run-compression-scan parameters. <p> If scan is false only data added since the last sis operation will be processed. Default value: "false"

=end html

=back



=over 2

=item * I<scan-all>  =>   B<boolean, optional>

=begin html

<br>If this argument is "true", scanner will scan entire volume without applying shared block optimization. This argument is valid only if scan argument is set to "true". Look at the documentation for scan parameter for more details. Default value: "false"

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 sis_status

[B<Family:> ontap-classic, vfiler]


=begin html

Get Status of a sis volume This API is not optimal for use in Data ONTAP Cluster-Mode systems, and is deprecated. Use sis-get and sis-get-iter APIs for Data ONTAP Cluster Mode systems. This API is still supported for Data ONTAP 7-Mode systems.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string, optional>

=begin html

<br>The full path of the sis volume, /vol/&lt;vol_name&gt;. Only one path can be specified at a time. The volume must be online if not then an error will be returned. If path variable is not used then the status for all online sis volumes in the filer will be returned.

=end html

=back



=over 2

=item * I<verbose>  =>   B<boolean, optional>

=begin html

<br>If set to true the output is detailed. Default value: "false"

=end html

=back



B<Outputs>

=over 2

=item * I<sis-object>  =>   B<L<"dense-status">[]>

=begin html

<br>sis status objects returned.

=end html

=back



=head2 sis_stop

[B<Family:> ontap-classic, vfiler]


=begin html

Abort currently active sis operation on the volume. The sis operation will remain paused and the operation can be resumed by "sis-start", SnapVault transfer, or the scheduler. <p> This API is not supported for Infinite Volumes.

=end html



B<Inputs>

=over 2

=item * I<all-operations>  =>   B<boolean, optional>

=begin html

<br>If this is "true", both active and queued sis operation will be stopped. Default value: "false"

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>The full path of the sis volume, /vol/&lt;vol_name&gt;.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 file_get_snaplock_retention_time

[B<Family:> ontap-classic, vfiler]


=begin html

Get the SnapLock retention attributes of a file.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Absolute path of the file to query. The value must be prefixed with "/vol/<volume-name>".

=end html

=back



B<Outputs>

=over 2

=item * I<retention-time>  =>   B<integer>

=begin html

<br>Retention time in seconds since 01/01/1970 00:00:00. A zero value indicates that the file is not in WORM state. Range: [0..2^64-1]

=end html

=back



=head2 file_get_snaplock_retention_time_list_info_max

[B<Family:> ontap-classic, vfiler]


=begin html

Get the maximum number of entries that can be processed and returned in one call to the zapi file-snaplock-retention-time-list-info.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<max-list-entries>  =>   B<integer>

=begin html

<br>The maximum number of pathnames that can be processed in one call to file-snaplock-retention-time-list-info. This limit is imposed to prevent taking up too much CPU/memory for a ZAPI call. If the number of input pathnames for file-snaplock-retention-time-list-info is more than this number, it returns the error EAPITOOMANYENTRIES. Range: [0..2^64-1]

=end html

=back



=head2 file_set_snaplock_retention_time

[B<Family:> ontap-classic, vfiler]


=begin html

Set the SnapLock retention attributes of a file. In some cases, even if the call to file-set-snaplock-retention-time fails (that is the file could not be committed to worm successfully), it is possible that the atime of the file would be modified. One can specify either only retention-time or only set-infinite-retention for a given file path while calling this api. If neither the retention-time nor set-infinite-retention is specified, the file is committed to worm as read-only. If the expiry time of the file has been set explicitly, the expiry time is the atime of the file, otherwise the expiry time is calculated using the default retention of the volume as follows: Expiry time = current time + snaplock_default_period

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Absolute path of the file. The value must be prefixed with "/vol/&lt;volume-name&gt;".

=end html

=back



=over 2

=item * I<retention-time>  =>   B<integer, optional>

=begin html

<br>Expiry time in seconds since 01-Jan-1970 00:00:00 at which time the file will be eligible for deletion. If the expiry time specified does not comply with the snaplock_minimum_period and snaplock_maximum_period of the volume, the expiry time will be increased or decreased to do so.

=end html

=back



=over 2

=item * I<set-infinite-retention>  =>   B<boolean, optional>

=begin html

<br>Indicates if the retention period on the file needs to be set or extended to the infinite retention period. This field is available in Data ONTAP 8.1 and later. Default is false.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 file_snaplock_retention_time_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Get the Snaplock retention attributes for a list of files.

=end html



B<Inputs>

=over 2

=item * I<pathnames>  =>   B<L<"pathname-info">[]>

=begin html

<br>List of pathnames to query. The function returns the file-retention-information for each of these pathnames. If this ZAPI function is called without any input parameter, the error EAPIMISSINGARGUMENT is returned If number of input pathnames exceeds max-list-entries an error of EAPITOOMANYENTRIES is returned. The value of max-list-entries can be retrieved using the zapi call file-get-snaplock-retention-time-list-info-max.

=end html

=back



B<Outputs>

=over 2

=item * I<file-retention-details>  =>   B<L<"file-retention-info">[]>

=begin html

<br>information about retention period for each file in the list

=end html

=back



=head2 snaplock_get_compliance_clock

[B<Family:> ontap-classic]


=begin html

Older API to get the system complaince Clock time. Now depricated. Use snaplock-get-system-compliance-clock and snaplock-get-volume-compliance-clock.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snaplock_get_log_volume



=begin html

Get the active WORM log volume configuration

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<log-volume>  =>   B<string, optional>

=begin html

<br>When asking for the WORM log volume, the string value of the configured log-volume is returned. If the value is not set, a string is returned saying that no log volume is configured.

=end html

=back



=head2 snaplock_get_options



=begin html

gets the value of given snaplock option on a volume

=end html



B<Inputs>

=over 2

=item * I<option>  =>   B<string>

=begin html

<br>Specifies snaplock option. Presently, only the "privdel" snaplock option is supported. This option specifies the privileged delete capability state of the volume. For unsupported options, this zapi returns EONTAPI_EINVAL.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Specifies the volume

=end html

=back



B<Outputs>

=over 2

=item * I<option-value>  =>   B<string>

=begin html

<br>Value of the option parameter.

=end html

=back



=head2 snaplock_get_system_compliance_clock

[B<Family:> ontap-classic, vfiler]


=begin html

Get the SnapLock System Compliance Clock date and time.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<system-compliance-clock>  =>   B<L<"compliance-clock-info">>

=begin html

<br>System Compliance Clock.

=end html

=back



=head2 snaplock_get_volume_compliance_clock

[B<Family:> ontap-classic, vfiler]


=begin html

Get the SnapLock Volume Compliance Clock date and time.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume whose ComplianceClock needs to be obtained.

=end html

=back



B<Outputs>

=over 2

=item * I<system-compliance-clock>  =>   B<L<"compliance-clock-info">>

=begin html

<br>System Compliance Clock.

=end html

=back



=over 2

=item * I<volume-compliance-clock>  =>   B<L<"compliance-clock-info">>

=begin html

<br>Volume Compliance Clock for input volume list.

=end html

=back



=head2 snaplock_log_archive



=begin html

Archive the active worm log file. This will close the current log file for furthur updates and it will open a new log file to write future log updates.

=end html



B<Inputs>

=over 2

=item * I<log-basename>  =>   B<string, optional>

=begin html

<br>The basename of the worm log file to be archived. The logfile is of the format basename.<creation_date>-present. The date is in the format YYYYMMDD_HHMMSS_ZZZ If the log-basename is not specified, all the active WORM log files in the log-volume are archived. If the old log file was basename.<old-date>-present, once the archive command is run, the file will be renamed to basename.<old-date>-<current-date> and closed. A new log file of the name basename.<current-date>-present will be opened for future log updates. e.g. - The system log file was created on Jan 1st, 2007. The file would have the name system_log.20070101_000000_GMT-present. If this zapi is run on the file on Jun 1st, 2007 at 5 pm, the file would get renamed to system_log.20070101_000000_GMT-20070601_170000_GMT and will be closed to future updates. A new log file system_log.20070601_170000_GMT-present will be opened to capture future log updates.

=end html

=back



=over 2

=item * I<log-volume>  =>   B<string, optional>

=begin html

<br>The name of the volume that contains the WORM log files. This volume must be a SnapLock Compliance volume. If the log-volume is not specified, the log-volume is considered to be the volume configured by the snaplock zapi or command.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snaplock_log_status_list_info



=begin html

Status of the active worm log file/s

=end html



B<Inputs>

=over 2

=item * I<log-basename>  =>   B<string, optional>

=begin html

<br>The basename of the worm log file whos status is required. The logfile is of the format basename.<creation_date>-present If the log-basename is not specified, the status of all the active WORM log files in this volume are returned

=end html

=back



=over 2

=item * I<log-volume>  =>   B<string, optional>

=begin html

<br>The name of the volume that contains the WORM log files. This volume must be a SnapLock Compliance volume. If the log-volume is not specified, the log-volume is considered to be the volume configured by the snaplock zapi or command.

=end html

=back



B<Outputs>

=over 2

=item * I<log-file-count>  =>   B<integer>

=begin html

<br>Number of active WORM log files contained in the log-volume

=end html

=back



=over 2

=item * I<log-file-details>  =>   B<L<"log-file-info">[], optional>

=begin html

<br>Status information of each of the active WORM log files present in log-volume

=end html

=back



=over 2

=item * I<log-volume>  =>   B<string>

=begin html

<br>The name of the log volume. If log-volume is specified in the input, this value should be the same. If it isn't specified, this should be the same as the name configured by the snaplock zapi or command. The log-volume is a SnapLock compliance volume.

=end html

=back



=head2 snaplock_privileged_delete_file



=begin html

Executes a privileged delete on a SnapLock file

=end html



B<Inputs>

=over 2

=item * I<do-it>  =>   B<boolean, optional>

=begin html

<br>If set to true, it will enable privileged delete of the file specified by the path argument. If set to false, This zapi will not delete the file, instead it will return error EAPIERROR with message that user is trying to delete a file that is retained by Snaplock. Default value of this argument is 'false'.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Absolute path of the file to delete The value must be prefixed with "/vol/<volume-name>".

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snaplock_set_log_volume



=begin html

Set the active WORM log volume configuration

=end html



B<Inputs>

=over 2

=item * I<is-force>  =>   B<boolean, optional>

=begin html

<br>If true it will enable the set log volume operation to ignore errors encountered during SnapLock log volume change. Useful when the log volume is inconsistent or have not enough disk space Default is false.

=end html

=back



=over 2

=item * I<log-volume>  =>   B<string>

=begin html

<br>The name of the volume that will contain the WORM log files. This volume must be a SnapLock Compliance volume. if log-volume is NULL, ENOENT is returned with a string saying no volume was specified. If the set fails, EONTAPI_EIO is returned with a string indicating the reason.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snaplock_set_options



=begin html

sets snaplock options on a volume

=end html



B<Inputs>

=over 2

=item * I<do-it>  =>   B<boolean, optional>

=begin html

<br>If set to true, it will allow setting of privileged delete snaplock option to "disallowed" state. if set to false it will not allow setting of privileged delete option to "disallowed" state. However setting of privileged delete option to "on" or "off" state can be done regardless of the value of this parameter. Default value of this parameter is false.

=end html

=back



=over 2

=item * I<option>  =>   B<string>

=begin html

<br>Specifies snaplock option. Presently, only the "privdel" snaplock option is supported. This option specifies the privileged delete capability state of the volume. For unsupported options, this zapi returns EONTAPI_EINVAL.

=end html

=back



=over 2

=item * I<option-value>  =>   B<string>

=begin html

<br>Specifies the new value of the option. Presently for the "privdel" snaplock option, three values "on"/"off"/"disallowed" are supported. To set new value to "disallowed" requires "do-it" parameter to be set to "true". For unsupported option-value string, this zapi returns EONTAPI_EINVAL.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Specifies the volume

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snaplock_set_system_compliance_clock

[B<Family:> ontap-classic]


=begin html

Set the Compliance Clock of the system equal to the current system clock.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapmirror_abort

[B<Family:> ontap-classic, vfiler]


=begin html

The snapmirror-abort API stops ongoing transfers for a SnapMirror relationship. The relationship is identified by its destination endpoint. You must specify the destination endpoint when using snapmirror-abort. On Data ONTAP operating in Cluster-Mode, the snapmirror-abort API stops all of the active transfers to each associated volume on the receiving side in a set of load-sharing mirrors. Load-sharing mirrors are either up to date and serving data to clients, or they are lagging and not serving data to clients. If the snapmirror-abort API identifies an up-to-date load-sharing mirror, then SnapMirror transfers to associated up-to-date load-sharing mirrors in the set of load-sharing mirrors are also aborted. If the snapmirror-abort API identifies a lagging load-sharing mirror, then only the SnapMirror transfer associated with the lagging load-sharing mirror is aborted. After the snapmirror-abort API successfully completes its operation, the volume on the receiving side of the transfer might contain a restart checkpoint. The restart checkpoint can be used by a subsequent transfer to restart and continue the aborted SnapMirror transfer. Snapmirror-abort API must be used from the destination storage system on Data ONTAP operating in 7-Mode, from the destination cluster on Data ONTAP 8.1 operating in Cluster-Mode, from the destination Vserver or cluster on Data ONTAP 8.2 or later operating in Cluster-Mode. <p> This API is not supported if the destination end point is an Infinite Volume.

=end html



B<Inputs>

=over 2

=item * I<clear-checkpoint>  =>   B<boolean, optional>

=begin html

<br>If true, the restart checkpoint is cleared. The default is false, not cleared.

=end html

=back



=over 2

=item * I<destination-location>  =>   B<string, optional>

=begin html

<br>Specifies the destination endpoint of the SnapMirror relationship in the following formats: <ul> <li> &lt;system&gt;:/vol/&lt;volume&gt;[/&lt;qtree&gt;] On Data ONTAP operating in 7-Mode. <li> [&lt;cluster&gt:]//&ltvserver&gt/&ltvolume&gt; On Data ONTAP 8.1 operating in Cluster-Mode, and on Data ONTAP 8.2 operating in Cluster-Mode for relationships using a control plane compatible with Data ONTAP 8.1 operating in Cluster-Mode. <li> &lt;[vserver:]volume&gt; On Data ONTAP 8.2 or later operating in Cluster-Mode except for relationships using a control plane compatible with Data ONTAP 8.1 operating in Cluster-Mode. This format depends on the Vserver peering setup between the source and destination Vservers. </ul> This format may change in the future. On Data ONTAP operating in Cluster-Mode, when specifying a destination endpoint, you must use either the destination location, or the destination cluster, destination Vserver, and destination volume. This parameter is mandatory on Data ONTAP operating in 7-mode.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapmirror_break

[B<Family:> ontap-classic, vfiler]


=begin html

Breaks a SnapMirror relationship between a source and destination volume of a data protection mirror. When Data ONTAP breaks the relationship, the destination volume is made a read-write volume and can diverge from the source volume, client redirection is turned off on the destination volume, the restart checkpoint is cleared, and the clients can see the latest Snapshot copy. <p> On Data ONTAP operating in 7-Mode, no check is done to determine whether the operation is legal or successful. You need to query the status afterward by using the snapmirror-get-status API. <p> Subsequent manual or scheduled SnapMirror updates to the broken relationship will fail until the SnapMirror relationship is re-established using the snapmirror-resync API. <p> On Data ONTAP operating in Cluster-Mode, this API applies only to data protection mirrors and not to load-sharing mirrors. <p> The snapmirror-break API must be issued on destination storage system on Data ONTAP operating in 7-Mode, and on the destination cluster on Data ONTAP 8.1 operating in Cluster-Mode, and on the destination cluster or Vserver on Data ONTAP 8.2 or later operating in Cluster-Mode. <p> This API is not supported if the destination end point is an Infinite Volume.

=end html



B<Inputs>

=over 2

=item * I<destination-location>  =>   B<string, optional>

=begin html

<br>Specifies the destination endpoint of the SnapMirror relationship in the following formats: <ul> <li> &lt;system&gt;:/vol/&lt;volume&gt;[/&lt;qtree&gt;] On Data ONTAP operating in 7-Mode. <li> [&lt;cluster&gt:]//&ltvserver&gt/&ltvolume&gt; On Data ONTAP 8.1 operating in Cluster-Mode, and on Data ONTAP 8.2 operating in Cluster-Mode for relationships using a control plane compatible with Data ONTAP 8.1 operating in Cluster-Mode. <li> &lt;[vserver:]volume&gt; On Data ONTAP 8.2 or later operating in Cluster-Mode except for relationships using a control plane compatible with Data ONTAP 8.1 operating in Cluster-Mode. This format depends on the Vserver peering setup between the source and destination Vservers. </ul> This format may change in the future. On Data ONTAP operating in Cluster-Mode, when specifying a destination endpoint, you must use either the destination location, or the destination cluster, destination Vserver, and destination volume. On Data ONTAP operating in 7-Mode, If the destination endpoint is a qtree, it must be quiesced using snapmirror-quiesce. This parameter is mandatory on Data ONTAP 7-mode

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapmirror_delete_connection

[B<Family:> ontap-classic, vfiler]


=begin html

Deletes a connection specified by connection. This API must be executed on the destination filer. Currently, the connections are in: /etc/snapmirror.conf.

=end html



B<Inputs>

=over 2

=item * I<connection>  =>   B<string>

=begin html

<br>Connection name to delete. The name is in ASCII and must begin with an alpha character.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapmirror_delete_schedule

[B<Family:> ontap-classic, vfiler]


=begin html

Delete the schedule for a given destination. This API must be executed on the destination filer.

=end html



B<Inputs>

=over 2

=item * I<destination-location>  =>   B<string>

=begin html

<br>The destination location of a schedule to delete. The destination location is of the volume form: &lt;filer&gt;:&lt;volume&gt; or the qtree form: &lt;filer&gt;:/vol/&lt;volume&gt;/&lt;qtree&gt;.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapmirror_delete_sync_schedule

[B<Family:> ontap-classic, vfiler]


=begin html

Delete a synchronous schedule for a given destination. This API must be executed on the destination filer.

=end html



B<Inputs>

=over 2

=item * I<destination-location>  =>   B<string>

=begin html

<br>The destination location of a schedule to delete. The destination location is of the volume form: &lt;filer&gt;:&lt;volume&gt; or the qtree form: &lt;filer&gt;:/vol/&lt;volume&gt;/&lt;qtree&gt;.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapmirror_get_status

[B<Family:> ontap-classic, vfiler]


=begin html

Return the SnapMirror status. This API can be issued on either the source or destination filer.

=end html



B<Inputs>

=over 2

=item * I<location>  =>   B<string, optional>

=begin html

<br>The source location or destination location of the SnapMirror pair. Possible types are volume or qtree only. If this input is provided, only the SnapMirror relationships with a matching source or destination will be reported. The argument is invalid if the named location doesn't exist. In this case, snapmirror-status-info output will not be present. The argument can also be invalid if it is a flexclone name. (Be aware that the snapmirror-list-destinations API can return flexclone names.) Then snapmirror-get-status API will return a snapmirror-status output value with a "state" of "unknown". If the argument is not specified, all source, destination SnapMirror pairs are returned.

=end html

=back



B<Outputs>

=over 2

=item * I<is-available>  =>   B<boolean>

=begin html

<br>True if SnapMirror is available.

=end html

=back



=over 2

=item * I<snapmirror-status>  =>   B<L<"snapmirror-status-info">[], optional>

=begin html

<br>An array of SnapMirror pair status. If there are no transfers or schedules, then snapmirror-status is not returned. Any and all pairs whose source or destination location matches the input location will be in the output.

=end html

=back



=head2 snapmirror_get_volume_status

[B<Family:> ontap-classic, vfiler]


=begin html

Returns SnapMirror status values for a given volume. Including whether: the volume is a source of a SnapMirror relationship; the volume is a destination of a SnapMirror relationship; a transfer is in progress; the relationship is broken off. On Data ONTAP 8.1 operating in Cluster-Mode, this API is provided for backward compatibility only. It will fail if the volume is the source or destination of a load-sharing SnapMirror relationship. It is recommended to use the snapmirror-get-iter API to get the same information. On Data ONTAP 8.1 operating in Cluster-Mode, this API must be issued on the cluster the volume belongs to. This API is not supported On Data ONTAP 8.2 or later operating in Cluster-Mode. You must use the snapmirror-get-iter and snapmirror-get-destination-iter APIs. If issued on Data ONTAP 8.2 or later operating in Cluster-Mode, this API will return EOPNOTSUPPORTED error.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume to be queried. On Data ONTAP operating in Cluster-Mode, specifies the location of the volume the following formats: [&lt;cluster&gt;:][//&lt;vserver&gt;/]&lt;volume&gt;

=end html

=back



B<Outputs>

=over 2

=item * I<is-destination>  =>   B<boolean, optional>

=begin html

<br>true if it was determined that the volume is a destination of a SnapMirror relationship. false otherwise

=end html

=back



=over 2

=item * I<is-source>  =>   B<boolean, optional>

=begin html

<br>true if it was determined that the volume is a source of a SnapMirror relationship. false otherwise

=end html

=back



=over 2

=item * I<is-transfer-broken>  =>   B<boolean, optional>

=begin html

<br>true if it was determined that the volume is a destination of a SnapMirror relationship that was broken off. The volume allows reads and writes. false otherwise

=end html

=back



=over 2

=item * I<is-transfer-in-progress>  =>   B<boolean, optional>

=begin html

<br>true if it was determined that the volume is a source or a destination of a SnapMirror relationship that has a transfer going on. false otherwise

=end html

=back



=head2 snapmirror_initialize

[B<Family:> ontap-classic, vfiler]


=begin html

Performs the initial update of a SnapMirror relationship. You must specify the destination endpoint when using snapmirror-initialize. This API must be used from the destination storage system on Data ONTAP operating in 7-Mode, from the destination cluster on Data ONTAP 8.1 operating in Cluster-Mode, and from the destination Vserver on Data ONTAP 8.2 or later operating in Cluster-Mode. <p> On Data ONTAP operating in 7-Mode, If the destination endpoint is a volume, the volume must be in the restricted state. If the destination endpoint is a qtree, the qtree must not already exist. <p> On Data ONTAP operating in Cluster-Mode, this API is usually used after the snapmirror-create API, but it can be used alone, that is, without the snapmirror-create API, to create and initially update a SnapMirror relationship. <p> On Data ONTAP 8.1 operating in Cluster-Mode, and on Data ONTAP 8.2 operating in Cluster-Mode for relationships using a control plane compatible with Data ONTAP 8.1 operating Cluster-Mode (The relationship-control-plane field is set to 'v1'), a job will be spawned to operate on the SnapMirror relationship, and the job id will be returned. The progress of the job can be tracked using the job APIs. <p> On Data ONTAP 8.2 or later operating in Cluster-Mode, for vault relationships, a 32-bit volume cannot be the source or destination of the relationship. <p> On Data ONTAP 8.2 or later operating in Cluster-Mode, you can track the progress of the operation using the snapmirror-get API, except for relationships using a control plane compatible with Data ONTAP 8.1 operating in Cluster-Mode.

=end html



B<Inputs>

=over 2

=item * I<destination-location>  =>   B<string, optional>

=begin html

<br>Specifies the destination endpoint of the SnapMirror relationship in the following formats: <ul> <li> &lt;system&gt;:/vol/&lt;volume&gt;[/&lt;qtree&gt;] On Data ONTAP operating in 7-Mode. <li> [&lt;cluster&gt:]//&ltvserver&gt/&ltvolume&gt; On Data ONTAP 8.1 operating in Cluster-Mode, and on Data ONTAP 8.2 operating in Cluster-Mode for relationships using a control plane compatible with Data ONTAP 8.1 operating in Cluster-Mode. <li> &lt;[vserver:]volume&gt; On Data ONTAP 8.2 or later operating in Cluster-Mode except for relationships using a control plane compatible with Data ONTAP 8.1 operating in Cluster-Mode. This format depends on the Vserver peering setup between the source and destination Vservers. </ul> This format may change in the future. On Data ONTAP operating in Cluster-Mode, when specifying a destination endpoint, you must use either the destination location, or the destination cluster, destination Vserver, and destination volume. On Data ONTAP operating in 7-Mode, if the destination endpoint is a volume, the volume must be in the restricted state. If the destination endpoint is a qtree, the qtree must not already exist. <p> This parameter is mandatory on Data ONTAP operating in 7-mode.

=end html

=back



=over 2

=item * I<destination-snapshot>  =>   B<string, optional>

=begin html

<br>Creates the specified snapshot (in addition to the regular SnapMirror snapshot) on the destination after the qtree SnapMirror transfer is over.

=end html

=back



=over 2

=item * I<max-transfer-rate>  =>   B<integer, optional>

=begin html

<br>Specifies the upper bound, in kilobytes per second, at which data is transferred between clusters on Data ONTAP Cluster-Mode, or between storage systems on ata ONTAP 7-Mode. The default is unlimited (0)which permits the SnapMirror relationship to fully utilize the available network bandwidth. On Data ONTAP operating in Cluster-Mode, the max-transfer-rate option does not affect load-sharing mirrors and other SnapMirror relationships confined to a single cluster.

=end html

=back



=over 2

=item * I<source-location>  =>   B<string, optional>

=begin html

<br>Specifies the source endpoint of the SnapMirror relationship in the following formats: <ul> <li> &lt;system&gt;:/vol/&lt;volume&gt;[/&lt;qtree&gt;] On Data ONTAP operating in 7-Mode. <li> [&lt;cluster&gt:]//&ltvserver&gt/&ltvolume&gt; On Data ONTAP 8.1 operating in Cluster-Mode, and on Data ONTAP 8.2 operating in Cluster-Mode for relationships using a control plane compatible with Data ONTAP 8.1 operating in Cluster-Mode. <li> &lt;[vserver:]volume&gt; On Data ONTAP 8.2 or later operating in Cluster-Mode except for relationships using a control plane compatible with Data ONTAP 8.1 operating in Cluster-Mode. This format depends on the Vserver peering setup between the source and destination Vservers. </ul> This format may change in the future. On Data ONTAP operating in Cluster-Mode when specifying a source endpoint, you must use either the source location, or the source cluster, source Vserver, and source volume. On Data ONTAP operating in 7-Mode, If the source-location is not specified, then the source in /etc/snapmirror.conf for the destination path is used.

=end html

=back



=over 2

=item * I<source-snapshot>  =>   B<string, optional>

=begin html

<br>Designates the source snapshot to use for a qtree update on Data ONTAP operating in 7-mode, and the snapshot on the source volume to use for the baseline transfer on Data ONTAP 8.2 or later operating in Cluster-Mode. The default creates new snapshot on the source for the transfer. <p>This parameter only applies on Data ONTAP 8.2 or later operating in Cluster-Mode if the relationship control plane is 'v2'.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapmirror_list_connections

[B<Family:> ontap-classic, vfiler]


=begin html

Returns connection information for a given connection or all connections. The API must be executed on the destination filer. Currently, the connections are in: /etc/snapmirror.conf.

=end html



B<Inputs>

=over 2

=item * I<connection>  =>   B<string, optional>

=begin html

<br>Connection name of the connection information to obtain. If the connections is not specified, then the connection information for all the connections is returned.

=end html

=back



B<Outputs>

=over 2

=item * I<snapmirror-connections>  =>   B<L<"snapmirror-connection-info">[]>

=begin html

<br>An array of SnapMirror connection information.

=end html

=back



=head2 snapmirror_list_destinations

[B<Family:> ontap-classic, vfiler]


=begin html

Returns a list of destination locations and information about SnapMirror relationships for given source locations, which can be a volume name or qtree path. This API must be issued on the source filer.

=end html



B<Inputs>

=over 2

=item * I<source-location>  =>   B<string, optional>

=begin html

<br>Source location of the SnapMirror pair. The source location is of the volume form: &lt;filer&gt;:&lt;volume&gt; or the qtree form: &lt;filer&gt;:/vol/&lt;volume&gt;/&lt;qtree&gt;. If the source-location is not specified, then all source, destination SnapMirror pairs are returned.

=end html

=back



B<Outputs>

=over 2

=item * I<destinations>  =>   B<L<"destination-info">[]>

=begin html

<br>A list of currently-known destinations on a source filer.

=end html

=back



=head2 snapmirror_list_schedule

[B<Family:> ontap-classic, vfiler]


=begin html

Returns the schedule for a given destination or all destinations. The API must be executed on the destination filer. Currently, the schedules is in /etc/snapmirror.conf.

=end html



B<Inputs>

=over 2

=item * I<destination-location>  =>   B<string, optional>

=begin html

<br>The destination location of a schedule to obtain. The destination location is of the volume form: &lt;filer&gt;:&lt;volume&gt; or the qtree form: &lt;filer&gt;:/vol/&lt;volume&gt;/&lt;qtree&gt;. The &lt;filer&gt; must match the destination filer. If the destination-location is not specified, then all the destination schedules are returned.

=end html

=back



B<Outputs>

=over 2

=item * I<snapmirror-schedules>  =>   B<L<"snapmirror-schedule-info">[]>

=begin html

<br>An array of SnapMirror schedule.

=end html

=back



=head2 snapmirror_list_sync_schedule

[B<Family:> ontap-classic, vfiler]


=begin html

Returns a synchronous schedule for a given destination or all destinations. The API must be executed on the destination filer. Currently, the schedules is in /etc/snapmirror.conf.

=end html



B<Inputs>

=over 2

=item * I<destination-location>  =>   B<string, optional>

=begin html

<br>The destination location of a schedule to obtain. The destination location is of the volume form: &lt;filer&gt;:&lt;volume&gt; or the qtree form: &lt;filer&gt;:/vol/&lt;volume&gt;/&lt;qtree&gt;. The &lt;filer&gt; must match the destination filer. If the destination-location is not specified, then all the destination schedules are returned.

=end html

=back



B<Outputs>

=over 2

=item * I<snapmirror-sync-schedules>  =>   B<L<"snapmirror-sync-schedule-info">[]>

=begin html

<br>An array of SnapMirror schedule.

=end html

=back



=head2 snapmirror_off

[B<Family:> ontap-classic, vfiler]


=begin html

Disables SnapMirror data transfers and turns off the SnapMirror scheduler. Check the SnapMirror status with the snapmirror-get-status API for results.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapmirror_on

[B<Family:> ontap-classic, vfiler]


=begin html

Enables SnapMirror data transfers and turns on the SnapMirror scheduler. Check the SnapMirror status with the snapmirror-get-status API for results.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapmirror_quiesce

[B<Family:> ontap-classic, vfiler]


=begin html

Disables future transfers to a SnapMirror destination. If there is no transfer in progress, the SnapMirror relationship becomes 'Quiesced'. If there is a transfer in progress, the SnapMirror relationship becomes 'Quiescing' until the transfer completes. If the current transfer aborts, it will be treated like a future transfer and will not restart. When a SnapMirror relationship is quiesced, it remains in that state across reboots and fail-overs. The relationship must exist on the destination and you must specify the destination endpoint when using snapmirror-quiesce. On Data ONTAP 8.1 operating in Cluster-Mode, if applied to a load-sharing (LS) SnapMirror relationship, all the relationships in the set will be quiesced. This API must be issued from the destination storage system on Data ONTAP operating in 7-Mode, on the destination cluster on Data ONTAP 8.1 operating in Cluster-Mode, and the destination Vserver on Data ONTAP 8.2 or later operating in Cluster-Mode.

=end html



B<Inputs>

=over 2

=item * I<destination-location>  =>   B<string, optional>

=begin html

<br>Specifies the destination endpoint of the SnapMirror relationship in the following formats: <ul> <li> &lt;system&gt;:/vol/&lt;volume&gt;[/&lt;qtree&gt;] On Data ONTAP operating in 7-Mode. <li> [&lt;cluster&gt:]//&ltvserver&gt/&ltvolume&gt; On Data ONTAP 8.1 operating in Cluster-Mode, and on Data ONTAP 8.2 operating in Cluster-Mode for relationships using a control plane compatible with Data ONTAP 8.1 operating in Cluster-Mode. <li> &lt;[vserver:]volume&gt; On Data ONTAP 8.2 or later operating in Cluster-Mode except for relationships using a control plane compatible with Data ONTAP 8.1 operating in Cluster-Mode. This format depends on the Vserver peering setup between the source and destination Vservers. </ul> This format may change in the future. On Data ONTAP operating in Cluster-Mode, when specifying a destination endpoint, you must use either the destination location, or the destination cluster, destination Vserver, and destination volume. This parameter is mandatory on Data ONTAP 7-mode

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapmirror_release

[B<Family:> ontap-classic, vfiler]


=begin html

The snapmirror-release API removes a SnapMirror relationship on the source endpoint. It unlocks and cleanups the snapshots pertaining to the relationship. It does not destroy any volume. You must specify the destination endpoint when using snapmirror-release. Unless relationship-info-only is specified, this operation will fail if it is unable to reach the source volume and clean up snapshots. On Data ONTAP 8.2 or later operating in Cluster-Mode, this API must be executed on the source Vserver or source cluster following the deletion of the relationship on the destination Vserver or destination cluster. It is possible to issue snapmirror-release on the source Vserver without deleting the relationship on the destination Vserver. However, the relationship will continue to exist because the destination is the authority. The relationship will reappear on the source on the next transfer. On Data ONTAP operating in 7-Mode, this API must be issued on the source storage system. On Data ONTAP 8.2 or later operating in Cluster-Mode, this API must be issued on the source Vserver if operating in Vserver context and on the source cluster if operating in a cluster context. This API is not supported on Data ONTAP 8.1 operating in Cluster-Mode, or Data ONTAP 8.2 or later operating in Cluster-Mode if the relationship control plane is 'v1'.

=end html



B<Inputs>

=over 2

=item * I<destination-location>  =>   B<string, optional>

=begin html

<br>Specifies the destination endpoint of the SnapMirror relationship in the following formats: <ul> <li> &lt;system&gt;:/vol/&lt;volume&gt;[/&lt;qtree&gt;] On Data ONTAP operating in 7-Mode. <li> [&lt;cluster&gt:]//&ltvserver&gt/&ltvolume&gt; On Data ONTAP 8.1 operating in Cluster-Mode, and on Data ONTAP 8.2 operating in Cluster-Mode for relationships using a control plane compatible with Data ONTAP 8.1 operating in Cluster-Mode. <li> &lt;[vserver:]volume&gt; On Data ONTAP 8.2 or later operating in Cluster-Mode except for relationships using a control plane compatible with Data ONTAP 8.1 operating in Cluster-Mode. This format depends on the Vserver peering setup between the source and destination Vservers. </ul> This format may change in the future. On Data ONTAP operating in Cluster-Mode, when specifying a destination endpoint, you must use either the destination location, or destination Vserver and destination volume. This parameter is mandatory on Data ONTAP operating in 7-mode

=end html

=back



=over 2

=item * I<source-location>  =>   B<string, optional>

=begin html

<br>Specifies the source endpoint of the SnapMirror relationship in the following formats: <ul> <li> &lt;system&gt;:/vol/&lt;volume&gt;[/&lt;qtree&gt;] On Data ONTAP operating in 7-Mode. <li> [&lt;cluster&gt:]//&ltvserver&gt/&ltvolume&gt; On Data ONTAP 8.1 operating in Cluster-Mode, and on Data ONTAP 8.2 operating in Cluster-Mode for relationships using a control plane compatible with Data ONTAP 8.1 operating in Cluster-Mode. <li> &lt;[vserver:]volume&gt; On Data ONTAP 8.2 or later operating in Cluster-Mode except for relationships using a control plane compatible with Data ONTAP 8.1 operating in Cluster-Mode. </ul> This format may change in the future. On Data ONTAP operating in Cluster-Mode, When specifying a source endpoint, you must use either the source location, or the source Vserver, and source volume.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapmirror_resume

[B<Family:> ontap-classic, vfiler]


=begin html

Enables future transfers for a SnapMirror relationship that has been quiesced. If there is a scheduled transfer, it will be triggered on the next schedule. If there is a restart checkpoint, it will be re-used if possible. On Data ONTAP Cluster-Mode, If applied on a load-sharing SnapMirror relationship, transfers will resume for all the relationships of the set. When a quiesced SnapMirror relationship is resumed, it remains in that state across reboots and fail-overs. The relationship must exist on the destination and you must specify the destination end point when using snapmirror-resume. This API must be issued on the destination storage system on Data ONTAP operating in 7-Mode, on the destination cluster on Data ONTAP 8.1 operating in Cluster-Mode, and on the destination Vserver on Data ONTAP 8.2 or later operating in Cluster-Mode.

=end html



B<Inputs>

=over 2

=item * I<destination-location>  =>   B<string, optional>

=begin html

<br>Specifies the destination endpoint of the SnapMirror relationship in the following formats: <ul> <li> &lt;system&gt;:/vol/&lt;volume&gt;[/&lt;qtree&gt;] On Data ONTAP operating in 7-Mode. <li> [&lt;cluster&gt:]//&ltvserver&gt/&ltvolume&gt; On Data ONTAP 8.1 operating in Cluster-Mode, and on Data ONTAP 8.2 operating in Cluster-Mode for relationships using a control plane compatible with Data ONTAP 8.1 operating in Cluster-Mode. <li> &lt;[vserver:]volume&gt; On Data ONTAP 8.2 or later operating in Cluster-Mode except for relationships using a control plane compatible with Data ONTAP 8.1 operating in Cluster-Mode. This format depends on the Vserver peering setup between the source and destination Vservers. </ul> This format may change in the future. On Data ONTAP operating in Cluster-Mode, when specifying a destination endpoint, you must use either the destination location, or the destination cluster, destination Vserver, and destination volume. This parameter is mandatory on Data ONTAP operating in 7-mode.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapmirror_resync

[B<Family:> ontap-classic, vfiler]


=begin html

Re-establishes a mirroring relationship between a source volume and a destination volume, typically in the following cases: <ul> <li> The destination mirror is broken (that is, the destination volume is a read-write volume and no longer a data protection mirror). After the snapmirror-resync API completes, the destination volume is made a data protection mirror and the mirror can be manually updated or scheduled for updates. <li> A snapmirror-update API failed because the required common Snapshot copy was deleted on the source volume. </ul> After the operation completes, the destination volume is made a data protection mirror and the mirror can be manually updated or scheduled for updates. <b>Attention:</b> The snapmirror-resync API can cause data loss on the destination volume because the API can remove the exported Snapshot copy on the destination volume. <p> The default behavior of the snapmirror-resync API is defined as follows: <ul> <li> Finds the most recent common Snapshot copy between the source and destination volumes, removes Snapshot copies on the destination volume that are newer than the common Snapshot copy and mounts the destination volume as a DP volume with the common Snapshot copy as the exported Snapshot copy. <li> For data protection relationships, takes a Snapshot copy of the source volume to capture the current image and transfers Snapshot copies that are newer than the common Snapshot copy from the source volume to the destination volume. For vault relationships, transfers Snapshot copies newer than the common Snapshot copy according to the relationship policy, i.e., Snapshot copies will match rules associated with the policy as defined by the snapmirror-policy API. </ul> On Data ONTAP 8.2 or later operating in Cluster-Mode, the snapmirror-resync API supports an optional parameter 'preserve'. The parameter 'preserve' is only supported for vault relationships. When used, the parameter 'preserve' changes the behavior of the snapmirror-resync API. The changed behavior can be described as follows: <ul> <li> Finds the most recent common Snapshot copy between the source and destination volumes, preserves all Snapshot copies on the destination volume that are newer than the common Snapshot copy, and mounts the destination volume as a DP volume with the common Snapshot copy as the exported Snapshot copy. <li> Performs a local rollback transfer to make a copy of the common Snapshot copy on the destination volume and establish it as the latest Snapshot copy on the destination volume. The command then transfers all Snapshot copies that are newer than the common Snapshot copy, from the source volume to the destination volume. The command only transfers Snapshot copies that match the vault relationship's policy, i.e., Snapshot copies will match rules associated with the policy as defined by the snapmirror-policy APIs. </ul> The snapmirror-resync API fails if the destination volume does not have a Snapshot copy in common with the source volume. <p> On Data ONTAP 8.1 operating in Cluster-Mode, or on Data ONTAP 8.2 operating in Cluster-Mode for relationships using a control plane compatible with Data ONTAP 8.1 operating in Cluster-Mode, a job is spawned to operate for the SnapMirror relationship and the job id is returned. The progress of the operation can be tracked using the job APIs. <p> On Data ONTAP 8.2 or later operating in Cluster-Mode, you can track the progress of the operation using the snapmirror-get API except for relationships using a control plane compatible with Data ONTAP 8.1 operating in Cluster-Mode. <p> On Data ONTAP operating in 7-Mode, the update is asynchronously handled, and there is no guarantee that it succeeds. This requires that a schedule in /etc/snapmirror.conf is set for the destination. <p> The API must be issued on the destination storage system on Data ONTAP operating in 7-Mode, on the destination cluster on Data ONTAP 8.1 operating in Cluster-Mode, and on the destination Vserver on Data ONTAP 8.2 or later operating in Cluster-Mode.

=end html



B<Inputs>

=over 2

=item * I<destination-location>  =>   B<string, optional>

=begin html

<br>Specifies the destination endpoint of the SnapMirror relationship in the following formats: <ul> <li> &lt;system&gt;:/vol/&lt;volume&gt;[/&lt;qtree&gt;] On Data ONTAP operating in 7-Mode. <li> [&lt;cluster&gt:]//&ltvserver&gt/&ltvolume&gt; On Data ONTAP 8.1 operating in Cluster-Mode, and on Data ONTAP 8.2 operating in Cluster-Mode for relationships using a control plane compatible with Data ONTAP 8.1 operating in Cluster-Mode. <li> &lt;[vserver:]volume&gt; On Data ONTAP 8.2 or later operating in Cluster-Mode except for relationships using a control plane compatible with Data ONTAP 8.1 operating in Cluster-Mode. This format depends on the Vserver peering setup between the source and destination Vservers. </ul> This format may change in the future. On Data ONTAP operating in Cluster-Mode, when specifying a destination endpoint, you must use either the destination location, or the destination cluster, destination Vserver, and destination volume. This parameter is mandatory on Data ONTAP operating in 7-mode

=end html

=back



=over 2

=item * I<destination-snapshot>  =>   B<string, optional>

=begin html

<br>Creates the specified snapshot (in addition to the regular SnapMirror snapshot) on the destination after the qtree SnapMirror transfer is over.

=end html

=back



=over 2

=item * I<max-transfer-rate>  =>   B<integer, optional>

=begin html

<br>Specified the upper bound, in kilobytes per second, at which data is transferred between clusters on Data ONTAP Cluster-Mode, or between storage systems on ata ONTAP 7-Mode. The default is unlimited (0) which permits the SnapMirror relationship to fully utilize the available network bandwidth. On Data ONTAP operating in Cluster-Mode, the max-transfer-rate option does not affect load-sharing mirrors and other SnapMirror relationships confined to a single cluster.

=end html

=back



=over 2

=item * I<source-location>  =>   B<string, optional>

=begin html

<br>Specifies the source endpoint of the SnapMirror relationship in the following formats: <ul> <li> &lt;system&gt;:/vol/&lt;volume&gt;[/&lt;qtree&gt;] On Data ONTAP operating in 7-Mode. <li> [&lt;cluster&gt:]//&ltvserver&gt/&ltvolume&gt; On Data ONTAP 8.1 operating in Cluster-Mode, and on Data ONTAP 8.2 operating in Cluster-Mode for relationships using a control plane compatible with Data ONTAP 8.1 operating in Cluster-Mode. <li> &lt;[vserver:]volume&gt; On Data ONTAP 8.2 or later operating in Cluster-Mode except for relationships using a control plane compatible with Data ONTAP 8.1 operating in Cluster-Mode. This format depends on the Vserver peering setup between the source and destination Vservers. </ul> This format may change in the future. On Data ONTAP Cluster-Mode when specifying a source endpoint, you must use either the source location, or the source cluster, source Vserver, and source volume. On Data ONTAP operating in 7-Mode, If the source-location is not specified, then the source in /etc/snapmirror.conf for the destination path is used.

=end html

=back



=over 2

=item * I<source-snapshot>  =>   B<string, optional>

=begin html

<br>Designates the source snapshot to use for a qtree update on Data ONTAP operating in 7-Mode, and the snapshot on the source volume to use for the transfer on Data ONTAP 8.2 or later operating in Cluster-Mode. <p>For data protection mirror relationships, Data ONTAP Cluster-Mode does not create a new Snapshot copy. It will use the specified Snapshot copy as if it were the most recent one; that is, all copies between the most recent common one and the specified one are transferred, but no copies newer than the specified one are transferred. <p>For vault relationships, Data ONTAP Cluster-Mode transfers the specified Snapshot copy instead of the ones that match its policy's rules. <p>This parameter only applies on Data ONTAP 8.2 or later operating in Cluster-Mode if the relationship control plane is 'v2'.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapmirror_set_connection

[B<Family:> ontap-classic, vfiler]


=begin html

Sets up a connection. snapmirror-set-connection will add a new connection or modify an existing one. This API must be executed on the destination filer. Currently, the connections are in: /etc/snapmirror.conf.

=end html



B<Inputs>

=over 2

=item * I<address-pair1>  =>   B<L<"address-pair">>

=begin html

<br>The connection's first source and destination address pair. In multi mode, the first address pair provides a connection path; while in failover mode, the first address pair provides the prefer connection path.

=end html

=back



=over 2

=item * I<address-pair2>  =>   B<L<"address-pair">, optional>

=begin html

<br>The connection's second source and destination address pair. In multi mode the second address pair provides another connection path, while in failover mode, the second address pair provides a connection path in case the first path fails.

=end html

=back



=over 2

=item * I<connection>  =>   B<string>

=begin html

<br>Name of the connection to add or modify. The name is in ASCII and must begin with an alpha character.

=end html

=back



=over 2

=item * I<mode>  =>   B<string, optional>

=begin html

<br>Possible mode values are "multi" or "failover". If not specified, the default is "multi".

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapmirror_set_schedule

[B<Family:> ontap-classic, vfiler]


=begin html

Sets the schedule for a given destination. The API must be executed on the destination filer. Currently, the schedule is in /etc/snapmirror.conf.

=end html



B<Inputs>

=over 2

=item * I<connection-mode>  =>   B<string, optional>

=begin html

<br>This option specifies the mode to be used for establishing connection between source and destination. Possible values are "inet", "inet6" and "default". If this option is set to "inet6", connections between source and destination will be established using IPv6 addresses only. If there are no IPv6 addresses configured, then the connection will fail. If the option is set to "inet", connections between source and destination will be established using IPv4 addresses only. If there are no IPv4 addresses configured, then the connection will fail. <p> If not specified, the previous value is retained. If nothing was mentioned previously, it is set as default, where connection will be tried using both "inet6" and "inet". "inet6" will have higher precedence than "inet". If connection request using "inet6" fails, SnapMirror will retry the connection using "inet". <p> This argument is not effective when an IP address is specified instead of source hostname. If the IP address format and connection mode do not match, the operation will fail with proper error message.

=end html

=back



=over 2

=item * I<days-of-month>  =>   B<string>

=begin html

<br>Minutes in the hour for which the schedule is set. The form is crontab-like, with possible values of: <ul> <li> - := match nothing; <li> 1 := match day 1; <li> 1,3 := match day 1 and 3; <li> 2-5 := match day 2,3,4,5; <li> 1-30/7 := match day 1,8,15,22,29; <li> * := matches all possible legal values; </ul>

=end html

=back



=over 2

=item * I<days-of-week>  =>   B<string>

=begin html

<br>Days in the week for which the schedule is set. 0 represents Sunday, and 6 represents Saturday. The form is crontab-like, with possible values of: <ul> <li> - := match nothing; <li> 1 := match day 1 (Mon); <li> 1,3 := match day 1 and 3 (Mon and Wed); <li> 2-5 := match day 2,3,4,5 (Tue,Wed,Thu,Fri); <li> * := matches all possible legal values; </ul>

=end html

=back



=over 2

=item * I<destination-location>  =>   B<string>

=begin html

<br>The destination location of a schedule to set. The destination location is of the volume form: &lt;filer&gt;:&lt;volume&gt; or the qtree form: &lt;filer&gt;:/vol/&lt;volume&gt;/&lt;qtree&gt;.

=end html

=back



=over 2

=item * I<hours>  =>   B<string>

=begin html

<br>Hours in the day for which the schedule is set. The form is crontab-like, with possible values of: <ul> <li> - := match nothing; <li> 1 := match hour 1; <li> 1,3 := match hour 1 and 3; <li> 2-5 := match hour 2,3,4,5; <li> 1-24/3 := match hour 1,4,7,10,13,16,19,22; <li> * := matches all possible legal values; </ul>

=end html

=back



=over 2

=item * I<is-compressed>  =>   B<boolean, optional>

=begin html

<br>If true SnapMirror will compress/decompress the data that is transferred between the source and destination storage system. If false, transferred data will not be compressed. Upon initial configuration, default is false. On subsequent requests, the current configured setting is retained if not provided. This argument can only be used when a connection definition is used for the relationship entry. Using this argument without a connection definition will throw an error message.

=end html

=back



=over 2

=item * I<max-transfer-rate>  =>   B<integer, optional>

=begin html

<br>Maximum transfer rate in kilobytes per second. If specified as 0, transfer happens as fast as the storage system can. If not specified, the previous value is retained. If nothing was mentioned previously, it is set to the default value.

=end html

=back



=over 2

=item * I<minutes>  =>   B<string>

=begin html

<br>Minutes in the hour for which the schedule is set. The form is crontab-like, with possible values of: <ul> <li> - := match nothing; <li> 1 := match minute 1; <li> 1,3 := match minute 1 and 3; <li> 2-5 := match minute 2,3,4,5; <li> 1-12/3 := match minute 1,4,7,10; <li> 0-55/5 := match minute 0,5,10,15,20,25,30,35,40,45,50,55; <li> * := matches all possible legal values; </ul>

=end html

=back



=over 2

=item * I<restart>  =>   B<string, optional>

=begin html

<br>restart mode when transfer is interrupted. Possible values are "always", "never" and "default". If value is set to "always", then an interrupted transfer will always restart, if it has a restart check point and the conditions are the same as before the transfer was interrupted. If value is set to "never", then an interrupted transfer will never restart, even if it has a restart checkpoint. If not specified, the previous value is retained. If nothing was mentioned previously, then it is set to default, where SnapMirror behaves like the "always" case, unless it has passed the next scheduled transfer time, in which case it will begin that scheduled transfer instead of restarting.

=end html

=back



=over 2

=item * I<source-location>  =>   B<string>

=begin html

<br>The source location of a schedule to set. The source location is of the volume form: &lt;filer&gt;:&lt;volume&gt; or the qtree form: &lt;filer&gt;:/vol/&lt;volume&gt;/&lt;qtree&gt;.

=end html

=back



=over 2

=item * I<tcp-window-size>  =>   B<integer, optional>

=begin html

<br>TCP window size in bytes. If specified as 0, size is set to an internally determined default value. If not specified, the previous value is retained.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapmirror_set_sync_schedule

[B<Family:> ontap-classic]


=begin html

Establishes a synchronous or semi-synchronous schedule. Currently, the schedules are in: /etc/snapmirror.conf. Semi-synchronous mode is determined by specifying semi-sync.

=end html



B<Inputs>

=over 2

=item * I<connection-mode>  =>   B<string, optional>

=begin html

<br>This option specifies the mode to be used for establishing connection between source and destination. If this option is set to "inet6", connections between source and destination will be established using IPv6 addresses only. If there are no IPv6 addresses configured, then the connection will fail. If the option is set to "inet", connections between source and destination will be established using IPv4 addresses only. If there are no IPv4 addresses configured, then the connection will fail. <p> If not specified, the previous value is retained. If nothing was mentioned previously, it is set as default, where connection will be tried using both "inet6" and "inet". "inet6" will have higher precedence than "inet". If connection request using "inet6" fails, SnapMirror will retry the connection using "inet". <p> This argument is not effective when an IP address is specified instead of source hostname. If the IP address format and connection-mode do not match, the operation will fail with proper error message.

=end html

=back



=over 2

=item * I<destination-location>  =>   B<string>

=begin html

<br>The destination location of a schedule to set. The destination location is of the volume form: &lt;filer&gt;:&lt;volume&gt; or the qtree form: &lt;filer&gt;:/vol/&lt;volume&gt;/&lt;qtree&gt;.

=end html

=back



=over 2

=item * I<is-compressed>  =>   B<boolean, optional>

=begin html

<br>If true SnapMirror will compress/decompress the data that is transferred between the source and destination storage system. If false, transferred data will not be compressed. Upon initial configuration, default is false. On subsequent requests, the current configured setting is retained if not provided. This argument can only be used when a connection definition is used for the relationship entry. Using this argument without a connection definition will throw an error message.

=end html

=back



=over 2

=item * I<ops-throttle>  =>   B<string, optional>

=begin html

<br>The number of outstanding operations allowed before blocking on the source. The format is a number followed by the one of the following units: "ops", "s", or "ms". If the specified value is less than 10s, the mirror is configured to run in a fully synchronous mode. If the specified value is greater than or equal to 10s, the mirror is configured to run in semi-synchronous mode. If not specified, the previous value is retained. This is a deprecated parameter. Use the sync-mode parameter instead to specify the sync mode.

=end html

=back



=over 2

=item * I<source-location>  =>   B<string>

=begin html

<br>The source location of a schedule to set. The source location is of the volume form: &lt;filer&gt;:&lt;volume&gt; or the qtree form: &lt;filer&gt;:/vol/&lt;volume&gt;/&lt;qtree&gt;.

=end html

=back



=over 2

=item * I<sync-mode>  =>   B<string, optional>

=begin html

<br>This specifies whether the mirror should be configured in sync or in semi-sync mode. Possible values are: "full_sync" and "semi_sync". If the user wants to configure the mirror to run in fully synchronous mode, the user must specify "full_sync" as the value for this parameter. If the user wants to configure the mirror to run in semi-synchronous mode, the user must specify "semi_sync" as the value of this parameter. If not specified, the mirror will be configured to run in full synchronous mode. This parameter overrides the deprecated ops-throttle parameter.

=end html

=back



=over 2

=item * I<tcp-window-size>  =>   B<integer, optional>

=begin html

<br>TCP window size in bytes. If specified as 0, size is set to an internally determined default value. If not specified, the previous value is retained.

=end html

=back



=over 2

=item * I<visibility-frequency>  =>   B<integer>

=begin html

<br>Controls how often the source snapspot will be visible on the destination mirror. This input is used to control the value of visibility_interval in the snapmirror.conf file. The units are in seconds. A typical value to use for this input is 180.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapmirror_throttle

[B<Family:> ontap-classic, vfiler]


=begin html

Changes the max transfer rate of an active transfer. The API can be issued to either the source or the destination filer.

=end html



B<Inputs>

=over 2

=item * I<destination-location>  =>   B<string>

=begin html

<br>The destination location of the active transfer. The destination location is of the volume form: &lt;filer&gt;:&lt;volume&gt; or the qtree form: &lt;filer&gt;:/vol/&lt;volume&gt;/&lt;qtree&gt;.

=end html

=back



=over 2

=item * I<max-transfer-rate>  =>   B<integer>

=begin html

<br>Maximum transfer rate in kilobytes per second. A value '0' disables the throttle, ie. the filer will transfer as fast as it can. Range: 0..2^32-1

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapmirror_update

[B<Family:> ontap-classic, vfiler]


=begin html

Updates the destination endpoint of the SnapMirror relationship. The update is asynchronously handled, and there is no guarantee that it will succeed. <p> On Data ONTAP operating in 7-Mode the snapmirror-get-status API can be used to check the status of the update. The API must be issued on the destination storage system. <p> On Data ONTAP 8.1 operating in Cluster-Mode, and on Data ONTAP 8.2 operating in Cluster-Mode and for relationships using a control plane compatible with Data 8.1 operating Cluster-Mode (relationship-control-plane set 'v1'), a job will be spawned to operate on the SnapMirror relationship, and the job id will be returned. The progress of the job can be tracked using the job APIs. <p> On Data ONTAP 8.2 or later operating in Cluster-Mode, you can track the progress of the operation using the snapmirror-get API, except for relationships using a control plane compatible with Data ONTAP 8.1 operating Cluster-Mode. <p> You must specify the destination endpoint when using snapmirror-update. <p> The API makes the destination volume an up-to-date mirror of the source volume. <p> This API must be used from the destination storage system on Data ONTAP 7-Mode, or from the destination cluster on Data ONTAP 8.1 operating in Cluster-Mode, and from the destination Vserver on Data ONTAP 8.2 or later operating in Cluster-Mode. <p> On Data ONTAP operating in 7-Mode, if the destination endpoint is a volume, the volume must be in the restricted state. If the destination endpoint is a qtree, the qtree must not already exist. <p> On Data ONTAP Cluster-Mode if the destination volume is empty, the snapmirror-update API will fail. The snapmirror-initialize API must be called to perform the baseline transfer before the the snapmirror-update can be called. <p> For data protection relationships, the snapmirror-update API makes the destination volume an up-to-date mirror of the source volume with the following steps:</p> <ul> <li>If the source volume is read-write, takes a Snapshot copy on the source volume to capture the current image of the source volume. <li>Finds the most recent Snapshot copy on the destination volume and validates that the corresponding Snapshot copy is on the source. <li>Incrementally transfers Snapshot copies that are newer than the corresponding Snapshot copy to the destination volume. </ul> <p> For vault relationships, the snapmirror-update API does not take a Snapshot copy on the source volume but transfers only selected Snapshot copies that are newer than the common Snapshot copy to the destination volume. Snapshot copies are selected by matching their 'snapmirror-label' with the 'snapmirror-label' of one of the rules from the corresponding SnapMirror policy associated to the SnapMirror relationship. All matching Snapshot copies are incrementally transferred to the destination volume. <p> For vault relationships, the snapmirror-update API also manages expiration of Snapshot copies on the destination volume. It does so by deleting Snapshot copies that have exceeded the value of 'keep' for the matching rule from the corresponding SnapMirror policy associated with the SnapMirror relationship. Snapshot copies that match the same 'snapmirror-label' will be deleted in oldest-first order. <p> For data protection relationships, the parameter 'source-snapshot' is optional and allows for the transfer of Snapshot copies newer than the common Snapshot copy up to the specified 'source-snapshot'. <p> For vault relationships, the parameter 'source-snapshot' is optional and allows transfer of a Snapshot copy that is older than the common Snapshot copy and/or may not be selected for transfer based on policy-based selection of a scheduled update transfer. <p> After the snapmirror-update API successfully completes, the last Snapshot copy transferred is made the new exported Snapshot copy on the destination volume. If an update to a vault relationship specifies a Snapshot copy using the 'source-snapshot' parameter that is older than the common snapshot, after the snapmirror-update API successfully completes, the exported Snapshot copy on the destination volume will remain unchanged. <p> If the snapmirror-update does not finish successfully, due to a network failure or because a snapmirror-abort API was issued for example, a restart checkpoint might be recorded on the destination volume. If a restart checkpoint is recorded, the next update restarts and continues the transfer from the restart checkpoint. For vault relationships, the next update will restart and continue the old transfer regardless of whether it is a matching Snapshot copy or not. <p> On Data ONTAP 8.1 operating in Cluster-Mode, you can use the snapmirror-update API to update a specific load-sharing mirror that lags behind up-to-date destination volumes in the set of load-sharing mirrors. An update to the lagging load-sharing mirror should bring it up to date with the other up-to-date destination volumes in the set of load-sharing mirrors. Note: You might have to run the snapmirror-update API more than once if the command does not finish before the next scheduled update of the set of load-sharing mirrors.

=end html



B<Inputs>

=over 2

=item * I<destination-location>  =>   B<string, optional>

=begin html

<br>Specifies the destination endpoint of the SnapMirror relationship in the following formats: <ul> <li> &lt;system&gt;:/vol/&lt;volume&gt;[/&lt;qtree&gt;] On Data ONTAP operating in 7-Mode. <li> [&lt;cluster&gt:]//&ltvserver&gt/&ltvolume&gt; On Data ONTAP 8.1 operating in Cluster-Mode, and on Data ONTAP 8.2 operating in Cluster-Mode for relationships using a control plane compatible with Data ONTAP 8.1 operating in Cluster-Mode. <li> &lt;[vserver:]volume&gt; On Data ONTAP 8.2 or later operating in Cluster-Mode except for relationships using a control plane compatible with Data ONTAP 8.1 operating in Cluster-Mode. This format depends on the Vserver peering setup between the source and destination Vservers. </ul> This format may change in the future. On Data ONTAP Cluster-Mode, when specifying a destination endpoint, you must use either the destination location, or the destination cluster, destination Vserver, and destination volume. On Data ONTAP 7-Mode, if the destination endpoint is a volume, the volume must be in the restricted state. If the destination endpoint is a qtree, the qtree must not already exist. This parameter is mandatory on Data ONTAP 7-mode

=end html

=back



=over 2

=item * I<destination-snapshot>  =>   B<string, optional>

=begin html

<br>Creates the specified snapshot (in addition to the regular SnapMirror snapshot) on the destination after the qtree SnapMirror transfer is over.

=end html

=back



=over 2

=item * I<max-transfer-rate>  =>   B<integer, optional>

=begin html

<br>Specified the upper bound, in kilobytes per second, at which data is transferred between clusters on Data ONTAP Cluster-Mode, or between storage systems on Data ONTAP operating in 7-Mode. The default is unlimited (0), which permits the SnapMirror relationship to fully utilize the available network bandwidth. On Data ONTAP operating in Cluster-Mode, the max-transfer-rate option does not affect load-sharing mirrors and other SnapMirror relationships confined to a single cluster.

=end html

=back



=over 2

=item * I<source-location>  =>   B<string, optional>

=begin html

<br>Specifies the source endpoint of the SnapMirror relationship in the following formats: <ul> <li> &lt;system&gt;:/vol/&lt;volume&gt;[/&lt;qtree&gt;] On Data ONTAP operating in 7-Mode. <li> [&lt;cluster&gt:]//&ltvserver&gt/&ltvolume&gt; On Data ONTAP 8.1 operating in Cluster-Mode, and on Data ONTAP 8.2 operating in Cluster-Mode for relationships using a control plane compatible with Data ONTAP 8.1 operating in Cluster-Mode. <li> &lt;[vserver:]volume&gt; On Data ONTAP 8.2 or later operating in Cluster-Mode except for relationships using a control plane compatible with Data ONTAP 8.1 operating in Cluster-Mode. This format depends on the Vserver peering setup between the source and destination Vservers. </ul> This format may change in the future. On Data ONTAP Cluster-Mode when specifying a source endpoint, you must use either the source location, or the source cluster, source Vserver, and source volume. On Data ONTAP 7-Mode, If the source-location is not specified, then the source in /etc/snapmirror.conf for the destination path is used.

=end html

=back



=over 2

=item * I<source-snapshot>  =>   B<string, optional>

=begin html

<br>Specifies the Snapshot copy on the source to use as the basis for the update. It is used for updates to Data ONTAP 7-mode qtree relationships and Data ONTAP Cluster-Mode relationships. <p>For a qtree relationship, Data ONTAP 7-mode does not create a new Snapshot copy and transfers the specified Snapshot copy instead. <p>For data protection mirror relationships, Data ONTAP Cluster-Mode does not create a new Snapshot copy. It will use the specified Snapshot copy as if it were the most recent one; that is, all copies between the most recent common one and the specified one are transferred, but no copies newer than the specified one are transferred. <p>For vault relationships, Data ONTAP Cluster-Mode transfers the specified Snapshot copy instead of the ones that match its policy's rules.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapshot_autodelete_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Returns the current snapshot autodelete settings.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the existing volume for which we want snapshot autodelete settings

=end html

=back



B<Outputs>

=over 2

=item * I<options>  =>   B<L<"snapshot-autodelete-info">[]>

=begin html

<br>List of snapshot autodelete options for this volume.

=end html

=back



=head2 snapshot_autodelete_set_option

[B<Family:> ontap-classic, vfiler]


=begin html

Set the option named 'option-name' to the value specified by 'option-value' in the autodelete settings of the specified volume. <p> This API is not supported on Infinite Volume.

=end html



B<Inputs>

=over 2

=item * I<option-name>  =>   B<string>

=begin html

<br>Name of the option to be set. Possible values: <dl> <dt>"state" (value: "on" | "off")</dt> <dd> This option determines if the snapshot autodelete is currently enabled for the volume. Setting the option to "on" switches on the snapshot autodelete for the volume. Setting the option to "off" switches off the snapshot autodelete for the volume. </dd><br> <dt>"commitment" (value: "try" | "disrupt" | "destroy" )</dt> <dd> This option determines the snapshots which snapshot autodelete is allowed to delete to get back space. Setting this option to "try" only permits the snapshots which are not locked by data protection utilities (dump, mirroring, NDMPcopy) and data backing functionalities (volume, LUN and File clones) to be deleted. Setting this option to "disrupt" only permits the snapshots which are not locked by data backing functionalities (volume, LUN and File clones) to be deleted. Setting this option to "destroy", will destroy the data backing functionality (volume, LUN and File clones) if the backing snapshot is deleted. </dd><br> <dt>"trigger" (value: "volume" | "snap_reserve" | "space_reserve") </dt> <dd> This option determines the condition which starts the automatic deletion of snapshots. Setting this option to "volume" triggers automatic deletion of snapshots when the volume reaches threshold capacity and the volume's snap reserve has been exceeded. Setting the option to "snap_reserve" triggers automatic deletion of snapshots when the snap reserve of the volume reaches threshold capacity. Setting the option to "space_reserve" triggers automatic deletion of snapshots when the space reserved the volume reaches threshold capacity and the volume's snap reserve has been exceeded. The threshold capacity is determined by the size of the volume as given below: <ul> <li>If the volume size is less than 20 GB, the autodelete threshold is 85%.</li> <li>If the volume size is equal to or greater than 20 GB and less than 100 GB, the autodelete threshold is 90%.</li> <li>If the volume size is equal to or greater than 100 GB and less than 500 GB, the autodelete threshold is 92%.</li> <li>If the volume size is equal to or greater than 500 GB and less than 1 TB, the autodelete threshold is 95%.</li> <li>If the volume size is equal to or greater than 1 TB, the autodelete threshold is 98%.</li> </ul></dd><br> <dt>"target_free_space" (value: &lt; number &gt;)</dt> <dd> This option determines when snapshot autodelete should stop deleting snapshot. Depending on the trigger, snapshots are deleted till we reach the target free space percentage. </dd><br> <dt>"delete_order" (value: newest_first | oldest_first)</dt> <dd> This option determines if the oldest or newest snapshot is deleted first. </dd><br> <dt>"defer_delete" (value: scheduled | user_created | prefix | none) </dt> <dd> This option determines which kind of snapshots to delete in the end. Setting this option value to "scheduled" will delete the snapshots created by the snapshot scheduler last. Setting this option value to "user_created" will delete the snapshots not created by the snapshot scheduler last. Setting this option value to "prefix" will delete the snapshots matching the prefix string to be deleted last. Setting this option value to "none" will disable the above choices. </dd><br> <dt>"prefix" (value: &lt; string &gt;)</dt> <dd> This option can be set to provide the prefix string for the "prefix" value of the "defer_delete" option. The prefix string length can be 15 char long. </dd><br> <dt>"destroy_list" (value: &lt; string &gt;)</dt> <dd> A comma seperated list of services which can be destroyed if the snapshot backing that service is deleted. For 7-mode, the possible values for this option are a combination of "lun_clone", "vol_clone", "cifs_share", "file_clone" or "none". For cluster-mode, the possible values for this option are a combination of "lun_clone,file_clone" (for LUN clone and/or file clone), "lun_clone,sfsr" (for LUN clone and/or sfsr), "vol_clone", "cifs_share", or "none". Please note that "lun_clone", "file_clone" and "sfsr" individually are not valid values. Only pairs "lun_clone,file_clone" and "lun_clone,sfsr" are supported. The option "sfsr" is not supported for 7-mode. The default value is "none" for 7-mode and cluster-mode. </dd><br> </dl>

=end html

=back



=over 2

=item * I<option-value>  =>   B<string>

=begin html

<br>The value to set the named option

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume for which we want to change autodelete settings.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapshot_create

[B<Family:> ontap-classic, vfiler]


=begin html

Create a new snapshot on a specified volume. <p> This API is not supported on Infinite Volume.

=end html



B<Inputs>

=over 2

=item * I<async>  =>   B<boolean, optional>

=begin html

<br>If true, the snapshot is to be created asynchronously. The default value is false.

=end html

=back



=over 2

=item * I<is-valid-lun-clone-snapshot>  =>   B<boolean, optional>

=begin html

<br>If true, the snapshot create has been requested by snapvault hence all backing snapshots for all the lun clones in this snapshot will be locked. This ensures the consistency of this snapshot. The default value is false.

=end html

=back



=over 2

=item * I<snapshot>  =>   B<string>

=begin html

<br>Name of the snapshot to be created. The maximum string length is 256 characters.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume on which the snapshot is to be created. The volume name can contain letters, numbers, and the underscore character (_), but the first character must be a letter or an underscore.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapshot_delete

[B<Family:> ontap-classic, vfiler]


=begin html

Delete a snapshot on a specified volume. EBUSY is returned when the snapshot is in use. EROFS is returned when the volume is read-only. EAGAIN is returned when splitting a blockmap or reverting. <p> This API is not supported on Infinite Volume.

=end html



B<Inputs>

=over 2

=item * I<snapshot>  =>   B<string>

=begin html

<br>Name of snapshot to be deleted on the specified volume.

=end html

=back



=over 2

=item * I<snapshot-instance-uuid>  =>   B<uuid, optional>

=begin html

<br>The 128 bit unique snapshot identifier expressed in the form of UUID. This field is optional and can appear together with 'snapshot' to uniquely identify a snapshot for deletion. If this field is provided, 'snapshot' is a required parameter. <p> An example of an actual UUID is: <p> 73a010ec-3d28-11df-84e8-123478563412

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume on which the snapshot is to be deleted.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapshot_delta_info

[B<Family:> ontap-classic, vfiler]


=begin html

Returns the amount of space consumed between two snapshots or a snapshot and active filesystem.

=end html



B<Inputs>

=over 2

=item * I<snapshot1>  =>   B<string>

=begin html

<br>Name of snapshot to be compared with snapshot2 for space consumption calculations.

=end html

=back



=over 2

=item * I<snapshot2>  =>   B<string, optional>

=begin html

<br>Name of snapshot to be compared with snapshot1 for space consumption calculations. If the snapshot is not specified, it is assumed to be Active File System.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume on which the snapshot delta is to be calculated.

=end html

=back



B<Outputs>

=over 2

=item * I<consumed-size>  =>   B<integer>

=begin html

<br>Size in bytes of space changed between the 2 specified snapshots or snapshot and the active file system. Range : [0 - 2^63-1].

=end html

=back



=over 2

=item * I<elapsed-time>  =>   B<integer>

=begin html

<br>Time in seconds elapsed between the 2 specified snapshots or the snapshot and the active file system. Range : [0 - 2^31-1].

=end html

=back



=head2 snapshot_get_reserve

[B<Family:> ontap-classic, vfiler]


=begin html

Obtain the current snapshot reserve on a specified volume. Error Returns: Invalid volume name.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume that contains the snapshot reserve.

=end html

=back



B<Outputs>

=over 2

=item * I<blocks-reserved>  =>   B<integer>

=begin html

<br>The number of 1024 byte blocks that has been set aside as reserve for snapshot usage.

=end html

=back



=over 2

=item * I<percent-reserved>  =>   B<integer>

=begin html

<br>The percentage of disk space that has been set aside as reserve for snapshot usage.

=end html

=back



=head2 snapshot_get_schedule

[B<Family:> ontap-classic, vfiler]


=begin html

Obtain the current snapshot schedule on a specified volume. Error Returns: Invalid volume name.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>This the volume name where the snapshots are located.

=end html

=back



B<Outputs>

=over 2

=item * I<days>  =>   B<integer>

=begin html

<br>The number of snapshots taken daily to keep on line. Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<hours>  =>   B<integer>

=begin html

<br>The number of snapshots taken hourly to keep on line. Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<minutes>  =>   B<integer>

=begin html

<br>The number of snapshots taken minutely to keep on line. Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<weeks>  =>   B<integer>

=begin html

<br>The number of snapshots taken weekly to keep on line. Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<which-hours>  =>   B<string>

=begin html

<br>A list of the hours at which the hourly snapshots are created.

=end html

=back



=over 2

=item * I<which-minutes>  =>   B<string>

=begin html

<br>A list of the minutes at which the minutely snapshots are created.

=end html

=back



=head2 snapshot_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Return snapshot information for a specified volume. A list of snapshots and information about each snapshot is returned. In Data ONTAP Cluster-Mode, 'snapshot-get-iter' API is the preferred way of retrieving snapshot information.

=end html



B<Inputs>

=over 2

=item * I<is-7-mode-snapshot>  =>   B<boolean, optional>

=begin html

<br>If set to true, check if snapshot is a 7-mode snapshot. A 7-mode snapshot can appear in a cluster-mode volume as a result of the volume being transitioned from 7-mode to cluster-mode. A 7-mode snapshot cannot be used in a volume snapshot restore. The default value is false.

=end html

=back



=over 2

=item * I<lun-clone-snapshot>  =>   B<boolean, optional>

=begin html

<br>If set to true, check if snapshot contains any lun clones. The default value is false.

=end html

=back



=over 2

=item * I<snapowners>  =>   B<boolean, optional>

=begin html

<br>If set to true, owners of the busy snapshot are returned. If false, or if the option is omitted, the list of owners is not returned.

=end html

=back



=over 2

=item * I<target-name>  =>   B<string, optional>

=begin html

<br>Name of the object on which to list the snaplist information. Arguments "target-name" and "target-type" should be used together. Arguments "volume" and ("target-name", "target-type") pair are mutually exclusive. One and only one of them should be specified.

=end html

=back



=over 2

=item * I<target-type>  =>   B<string, optional>

=begin html

<br>Type of the object on which to list the snaplist information. Possible values: volume, aggregate.

=end html

=back



=over 2

=item * I<terse>  =>   B<boolean, optional>

=begin html

<br>If set to true, the snapshot block ownership values, namely the "total" and "cumulative-total" outputs, will be omitted. If set to false, the block ownership calculation will be included in the output. The default value is false.

=end html

=back



=over 2

=item * I<volume>  =>   B<string, optional>

=begin html

<br>Name of the volume on which to list the snaplist information. It is for backward compatibility. The recommended usage is to use arguments ("target-name", "target-type") pair.

=end html

=back



B<Outputs>

=over 2

=item * I<snapshots>  =>   B<L<"snapshot-info">[], optional>

=begin html

<br>null

=end html

=back



=head2 snapshot_multicreate

[B<Family:> ontap-classic, vfiler]


=begin html

Create a snapshot with the specific name, on each of the specified volumes. It is the caller's responsibility to ensure that the data in the snapshots across all volumes is consistent, by quiescing I/O to these volumes (or the LUNs of interest in these volumes), across the call to this API. The API returns SUCCESS when a snapshot is successfully created on each of the specified volumes. This API bails out and reports FAILURE when an error is found at creating a snapshot on a volume. It does not continue on to create snapshots on the remaining volumes. When the API fails, the returned error code is for the failed volume. For clustered systems, the output 'status' will be set to FALSE in case of failure. In such case the caller should look at the output 'volume-errors' to find out in which volume snapshot creation failed. When an error occurs, it is possible that some snapshots may have been created. If the option cleanup is set to TRUE (default), API will attempt to delete these snapshots (but snapshot deletion may fail). When set to FALSE, it is users' responsibility to delete them. The output array volume-snapcreated-list records for each volume, if a snapshot has been created or not. There are at least two expected use cases for this API. The first one is to call this API with the cleanup option set to TRUE (default). If the call fails, any successfully created snapshots will be deleted before the function returns. This is a simple use case, but has the downside that in case of a failure, the call may take a long time to return due to snapshot cleanup. Another use case would be to call this API in a time critical environment. In such a scenario, it would be good to reduce the impact due to a failure. Hence, it would be better to first call the snapshot-multicreate-validate ZAPI, which would reduce the likelihood of failure of the snapshot-multicreate API. In case a failure does occur, the caller could avoid the cleanup delay by setting the cleanup option to FALSE, and performing snapshot cleanup later, outside the time-critical window. <p> This API is not supported on Infinite Volume.

=end html



B<Inputs>

=over 2

=item * I<cleanup>  =>   B<boolean, optional>

=begin html

<br>When the API fails, some snapshots may have been created for some volumes. When set to TRUE, the API will attempt to delete these snapshots. Note that newly created snapshots cannot be deleted right away until the snapshots are on-disk, which may take up to 10 secs. When set to FALSE, newly created snapshots are not deleted. Users can delete them later as needed. Default is TRUE.

=end html

=back



=over 2

=item * I<snapshot>  =>   B<string>

=begin html

<br>Name of the snapshot to be created. The maximum string length is 256 characters.

=end html

=back



=over 2

=item * I<volume-names>  =>   B<volume-name[]>

=begin html

<br>Names of the volumes across which the snapshot is to be created. The maximum number of volumes on a cluster system is 1200 (100 for traditional volumes and 500 for flexible volumes. The number is then doubled for a cluster system).

=end html

=back



B<Outputs>

=over 2

=item * I<volume-is-snapcreated-list>  =>   B<L<"volume-is-snapcreated">[], optional>

=begin html

<br>An array records if a snapshot has been created for a given volume. This is returned only in case of failure.

=end html

=back



=head2 snapshot_multicreate_validate

[B<Family:> ontap-classic, vfiler]


=begin html

This is a companion API of snapshot-multicreate. It validates the snapshot creation operation on the specified volumes. But it does not actually create any snapshot. This API only does validations on all volumes and report all errors in the output array. This API is intended to be issued before the snapshot-multicreate API to find out all the errors that may be found during the snapshot create. Its main purpose is to enable snapshot-multicreate's caller to reduce the likelihood of snapshot-multicreate's failure, thereby attempting to avoid the cleanup overhead (of deleting any newly created snapshots) during failure processing. However, this validation API does not guarantee that snapshot-multicreate API will actually work. Something could change between the two calls to cause the actual snapshot creations to fail. <p> This API is not supported on Infinite Volume.

=end html



B<Inputs>

=over 2

=item * I<snapshot>  =>   B<string>

=begin html

<br>Name of the snapshot to be created. The maximum string length is 256 characters.

=end html

=back



=over 2

=item * I<volume-names>  =>   B<volume-name[]>

=begin html

<br>Names of the volumes across which the snapshot creation is to be validated.

=end html

=back



B<Outputs>

=over 2

=item * I<volume-errors>  =>   B<L<"volume-error">[]>

=begin html

<br>An array records the error code associated with each volume.

=end html

=back



=head2 snapshot_multidelete

[B<Family:> ontap-classic]


=begin html

Delete the snapshot from the given flexible volumes. This API will return failure if the volume could not be found or it is busy. All the volumes should be online when this API is invoked. It will only delete snapshots on Read-Write volumes. Once all the necessary information to delete snapshots is available, this API will start deleting snapshots on the volumes. If any of the snapshot delete failed, the API will remember the failed volume and continue deleting snapshot on the remaining volumes. In case of failure to delete the snapshots from all the given volumes, the API will return a SUCCESS and also return information about the failed snapshot deletes via the 'volume-errors' output. If the API returns SUCCESS, the applications should check if the 'volume-errors' output is returned or not to check for failed snapshot deletions. <p> This API is not supported on Infinite Volume.

=end html



B<Inputs>

=over 2

=item * I<snapshot>  =>   B<string>

=begin html

<br>Name of the snapshot to be deleted. The maximum string length is 256 characters.

=end html

=back



=over 2

=item * I<volume-names>  =>   B<volume-name[]>

=begin html

<br>Names of the volumes across which the snapshot is to be deleted.

=end html

=back



B<Outputs>

=over 2

=item * I<volume-errors>  =>   B<L<"volume-error">[], optional>

=begin html

<br>Error code and reason due to which snapshot deletion failed on a volume. This output is only returned when the API returns SUCCESS but snapshot on some volumes could not be deleted.

=end html

=back



=head2 snapshot_partial_restore_file

[B<Family:> ontap-classic, vfiler]


=begin html

Restores a particular range of bytes in a file from a specified snapshot. <p> Partial file restores are used to restore particular pieces of LUNs and NFS or CIFS container files that are used by a host to store multiple sources of data. For example, a host may be storing multiple user databases in the same LUN. A partial file restore can be used to restore one of those databases in the LUN while not touching the other databases that are also stored in the LUN. Compressed files will not be restored, thought compression may be enabled on the volume. <p> Partial file restores require significant management by the caller. The caller must understand the metadata of the host LUN or container file so that they can know which bytes belong to the object being restored. <p> Before the restore operation beings, the caller must quiesce the object being restored. It must remain quiesced for the duration of the restore operation. No host I/O should be issued for the object while it is being restored because the snapshot-partial-restore-file commands will be incrementally restoring the LUN or file and the host will therefore see inconsistent content for the object until the restore operation is completed. Host I/O is permitted for the other objects stored in the LUN or container file because the partial file restore will not touch the bytes belonging to those other objects. <p> During the restore the caller must issue a snapshot-partial-restore-file command for each of the byte ranges that belong to the object being restored, based on the metadata of the LUN or container file. Once each command returns, that byte range is restored and the changes are persistent. If the filer should halt while processing a command, that byte range of the LUN or container file is inconsistent. Some of the bytes at the beginning of the range may have been restored while bytes at the end of the range have not been restored. Once the filer is rebooted the caller should re-issue the command to restore that byte range to complete the restore. <p> Once the restore is completed, the caller must purge any host operating system or application buffers that may hold data for the LUN or file that is now stale. For NFS or CIFS mounted volumes the easiest way to purge any host buffers is to unmount and remount the volume. Applications holding buffered data may need to be shut down and restarted. <p> Multiple partial file restore requests may be issued to the same LUN or file simultaneously. There is no requirement that the requests are all restoring from the same snapshot so that multiple restore operations for different objects may be concurrent on the same file. There is no checking to prevent overlapping byte ranges between requests. Preventing this condition is the responsibility of the caller. <p> Partial file restores are not intended for restoring parts of normal user-level files that are stored in an NFS or CIFS exported volume. Use snapshot-restore-file to restore normal files like these. <p> The volume where the LUN or container file to restore and where the snapshot to restore from live must be online and must not be a mirror volume. <p> The partial file restore request may fail if there is not sufficient free space to overwrite all of the blocks in the byte range to be restored. <p> The partial file restore request is synchronous, meaning that the command will not return until the entire byte range is restored. The snapshot being restored from cannot be deleted while a request is being executed, but it can be deleted between requests. If this happens the next request will notice that the snapshot has been deleted and will return an error. <p> The maximum number of bytes of data that can be restored in a single request is given by the max-byte-count value returned by the snapshot-partial-restore-file-list-info command. This limit ensures that requests are periodically interruptible and avoids overloading the filer. <p> If the system halts while a partial file restore request is being executed, the request will not be restarted upon reboot. Some of the bytes at the beginning of the range may have been restored while bytes at the end of the range have not been restored. The caller should reissue the partial file restore request for that byte range to complete the restore.

=end html



B<Inputs>

=over 2

=item * I<byte-count>  =>   B<integer>

=begin html

<br>The number of bytes to restore, beginning at start-byte. The byte count must be a multiple of 4096. Use snapshot-partial-restore-file-list-info to determine the maximum number of bytes that can be restored in a single request. Range : [0 - 2^64-1]

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the file to restore. Path syntax has two forms: /vol/<volumename>/<rest of path> /<rest of path> In the latter case (relative path), if volume was not specified, the root volume will be used.

=end html

=back



=over 2

=item * I<snapshot>  =>   B<string>

=begin html

<br>The simple name of the snapshot to restore from. The snapshot must be from same volume as the file to partially restore.

=end html

=back



=over 2

=item * I<snapshot-instance-uuid>  =>   B<string, optional>

=begin html

<br>A unique physical version identifier for a given snapshot within a volume or an aggregate. A typical snapshot instance UUID will look like: c0335624-21f3-450c-aea1-55884d0218b9

=end html

=back



=over 2

=item * I<start-byte>  =>   B<integer>

=begin html

<br>The starting byte offset in the file to partially restore. The first byte of the file is byte zero. The start byte must be a multiple of 4096. Range : [0 - 2^64-1]

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapshot_partial_restore_file_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Returns partial file restore settings of the vserver. <p> This API is not supported on Infinite Volume.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<max-byte-count>  =>   B<integer>

=begin html

<br>The maximum number of bytes that can be restored in a single request. This limit ensures that requests are periodically interruptible and avoids overloading the filer. Range : [0 - 2^64-1]

=end html

=back



=head2 snapshot_reclaimable_info

[B<Family:> ontap-classic, vfiler]


=begin html

Returns the amount of space that would be freed when a set of snapshots are deleted from a specified volume.

=end html



B<Inputs>

=over 2

=item * I<snapshots>  =>   B<snapshot-name[]>

=begin html

<br>List of snapshots. A maximum of 255 snapshots can be listed.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume on which the snapshot reclaimable space info is to be collected.

=end html

=back



B<Outputs>

=over 2

=item * I<reclaimable-size>  =>   B<integer>

=begin html

<br>Size in bytes of space reclaimable if the snapshots were deleted. Range : [0 - 2^63-1].

=end html

=back



=head2 snapshot_rename

[B<Family:> ontap-classic, vfiler]


=begin html

Rename a specified snapshot to a new name on a specified volume. This API is not supported on Infinite Volume constituents.

=end html



B<Inputs>

=over 2

=item * I<current-name>  =>   B<string>

=begin html

<br>Name of snapshot to be renamed.

=end html

=back



=over 2

=item * I<new-name>  =>   B<string>

=begin html

<br>New name of snapshot as a result of the rename.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume where the current snapshot and the new snapshot are located.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapshot_reserve_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Gets the percentage of disk space that is reserved for snapshots in the indicated volume. If no volume is specified, this will return the percentage of disk space reserved for snapshots for each of the volumes in the system. Reserve space can be used only by snapshots and not by the active file system. This API is deprecated in Data ONTAP Cluster-Mode 8.2 and later. Use volume-get-iter instead.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string, optional>

=begin html

<br>Volume to get percentage of space reserved for snapshots.

=end html

=back



B<Outputs>

=over 2

=item * I<snapshot-reserve-details>  =>   B<L<"snapshot-reserve-detail-info">[]>

=begin html

<br>List of volumes along with their snapshot space reservation configuration.

=end html

=back



=head2 snapshot_restore_file

[B<Family:> ontap-classic, vfiler]


=begin html

Reverts a single file to a revision from a specified snapshot. The volume used for restoring the file must be online and must not be a mirror. Files other than normal files and LUNs are not restored. This includes directories (and their contents), and files with NT streams. Compressed files will not be restored in Data ONTAP 7-mode, though compression may be enabled on the volume. <p> If there is not enough space in the volume, the single file snap restore will not start. If the file already exists (in the active filesystem), it will be overwritten with the version in the snapshot. Exclusive oplocks and hard exclusive locks like the DOS compatibility lock will be invalidated. <p> Other single file snap restores can be executed concurrently. Also it is possible for the single file snap restore to be aborted if we run out of disk space during the operation. When this happens the timestamp of the file being restored will be updated. Thus it will not be the same as the timestamp of the file in the snapshot. <p> For normal files, an in-progress restore can be aborted by removing the file. For NFS users, the last link to the file must be removed. <p> For all restored files, the snapshot used for the restore cannot be deleted. New snapshots cannot be created while a single-file snaprestore is in progress. Scheduled snapshots on the volume will be suspended for the duration of the restore. Tree, user and group quota limits are not enforced for the owner, group and tree in which the file is being restored. Thus if the user, group or tree quotas are exceeded, /etc/quotas will need to be altered after the single file snap restore operation has completed. Then quota resize will need to be run. When the restore completes, the file's attributes (size, permissions, ownership, etc.) should be identical as those in the snapshot. <p> If the system is halted or crashes while a single file snap restore is in progress then the operation will be restarted on reboot. A volume cannot have both a volume snaprestore and a single-file snaprestore executing simultaneously. Multiple single-file snaprestores can be in progress simultaneously. <p> <b>The following applies to Data ONTAP 7-mode only:</b> <p> For normal files while the restore is proceeding, any operation which tries to change the file will be suspended until the restore is done. It could take up to several minutes for before the API invocation returns. Once the invocation returns, the file restore will proceed in the background. The restore may take a long time to complete depending on the size of the file being restored. The file is unavailable for use during this time. <p> For LUNs that are restored over top of their existing LUN, a LUN clone can be created that is backed by the snapshot being restored from and then the clone is split. For LUNs that are restored over top of their existing LUN, an in-progress restore can be aborted by using lun-clone-stop when in Data ONTAP 7-mode. The restored LUN will still be a clone in this case and it will still be partially backed by the snapshot it was restored from. Snapshots are disabled during restore due to space efficient LUN clone split. In order to disable space efficient split during restore set the optional parameter space-efficient-split-disabled. While the restore is proceeding the LUN is available and I/O (both reads and writes) is permitted. Data that is modified in the LUN while the restore is proceeding will not be overwritten by the restore process. The restore may take a long time to complete depending on the size of the LUN being restored. Use lun-clone-status-list-info to see the progress of the LUN restore.

=end html



B<Inputs>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the file to restore. Path syntax has two forms: /vol/<volumename>/<rest of path> /<rest of path> In the latter case (relative path), if volume was not specified, the root volume will be used.

=end html

=back



=over 2

=item * I<restore-path>  =>   B<string, optional>

=begin html

<br>Path to restore to. The path must be a full path to a filename, and must be in the same volume as the volume used for the restore. If not specified, restore-path is defaulted to the original path.

=end html

=back



=over 2

=item * I<snapshot>  =>   B<string>

=begin html

<br>Name of snapshot to restore from. Snapshot must be from same volume as the file to restore.

=end html

=back



=over 2

=item * I<snapshot-instance-uuid>  =>   B<string, optional>

=begin html

<br>A unique physical version identifier for a given snapshot within a volume or an aggregate. A typical snapshot instance UUID will look like: c0335624-21f3-450c-aea1-55884d0218b9

=end html

=back



=over 2

=item * I<space-efficient-split-disabled>  =>   B<boolean, optional>

=begin html

<br>By default 'false', space-efficient LUN clone split is allowed during restore. This parameter, if set to 'true', disables space-efficient splitting for this specific operation.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapshot_restore_file_info

[B<Family:> ontap-classic, vfiler]


=begin html

Get information about snapshot file restores on a given vserver. Returns maximum snapshot file restores limit and snapshot file restores in progress numbers.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<max-sfsr-limit>  =>   B<integer>

=begin html

<br>The maximum number of parallel single file snapshot restores (SFSR) allowed on a filer.

=end html

=back



=over 2

=item * I<sfsr-in-progress>  =>   B<integer>

=begin html

<br>Number of single file snapshot restores (SFSR) in progress on a filer.

=end html

=back



=head2 snapshot_restore_volume

[B<Family:> ontap-classic, vfiler]


=begin html

Reverts a volume to a specified snapshot. The volume must be online and must not be a mirror. If reverting the root volume, the filer will be rebooted. Non-root volumes do not require a reboot. A volume cannot have both a volume snaprestore and a single-file snaprestore executing simultaneously. Multiple single-file snaprestores can be in progress simultaneously. After the reversion, the volume is in the same state as it was when the snapshot was taken. <p> This API is not supported on Infinite Volume.

=end html



B<Inputs>

=over 2

=item * I<snapshot>  =>   B<string>

=begin html

<br>Name of snapshot to restore from.

=end html

=back



=over 2

=item * I<snapshot-instance-uuid>  =>   B<uuid, optional>

=begin html

<br>The 128 bit unique snapshot identifier expressed in the form of UUID. This field is optional and can appear together with 'snapshot' to uniquely identify a snapshot to restore. If this field is provided, 'snapshot' is a required parameter. <p> An example of an actual UUID is: <p> 84a010ec-3d28-11df-84e8-123478653412

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of volume to restore.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapshot_set_reserve

[B<Family:> ontap-classic, vfiler]


=begin html

Sets the size of the indicated volume's snapshot reserve to the specified percentage. Reserve space can be used only by snapshots and not by the active file system.

=end html



B<Inputs>

=over 2

=item * I<percentage>  =>   B<integer>

=begin html

<br>Percentage to set. Range [0-100].

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of volume on which to set the snapshot space reserve.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapshot_set_schedule

[B<Family:> ontap-classic, vfiler]


=begin html

Set the snapshot schedule on a specified volume. If number of snapshots requested is greater than ONTAP allows, then ESNAPTOOMANY will be returned with the maximum allow snapshots in the reason.

=end html



B<Inputs>

=over 2

=item * I<days>  =>   B<integer, optional>

=begin html

<br>Number of snapshots taken daily to keep on line. If not provided, the number of daily snapshots is left at the previous value.

=end html

=back



=over 2

=item * I<hours>  =>   B<integer, optional>

=begin html

<br>Number of snapshots taken hourly to keep on line. If not provided, the number of weekly snapshots is left at the previous value.

=end html

=back



=over 2

=item * I<minutes>  =>   B<integer, optional>

=begin html

<br>Number of snapshots taken minutely to keep on line. If not provided, the number of minutely snapshots is left at the previous value.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume name where the snapshots are located.

=end html

=back



=over 2

=item * I<weeks>  =>   B<integer, optional>

=begin html

<br>Number of snapshots taken weekly to keep on line. If not provided, the number of weekly snapshots is left at the previous value.

=end html

=back



=over 2

=item * I<which-hours>  =>   B<string, optional>

=begin html

<br>Comma-separated list of the hours at which the hourly snapshots are created. If hours is 0, which-hours is ignored and cleared.

=end html

=back



=over 2

=item * I<which-minutes>  =>   B<string, optional>

=begin html

<br>Comma-separated list of the minutes at which the minutely snapshots are created. If minutes is 0, which-minutes is ignored and cleared.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapshot_volume_info

[B<Family:> ontap-classic, vfiler]


=begin html

Returns snapshot related volume information. The information returned is valid at the time the API call reached the filer and maybe outdated soon after.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume on which the space needs to be checked.

=end html

=back



B<Outputs>

=over 2

=item * I<size-available>  =>   B<integer>

=begin html

<br>Total bytes that when exhausted will disable us from taking snapshots. If this value is 0, snapshots cannot be taken. Any other value would allow us to take a reliable snapshot. This space may or may not get exhausted by taking a snapshot. Also it may get used by writes/allocations in the volume. This is not equal to the free space in the active file system or anyway related to the size of the next snapshot. Range : [0..2^64-1].

=end html

=back



=head2 snapvault_add_softlock

[B<Family:> ontap-classic]


=begin html

Request the system to add softlock for the specified snapshot. Softlocks can be added to preserve the snapshots which user wants to retain down the cascade.

=end html



B<Inputs>

=over 2

=item * I<snapshot>  =>   B<string>

=begin html

<br>Name of the snapshot to be softlocked.

=end html

=back



=over 2

=item * I<softlock-name>  =>   B<string, optional>

=begin html

<br>Name of softlock which uniquely identifies the softlock for the snapshot. When not specified, softlock will be added with default name. Name of softlock can contain letters, numbers, and underscore character (_), and can be up to 64 characters long.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume where the snapshot exists.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapvault_get_all_softlocked_snapshots

[B<Family:> ontap-classic]


=begin html

List all snapshots which are softlocked for snapvault by external means.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume for which softlocked snapshots to be listed.

=end html

=back



B<Outputs>

=over 2

=item * I<snapshot-list>  =>   B<snapshot-name[], optional>

=begin html

<br>List of snapshots which are softlocked by external means.

=end html

=back



=head2 snapvault_get_softlocks

[B<Family:> ontap-classic]


=begin html

List all snapvault softlocks on the given snapshot which are locked by external means.

=end html



B<Inputs>

=over 2

=item * I<snapshot>  =>   B<string>

=begin html

<br>Name of the snapshot for which softlocks to be listed.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume where the snapshot exists.

=end html

=back



B<Outputs>

=over 2

=item * I<snapvault-softlocks>  =>   B<L<"snapvault-softlock-info">>

=begin html

<br>snapvault softlock information for the snapshot.

=end html

=back



=head2 snapvault_primary_abort_snapshot_create

[B<Family:> ontap-classic, vfiler]


=begin html

Request the primary to abort a snapshot creation that is already in progress. The snapshot schedule for which the snapshot creation is in progress must be specified as input.

=end html



B<Inputs>

=over 2

=item * I<schedule-name>  =>   B<string>

=begin html

<br>Name of the schedule used for snapshot creation.

=end html

=back



=over 2

=item * I<volume-name>  =>   B<string>

=begin html

<br>Primary volume in which snapshot create is in progress.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapvault_primary_abort_transfer

[B<Family:> ontap-classic, vfiler]


=begin html

Request the primary system to abort an active transfer. The abort can be hard abort, which means the transfer will not be restartable. Or it could be a soft abort, which will not clean the restart checkpoints. In that case the transfer may be restartable. An aborted transfer may be restarted by using the same API used to initiate the transfer in the previous attempt. If that request cannot restart the aborted transfer, then it will initiate a fresh new transfer.

=end html



B<Inputs>

=over 2

=item * I<is-hard-abort>  =>   B<boolean, optional>

=begin html

<br>When set to 'true' a hard abort is performed. In that case the restart checkpoints are cleared. Default value is 'false'.

=end html

=back



=over 2

=item * I<system-path>  =>   B<string>

=begin html

<br>The system path which is the target of transfer.

=end html

=back



=over 2

=item * I<target-system>  =>   B<string, optional>

=begin html

<br>The system filer which is the target of transfer.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapvault_primary_delete_snapshot_schedule

[B<Family:> ontap-classic, vfiler]


=begin html

Request the primary system to delete the specified snapshot schedules. The snapshot schedules that match the volume name and if specified the schedule name, will be deleted.

=end html



B<Inputs>

=over 2

=item * I<schedule-name>  =>   B<string, optional>

=begin html

<br>Name of the schedule to be deleted.

=end html

=back



=over 2

=item * I<volume-name>  =>   B<string>

=begin html

<br>The primary volume for which the schedules are to be deleted.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapvault_primary_destinations_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Request the primary to list all snapvault destinations that have been replicated from any source path on this primary system. If a source path is provided, then the primary will return destinations information only for that source path. When snapvault primary and secondary are licensed on the same filer, output of this API is identical to the output of snapvault-primary-destinations-list-info

=end html



B<Inputs>

=over 2

=item * I<source-path>  =>   B<string, optional>

=begin html

<br>Source path on this primary for which the destination information is desired.

=end html

=back



B<Outputs>

=over 2

=item * I<destinations>  =>   B<L<"snapvault-destination-info">[]>

=begin html

<br>List of all snapvault destinations known to this primary.

=end html

=back



=head2 snapvault_primary_get_relationship_status

[B<Family:> ontap-classic, vfiler]


=begin html

Request the primary to return the status entries for desired relationships. The relationships whose status is desired must be specified using the system path. When snapvault primary and secondary are licensed on the same filer, output of this API is identical to the output of snapvault-secondary-get-relationship-status

=end html



B<Inputs>

=over 2

=item * I<system-path>  =>   B<string>

=begin html

<br>System path for relationships whose status is desired.

=end html

=back



B<Outputs>

=over 2

=item * I<status>  =>   B<L<"snapvault-status-info">[]>

=begin html

<br>Status entries for desired relationships.

=end html

=back



=head2 snapvault_primary_initiate_incremental_restore_transfer

[B<Family:> ontap-classic, vfiler]


=begin html

Request to initiate an incremental restore from a given secondary path to an existing primary path, using the specified secondary snapshot. The request will only initiate the restore and return. The actual restore operation will proceed asynchronously and there is no guarantee that it will succeed. The snapvault-primary-get-relationship- status API should be used to determine progress of the restore operation. If the dataset contains LUNs, the restore will attempt to prevent disruptions to clients using those LUNs. Upon success, the primary path will have the exact same contents as the specified secondary path in the specified secondary snapshot.

=end html



B<Inputs>

=over 2

=item * I<connection-mode>  =>   B<string, optional>

=begin html

<br>This option specifies the mode to be used for establising connection between primary and secondary. If this option is set to "inet6", connections between primary and secondary will be established using IPv6 addresses only. If there are no IPv6 addressess configured, then the connection will fail. If the option is set to "inet", connections between primary and secondary will be established using IPv4 addresses only. If there are no IPv4 addresses configured, then the connection will fail. When this option is not specified, Connection will be tried using both "inet6" and "inet". "inet6" will have higher precedence than "inet". If connection request using "inet6" fails, SnapMirror will retry the connection using "inet". This argument is not effective when an IP address is specified instead of secondary hostname. If the IP address format and connection mode do not match, the operation will fail with proper error message.

=end html

=back



=over 2

=item * I<max-transfer-rate>  =>   B<integer>

=begin html

<br>null

=end html

=back



=over 2

=item * I<no-lun-clone-expansion>  =>   B<boolean, optional>

=begin html

<br>This option dictates how a lun clone would be transferred from source to destination. If this option is "flase", a LUN clone would be transferred as a LUN and if it is "true", it will be transferred as a clone. By default the value of the option is "false".

=end html

=back



=over 2

=item * I<primary-path>  =>   B<string>

=begin html

<br>The pre-existing primary path to which data is being restored.

=end html

=back



=over 2

=item * I<secondary-path>  =>   B<string>

=begin html

<br>The secondary path to restore from.

=end html

=back



=over 2

=item * I<secondary-snapshot>  =>   B<string, optional>

=begin html

<br>Name of the secondary snapshot to be used for this restore transfer.

=end html

=back



=over 2

=item * I<secondary-system>  =>   B<string>

=begin html

<br>The secondary system to restore from. This input will be used by the primary system to establish contact with the secondary. Therefore it is expected to be a hostname that the primary can resolve.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapvault_primary_initiate_restore_transfer

[B<Family:> ontap-classic, vfiler]


=begin html

Request the primary system to begin a baseline restore transfer from the given secondary path to the given primary path. If the primary path does not already exist, it will be created before starting the restore transfer. If it already exists, its contents will be overwritten by the restore transfer if overwrite-existing-content is set to true else an error is returned. If an existing primary path contains LUNs, then under certain conditions, restore will prevent disruptions to clients using those LUNs. The request will only start the restore transfer and return. The actual transfer will proceed asynchronously and there is no guarantee that it will succeed. The snapvault-primary-get-relationship-status API should be used to check the status of the restore.

=end html



B<Inputs>

=over 2

=item * I<connection-mode>  =>   B<string, optional>

=begin html

<br>This option specifies the mode to be used for establising connection between primary and secondary. If this option is set to "inet6", connections between primary and secondary will be established using IPv6 addresses only. If there are no IPv6 addressess configured, then the connection will fail. If the option is set to "inet", connections between primary and secondary will be established using IPv4 addresses only. If there are no IPv4 addresses configured, then the connection will fail. When this option is not specified, Connection will be tried using both "inet6" and "inet". "inet6" will have higher precedence than "inet". If connection request using "inet6" fails, SnapMirror will retry the connection using "inet". This argument is not effective when an IP address is specified instead of secondary hostname. If the IP address format and connection mode do not match, the operation will fail with proper error message.

=end html

=back



=over 2

=item * I<max-transfer-rate>  =>   B<integer, optional>

=begin html

<br>The maximum transfer rate in kilobytes (1024 bytes) per second to be applied only for this update transfer. If this option is not provided the default behavior will be to allow the transfer to proceed as fast as possible. Range:[1..2^31-2]

=end html

=back



=over 2

=item * I<no-lun-clone-expansion>  =>   B<boolean, optional>

=begin html

<br>This option dictates how a lun clone would be transferred from source to destination. If this option is "false", a LUN clone would be transferred as a LUN and if it is "true", it will be transferred as a clone. By default the value of the option is "false".

=end html

=back



=over 2

=item * I<overwrite-existing-content>  =>   B<boolean, optional>

=begin html

<br>This option specifies to overwrite an existing primary qtree or not. If specified primary qtree path already exists and the option is set to "true" the existing qtree will be overwritten and and previous data will be lost. If specified primary qtree path already exists and the option is set to "false" then an error is returned. The default value of the option is "true".

=end html

=back



=over 2

=item * I<primary-path>  =>   B<string>

=begin html

<br>The primary path to which data is being restored. The primary path will be created during the restore if it doesn't already exist.

=end html

=back



=over 2

=item * I<secondary-path>  =>   B<string>

=begin html

<br>The secondary path to restore from.

=end html

=back



=over 2

=item * I<secondary-snapshot>  =>   B<string, optional>

=begin html

<br>Name of the secondary snapshot to be used for this restore transfer. If this option is not provided, the secondary system will choose the snapshot that contains the most recent back-up for this secondary path.

=end html

=back



=over 2

=item * I<secondary-system>  =>   B<string>

=begin html

<br>The secondary system to restore from. This input will be used by the primary system to establish contact with the secondary. Therefore it is expected to be a hostname that the primary can resolve.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapvault_primary_initiate_snapshot_create

[B<Family:> ontap-classic, vfiler]


=begin html

Request the primary to force a snapshot creation for a specified snapshot schedule. The snapshot schedule must be identified by the volume name and the snapshot prefix. All the properties of the specified schedule will be applied to the snapshot creation. This API should be used when it is desirable to create snapshots right away, without having to wait for the pre-configured scheduled time. This API returns after only initiating the snapshot creation, and there is no guarantee that the snapshot creation will succeed. The snapvault-primary-snapshot-schedule-status-list-info API should be used to track progress of the snapshot creation.

=end html



B<Inputs>

=over 2

=item * I<options>  =>   B<L<"snapvault-snapcreate-options">, optional>

=begin html

<br>Describes options for snap create request.

=end html

=back



=over 2

=item * I<schedule-name>  =>   B<string>

=begin html

<br>The name of the schedule to be used for this snapshot creation.

=end html

=back



=over 2

=item * I<volume-name>  =>   B<string>

=begin html

<br>The primary volume for which the snapshot schedule was configured.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapvault_primary_relationship_status_list_iter_end

[B<Family:> ontap-classic, vfiler]


=begin html

Terminate the status list iteration set up by the snapvault-primary-relationship-status-list-iter-start API. The primary will clean up any saved info for this iteration.

=end html



B<Inputs>

=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from the previous primary-relationship-status-list-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapvault_primary_relationship_status_list_iter_next

[B<Family:> ontap-classic, vfiler]


=begin html

Request the primary to continue the iteration set up with the snapvault-primary-relationship-status-list-iter-start API. A list consisting of a number of status entries, upto the specified maximum, will be returned. When snapvault primary and secondary are licensed on the same filer, output of this API is identical to the output of snapvault-secondary-relationship-status-list-iter-next

=end html



B<Inputs>

=over 2

=item * I<maximum>  =>   B<integer>

=begin html

<br>The maximum number of entries to retrieve. Range:[0..2^32-1]

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous primary-relationship-status-list-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>The number of records being returned by this particular request. When this value is 0, there are no more records to be returned. Range:[0..2^32-1]

=end html

=back



=over 2

=item * I<status-list>  =>   B<L<"snapvault-status-info">[], optional>

=begin html

<br>List of entries, each representing status entry for a relationship.

=end html

=back



=head2 snapvault_primary_relationship_status_list_iter_start

[B<Family:> ontap-classic, vfiler]


=begin html

Request the primary to start an iteration through the list of the status entries for all relationships.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>This tells you the number of items that have been saved for future retrieval with primary-relationship-status-list-iter-next. Range:[0..2^32-1]

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag to be used in subsequent iterations.

=end html

=back



=head2 snapvault_primary_release_relationship

[B<Family:> ontap-classic, vfiler]


=begin html

Request the release of a snapvault relationship formed by a "create-relationship" or "resync-relationship" operation. This operation deletes the registry entry and the softlocks on the source snapshot.

=end html



B<Inputs>

=over 2

=item * I<primary-path>  =>   B<string>

=begin html

<br>The primary path for the relationship.

=end html

=back



=over 2

=item * I<secondary-path>  =>   B<string>

=begin html

<br>The secondary path for the relationship.

=end html

=back



=over 2

=item * I<secondary-system>  =>   B<string>

=begin html

<br>The secondary system for the relationship.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapvault_primary_set_snapshot_schedule

[B<Family:> ontap-classic, vfiler]


=begin html

Request the primary system to configure the specified snapshot schedule. It can also update existing snapshot schedules. If the optional input schedule is skipped, the days-of-week is set to "mon-sun" and hours-of-day set to 0, i.e. midnight.

=end html



B<Inputs>

=over 2

=item * I<snapshot-schedule>  =>   B<L<"snapvault-primary-snapshot-schedule-info">>

=begin html

<br>Specifies details of the schedule to be set.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapvault_primary_snapshot_schedule_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Request the primary to return a list of configured snapshot schedules. Without any input arguments this request returns the list of all snapshot schedules configured on the primary. If a volume is specified then only the list of schedules configured for that volume will be returned. When snapvault primary and secondary are licensed on the same filer, snapvault-secondary-snapshot-schedule-list-info and this API return the same number of schedules.

=end html



B<Inputs>

=over 2

=item * I<volume-name>  =>   B<string, optional>

=begin html

<br>The primary volume for which the list of snapshot schedules are desired.

=end html

=back



B<Outputs>

=over 2

=item * I<snapshot-schedules>  =>   B<L<"snapvault-primary-snapshot-schedule-info">[], optional>

=begin html

<br>List of snapshot schedule entries.

=end html

=back



=head2 snapvault_primary_snapshot_schedule_status_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Request the primary to return status for all configured snapshot schedules. If a specific volume is provided as input, this API will return only the status for schedules within that volume. When snapvault primary and secondary are licensed on the same filer, output of this API is identical to the output of snapvault-secondary-snapshot-schedule-status-list-info

=end html



B<Inputs>

=over 2

=item * I<volume-name>  =>   B<string, optional>

=begin html

<br>Primary volume for which snapshot schedule status is desired.

=end html

=back



B<Outputs>

=over 2

=item * I<snapshot-schedule-status>  =>   B<L<"snapvault-snapshot-schedule-status-info">[]>

=begin html

<br>List of status entries, one for each snapshot schedule.

=end html

=back



=head2 snapvault_remove_softlock

[B<Family:> ontap-classic]


=begin html

request the system to remove softlock for the given snapshot.

=end html



B<Inputs>

=over 2

=item * I<snapshot>  =>   B<string>

=begin html

<br>Name of the snapshot for which softlock to be removed.

=end html

=back



=over 2

=item * I<softlock-name>  =>   B<string, optional>

=begin html

<br>Name of softlock which uniquely identifies the softlock for the snapshot. When not specified, softlock with default name will be removed. When softlock-name has value "-all", all softlocks on the snapshot will be removed. Name of softlock can contain letters, numbers, and underscore character (_), and can be up to 64 characters long.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume where the snapshot exists.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapvault_secondary_abort_snapshot_create

[B<Family:> ontap-classic, vfiler]


=begin html

Request the secondary to abort a snapshot creation that is already in progress. The snapshot schedule for which the snapshot creation is in progress must be specified as input.

=end html



B<Inputs>

=over 2

=item * I<schedule-name>  =>   B<string>

=begin html

<br>The name of the schedule used by the snapshot creation.

=end html

=back



=over 2

=item * I<volume-name>  =>   B<string>

=begin html

<br>The secondary volume in which snapshot create is in progress.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapvault_secondary_abort_transfer

[B<Family:> ontap-classic, vfiler]


=begin html

Request the secondary system to abort the current transfer. The abort can be hard abort, which means the transfer will not be restartable. By default, a soft abort is used, which means the transfer is restartable. An aborted transfer may be restarted by using the same API used to initiate the transfer in the previous attempt. If that request cannot restart the aborted transfer, then it will initiate a fresh new transfer.

=end html



B<Inputs>

=over 2

=item * I<is-hard-abort>  =>   B<boolean, optional>

=begin html

<br>When set to 'true' a hard abort is performed. In that case the restart checkpoints are cleared. Default value is 'false'.

=end html

=back



=over 2

=item * I<system-path>  =>   B<string>

=begin html

<br>The system path which is the target of update.

=end html

=back



=over 2

=item * I<target-system>  =>   B<string, optional>

=begin html

<br>The system filer which is the target of transfer.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapvault_secondary_configuration_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Request to return a list of all configuration entries found on the secondary system.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<configurations>  =>   B<L<"snapvault-configuration-info">[], optional>

=begin html

<br>List of configuration entries.

=end html

=back



=head2 snapvault_secondary_create_relationship

[B<Family:> ontap-classic, vfiler]


=begin html

Request the secondary system to configure a new snapvault relationship with the given primary and secondary systems and paths. This API is equivalent to the 'snapvault start' Data ONTAP command. All the inputs provided with this request will be stored in the configuration entry maintained by the secondary system. These values will be used as default settings for further incremental update transfers for this relationship. The snapvault-secondary-modify-configuration API can be used to change these configured settings. A successful configuration will automatically be followed by a baseline transfer from the primary to the secondary. The secondary path will be created during the baseline transfer hence it is required that the secondary path must not exist when issuing this request. This request will only begin the baseline transfer and return. The transfer will proceed asynchronously and there is no guarantee that it will succeed. The snapvault-get-relationship-status API should be used to check the status of the transfer.

=end html



B<Inputs>

=over 2

=item * I<configuration>  =>   B<L<"snapvault-configuration-info">>

=begin html

<br>Relationship configuration

=end html

=back



=over 2

=item * I<no-lun-clone-expansion>  =>   B<boolean, optional>

=begin html

<br>This option dictates how a lun clone would be transferred from source to destination. If this option is "false", a LUN clone would be transferred as a LUN and if it is "true", it will be transferred as a clone. By default the value of the option is "false".

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapvault_secondary_delete_relationship

[B<Family:> ontap-classic, vfiler]


=begin html

Request the secondary system to unconfigure and delete the relationship permanently. The secondary path will be deleted. But none of the snapshots that capture this secondary path will be deleted. This API corresponds to the 'snapvault stop' Data ONTAP command.

=end html



B<Inputs>

=over 2

=item * I<secondary-path>  =>   B<string>

=begin html

<br>The secondary-path to be deleted. The path will be unconfigured and deleted.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapvault_secondary_delete_snapshot_schedule

[B<Family:> ontap-classic, vfiler]


=begin html

Request the secondary system to delete the specified snapshot schedules. The snapshot schedules that match the volume name and the snapshot prefix when specified, will be deleted.

=end html



B<Inputs>

=over 2

=item * I<delete-schedule-softlock>  =>   B<boolean, optional>

=begin html

<br>When set to 'true', snapvault will delete ACS softlock set by this schedule. The default value for this option is 'false'.

=end html

=back



=over 2

=item * I<schedule-name>  =>   B<string, optional>

=begin html

<br>The name of the schedule to be deleted.

=end html

=back



=over 2

=item * I<volume-name>  =>   B<string>

=begin html

<br>The secondary volume for which the schedule is to be deleted.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapvault_secondary_destinations_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Request the secondary to list all snapvault destinations that have been replicated from any source path on this secondary system. If a source path is provided, then the secondary will return destinations information only for that source path. When snapvault primary and secondary are licensed on the same filer, output of this API is identical to the output of snapvault-primary-destinations-list-info

=end html



B<Inputs>

=over 2

=item * I<source-path>  =>   B<string, optional>

=begin html

<br>Source path on this secondary for which the destination information is desired.

=end html

=back



B<Outputs>

=over 2

=item * I<destinations>  =>   B<L<"snapvault-destination-info">[]>

=begin html

<br>List of all snapvault destinations known to this secondary.

=end html

=back



=head2 snapvault_secondary_get_configuration

[B<Family:> ontap-classic, vfiler]


=begin html

Request the secondary to return the configuration entry for a relationship. The relationship must be specified by providing the secondary path as input.

=end html



B<Inputs>

=over 2

=item * I<secondary-path>  =>   B<string>

=begin html

<br>The secondary path for the relationship whose configuration entry is desired.

=end html

=back



B<Outputs>

=over 2

=item * I<configuration>  =>   B<L<"snapvault-configuration-info">, optional>

=begin html

<br>A single configuration entry.

=end html

=back



=head2 snapvault_secondary_get_relationship_status

[B<Family:> ontap-classic, vfiler]


=begin html

Request the secondary to return the status entries for desired relationships. The relationships whose status is desired must be specified using the system path. When snapvault primary and secondary are licensed on the same filer, output of this API is identical to the output of snapvault-primary-get-relationship-status

=end html



B<Inputs>

=over 2

=item * I<system-path>  =>   B<string>

=begin html

<br>System path for the relationships whose status is desired.

=end html

=back



B<Outputs>

=over 2

=item * I<status>  =>   B<L<"snapvault-status-info">[]>

=begin html

<br>Status entries for desired relationships.

=end html

=back



=head2 snapvault_secondary_initiate_incremental_transfer

[B<Family:> ontap-classic, vfiler]


=begin html

Request the snapvault secondary system to begin an incremental transfer to the given secondary path. This API is equivalent to the 'snapvault update' Data ONTAP command. It is required that this secondary path has already been configured as part of a snapvault relationship. The primary system and path configured in that relationship will be used as the source for this transfer. The request will only start the transfer and return. The actual transfer will proceed asynchronously and there is no guarantee that it will succeed. The snapvault-secondary-get-relationship-status API should be used to check the status of the update.

=end html



B<Inputs>

=over 2

=item * I<max-transfer-rate>  =>   B<integer, optional>

=begin html

<br>The maximum transfer rate in kilobytes (1024 bytes) per second to be applied only for this update transfer. If this option is not provided the default behavior will be to allow the transfer to proceed as fast as possible. Range:[1.. 2^31-2]

=end html

=back



=over 2

=item * I<no-lun-clone-expansion>  =>   B<boolean, optional>

=begin html

<br>This option dictates how a lun clone would be transferred from source to destination. If this option is "false", a LUN clone would be transferred as a LUN and if it is "true", it will be transferred as a clone. By default the value of the option is "false".

=end html

=back



=over 2

=item * I<primary-snapshot>  =>   B<string, optional>

=begin html

<br>Name of the primary snapshot to be used for this update transfer. This option is supported for only primary systems. If this option is not provided, the primary system will create a new source snapshot for this transfer.

=end html

=back



=over 2

=item * I<secondary-path>  =>   B<string>

=begin html

<br>The secondary path that will be used as the destination for this update transfer. It is required that this secondary path is already a part of some configured snapvault relationship.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapvault_secondary_initiate_snapshot_create

[B<Family:> ontap-classic, vfiler]


=begin html

Request the secondary to force a snapshot creation for a specified snapshot schedule. The snapshot schedule must be identified by the volume name and the schedule name. All the properties of the specified schedule will be applied to the snapshot creation. This API should be used when it is desirable to create snapshots right away, without having to wait for the pre-configured scheduled time. This API returns after only initiating the snapshot creation, and there is no guarantee that the snapshot creation will succeed. The snapvault-secondary-snapshot-schedule-status-list-info API should be used to track progress of the snapshot creation.

=end html



B<Inputs>

=over 2

=item * I<lock-backing-snapshot>  =>   B<boolean, optional>

=begin html

<br>When set to 'true' any snapshots backing the LUN clones present in the snapshot being created will be locked down. As a result, the locked backing snapshots can't be deleted as long as the snapshot that is locking them exists. The default value for this option is 'false', which doesn't lock any backing snapshots.

=end html

=back



=over 2

=item * I<options>  =>   B<L<"snapvault-snapcreate-options">, optional>

=begin html

<br>Describes options for snap create request.

=end html

=back



=over 2

=item * I<schedule-name>  =>   B<string>

=begin html

<br>The name of the schedule to be used for creating the snapshot. The schedule-name will be used as a prefix in the name of each snapshot created by this schedule. If an empty string is provided, the snapshot creation process will be started, but a snapshot will not be created. This is useful to bring all the relationships of a secondary volume to a consistent state.

=end html

=back



=over 2

=item * I<volume-name>  =>   B<string>

=begin html

<br>The secondary volume in which the snapshot is to be created.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapvault_secondary_modify_configuration

[B<Family:> ontap-classic, vfiler]


=begin html

Request change in one or more configuration parameters of an existing snapvault relationship identified by the secondary path provided. Only the parameters that are specified as input will be changed for this configuration.

=end html



B<Inputs>

=over 2

=item * I<configuration>  =>   B<L<"snapvault-configuration-info">>

=begin html

<br>Relationship configuration

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapvault_secondary_relationship_status_list_iter_end

[B<Family:> ontap-classic, vfiler]


=begin html

Terminate the status list iteration set up by the snapvault-secondary-relationship-status-list-iter-start API. The secondary will clean up any saved info for this iteration.

=end html



B<Inputs>

=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from the previous secondary-relationship-status-list-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapvault_secondary_relationship_status_list_iter_next

[B<Family:> ontap-classic, vfiler]


=begin html

Request the secondary to continue the iteration set up with the snapvault-secondary-relationship-status-list-iter-start API. A list consisting of a number of status entries, upto the specified maximum, will be returned. When snapvault primary and secondary are licensed on the same filer, output of this API is identical to the output of snapvault-primary-relationship-status-list-iter-next

=end html



B<Inputs>

=over 2

=item * I<maximum>  =>   B<integer>

=begin html

<br>The maximum number of entries to retrieve. Range:[0..2^32-1]

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous secondary-relationship-status-list-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>The number of records being returned by this particular request. When this value is 0, there are no more records to be returned. Range:[0..2^32-1]

=end html

=back



=over 2

=item * I<status-list>  =>   B<L<"snapvault-status-info">[], optional>

=begin html

<br>List of entries, each representing status entry for a relationship.

=end html

=back



=head2 snapvault_secondary_relationship_status_list_iter_start

[B<Family:> ontap-classic, vfiler]


=begin html

Request the secondary to start an iteration through the list of the status entries for all relationships. This list will also include entries for snapvault restores from this secondary.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>This tells you the number of items that have been saved for future retrieval with secondary-relationship-status-list-iter-next. Range:[0..2^32-1]

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag to be used in subsequent iterations.

=end html

=back



=head2 snapvault_secondary_release_relationship

[B<Family:> ontap-classic, vfiler]


=begin html

Request the release of a snapvault relationship formed after a restore operation on the primary system. This operation deletes the registry entry and removes the softlock on the source base snapshot.

=end html



B<Inputs>

=over 2

=item * I<primary-path>  =>   B<string>

=begin html

<br>The primary path that had been used for the restore.

=end html

=back



=over 2

=item * I<primary-system>  =>   B<string>

=begin html

<br>The primary system which had performed the restore.

=end html

=back



=over 2

=item * I<secondary-path>  =>   B<string>

=begin html

<br>The secondary path that was used as source for restore.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapvault_secondary_resync_relationship

[B<Family:> ontap-classic, vfiler]


=begin html

Request to resynchronize the relationship for an existing secondary path. This API is equivalent to the 'snapvault start -r' Data ONTAP command. In addition the configuration entry for this relationship will be updated with any parameters that are provided as input. Finally an update transfer to this secondary path will be started. The resynchronization is commonly used when the primary dataset has been migrated to a different location for e.g. via snapvault restore. This functionality is also required if the secondary path was made writable for e.g. via wafl iron. This request will only start the resync process and return. The process will proceed asynchronously and there is no guarantee that it will succeed. The snapvault-secondary-get-relationship-status API should be used to check the status of this restore.

=end html



B<Inputs>

=over 2

=item * I<configuration>  =>   B<L<"snapvault-configuration-info">>

=begin html

<br>Relationship configuration

=end html

=back



=over 2

=item * I<no-lun-clone-expansion>  =>   B<boolean, optional>

=begin html

<br>This option dictates how a lun clone would be transferred from source to destination. If this option is "false", a LUN clone would be transferred as a LUN and if it is "true", it will be transferred as a clone. By default the value of the option is "false".

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapvault_secondary_set_snapshot_schedule

[B<Family:> ontap-classic, vfiler]


=begin html

Request the secondary system to configure the specified snapshot schedule. If this request is made for an existing snapshot schedule, then that snapshot schedule is updated with any new values specified. If the optional input schedule is skipped, the days-of-week is set to "mon-sun" and hours-of-day set to 0, i.e. midnight.

=end html



B<Inputs>

=over 2

=item * I<snapshot-schedule>  =>   B<L<"snapvault-secondary-snapshot-schedule-info">>

=begin html

<br>Specifies details of the schedule to be set.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snapvault_secondary_snapshot_schedule_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Request the secondary to return a list of configured snapshot schedules. Without any input arguments this request returns the list of all snapshot schedules configured on the secondary. If a volume is specified then only the list of schedules configured for that volume will be returned. When snapvault primary and secondary are licensed on the same filer, snapvault-primary-snapshot-schedule-list-info and this API return the same number of schedules.

=end html



B<Inputs>

=over 2

=item * I<volume-name>  =>   B<string, optional>

=begin html

<br>The secondary volume for which the list of snapshot schedules are desired.

=end html

=back



B<Outputs>

=over 2

=item * I<snapshot-schedules>  =>   B<L<"snapvault-secondary-snapshot-schedule-info">[], optional>

=begin html

<br>List of snapshot schedule entries.

=end html

=back



=head2 snapvault_secondary_snapshot_schedule_status_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Request the secondary to return status for all configured snapshot schedules. If a specific volume is provided as input, this API will return only the status for schedules within that volume. This API corresponds to the 'snapvault status -s' Data ONTAP command. When snapvault primary and secondary are licensed on the same filer, output of this API is identical to the output of snapvault-primary-snapshot-schedule-status-list-info

=end html



B<Inputs>

=over 2

=item * I<volume-name>  =>   B<string, optional>

=begin html

<br>Secondary volume for which snapshot schedule status is desired.

=end html

=back



B<Outputs>

=over 2

=item * I<snapshot-schedule-status>  =>   B<L<"snapvault-snapshot-schedule-status-info">[]>

=begin html

<br>List of status entries, one for each snapshot schedule.

=end html

=back



=head2 snmp_community_add

[B<Family:> ontap-classic]


=begin html

Adds a community to the list of communities.

=end html



B<Inputs>

=over 2

=item * I<access-control>  =>   B<string>

=begin html

<br>Access control for the community. Possible values are "ro" (read-only) and "rw" (read-write). But, only "ro" (read-only) communities are supported.

=end html

=back



=over 2

=item * I<community>  =>   B<string>

=begin html

<br>Community name to be added.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snmp_community_delete

[B<Family:> ontap-classic]


=begin html

Deletes a community from the list of communities.

=end html



B<Inputs>

=over 2

=item * I<access-control>  =>   B<string>

=begin html

<br>Access control for the community. Possible values are "ro" (read-only) and "rw" (read-write). But, only "ro" (read-only) communities are supported.

=end html

=back



=over 2

=item * I<community>  =>   B<string>

=begin html

<br>Community name to be deleted.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snmp_community_delete_all

[B<Family:> ontap-classic]


=begin html

Deletes all the communities.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snmp_disable

[B<Family:> ontap-classic]


=begin html

Disables snmp protocol.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snmp_enable

[B<Family:> ontap-classic]


=begin html

Enables snmp protocol.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snmp_get

[B<Family:> ontap-classic]


=begin html

Retrieves the value of a snmp object.

=end html



B<Inputs>

=over 2

=item * I<object-id>  =>   B<string>

=begin html

<br>Fully qualified object identifier of a snmp object. Only numeric OID's (ex: .1.3.6.1.4.1.789.1.1.1.0) are allowed.

=end html

=back



B<Outputs>

=over 2

=item * I<is-value-hexadecimal>  =>   B<boolean, optional>

=begin html

<br>If true, the string returned in 'value' is the hexadecimal representation of the octet string returned by a snmp call to the object-id. This output is not present if 'value' is a normal string.

=end html

=back



=over 2

=item * I<value>  =>   B<string>

=begin html

<br>Value of the snmp object specified through the input argument "object-id".

=end html

=back



=head2 snmp_get_next

[B<Family:> ontap-classic]


=begin html

This is used to retrieve the next OID in the mib tree of data. Instead of returning the data you requested, it returns the next OID in the tree and its value. Unlike the snmp-get api, this api does return data for a OID which is too short or is missing the index part of the OID.

=end html



B<Inputs>

=over 2

=item * I<object-id>  =>   B<string>

=begin html

<br>Object Identifier of a snmp object. The OID can be a fully qualified OID or a partial OID. Only numeric OID's (ex: .1.3.6.1.4.1.789.1.1.1.0) are allowed.

=end html

=back



B<Outputs>

=over 2

=item * I<is-value-hexadecimal>  =>   B<boolean, optional>

=begin html

<br>If true, the string returned in 'value' is the hexadecimal representation of the octet string returned by a snmp call to the object-id. This output is not present if 'value' is a normal string.

=end html

=back



=over 2

=item * I<next-object-id>  =>   B<string>

=begin html

<br>Object Identifier of the next snmp object in the mib.

=end html

=back



=over 2

=item * I<value>  =>   B<string>

=begin html

<br>Value of the snmp object reported through the output argument "next-object-id".

=end html

=back



=head2 snmp_status

[B<Family:> ontap-classic]


=begin html

Returns configuration information of the SNMP agent daemon.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<communities>  =>   B<L<"community-info">[], optional>

=begin html

<br>Returns a list of communities and their access control settings.

=end html

=back



=over 2

=item * I<contact>  =>   B<string>

=begin html

<br>Contact name.

=end html

=back



=over 2

=item * I<is-trap-enabled>  =>   B<boolean>

=begin html

<br>Retuns "true" if traps are enabled. "false" otherwise.

=end html

=back



=over 2

=item * I<location>  =>   B<string>

=begin html

<br>Location name.

=end html

=back



=over 2

=item * I<traphosts>  =>   B<L<"traphost-info">[], optional>

=begin html

<br>Returns a list of registered trap hosts followed by their IP addresses. Only resolvable trap hosts are returned. If a host name cannot be found in /etc/hosts for a previously registered IP address, its name defaults to a string representation of its IP address.

=end html

=back



=head2 snmp_trap_delete



=begin html

Delete a user defined trap.

=end html



B<Inputs>

=over 2

=item * I<trap-name>  =>   B<string>

=begin html

<br>Name of the trap to be deleted.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snmp_trap_disable

[B<Family:> ontap-classic]


=begin html

Disables snmp traps.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snmp_trap_enable

[B<Family:> ontap-classic]


=begin html

Enables snmp traps.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snmp_trap_list



=begin html

List all user defined traps and their attributes.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<trap-list>  =>   B<L<"trap-info">[]>

=begin html

<br>The list of user defined snmp traps and their attributes.

=end html

=back



=head2 snmp_trap_load



=begin html

Loads traps from a specified file.

=end html



B<Inputs>

=over 2

=item * I<filename>  =>   B<string>

=begin html

<br>Name, including full PATH, of the file specifying the user defined traps. Example: /etc/MyTraps.txt would open the MyTraps.txt file located on the filer's /etc directory.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snmp_trap_reset



=begin html

Reloads one or all user defined traps from registry.

=end html



B<Inputs>

=over 2

=item * I<trap-name>  =>   B<string, optional>

=begin html

<br>Name of the trap to be reset. If absent, all traps are reset.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snmp_trap_set



=begin html

Set the named user defined trap and the enumerated attribute(s). The trap-name must be specified for this api.

=end html



B<Inputs>

=over 2

=item * I<trap-def>  =>   B<L<"trap-info">>

=begin html

<br>Characterizes a user defined trap and its attributes.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snmp_traphost_add

[B<Family:> ontap-classic]


=begin html

Adds a host to the list of trap hosts.

=end html



B<Inputs>

=over 2

=item * I<host>  =>   B<string>

=begin html

<br>Specify the host to be added. Host may be specified in Domain Name format such as MyHost.MyNetwork.com, or as an IP address such as 10.20.30.40. If a Domain Name is used, the host must resolve to an IP address.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 snmp_traphost_delete

[B<Family:> ontap-classic]


=begin html

Deletes a host from the list of trap hosts.

=end html



B<Inputs>

=over 2

=item * I<host>  =>   B<string>

=begin html

<br>Specify the host to be added. Host may be specified in Domain Name format such as MyHost.MyNetwork.com, or as an IP address such as 10.20.30.40. If a Domain Name is used, the host must resolve to an IP address.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 software_extract_metadata



=begin html

Retrieve metadata from the kernel image in the Compact Flash (CF), or from a specific package.<br> <br> Older packages do not have metadata. If metadata is not found, an error code of ENPMNOMETA is returned.<br> <br> There are two types of software packages: ONTAP and Service. Metadata content depends on package type. <dl compact> Common section meta items are present in all packages. <dt>Package type</dt> <dd>Meta name : <samp>PKG_TYPE</samp></dd> <dd>Possible values : <samp>DataOntap, Service</samp></dd> <dt>Date and Timestamp</dt> <dd>Meta name : <samp>PKG_DTS</samp></dd> <dd>Possible value : <samp><var>Day</var> <var>Mmm</var> <var>dd</var> <var>hh</var>:<var>mm</var>:</var>ss</var> <var>yyyy</var> GMT</samp></dd> <dt>CPU architecture</dt> <dd>Meta name : <samp>CPU_ARCH</samp></dd> <dd>Possible values : <samp>pc, mips</samp></dd> </dl> <dl compact> ONTAP section meta items are only in ONTAP packages. <dt>Data ONTAP release</dt> <dd>Meta name : <samp>ONTAP_RLS</samp></dd> <dd>Possible value : <samp>Release <var>version</var>: <var>date & time stamp</var></samp></dd> <dt>File system version</dt> <dd>Meta name : <samp>FILESYS_VER</samp></dd> <dd>Possible value : <samp><var>integer</var></samp></dd> <dt>NVLOG version</dt> <dd>Meta name : <samp>NVLOG_VER</samp></dd> <dd>Possible value : <samp><var>integer</var></samp></dd> </dl> <dl compact> Diagnostics section meta items are only in Service packages. <dt>Diagnostics version</dt> <dd>Meta name : <samp>DIAG_VER</samp></dd> <dd>Possible value : <samp>Diagnostic Monitor v-<var>version</var></samp></dd> <dt>Diagnostics release</dt> <dd>Meta name : <samp>DIAG_RLS</samp></dd> <dd>Possible value : <samp>Release Diagnostic_<var>version</var>: <var>date stamp</var></samp></dd> </dl> <dl compact> Firmware items are only in Service packages and are of two types, Common Firmware Environment (CFE) and Open Firmware (OFW). <dt>CFE version</dt> <dd>Meta name : <samp>CFE_VER</samp> <dd>Possible value : <samp>CFE-<var>p</var>.<var>q</var>.<var>r</var></samp> <dt>OFW version</dt> <dd>Meta name : <samp>OFW_VER</samp> <dd>Possible value : <samp><var>m</var>.<var>n</var></samp> </dl>

=end html



B<Inputs>

=over 2

=item * I<package-location>  =>   B<string>

=begin html

<br>Location of the package to be scanned for metadata <dl compact> Possible values: <dt><samp>repository</samp></dt> <dd>package directory on Filer disk</dd> <dt><samp>cf-pri-part</samp></dt> <dd>Compact Flash primary partition</dd> </dl>

=end html

=back



=over 2

=item * I<package-name>  =>   B<string, optional>

=begin html

<br>Name of the software package; used only if package-location is <samp>repository</samp>

=end html

=back



B<Outputs>

=over 2

=item * I<npm-metadata>  =>   B<L<"npm-meta-elem-info">[]>

=begin html

<br>List of meta elements containing requested metadata

=end html

=back



=head2 storage_adapter_enable_adapter

[B<Family:> ontap-classic]


=begin html

Enables specified host adapter. I/O traffic can be issued on the adapter.

=end html



B<Inputs>

=over 2

=item * I<adapter-name>  =>   B<string>

=begin html

<br>The adapter name is either a slot number, or, if a port letter is also present, a slot number and port letter concatenated into a single name -- for example, "8a" or "11b". If adapter-name is not supplied, the command will return EAPIMISSINGARGUMENT.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 storage_adapter_get_adapter_info

[B<Family:> ontap-classic]


=begin html

Display the information about a specified host adapter. The information is displayed base on the controller interface type. ATA, Paralell SCSI, SAS, FC.

=end html



B<Inputs>

=over 2

=item * I<adapter-name>  =>   B<string>

=begin html

<br>The adapter name is either a slot number, or, if a port letter is also presented, a slot number and port letter concatenated into a single name -- for example, "8a" or "11b".

=end html

=back



B<Outputs>

=over 2

=item * I<adapter-details>  =>   B<L<"adapter-detail-info">>

=begin html

<br>List of detail info for given adapter.

=end html

=back



=head2 storage_adapter_get_adapter_list

[B<Family:> ontap-classic]


=begin html

Get the list of adapters present on this system.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<adapter-list>  =>   B<L<"adapter-name-elem">[]>

=begin html

<br>The adapter-list is a list of the names of adapters on this system. These adapter names can be used by other commands, including storage-adapter-enable-adapter and storage-adapter-disable-adapter.

=end html

=back



=head2 storage_adapter_modify

[B<Family:> ontap-classic]


=begin html

Modify the adapter state.

=end html



B<Inputs>

=over 2

=item * I<adapter-state>  =>   B<string>

=begin html

<br>The new requested state for the adapter, Possible values: <ul> <li> "online" - enable the specified port. <li> "offline" - disable the specified port. </ul>

=end html

=back



=over 2

=item * I<force-offline>  =>   B<boolean, optional>

=begin html

<br>When true, this allows disabling a port when the port is busy, i.e. has pending or active commands. Default is false. This field is allowed, only when the adapter-state is "offline".

=end html

=back



=over 2

=item * I<port-name>  =>   B<string>

=begin html

<br>The port name is a slot number and port letter concatenated into a single name -- for example, "8a" or "11b".

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 storage_array_get_config_summary

[B<Family:> ontap-classic]


=begin html

Generates a high level summary of array LUN pathing (connectivity) information.

=end html



B<Inputs>

=over 2

=item * I<ownership-type>  =>   B<string, optional>

=begin html

<br>Option that allows the user to select which array LUNs are displayed. Valid values for ownership-type are 'assigned', 'unassigned' and 'all'. If ownership-type is set to 'assigned' only assigned array LUNs are displayed. If ownership-type is set to 'unassigned' only unassigned array LUNs are displayed. If ownership-type is set to 'all', all array LUNs are displayed. Default: 'all'.

=end html

=back



B<Outputs>

=over 2

=item * I<config-summary>  =>   B<L<"storage-array-config-summary">[], optional>

=begin html

<br>A summary of array LUN connectivity for each attached array.

=end html

=back



=head2 storage_array_list_info

[B<Family:> ontap-classic]


=begin html

Retrieves a list of all array profiles known to the controller.

=end html



B<Inputs>

=over 2

=item * I<array-name>  =>   B<string, optional>

=begin html

<br>When specified, only the named array profile record will be returned. (28 chars)

=end html

=back



B<Outputs>

=over 2

=item * I<array-profiles>  =>   B<L<"storage-array-profile">[]>

=begin html

<br>A list of arrays (and their details)

=end html

=back



=head2 storage_array_luns_list_info

[B<Family:> ontap-classic]


=begin html

Generate a list of array LUNs associated with the named array.

=end html



B<Inputs>

=over 2

=item * I<array-name>  =>   B<string>

=begin html

<br>The name of the array profile to list array LUN information for. (28 chars)

=end html

=back



=over 2

=item * I<ownership-type>  =>   B<string, optional>

=begin html

<br>Option that allows the user to select which array LUNs are displayed. Valid values for ownership-type are 'assigned', 'unassigned' and 'all'. If ownership-type is set to 'assigned' only assigned array LUNs are displayed. If ownership-type is set to 'unassigned' only unassigned array LUNs are displayed. If ownership-type is set to 'all', all array LUNs are displayed. Default: 'all'.

=end html

=back



B<Outputs>

=over 2

=item * I<array-luns>  =>   B<L<"disk-detail-info">[]>

=begin html

<br>A list of all array LUNs exported by the named array.

=end html

=back



=head2 storage_array_ports_list_info

[B<Family:> ontap-classic]


=begin html

generate a list of online array ports and their associated arrays

=end html



B<Inputs>

=over 2

=item * I<array-name>  =>   B<string, optional>

=begin html

<br>When supplied, only port records for the named array are returned. (28 chars)

=end html

=back



B<Outputs>

=over 2

=item * I<array-ports>  =>   B<L<"storage-array-port">[], optional>

=begin html

<br>A list of all array ports, or just the ports for the named array

=end html

=back



=head2 storage_array_update

[B<Family:> ontap-classic]


=begin html

Update an array profile with new or changed information. Arguments passed in will be used to update the profile. Arguments not passed will keep their existing values.

=end html



B<Inputs>

=over 2

=item * I<array-name>  =>   B<string>

=begin html

<br>28 character string, no spaces The name of the array profile to update.

=end html

=back



=over 2

=item * I<firmware>  =>   B<string, optional>

=begin html

<br>The firmware revision of the array being entered. (64 chars)

=end html

=back



=over 2

=item * I<model>  =>   B<string, optional>

=begin html

<br>The model number of the array. (16 chars)

=end html

=back



=over 2

=item * I<network-address>  =>   B<string, optional>

=begin html

<br>The I/O address of the array's SNMP management service in dotted-decimal format (for example, "192.168.11.12").

=end html

=back



=over 2

=item * I<new-array-name>  =>   B<string, optional>

=begin html

<br>28 character string, no spaces The new name to assign to this array profile.

=end html

=back



=over 2

=item * I<options>  =>   B<string, optional>

=begin html

<br>Array profile specific options. (comma separated list of name/value pairs) (128 chars)

=end html

=back



=over 2

=item * I<prefix>  =>   B<string, optional>

=begin html

<br>A unique 5 character user defined code used to refer to this array.

=end html

=back



=over 2

=item * I<vendor>  =>   B<string, optional>

=begin html

<br>The name of the array's manufacturer. (8 chars)

=end html

=back



B<Outputs>

=over 2

=item * I<array-profile>  =>   B<L<"storage-array-profile">>

=begin html

<br>The updated array record.

=end html

=back



=head2 storage_disk_fw_status

[B<Family:> ontap-classic]


=begin html

Based on input, displays: The number of disks waiting for firmware update, Average firmware update duration per disk in seconds, Estimate for background firmware download completion in minutes, or Name of disk that cannot be updated.

=end html



B<Inputs>

=over 2

=item * I<status-type>  =>   B<string>

=begin html

<br>Possible values: 1. time-estimate 2. waiting-disks 3. average-time 4. pending-disks

=end html

=back



B<Outputs>

=over 2

=item * I<fw-update-status>  =>   B<L<"fw-update-status-info">[]>

=begin html

<br>Firmware Update status.

=end html

=back



=head2 storage_disk_get_iter

[B<Family:> ontap-classic, vfiler]


=begin html

Disk enumeration ZAPI. Get disk information about one or more disks, from the Storage Subsystem. Currently only the Data ONTAP Cluster-Mode iterator APIs support filtering of output, to constrain the disks that are included in the return list, and/or what information is returned about each disk. The default is to return all information about all disks in the cluster. That list may be reduced using the 'query' input element. For example, the return list may include only (1) Disks visible to a particular cluster node "nodeA", e.g., "query.disk-paths.disk-name=nodeA:*" (2) A particular disk visible to a particular node, e.g., "query.disk-paths.node=nodeA:6a.01". (3) A disk with a particular unique id, e.g., "query.disk-uid=20000000:87A9652B:00000000:00000000:00000000:00000000:00000000:00000000:00000000:00000000" (4) Disks with a name that matches a certain wildcard pattern, e.g., "query.disk-paths.disk-name=*:6a*". (5) Disks assigned to a particular node. e.g., "query.disk-ownership-info.home-node-id=1252487" or "query.disk-ownership-info.home-node-name=nodeA". (6) Some subset of disks in the cluster or visible to a particular node in the cluster. If 'desired-attributes' is included, then only those data specified by in 'desired-attributes' are returned for each disk. For the Data ONTAP 7-Mode API, since filtering based upon 'query' and 'desired-attributes' is not yet supported, the behavior is currently to return all available information about all disks visible to the local node. If there is badly formed input or an invalid input value is specified, then EINVALIDINPUTERROR is returned. If there is some internal error which prevents processing of this request, then EINTERNALERROR is returned.

=end html



B<Inputs>

=over 2

=item * I<max-records>  =>   B<integer, optional>

=begin html

<br>The maximum number of records to return to the caller per iteration. The default is 2000 for the Data ONTAP Cluster- Mode and 200 for other Data ONTAP 7-mode and D-blade calls. If the total number of records exceeds either the 'max-records' supplied, or the number the system is capable of returning at one time, then storage-disk-get-iter must be called multiple times to get all the records. The 'num-records' output field informs the caller how many records are returned by a single iterative call to storage-disk-get-iter.

=end html

=back



=over 2

=item * I<tag>  =>   B<string, optional>

=begin html

<br>This indicates where to continue iteration. A first invocation would normally omit this, to indicate to start iteration with the first disk. If multiple invocations are required to fetch all disk records, then each successive call would set 'tag' to the 'next-tag' value from the prior invocation. If an invalid value is specified, then EINVAIDINPUTERROR is returned.

=end html

=back



B<Outputs>

=over 2

=item * I<attributes-list>  =>   B<L<"storage-disk-info">[], optional>

=begin html

<br>List of disk records.

=end html

=back



=over 2

=item * I<next-tag>  =>   B<string, optional>

=begin html

<br>An opaque string indicating that there are more records to fetch. If this field is returned, then the API must be called again with the 'tag' parameter set to this 'next-tag' value, to continue fetching additional records from this point. Omitted if there are no more records to fetch.

=end html

=back



=over 2

=item * I<num-records>  =>   B<integer>

=begin html

<br>The number of records returned in this call. This is guaranteed to be less than or equal to the minimum of 'max-records' and 2000.

=end html

=back



=head2 storage_initiator_balance

[B<Family:> ontap-classic]


=begin html

Balances primary/secondary array LUN paths across available initiator ports based on I/O load.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 storage_initiator_disk_path_list_info

[B<Family:> ontap-classic]


=begin html

Returns path information and statistics for a given disk or all disks. We use the word disk to refer to an array lun, real disk, or Solid State Device

=end html



B<Inputs>

=over 2

=item * I<disk-name>  =>   B<string, optional>

=begin html

<br>The name of the disk to list path information for. If not supplied all paths to all attached targets are returned.

=end html

=back



B<Outputs>

=over 2

=item * I<disk-path-info>  =>   B<L<"disk-path-info">[]>

=begin html

<br>A table of per path statistics, errors and other related data for this disk

=end html

=back



=head2 storage_initiator_errors_list_info

[B<Family:> ontap-classic]


=begin html

Lists all known disk/configuration errors associated with an array or shelves acting like array.

=end html



B<Inputs>

=over 2

=item * I<array-name>  =>   B<string, optional>

=begin html

<br>The name of the array to list error information for. (28 chars)

=end html

=back



=over 2

=item * I<disk-name>  =>   B<string, optional>

=begin html

<br>The name of the disk or array lun to list error information for. If not specified, all errors for all disks/array LUNs will be returned.

=end html

=back



B<Outputs>

=over 2

=item * I<errors>  =>   B<L<"storage-error-info">[], optional>

=begin html

<br>A list of all errors for the requested array/shelf or disks/luns.

=end html

=back



=head2 storage_initiator_get_load

[B<Family:> ontap-classic]


=begin html

Gets disk I/O rates for a given fibre channel initiator port or for all initiator ports if no port is specified. The term disk refers to an array LUN, actual disk, or solid state device.

=end html



B<Inputs>

=over 2

=item * I<port>  =>   B<string, optional>

=begin html

<br>Port to show load on, e.g. 0a.

=end html

=back



B<Outputs>

=over 2

=item * I<load-info>  =>   B<L<"storage-initiator-load-info">[]>

=begin html

<br>A table of per disk load related information for the named port.

=end html

=back



=head2 storage_initiator_path_list_info

[B<Family:> ontap-classic]


=begin html

Returns information and statistics on all known paths to back end storage.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<path-info>  =>   B<L<"storage-initiator-path-info">[], optional>

=begin html

<br>A table of back end path statistics, errors and other related data.

=end html

=back



=head2 storage_initiator_path_quiesce

[B<Family:> ontap-classic]


=begin html

Quiesces an array LUN on a path. A quiesced array LUN will not be sent I/O on the specified path.

=end html



B<Inputs>

=over 2

=item * I<initiator>  =>   B<string>

=begin html

<br>The initiator port of the path that I/O will be quiesced on.

=end html

=back



=over 2

=item * I<lun-number>  =>   B<integer>

=begin html

<br>LU number. Range: [0..65535]

=end html

=back



=over 2

=item * I<target-wwpn>  =>   B<string>

=begin html

<br>The array target port of the path that I/O will be quiesced on. World wide port number has to be specified without colons.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 storage_initiator_path_resume

[B<Family:> ontap-classic]


=begin html

Resumes I/O to array LUN on a path that was previously quiesced. Resuming I/O to a non-quiesced array LUN is a no-op and not an error.

=end html



B<Inputs>

=over 2

=item * I<initiator>  =>   B<string>

=begin html

<br>The initiator port of the path that I/O will be resumed to.

=end html

=back



=over 2

=item * I<lun-number>  =>   B<integer>

=begin html

<br>LU number. Range: [0..65535]

=end html

=back



=over 2

=item * I<target-wwpn>  =>   B<string>

=begin html

<br>The array target port of the path that I/O will be resumed to. World wide port number has to be specified without colons.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 system_api_get_elements

[B<Family:> ontap-classic, vfiler]


=begin html

get elements for specified apis

=end html



B<Inputs>

=over 2

=item * I<api-list>  =>   B<api-list-info[]>

=begin html

<br>list of apis to retrieve

=end html

=back



B<Outputs>

=over 2

=item * I<api-entries>  =>   B<L<"system-api-entry-info">[]>

=begin html

<br>null

=end html

=back



=head2 system_api_list

[B<Family:> ontap-classic, vfiler]


=begin html

get list of apis. This returns the names only - to get the parameter info, use system-api-get-elements

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<apis>  =>   B<L<"system-api-info">[]>

=begin html

<br>null

=end html

=back



=head2 system_api_list_types

[B<Family:> ontap-classic, vfiler]


=begin html

get list and description of typedefs

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<type-entries>  =>   B<L<"system-api-type-entry-info">[]>

=begin html

<br>null

=end html

=back



=head2 system_available_replication_transfers

[B<Family:> ontap-classic, vfiler]


=begin html

Provide a mechanism to calculate the number of replication operations that could be started. Returns the number of replication operations that could be started for each replication type. Another output is the maximum number of transfers for each replication type.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<replication-transfer-table>  =>   B<L<"replication-transfer-info">[]>

=begin html

<br>Table with entries mapping each replication operation to number of transfers which could be started.

=end html

=back



=head2 system_get_info

[B<Family:> ontap-classic, vfiler]


=begin html

Obtain appliance information which includes cpu and backplane information. The output contains the head information in a sysconfig -a command. I/O information is not included.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<system-info>  =>   B<L<"system-info">>

=begin html

<br>null

=end html

=back



=head2 system_get_ontapi_version

[B<Family:> ontap-classic, vfiler]


=begin html

Obtain the current ONTAPI major and minor versions.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<major-version>  =>   B<integer>

=begin html

<br>Current ONTAPI major version supported by this appliance.

=end html

=back



=over 2

=item * I<minor-version>  =>   B<integer>

=begin html

<br>Current ONTAPI minor version supported by this appliance.

=end html

=back



=head2 system_get_vendor_info

[B<Family:> ontap-classic, vfiler]


=begin html

Obtain the Data ONTAP vendor information.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<autosupport-email>  =>   B<string>

=begin html

<br>Vendor's AutoSupport e-mail target.

=end html

=back



=over 2

=item * I<autosupport-url>  =>   B<string>

=begin html

<br>Vendor's AutoSupport URL target.

=end html

=back



=over 2

=item * I<complete-name>  =>   B<string>

=begin html

<br>Complete name of vendor.

=end html

=back



=over 2

=item * I<customer-support-contact>  =>   B<string>

=begin html

<br>Vendor's technical support contact information.

=end html

=back



=over 2

=item * I<customer-support-name>  =>   B<string>

=begin html

<br>Name of vendor's customer support organization.

=end html

=back



=over 2

=item * I<information-url>  =>   B<string>

=begin html

<br>Vendor's AutoSupport information URL.

=end html

=back



=over 2

=item * I<ontap-oid-prefix>  =>   B<string>

=begin html

<br>Vendor's starting SNMP OID prefix for Data ONTAP. The suffix that follows is the storage system MIB. For example, ".1.3.6.1.4.1.789". To obtain the filer's model name, one would concatenate the OID prefix and ".1.1.5.0" from the storage system MIB.

=end html

=back



=over 2

=item * I<product-url>  =>   B<string>

=begin html

<br>Vendor's installed product information URL.

=end html

=back



=over 2

=item * I<short-name>  =>   B<string>

=begin html

<br>Vendor's short name.

=end html

=back



=head2 system_get_version

[B<Family:> ontap-classic, vfiler]


=begin html

Obtain the Data ONTAP version.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<is-clustered>  =>   B<boolean>

=begin html

<br>If true, indicates Data ONTAP Cluster-Mode, else Data ONTAP 7-Mode. This field is available in Data ONTAP 8.1 or later.

=end html

=back



=over 2

=item * I<version>  =>   B<string>

=begin html

<br>Current Data ONTAP version running on the appliance. If the cluster is currently operating with more than one version of Data ONTAP, then the lowest version of all is returned.

=end html

=back



=head2 useradmin_domainuser_add

[B<Family:> ontap-classic, vfiler]


=begin html

Adds a nonlocal user into a group or groups. The user can be added as a SID or as domain\username. This API is only used in a windows environment.

=end html



B<Inputs>

=over 2

=item * I<user-identifier>  =>   B<string>

=begin html

<br>Name of the user in domain\username format. This can also be a SID (Windows security identifier) describing a user. A SID has the format S-1-5-21-int-int-int-rid.

=end html

=back



=over 2

=item * I<useradmin-groups>  =>   B<L<"useradmin-group-info">[]>

=begin html

<br>List of local groups to contain the domain user.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 useradmin_domainuser_delete

[B<Family:> ontap-classic, vfiler]


=begin html

Removes a nonlocal user from a group or groups. The user can be removed as a SID or as domain\username. This API is only used in a windows environment.

=end html



B<Inputs>

=over 2

=item * I<user-identifier>  =>   B<string>

=begin html

<br>Name of the user in domain\username format. This can also be a SID (Windows security identifier) describing a user. A SID has the format S-1-5-21-int-int-int-rid.

=end html

=back



=over 2

=item * I<useradmin-groups>  =>   B<L<"useradmin-group-info">[]>

=begin html

<br>Remove the SID from this list of local groups.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 useradmin_domainuser_list

[B<Family:> ontap-classic, vfiler]


=begin html

List all of the SIDs in a given group. This API is only used in a windows environment.

=end html



B<Inputs>

=over 2

=item * I<group-name>  =>   B<string>

=begin html

<br>List only the SIDs in this group.

=end html

=back



B<Outputs>

=over 2

=item * I<user-identifiers>  =>   B<sid[]>

=begin html

<br>List of SID's inside of the group.

=end html

=back



=head2 useradmin_group_add

[B<Family:> ontap-classic, vfiler]


=begin html

Adds a group given the information provided.

=end html



B<Inputs>

=over 2

=item * I<useradmin-group>  =>   B<L<"useradmin-group-info">>

=begin html

<br>New group information. A group must have a name and at least one role. A comment is also allowed. All other fields are ignored.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 useradmin_group_delete

[B<Family:> ontap-classic, vfiler]


=begin html

Deletes a group.

=end html



B<Inputs>

=over 2

=item * I<group-name>  =>   B<string>

=begin html

<br>The name of the group to be deleted.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 useradmin_group_list

[B<Family:> ontap-classic, vfiler]


=begin html

Lists full information for all groups on the system.

=end html



B<Inputs>

=over 2

=item * I<group-name>  =>   B<string, optional>

=begin html

<br>List only the information associated with this group.

=end html

=back



=over 2

=item * I<verbose>  =>   B<boolean, optional>

=begin html

<br>Default is false. If set to true, then the allowed capabilities are placed into the group-info structure. Depending on number of groups and roles, this operation may take a long time.

=end html

=back



B<Outputs>

=over 2

=item * I<useradmin-groups>  =>   B<L<"useradmin-group-info">[]>

=begin html

<br>List of groups and information associated with them.

=end html

=back



=head2 useradmin_group_modify

[B<Family:> ontap-classic, vfiler]


=begin html

Modifies a group given the information provided.

=end html



B<Inputs>

=over 2

=item * I<new-group-name>  =>   B<string, optional>

=begin html

<br>New group name for this group. This is used to rename the group specified in useradmin-group. If this value is invalid, useradmin-group-modify fails without changing anything. The value is optional, and if not provided, the group name will be unchanged.

=end html

=back



=over 2

=item * I<useradmin-group>  =>   B<L<"useradmin-group-info">>

=begin html

<br>A group must have a name. If one or more roless and/or a comment is provided, the group is modified accordingly. All other fields are ignored.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 useradmin_role_add

[B<Family:> ontap-classic, vfiler]


=begin html

Adds a role given the information provided.

=end html



B<Inputs>

=over 2

=item * I<useradmin-role>  =>   B<L<"useradmin-role-info">>

=begin html

<br>New role information. A role must have a name and at least one allowed capability. A role-info comment is also allowed. All other fields are ignored.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 useradmin_role_delete

[B<Family:> ontap-classic, vfiler]


=begin html

Deletes a role.

=end html



B<Inputs>

=over 2

=item * I<role-name>  =>   B<string>

=begin html

<br>The name of the role to be deleted.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 useradmin_role_list

[B<Family:> ontap-classic, vfiler]


=begin html

Lists full information for all roles on the system.

=end html



B<Inputs>

=over 2

=item * I<role-name>  =>   B<string, optional>

=begin html

<br>List only the information associated with this role.

=end html

=back



B<Outputs>

=over 2

=item * I<useradmin-roles>  =>   B<L<"useradmin-role-info">[]>

=begin html

<br>List of roles and information associated with them.

=end html

=back



=head2 useradmin_role_modify

[B<Family:> ontap-classic, vfiler]


=begin html

Modifies a role given the information provided.

=end html



B<Inputs>

=over 2

=item * I<useradmin-role>  =>   B<L<"useradmin-role-info">>

=begin html

<br>A role must have a name. If one or more capabilities and/or a comment is provided, the role is modified accordingly.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 useradmin_user_add

[B<Family:> ontap-classic, vfiler]


=begin html

Adds a user given the information provided.

=end html



B<Inputs>

=over 2

=item * I<password>  =>   B<string>

=begin html

<br>Password for the user. Please see documentation for constraints on the password.

=end html

=back



=over 2

=item * I<useradmin-user>  =>   B<L<"useradmin-user-info">>

=begin html

<br>New user information. A user must have a name and at least one group. A comment and full-name are also allowed. All other fields are ignored.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 useradmin_user_delete

[B<Family:> ontap-classic, vfiler]


=begin html

Deletes a user.

=end html



B<Inputs>

=over 2

=item * I<user-name>  =>   B<string>

=begin html

<br>The name of the user to be deleted.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 useradmin_user_list

[B<Family:> ontap-classic, vfiler]


=begin html

Lists information for all administrative users on the system with the exception of root and snmp.

=end html



B<Inputs>

=over 2

=item * I<group-name>  =>   B<string, optional>

=begin html

<br>List only the users which are a part of this group. This option must be left empty if the option "user-name" contains a value.

=end html

=back



=over 2

=item * I<user-name>  =>   B<string, optional>

=begin html

<br>List only the information associated with this user. This option must be left empty if the option "group-name" contains a value.

=end html

=back



=over 2

=item * I<verbose>  =>   B<boolean, optional>

=begin html

<br>Default is false. If set to true, then the allowed capabilities are placed into the user-info structure. Depending on number of users, groups, and roles; this operation may take a long time.

=end html

=back



B<Outputs>

=over 2

=item * I<useradmin-users>  =>   B<L<"useradmin-user-info">[]>

=begin html

<br>List of users and information associated with them.

=end html

=back



=head2 useradmin_user_modify

[B<Family:> ontap-classic, vfiler]


=begin html

Modifies a user given the information provided.

=end html



B<Inputs>

=over 2

=item * I<useradmin-user>  =>   B<L<"useradmin-user-info">>

=begin html

<br>A user must have a name. If one or more groups a comment and/or a full-name is provided, the user is modified accordingly. All other fields are ignored.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 useradmin_user_modify_password

[B<Family:> ontap-classic, vfiler]


=begin html

Changes the password of a specified user.

=end html



B<Inputs>

=over 2

=item * I<new-password>  =>   B<string>

=begin html

<br>New password for the user. Please see documentation for constraints on the password.

=end html

=back



=over 2

=item * I<old-password>  =>   B<string, optional>

=begin html

<br>Current password for the user. A user with the capability 'security-passwd-change-others' and at least the same capabilities as the user being changed, does not need to enter the current password in order to change it to a new one.

=end html

=back



=over 2

=item * I<user-name>  =>   B<string>

=begin html

<br>The user who's password should be changed.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 vfiler_add_ipaddress



=begin html

Add an ipaddress to a vfiler

=end html



B<Inputs>

=over 2

=item * I<ipaddress>  =>   B<string>

=begin html

<br>Ipaddress to be added, in dotted-decimal format (for example, "192.168.11.12"). If IPv6 address then, it should be in the format a:b:c:d:e:f:g:h (for example, fd20:81be:b255:4213:2a0:98ff:fe07:609b).

=end html

=back



=over 2

=item * I<vfiler>  =>   B<string>

=begin html

<br>Name of the vfiler.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 vfiler_add_storage



=begin html

Add a storage unit to a vfiler

=end html



B<Inputs>

=over 2

=item * I<storage-path>  =>   B<string>

=begin html

<br>Storage-path to be added, in the form "/vol/&lt;volume&gt;/..."

=end html

=back



=over 2

=item * I<vfiler>  =>   B<string>

=begin html

<br>Name of the vfiler.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 vfiler_allow_protocol



=begin html

Allow a protocol on a specified vfiler

=end html



B<Inputs>

=over 2

=item * I<protocol>  =>   B<string>

=begin html

<br>Name of the protocol to be allowed. Possible values are: nfs, cifs, rsh.

=end html

=back



=over 2

=item * I<vfiler>  =>   B<string>

=begin html

<br>Name of the vfiler.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 vfiler_create



=begin html

Create a new vfiler. The inputs specify a list of storage units, which are qtree or volume paths.

=end html



B<Inputs>

=over 2

=item * I<ip-addresses>  =>   B<ip-address[]>

=begin html

<br>null

=end html

=back



=over 2

=item * I<ipspace>  =>   B<string, optional>

=begin html

<br>Name of the ipspace.

=end html

=back



=over 2

=item * I<storage-units>  =>   B<storage-unit[]>

=begin html

<br>null

=end html

=back



=over 2

=item * I<vfiler>  =>   B<string>

=begin html

<br>Name of the vfiler.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 vfiler_destroy



=begin html

Destroy a vfiler

=end html



B<Inputs>

=over 2

=item * I<vfiler>  =>   B<string>

=begin html

<br>Name of the vfiler.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 vfiler_disallow_protocol



=begin html

Disallow a protocol on a specified vfiler

=end html



B<Inputs>

=over 2

=item * I<protocol>  =>   B<string>

=begin html

<br>Name of the protocol to be disallowed. Possible values are: nfs, cifs, rsh.

=end html

=back



=over 2

=item * I<vfiler>  =>   B<string>

=begin html

<br>Name of the vfiler.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 vfiler_dr_activate



=begin html

Stop the remote vfiler and activate the disaster recovery vfiler on the local machine.

=end html



B<Inputs>

=over 2

=item * I<remote-vfiler-location>  =>   B<L<"vfiler-location">>

=begin html

<br>Name of the remote vfiler and the remote filer hosting it

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 vfiler_dr_configure



=begin html

Create a new vfiler disaster recovery relationship. The inputs specify the information for the remote vfiler/filer to connect to and configuration information for the vfiler to use upon activation.

=end html



B<Inputs>

=over 2

=item * I<DNS-server-ipaddrs>  =>   B<ip-address[], optional>

=begin html

<br>ip-addresses of the DNS servers the vfiler should use

=end html

=back



=over 2

=item * I<NIS-server-ipaddrs>  =>   B<ip-address[], optional>

=begin html

<br>ip-addresses of the NIS servers the vfiler should use

=end html

=back



=over 2

=item * I<alternate-src-dst>  =>   B<L<"hostname-pair">, optional>

=begin html

<br>Alternate hostnames or IP addresses for redundancy purposes

=end html

=back



=over 2

=item * I<ipaddrs>  =>   B<L<"ipaddr-info">[]>

=begin html

<br>Contains a list of all the IP address (and associated information) which should be bound to the vfiler at the destination

=end html

=back



=over 2

=item * I<is-synchronous>  =>   B<boolean>

=begin html

<br>Set true to use synchronous snapmirror

=end html

=back



=over 2

=item * I<remote-authentication-info>  =>   B<L<"authentication-info">, optional>

=begin html

<br>Login name and password to use on the remote filer. Either this or encrypted-authentication-info must be present.

=end html

=back



=over 2

=item * I<remote-encrypted-authentication-info>  =>   B<L<"encrypted-authentication-info">, optional>

=begin html

<br>Encrypted login name and password to be used on remote filer.Either this or authentication-info must be present.

=end html

=back



=over 2

=item * I<remote-vfiler-location>  =>   B<L<"vfiler-location">>

=begin html

<br>Name of the remote vfiler and the remote filer hosting it

=end html

=back



=over 2

=item * I<snapmirror-not-initialize>  =>   B<boolean, optional>

=begin html

<br>Set true for not creating baseline snapshot during dr configure. Default is false.

=end html

=back



=over 2

=item * I<use-secure-command-channel>  =>   B<boolean, optional>

=begin html

<br>Set true to use the secure command channel while communicating with remote filer. Default is false.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 vfiler_dr_delete



=begin html

delete the vfiler disaster recovery relationship on this machine.

=end html



B<Inputs>

=over 2

=item * I<is-forced>  =>   B<boolean>

=begin html

<br>if set it will force the deletion of the vfiler

=end html

=back



=over 2

=item * I<remote-vfiler-location>  =>   B<L<"vfiler-location">>

=begin html

<br>Name of the remote vfiler and the remote filer hosting it

=end html

=back



=over 2

=item * I<use-secure-command-channel>  =>   B<boolean, optional>

=begin html

<br>Set true to use the secure command channel while communicating with remote filer. Default is false.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 vfiler_dr_get_status



=begin html

Get the status of the disaster recovery relationship with the given remote vfiler and filer.

=end html



B<Inputs>

=over 2

=item * I<remote-vfiler-location>  =>   B<L<"vfiler-location">>

=begin html

<br>Name of the remote vfiler and the remote filer hosting it

=end html

=back



B<Outputs>

=over 2

=item * I<dr-status>  =>   B<L<"storage-dr-status">[]>

=begin html

<br>array with disaster recovery status of each storage entity

=end html

=back



=head2 vfiler_dr_resync



=begin html

move a vfiler which has been migrated by vfiler disaster recovery to back to its original filer

=end html



B<Inputs>

=over 2

=item * I<alternate-src-dst>  =>   B<L<"hostname-pair">, optional>

=begin html

<br>Alternate hostnames or IP addresses for redundancy

=end html

=back



=over 2

=item * I<is-synchronous>  =>   B<boolean>

=begin html

<br>Set true to use synchronous snapmirror

=end html

=back



=over 2

=item * I<remote-authentication-info>  =>   B<L<"authentication-info">, optional>

=begin html

<br>Login name and password to use on the remote filer. Either this or encrypted-authentication-info must be present.

=end html

=back



=over 2

=item * I<remote-encrypted-authentication-info>  =>   B<L<"encrypted-authentication-info">, optional>

=begin html

<br>Encrypted login name and password to be used on remote filer. Either this or authentication-info must be present.

=end html

=back



=over 2

=item * I<remote-vfiler-location>  =>   B<L<"vfiler-location">>

=begin html

<br>Name of the remote vfiler and the remote filer hosting it

=end html

=back



=over 2

=item * I<use-secure-command-channel>  =>   B<boolean, optional>

=begin html

<br>Set true to use the secure command channel while communicating with remote filer. Default is false.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 vfiler_get_allowed_protocols



=begin html

Get the protocols allowed for a vfiler

=end html



B<Inputs>

=over 2

=item * I<vfiler>  =>   B<string>

=begin html

<br>Name of the vfiler.

=end html

=back



B<Outputs>

=over 2

=item * I<allowed-protocols>  =>   B<L<"protocol-info">[]>

=begin html

<br>This contains a list of all allowed protocols for this vfiler.

=end html

=back



=head2 vfiler_get_disallowed_protocols



=begin html

Get the protocols disallowed for a vfiler

=end html



B<Inputs>

=over 2

=item * I<vfiler>  =>   B<string>

=begin html

<br>Name of the vfiler.

=end html

=back



B<Outputs>

=over 2

=item * I<disallowed-protocols>  =>   B<L<"protocol-info">[]>

=begin html

<br>This contains a list of all disallowed protocols for this vfiler.

=end html

=back



=head2 vfiler_get_status



=begin html

Get the status of a vfiler

=end html



B<Inputs>

=over 2

=item * I<vfiler>  =>   B<string>

=begin html

<br>Name of the vfiler.

=end html

=back



B<Outputs>

=over 2

=item * I<status>  =>   B<string>

=begin html

<br>Status of the vfiler. Possible values: running, stopped, inconsistent or defunct.

=end html

=back



=head2 vfiler_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Retrieve information about all vfilers. An optional vfiler parameter lets you retrive information about a single vfiler.

=end html



B<Inputs>

=over 2

=item * I<vfiler>  =>   B<string, optional>

=begin html

<br>Name of the vfiler whose information you want to retrieve. If this parameter is not provided and this zapi is run on pfiler then, information about all vfilers will be retrieved. This parameter is not provided and if you are running zapi on vfiler then information about that vfiler only will be retrieved.

=end html

=back



B<Outputs>

=over 2

=item * I<vfilers>  =>   B<L<"vfiler-info">[]>

=begin html

<br>This contains a list of all the vfilers.

=end html

=back



=head2 vfiler_migrate



=begin html

Migrate a vfiler on remote filer to this filer. The vfiler facility must be licensed on the remote filer and on the local filer. Other requirements are detailed in the migration-method parameter documentation below. <p> Migration may fail for a number of reasons. For example, the vfiler facility may not be licensed or the vfiler may not be in a state suitable for migration. In these cases EVFILEROPNOTALLOWED will be returned, along with a descriptive reason string.

=end html



B<Inputs>

=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>If this value is true, the vfiler should be migrated even under various conditions which would normally prevent a migration are encountered. See na_vfiler(1) for details.

=end html

=back



=over 2

=item * I<ipaddrs>  =>   B<L<"ipaddr-info">[]>

=begin html

<br>Contains a list of all the IP address (and associated information) which should be bound to the vfiler at the destination

=end html

=back



=over 2

=item * I<migration-method>  =>   B<string, optional>

=begin html

<br>Name of the vfiler migration method. Possible values: snapmirror, nocopy. Defaults to "snapmirror". <p> Snapmirror: SnapMirror must be licensed on the local and remote filer. <p> Nocopy:If the force parameter is not set to true, the vfiler will not be migrated if data belonging to belonging to the source vfiler is part of a SnapMirror or SnapVault relationship, if the source filer file system version is not the same as the local file system version, if NFS, CIFS, DAFS, or iSCSI are allowed on the source vfiler but not licensed locally, or if clustering is licensed on the source filer but not licensed locally. The "force" parameter overrides these checks. However, even if the "force" parameter is supplied the vfiler will not be migrated if the source filer's file system version is greater than the local filer's file system version.

=end html

=back



=over 2

=item * I<password>  =>   B<string, encrypted>

=begin html

<br>Administrative password on remote-filer.

=end html

=back



=over 2

=item * I<remote-filer>  =>   B<string>

=begin html

<br>Name of the filer on which the vfiler resides. This may also take the form of an IP address.

=end html

=back



=over 2

=item * I<use-secure-command-channel>  =>   B<boolean, optional>

=begin html

<br>Set true to use the secure command channel while communicating with remote filer. Default is false.

=end html

=back



=over 2

=item * I<username>  =>   B<string>

=begin html

<br>Administrative login name on remote-filer.

=end html

=back



=over 2

=item * I<vfiler>  =>   B<string>

=begin html

<br>Name of the vfiler being migrated. There must not be a vfiler with the same name on the local filer. "vfiler0" is not allowed, as the default vfiler may not be migrated.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 vfiler_migrate_cancel



=begin html

cancels the vfiler migration.

=end html



B<Inputs>

=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>If this value is true, the vfiler migration should be canceled even under various conditions which would normally prevent it. Default is FALSE.

=end html

=back



=over 2

=item * I<remote-vfiler-location>  =>   B<L<"vfiler-location">>

=begin html

<br>Name of the remote vfiler and the remote filer hosting it

=end html

=back



=over 2

=item * I<use-secure-command-channel>  =>   B<boolean, optional>

=begin html

<br>Set true to use the secure command channel while communicating with remote filer. Default is false.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 vfiler_migrate_complete



=begin html

Completes the migration by stopping the remote vfiler and activating the vfiler on the local machine. The source vfiler unit will be destroyed after migration is complete.

=end html



B<Inputs>

=over 2

=item * I<migrate-transparent>  =>   B<boolean, optional>

=begin html

<br>If this value is true, then the vfiler will migrate non-disruptively. This kind of migration will take place within 120 seconds using semi-sync VSM relationship. Default is false.

=end html

=back



=over 2

=item * I<remote-authentication-info>  =>   B<L<"authentication-info">, optional>

=begin html

<br>Login name and password to use on the remote filer. Use this option if the password has been changed at the remote filer after configuring migrate start.

=end html

=back



=over 2

=item * I<remote-vfiler-location>  =>   B<L<"vfiler-location">>

=begin html

<br>Name of the remote vfiler and the remote filer hosting it

=end html

=back



=over 2

=item * I<use-secure-command-channel>  =>   B<boolean, optional>

=begin html

<br>Set true to use the secure command channel while communicating with remote filer. Default is false.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 vfiler_migrate_start



=begin html

Starts vfiler unit migration from remote filer to this filer. The data and remote vfiler configuration are migrated as a vfiler unit. It starts SnapMirror relationships between source vfiler volumes and destination vfiler volumes. The ZAPI vfiler-migrate-complete, when run completes the vfiler migration. The following are requirements for vfiler migration 1.The vfiler facility must be licensed on the remote filer and on the local filer. 2.There should not be a local vfiler with the same name as the source vfiler. 3.The local filer should have enough storage space to hold the source vFiler unit's volumes. 4.The volumes to be used by the destination vFiler unit should exist and should not be used by any other non defualt vFiler unit. 5.The destination vFiler unit must have the same path names to the volumes that remote vFiler unit is holding. 6.There should not be any qtrees in the destination volumes whose names match those of qtrees in the source volumes. 7.SnapMirror facility must be licensed on the remote filer and on the local filer. The destination vfiler will have same DNS, NIS and IPSpace configuration as the source vfiler after migration. If the destination vfiler is in different domain or in different subnet then user might need to run setup on destination vfiler. <p> Migration may fail for a number of reasons. For example, the vfiler facility may not be licensed or the vfiler may not be in a state suitable for migration. In these cases EVFILEROPNOTALLOWED will be returned, along with a descriptive reason string.

=end html



B<Inputs>

=over 2

=item * I<ipaddrs>  =>   B<L<"ipaddr-info">[]>

=begin html

<br>Contains a list of all the IP addresses (and associated information) which should be bound to the vfiler at the destination

=end html

=back



=over 2

=item * I<remote-authentication-info>  =>   B<L<"authentication-info">>

=begin html

<br>Login name and password to use on the remote filer

=end html

=back



=over 2

=item * I<remote-vfiler-location>  =>   B<L<"vfiler-location">>

=begin html

<br>Name of the vfiler being migrated.

=end html

=back



=over 2

=item * I<snapmirror-not-initialize>  =>   B<boolean, optional>

=begin html

<br>Set true avoid snapmirror initialization during migrate start Default is false.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 vfiler_migrate_status



=begin html

Get the status of the vfiler migrate relationship with the given remote vfiler and filer.

=end html



B<Inputs>

=over 2

=item * I<remote-vfiler-location>  =>   B<L<"vfiler-location">>

=begin html

<br>Name of the remote vfiler and the remote filer hosting it

=end html

=back



B<Outputs>

=over 2

=item * I<migrate-status>  =>   B<L<"storage-mr-status">[]>

=begin html

<br>migration status of the storage entities.

=end html

=back



=head2 vfiler_remove_ipaddress



=begin html

Remove an ipaddress from a vfiler

=end html



B<Inputs>

=over 2

=item * I<ipaddress>  =>   B<string>

=begin html

<br>Ipaddress to be removed, in dotted-decimal format (for example, "192.168.11.12"). If IPv6 address then, it should be in the format a:b:c:d:e:f:g:h (for example, fd20:81be:b255:4213:2a0:98ff:fe07:609b).

=end html

=back



=over 2

=item * I<vfiler>  =>   B<string>

=begin html

<br>Name of the vfiler.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 vfiler_remove_storage



=begin html

Remove a storage unit from a vfiler

=end html



B<Inputs>

=over 2

=item * I<storage-path>  =>   B<string>

=begin html

<br>Storage-path to be removed, in the form "/vol/&lt;volume&gt;/..."

=end html

=back



=over 2

=item * I<vfiler>  =>   B<string>

=begin html

<br>Name of the vfiler.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 vfiler_setup



=begin html

Setup services for a vfiler that has been already created. At least one of the optional arguments must be specified. This ZAPI will rewrite the /etc/exports, /etc/hosts, /etc/hosts.equiv, /etc/nsswitch.conf and /etc/resolv.conf files, saving the original contents of these files in .bak files (e.g. /etc/exports.bak).

=end html



B<Inputs>

=over 2

=item * I<adminhost>  =>   B<L<"adminhost">, optional>

=begin html

<br>Information about the administrative host

=end html

=back



=over 2

=item * I<dnsdomain>  =>   B<string, optional>

=begin html

<br>DNS domain name

=end html

=back



=over 2

=item * I<dnsservers>  =>   B<L<"dnsserver-info">[], optional>

=begin html

<br>List of DNS servers

=end html

=back



=over 2

=item * I<ipbindings>  =>   B<L<"ipbinding-info">[], optional>

=begin html

<br>Contains a list of all IP address bindings to apply

=end html

=back



=over 2

=item * I<nisdomain>  =>   B<string, optional>

=begin html

<br>NIS domain name

=end html

=back



=over 2

=item * I<nisservers>  =>   B<L<"nisserver-info">[], optional>

=begin html

<br>List of NIS servers

=end html

=back



=over 2

=item * I<password>  =>   B<string, optional>

=begin html

<br>root password for the vfiler

=end html

=back



=over 2

=item * I<vfiler>  =>   B<string>

=begin html

<br>Name of the vfiler that you want to setup.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 vfiler_start



=begin html

Start a stopped vfiler. This operation is synchronous.

=end html



B<Inputs>

=over 2

=item * I<vfiler>  =>   B<string>

=begin html

<br>Name of the vfiler.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 vfiler_stop



=begin html

Stop a started vfiler

=end html



B<Inputs>

=over 2

=item * I<vfiler>  =>   B<string>

=begin html

<br>Name of the vfiler.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 vmservices_vsphere_credential_check

[B<Family:> ontap-classic]


=begin html

Check vSphere credentials by attempting to login to the vSphere server. <p> The error return values may be interpreted as follows: EOPNOTSUPPORTED This was invoked on a non-VSA platform. EINVALIDINPUTERROR Missing username or password. EAPIAUTHENTICATION vSphere server authentication failed. EHOSTNOTFOUND could not resolve server name with DNS EONTAPI_ECONNREFUSED could not connect to server EINTERNALERROR internal error in underlying implementation

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * None

=back



=head2 vmservices_vsphere_credential_get

[B<Family:> ontap-classic]


=begin html

Reports the currently configured vSphere server and username. <p> The error return values may be interpreted as follows: EOPNOTSUPPORTED This was invoked on a non-VSA platform. EINTERNALERROR internal error in underlying implementation

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<server>  =>   B<string, optional>

=begin html

<br>The currently configured vSphere server, if any. It can be a hostname if DNS is enabled, otherwise it must be an IP address.

=end html

=back



=over 2

=item * I<username>  =>   B<string, optional>

=begin html

<br>The currently configured vSphere username, if any.

=end html

=back



=head2 vmservices_vsphere_credential_modify

[B<Family:> ontap-classic]


=begin html

Modify or set initial value for vSphere server, user, and/or password. <p> The error return values may be interpreted as follows: EOPNOTSUPPORTED This was invoked on a non-VSA platform. EINVALIDINPUTERROR argument(s) too large EINTERNALERROR internal error in underlying implementation

=end html



B<Inputs>

=over 2

=item * I<password>  =>   B<string, optional, encrypted>

=begin html

<br>Password for the vSphere user. If not specified, the configured password (if any) is not changed.

=end html

=back



=over 2

=item * I<server>  =>   B<string, optional>

=begin html

<br>vSphere server managing this VSA instance: either the ESX host itself or its managing vCenter server. It can be a hostname if DNS is enabled, otherwise it must be an IP address. If not specified, the configured server (if any) is not changed.

=end html

=back



=over 2

=item * I<username>  =>   B<string, optional>

=begin html

<br>A vSphere username (only "read-only" access required) to be used when connecting to the vSphere server. If not specified, the configured username (if any) is not changed.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_add



=begin html

Adds disks to the given traditional volume. Specify the disks to add in the same way as for 'volume-create'. Disks cannot be added to a mirrored traditional volume if one of its plexes is offline. Addition of the specified disk(s) may not have completed by the time the API returns. Use 'volume-list-info' to query the traditional volume's status, and thus determine when the disk addition is complete. It is not possible to add disks directly to a flexible volume; if that is the goal, then consider using 'volume-container' to find the flexible volume's containing aggregate, then use 'aggr-add' to add the desired disks there (which, of course, will make their storage available to all flexible volumes contained in that same aggregate).

=end html



B<Inputs>

=over 2

=item * I<disk-count>  =>   B<integer, optional>

=begin html

<br>Number of disks to add, including parity disks. The disks will come from the spare pool. The smallest disks in the spare pool join the volume first, unless "disk-size" is specified as an argument. Range : [0..2^31-1].

=end html

=back



=over 2

=item * I<disk-size>  =>   B<integer, optional>

=begin html

<br>The disk size in 4KB blocks. Disks that are within approximately 20% of the specified size are selected for use in the traditional volume. If neither the "disk-size" nor the "disk-size-with-unit" is specified, the smallest disks in the spare pool join the traditional volume first. This option is ignored if a specific list of disks to use is provided via the "disks" argument. Range : [0..2^31-1]. You must only use one of either "disk-size" or "disk-size-with-unit" parameters. If both appear, an error message will be returned.

=end html

=back



=over 2

=item * I<disk-size-with-unit>  =>   B<string, optional>

=begin html

<br>The disk size in specified unit. It is a positive integer number followed by unit of "T", "G", "M" or "K". This option is ignored if a specific list of disks to use is provided via the "disks" argument. You must only use one of either "disk-size" or "disk-size-with-unit" parameters. If both appear, an error message will be returned.

=end html

=back



=over 2

=item * I<disks>  =>   B<L<"disk-info">[], optional>

=begin html

<br>Specific list of disks to add to the traditional volume. If the traditional volume is mirrored and a specific disk list is supplied, another list ("mirror-disks") must also be supplied with the same number of disks.

=end html

=back



=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>Disks in a plex are not permitted to span spare spare pools. This behavior is overridden with this option when it is set to "true".

=end html

=back



=over 2

=item * I<mirror-disks>  =>   B<L<"disk-info">[], optional>

=begin html

<br>Specific list of mirror disks needed to accompany the list in the "disks" argument. This list must contain the same number of disks specified in "disks".

=end html

=back



=over 2

=item * I<raid-group>  =>   B<string, optional>

=begin html

<br>Specifies the RAID group (for example, 'rg0') to which the indicated disks are to be added. When a RAID group other than the last RAID group is specified, the traditional volume can no longer be reverted to a version of ONTAP prior to 6.2. In such a case, the "force" option must be specified as well. By default, the filer fills up one RAID group with disks before starting another RAID group. Suppose a traditional volume currently has one RAID group of 12 disks and its RAID group size is 14. If you add 5 disks to this traditional volume, it will have one RAID group with 14 disks and another RAID group with 3 disks. The filer does not evenly distribute disks among RAID groups.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the traditional volume to which disks are to be added.

=end html

=back



B<Outputs>

=over 2

=item * I<bad-disks>  =>   B<L<"disk-info">[], optional>

=begin html

<br>List of disks that were not added. This is only returned if there are bad disks.

=end html

=back



=head2 volume_autosize_get

[B<Family:> ontap-classic, vfiler]


=begin html

Given the name of a flexible volume, get the autosize settings. This API is not supported for Infinite Volumes.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>The name of the flexible volume for which we want to get autosize.

=end html

=back



B<Outputs>

=over 2

=item * I<grow-threshold-percent>  =>   B<integer, optional>

=begin html

<br>The threshold capacity percentage at which the volume automatiacally grows. Range : [0..100]

=end html

=back



=over 2

=item * I<increment-size>  =>   B<string, optional>

=begin html

<br>The increment size by which the volume would be grown, in kbytes.

=end html

=back



=over 2

=item * I<is-enabled>  =>   B<boolean>

=begin html

<br>This element is deprecated in Data ONTAP 8.2 and later. Please use autosize-mode instead. When this parameter is 'true', the 'grow' autosize mode is in effect, while 'false' means that the autosize mode to 'off'.

=end html

=back



=over 2

=item * I<maximum-size>  =>   B<string>

=begin html

<br>The maximum size to which the volume would be grown automatically, in kbytes.

=end html

=back



=over 2

=item * I<minimum-size>  =>   B<string, optional>

=begin html

<br>The minimum size to which the volume would be shrunk automatically, in kbytes.

=end html

=back



=over 2

=item * I<mode>  =>   B<string, optional>

=begin html

<br>The operating mode of autosize. Valid values are "grow", "grow_shrink", and "off".

=end html

=back



=over 2

=item * I<shrink-threshold-percent>  =>   B<integer, optional>

=begin html

<br>The threshold capacity percentage at which the volume automatically shrinks. Range : [0..100]

=end html

=back



=head2 volume_autosize_set

[B<Family:> ontap-classic]


=begin html

Given the name of a flexible volume, set the autosize settings. This API is not supported for Infinite Volumes.

=end html



B<Inputs>

=over 2

=item * I<grow-threshold-percent>  =>   B<integer, optional>

=begin html

<br>Specifies the percentage of the flexible volume's capacity at which autogrow is initiated. The default grow threshold varies from 85% to 98%, depending on the volume size. It is an error for the grow threshold to be less than or equal to the shrink threshold. Range : [0..100]

=end html

=back



=over 2

=item * I<increment-size>  =>   B<string, optional>

=begin html

<br>Specify the flexible volume's increment size using the following format &lt number &gt [k|m|g|t] The amount is the absolute size to set. The optional trailing 'k', 'm', 'g', and 't' indicates the desired units, namely 'kilobytes', 'megabytes', 'gigabytes', and 'terabytes' (respectively). If the trailing unit character doesn't appear, then &lt number &gt is interpreted as the number of bytes desired. The default value of increment size is 5%.

=end html

=back



=over 2

=item * I<is-enabled>  =>   B<boolean, optional>

=begin html

<br>This element is deprecated in Data ONTAP 8.2 and later. Please use autosize-mode instead. Setting this parameter to 'true' enables the 'grow' mode, while setting it to 'false' disables autosize and sets the autosize mode to 'off'. The default value is 'false'.

=end html

=back



=over 2

=item * I<maximum-size>  =>   B<string, optional>

=begin html

<br>Specify the flexible volume's maximum allowed size using the following format &lt number &gt [k|m|g|t] The amount is the absolute size to set. The optional trailing 'k', 'm', 'g', and 't' indicates the desired units, namely 'kilobytes', 'megabytes', 'gigabytes', and 'terabytes' (respectively). If the trailing unit character doesn't appear, then &lt number &gt is interpreted as the number of bytes desired. The default value is 20% greater than the volume size at the time autosize was enabled. It is an error for the maximum volume size to be less than the current volume size. It is also an error for the maximum size to be less than or equal to the minimum size.

=end html

=back



=over 2

=item * I<minimum-size>  =>   B<string, optional>

=begin html

<br>Specify the flexible volume's minimum allowed size using the following format &lt number &gt [k|m|g|t] The amount is the absolute size to set. The optional trailing 'k', 'm', 'g', and 't' indicates the desired units, namely 'kilobytes', 'megabytes', 'gigabytes', and 'terabytes' (respectively). If the trailing unit character doesn't appear, then &lt number &gt is interpreted as the number of bytes desired. The default value is the size of the volume at the time the 'grow_shrink' mode was enabled. It is an error for the minimum size to be greater than or equal to the maximum size.

=end html

=back



=over 2

=item * I<mode>  =>   B<string, optional>

=begin html

<br>Specify the flexible volume's autosize mode of operation. Valid values are "grow", "grow_shrink", and "off". The default mode is "off".

=end html

=back



=over 2

=item * I<reset>  =>   B<boolean, optional>

=begin html

<br>Sets the values of is-enabled, maximum size, increment-size, minimum-size, grow-threshold-percent, shrink-threshold-percent and mode to their defaults.

=end html

=back



=over 2

=item * I<shrink-threshold-percent>  =>   B<integer, optional>

=begin html

<br>Specifies the percentage of the flexible volume's capacity at which autoshrink is initiated. The default shrink theshold is 50%. It is an error for the shrink threshold to be greater than or equal to the grow threshold. Range : [0..100]

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>The name of the flexible volume for which we want to set autosize.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_charmap_get

[B<Family:> ontap-classic, vfiler]


=begin html

Return charmap information for a specified volume.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume on which to list the charmap information.

=end html

=back



B<Outputs>

=over 2

=item * I<charmap>  =>   B<string, optional>

=begin html

<br>null

=end html

=back



=head2 volume_charmap_set

[B<Family:> ontap-classic, vfiler]


=begin html

Associate a charmap description with a specified volume.

=end html



B<Inputs>

=over 2

=item * I<charmap>  =>   B<string, optional>

=begin html

<br>Description of the character mapping to be done for this volume. This mapping is to allow CIFS clients to use NFS file names that would otherwise result in invalid CIFS names. The values are comma-separated pairs of hex character mappings. The A-F hex values can be in upper or lower case, and the values do not have to be padded. Example: "5c:f2e1,3c:b6,3e:ae,7C:394". If a value is not passed, any existing charmap will be removed.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume with which the charmap is to be associated.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_clone_create

[B<Family:> ontap-classic, vfiler]


=begin html

Create a flexible volume that is a clone of a "backing" or "parent" flexible volume. A clone is a volume that is a writable snapshot of another volume. Initially, the clone and its parent share the same storage; more storage space is consumed only as one volume or the other changes. If a specific snapshot name within the parent volume is provided, it is chosen as the parent snapshot. Otherwise, the filer will create a new, distinctively- named snapshot in the parent volume for that purpose. The parent snapshot is locked in the parent volume, preventing its deletion until the clone is either destroyed or split from the parent using the 'volume-clone-split-start' command (see below). This command fails if the chosen parent volume is currently involved in a split operation. This command also fails if the chosen parent volume is a traditional volume. Cloning is a new capability that applies exclusively to flexible volumes.

=end html



B<Inputs>

=over 2

=item * I<force-worm-clone>  =>   B<boolean, optional>

=begin html

<br>If set to 'true', forces the creation of clone on a worm volume. If set to 'false', clone creation on any worm volume will fail, because clones of worm volumes are not deletable until all the inherited worm files on newly created clone have expired. Default value is false.

=end html

=back



=over 2

=item * I<parent-snapshot>  =>   B<string, optional>

=begin html

<br>Name of the snapshot within 'parent-volume' that is to serve as the parent snapshot for the clone. If not provided, the filer will create a new snapshot named 'clone_parent_<UUID>' (using a freshy-generated UUID) in 'parent-volume' for this purpose.

=end html

=back



=over 2

=item * I<parent-volume>  =>   B<string>

=begin html

<br>Name of the parent flexible volume for the clone.

=end html

=back



=over 2

=item * I<qos-policy-group-name>  =>   B<string, optional>

=begin html

<br>The QoS Policy Group Name that is to be associated with this FlexClone volume in order to enforce Service Level Objectives (SLO). If you do not assign a QoS policy group to a volume, the system will not monitor and control the traffic to it. Note that "none" is a reserved keyword used to remove the association of a storage object to a QoS policy group. Specifying "none" as a QoS policy group in this command would have no effect.

=end html

=back



=over 2

=item * I<space-reserve>  =>   B<string, optional>

=begin html

<br>Specifies the type of volume guarantee for the clone. Possible values: none, file, volume. If this argument is not provided, then guarantee type is inherited from parent volume.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Desired name of the clone.

=end html

=back



=over 2

=item * I<volume-type>  =>   B<string, optional>

=begin html

<br>The type of the volume to be created. Possible values: <ul> <li> "rw" - read-write volume (default setting), <li> "dp" - data-protection volume </ul> If not provided, the filer will assume the default value i.e. "rw" volume. Creation of data-protection volume clone is only allowed from parent-volume which is paloma logical DP volume.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_clone_split_estimate

[B<Family:> ontap-classic, vfiler]


=begin html

Display an estimate of additional storage required in the underlying aggregate to perform a volume clone split operation. This command fails if applied to a traditional volume. Cloning is a new capability that applies exclusively to flexible volumes.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>The name of the clone whose split usage is being estimated.

=end html

=back



B<Outputs>

=over 2

=item * I<clone-split-estimate>  =>   B<L<"clone-split-estimate-info">[]>

=begin html

<br>An estimate of the number of blocks required in the enclosing aggregate to split a clone from its parent.

=end html

=back



=head2 volume_clone_split_start

[B<Family:> ontap-classic, vfiler]


=begin html

Begin the process by which the given clone is split off from its underlying parent volume and snapshot. New storage is allocated for the clone that is distinct from its parent. This process may take some time and proceeds in the background. Use the 'volume-clone-split-status' command to view the operation's progress. Both clone and parent volumes remain available during the process of splitting them apart. Upon completion, the snapshot on which the clone was based will be unlocked in the parent volume. Any snapshots in the clone are removed at the end of processing. Use the 'volume-clone-split-stop' command to stop this process. This command fails if applied to a traditional volume. Cloning is a new capability that applies exclusively to flexible volumes. <p> In Data ONTAP Cluster-Mode, a job is created to perform the split operation. The job id of the job is returned in the API response. The progress of the job can be tracked using the job APIs.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the clone that we want split off from its parent volume and snapshot.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_clone_split_status

[B<Family:> ontap-classic, vfiler]


=begin html

Display the progress in separating clones from their underlying parent volumes and snapshots. If a clone name is specified, then the split status for that clone is provided. If no clone name is provided, then status is provided for all clones currently being split. This command fails if applied to a traditional volume, and EONTAPI_EVOLNOTFLEX is thrown. Cloning is a capability that applies exclusively to flexible volumes. This command fails if the volume specified is not a clone, and EVOLNOTCLONE is thrown. This command fails if the volume specified is not being split, and EVOLOPNOTUNDERWAY is thrown.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string, optional>

=begin html

<br>The name of the clone being split off from its parent volume and snapshot for which we want status.

=end html

=back



B<Outputs>

=over 2

=item * I<clone-split-details>  =>   B<L<"clone-split-detail-info">[], optional>

=begin html

<br>List of clones that are currently being split from their parent volumes, along with all relevant status information.

=end html

=back



=head2 volume_clone_split_stop

[B<Family:> ontap-classic, vfiler]


=begin html

Stop the process of splitting off a clone from its parent volume and snapshot. All of the blocks that were formerly shared between the given clone and its parent volume that have already been split off will remain that way. This command fails if applied to a traditional volume. Cloning is a new capability that applies exclusively to flexible volumes.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>The name of the clone for which we want to stop the process of being split off from its parent volume and snapshot.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_container

[B<Family:> ontap-classic, vfiler]


=begin html

Return the name of the containing aggregate for the named flexible volume.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>The name of the flexible volume for which we want the containing aggregate.

=end html

=back



B<Outputs>

=over 2

=item * I<containing-aggregate>  =>   B<string>

=begin html

<br>Name of the given volume's containing aggregate, if applicable.

=end html

=back



=head2 volume_create

[B<Family:> ontap-classic]


=begin html

Create a volume. <p> The detailed behavior of this API depends on where it is received: <p> 1. In Data ONTAP Cluster-Mode, create a new flexible volume. <p> 2. In Data ONTAP 7-Mode, create a new flexible, traditional, or sparse volume with the given name and characteristics. Freshly-created traditional volumes may not be operational immediately after the API returns. Use 'volume-list-info' to obtain information about volumes, including the status of the newly-created traditional volume in order to determine when it is fully operational. <p> This API is not supported for Infinite Volumes.

=end html



B<Inputs>

=over 2

=item * I<constituent-role>  =>   B<string, optional>

=begin html

<br>This field specifies the role of a constituent within an Infinite Volume. This field is only supported for Infinite Volume constituents and this API will fail if no value is passed for an Infinite Volume constituent. <p> Possible values: <ul> <li> 'namespace' ... namespace constituent, <li> 'data' ... data constituent, <li> 'ns_mirror' ... namespace mirror constituent </ul>

=end html

=back



=over 2

=item * I<containing-aggr-name>  =>   B<string, optional>

=begin html

<br><b>Flexible</b> volumes only. The name of the aggregate in which to create the new flexible volume. If provided, this argument must be accompanied by the "size" parameter described below. <p> This input is required for creating a Cluster-Mode volume.

=end html

=back



=over 2

=item * I<disk-count>  =>   B<integer, optional>

=begin html

<br><b>Traditional</b> volumes only. Number of disks to place into the new traditional volume, including the parity disks. The disks in this newly-created traditional volume come from the spare disk pool. The smallest disks in this pool join the traditional volume first, unless the "disk-size" argument is specified. Either "disk-count" or "disks" must be supplied for traditional volumes. Range [0..2^31-1].

=end html

=back



=over 2

=item * I<disk-size>  =>   B<integer, optional>

=begin html

<br><b>Traditional</b> volumes only. Disk size in 4KB blocks. Disks that are within 20% of the specified size will be selected for use in the traditional volume. If neither "disk-size" nor "disk-size-with-unit" is specified, existing groups are appended with disks that are the best match for the largest disk in the group. When starting new groups, the smallest disks are selected first. This option is ignored if a specific list of disks to use is specified through the "disks" parameter. Range [0..2^31-1]. You must only use one of either "disk-size" or "disk-size-with-unit" parameters. If both appear, an error message will be returned.

=end html

=back



=over 2

=item * I<disk-size-with-unit>  =>   B<string, optional>

=begin html

<br><b>Traditional</b> volumes only. Disk size in the specified unit. It is a positive integer number followed by unit of "T", "G", "M" or "K". This option is ignored if a specific list of disks to use is specified through the "disks" parameter. You must only use one of either "disk-size" or "disk-size-with-unit" parameters. If both appear, an error message will be returned.

=end html

=back



=over 2

=item * I<disks>  =>   B<L<"disk-info">[], optional>

=begin html

<br><b>Traditional</b> volumes only. Specific list of disks to use for the new volume. If "mirrored" is set to true and a specific list of disks is supplied, the "mirror-disks" list with the same number of disks must also be supplied. Either "disk-count" or "disks" must be supplied when creating traditional volumes.

=end html

=back



=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br><b>Traditional</b> volumes only. Disks in a plex are not normally permitted to span spare pools. This behavior is overridden with this option when it is set to "true".

=end html

=back



=over 2

=item * I<is-mirrored>  =>   B<boolean, optional>

=begin html

<br><b>Traditional</b> volumes only. Specifies that the new traditional volume be mirrored (have two plexes). If set to "true", then the indicated disks will be split across the two plexes. By default, the new volume will not be mirrored.

=end html

=back



=over 2

=item * I<is-snaplock>  =>   B<boolean, optional>

=begin html

<br>Specifies the creation of a SnapLock volume. By default, is-snaplock is not specified. When is-snaplock is "true" the type of snaplock volume is determined in the following way - 1> If snaplock-type is set, create the type specified in snaplock-type (see snaplock-type for more details) 2> Otherwise, create a Snaplock enterprise volume if a Snaplock enterprise license has been installed. 3> Otherwise, create a Snaplock compliance volume. ESERVICENOTLICENSED is returned if the required Snaplock Compliance or Enterprise license is not installed. EONTAPI_EWORMNOCLOCK is returned if SnapLock Compliance Clock is not running. If you need to create a snaplock volume, the suggested method is to specify snaplock-type as "compliance" or "enterprise" and not specify is-snaplock at all. If you want to create a non-snaplock volume, the suggested method is to specify neither snaplock-type nor is-snaplock.

=end html

=back



=over 2

=item * I<language-code>  =>   B<string, optional>

=begin html

<br>Specifies the language to use for the new volume via a language code. The default language is the one used by the filer's root volume. Available language codes are: <ul> <li> 'C' ... POSIX, <li> 'ar' ... Arabic, <li> 'cs' ... Czech, <li> 'da' ... Danish, <li> 'de' ... German, <li> 'en' ... English, <li> 'en_US' ... English (US), <li> 'es' ... Spanish, <li> 'fi' ... Finnish, <li> 'fr' ... French, <li> 'he' ... Hebrew, <li> 'hr' ... Croatian, <li> 'hu' ... Hungarian, <li> 'it' ... Italian, <li> 'ja' ... Japanese euc-j*, <li> 'ja_v1' ... Japanese euc-j, <li> 'ja_JP.PCK' ... Japanese PCK (sjis)*, <li> 'ja_JP.932' ... Japanese cp932*, <li> 'ja_JP.PCK_v2' ... Japanese PCK (sjis), <li> 'ko' ... Korean, <li> 'no' ... Norwegian, <li> 'nl' ... Dutch, <li> 'pl' ... Polish, <li> 'pt' ... Portuguese, <li> 'ro' ... Romanian, <li> 'ru' ... Russian, <li> 'sk' ... Slovak, <li> 'sl' ... Slovenian, <li> 'sv' ... Swedish, <li> 'tr' ... Turkish, <li> 'zh' ... Simplified Chinese, <li> 'zh.GBK' ... Simplified Chinese (GBK), <li> 'zh_TW' ... Traditional Chinese euc-tw, <li> 'zh_TW.BIG5' ... Traditional Chinese Big 5 </ul> <p> To use UTF-8 as the NFS character set, append '.UTF-8' to the language code.

=end html

=back



=over 2

=item * I<mirror-disks>  =>   B<L<"disk-info">[], optional>

=begin html

<br><b>Traditional</b> volumes only. List of mirror disks to use. It must contain the same number of disks specified in "disks".

=end html

=back



=over 2

=item * I<qos-policy-group-name>  =>   B<string, optional>

=begin html

<br>The QoS Policy Group Name that is to be associated with this volume in order to enforce Service Level Objectives (SLO). If you do not assign a QoS policy group to a volume, the system will not monitor and control the traffic to it. NOTE: "none" is a reserved keyword for deleting the association of the volume with a QoS policy group. Specifying "none" as a the QoS policy group during volume creation will have no effect. This parameter is not supported on Infinite Volumes.

=end html

=back



=over 2

=item * I<raid-size>  =>   B<integer, optional>

=begin html

<br><b>Traditional</b> volumes only. Specifies the maximum number of disks in each RAID group in the traditional volume. The maximum value for this parameter is of raidsize is 28. The default value is platform-dependent. The valid range of values is also platform-dependent, but never wider than [2..28].

=end html

=back



=over 2

=item * I<remote-location>  =>   B<string, optional>

=begin html

<br>Specifies the remote host and volume name for the origin of the FlexCache. A FlexCache license is necessary for this option to be utilized. The default action is not to create a FlexCache Volume. Format: <Remote-Host>:<Remote-Volume> Create a sparse volume as a FlexCache for the given remote host and remote volume name. Remote Host: Should be formatted as either the DNS hostname or as an IP address. Remote Volume: Should be formatted the same as a volume name. ESERVICENOTLICENSED is returned if the FlexCache service is not licensed. EINVALIDINPUT is returned if the host, or source volume is found to be invalid.

=end html

=back



=over 2

=item * I<size>  =>   B<string, optional>

=begin html

<br><b>Flexible</b> volumes only. The initial size of the new flexible volume. The format to use is: &lt number &gt k|m|g|t where "k" means kilobytes, "m" means megabytes, "g" means gigabytes, and "t" means terabytes. If the trailing unit character doesn't appear, then &lt number &gt is interpreted as the number of bytes desired. If provided, this argument must be accompanied by the "containing-aggr-name" parameter described above.

=end html

=back



=over 2

=item * I<snaplock-type>  =>   B<string, optional>

=begin html

<br>Specifies the type of Snaplock volume to be created. Possible values - "compliance" or "enterprise" ESERVICENOTLICENSED is returned if the necessary Snaplock compliance or enterprise license has not been installed. EINVALIDINPUT is returned if snaplock-type has an illegal value or if is-snaplock has been set to "false". EONTAPI_EWORMNOCLOCK is returned if SnapLock Compliance Clock is not running.

=end html

=back



=over 2

=item * I<space-reserve>  =>   B<string, optional>

=begin html

<br>Specifies the type of volume guarantee the new volume will use. Possible values: none, file, volume. If this argument is not provided, the default volume guarantee type is volume. <p> If this argument is not specified for the creation of constituents of an Infinite Volume that does not support storage services, the default guarantee is the guarantee of the Infinite Volume.

=end html

=back



=over 2

=item * I<storage-service>  =>   B<string, optional>

=begin html

<br>Name of the storage service with which to associate the creation of a constituent of an Infinite Volume. <p> This argument is required for the creation of constituents of an Infinite Volume that supports storage services. If the storage service does not exist before creating the constituent, it will be automatically created. Clients can query for the 'is-managed-by-service' field to determine if an Infinite Volume supports storage services. <p> This argument is not supported for Flexible Volumes.

=end html

=back



=over 2

=item * I<vm-align-sector>  =>   B<integer, optional>

=begin html

<br>The Virtual Machine alignment 512 byte sector number. All files created with the suffix specified in the 'vm-align-suffix' input parameter will have zero-filled <512 * 'vm-align-sector'> bytes data at the beginning so that it's actual data starts at a different offset instead of zero. This is done so that the read & writes to such files are aligned to WAFL's 4k block boundary.

=end html

=back



=over 2

=item * I<vm-align-suffix>  =>   B<string, optional>

=begin html

<br>The Virtual Machine alignment suffix. The suffix such as '.xyz' is used to identify the files which needs to be aligned. This element can only be specified if the vm-align-sector input element is also specified. See the description for 'vm-align-sector' above for more information on this.

=end html

=back



=over 2

=item * I<volume>  =>   B<string, optional>

=begin html

<br>Name of the volume to create. The volume name can contain letters, numbers, and the underscore character (_), but the first character must be a letter or an underscore. In Data ONTAP Cluster-Mode, the volume names must be unique within a Vserver. In Data ONTAP 7-mode, the volume names must be unique on a controller. For an Infinite Volume constituent, the parameter is optional; if a name is not specified, DATA ONTAP will generate the correct name based on the constituent type.

=end html

=back



=over 2

=item * I<volume-raid-type>  =>   B<string, optional>

=begin html

<br><b>Traditional</b> volumes only. Specifies the type of RAID groups to use in the new traditional volume. The default is "raid4" on most platforms. Possible values: raid4, raid_dp.

=end html

=back



B<Outputs>

=over 2

=item * I<bad-disks>  =>   B<L<"disk-info">[], optional>

=begin html

<br><b>Traditional</b> volumes only. List of disks that were not added. This is only returned if there are bad disks.

=end html

=back



=head2 volume_decompress_abort

[B<Family:> ontap-classic, vfiler]


=begin html

Abort in-progress decompression scan of data in volume.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume. Ex: flex1, vol0 etc.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_decompress_start

[B<Family:> ontap-classic, vfiler]


=begin html

Start decompression of data in a volume. The volume should should have compressed data and it should not have compression option enabled.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume. Ex: flex1, vol0 etc.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_destroy

[B<Family:> ontap-classic, vfiler]


=begin html

Destroy the specified volume or plex. If a flexible volume is specified, all of its blocks are freed and returned to its containing aggregate; no other flexible volumes in the same containing aggregate (if any) are affected. If a traditional volume is specified, all of its plexes are destroyed, and its disks are returned to the appropriate spare pool(s). If a plex is specified, it must be for a mirrored aggregate (which could potentially be embedded in a traditional volume), leaving it unmirrored. Only offline volumes and plexes can be destroyed. Plexes are not supported for Cluster-Mode volumes. <p> This API is not supported for Infinite Volumes.

=end html



B<Inputs>

=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>Force the destruction of the volume even if a non-default vfiler has storage on it. Normally, the system will not destroy such a volume and will instead return EVOLUME_HAS_VFILER_STORAGE.

=end html

=back



=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Name of an existing volume or plex.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_footprint_list_info

[B<Family:> ontap-classic]


=begin html

Return a list of volumes and a breakdown of their data and metadata footprints in their parent aggregates. The term footprint is used to refer to the portion of aggregate used space that will be freed when the relevant volume is destroyed. This can exceed the size of the volume due to metadata. If no volume is specified, footprints are displayed for all online volumes on the filer. Note that if space footprint information for more than 20 volumes is desired, the volume-footprint-list-info-iter-* ZAPIs will be more efficient and should be used instead.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string, optional>

=begin html

<br>The name of the volume for which we want status information. If not supplied, then we want status for all volumes on the filer.

=end html

=back



B<Outputs>

=over 2

=item * I<vol-footprint-infos>  =>   B<L<"vol-footprint-info">>

=begin html

<br>Details of space utilization footprint in the hosting aggregate.

=end html

=back



=head2 volume_footprint_list_info_iter_end

[B<Family:> ontap-classic]


=begin html

Terminate a list iteration and clean up any saved info.

=end html



B<Inputs>

=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous volume-footprint-list-info-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_footprint_list_info_iter_next

[B<Family:> ontap-classic]


=begin html

Continues an iteration through the list of volumes.

=end html



B<Inputs>

=over 2

=item * I<maximum>  =>   B<integer>

=begin html

<br>The maximum number of entries to retrieve.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous volume-footprint-list-info-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>This tells you how many records are being returned from this particular call to volume-footprint-list-info-iter- next. When this value is 0, you have retrieved everything.

=end html

=back



=over 2

=item * I<vol-footprint-infos>  =>   B<L<"vol-footprint-info">[]>

=begin html

<br>List of volumes and their footprint information. See volume- footprint-list-info for a description of type vol-footprint-info.

=end html

=back



=head2 volume_footprint_list_info_iter_start

[B<Family:> ontap-classic]


=begin html

Starts an iteration through the list of volumes.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string, optional>

=begin html

<br>The name of the volume for which we want space footprint information. If not supplied, then we display space footprint for all volumes on the filer.

=end html

=back



B<Outputs>

=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>This tells you the number of items that have been saved for future retrieval with volume-footprint-list-info-iter-next.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag to be used in subsequent iterations.

=end html

=back



=head2 volume_get_filer_info



=begin html

Get information on what possibilities and parameters exist for volumes on a given filer.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<allowed-raidtypes>  =>   B<L<"raidtype-info">[]>

=begin html

<br>List of RAID types allowed for aggregates on this filer.

=end html

=back



=over 2

=item * I<checksum-types>  =>   B<string>

=begin html

<br>Checksum types supported by this filer. The possible values: <ul> <li> "zoned" - if all aggregates are Fixed VBN, <li> "block" - if all aggregates are Block Appended, <li> "mixed" - if aggregates are mixed (Fixed VBN and Block Appended and Advanced Zoned), <li> "none" - if no aggregates have zoned or block checksums or advanced_zoned checksum (azcs) or mixed, <li> "advanced_zoned" - if all aggregates have Advanced Zoned Checksum scheme. </ul>

=end html

=back



=over 2

=item * I<default-raidtype>  =>   B<string>

=begin html

<br>Default type of RAID used to protect against disk failure in aggregates on this filer. Possible values: raid0, raid4, raid_dp.

=end html

=back



=over 2

=item * I<disk-types>  =>   B<string>

=begin html

<br>Type of disks supported by this filer. Possible values: "512", "520", "4096", "mixed", "none". "512" if all disks are 512 BPS, "520" if all disks 520 BPS "4096" if all disks 4096 BPS, "mixed" if disks are mixed 512, 520 and 4096 BPS "none" if no disks have 512 or 520 or 4096 BPS.

=end html

=back



=over 2

=item * I<raidgroup-size>  =>   B<L<"raidgroup-size-info">[]>

=begin html

<br>List of the RAID group sizing parameters for each RAID type supported on this filer.

=end html

=back



=over 2

=item * I<root-volume>  =>   B<string>

=begin html

<br>Current root volume on the filer.

=end html

=back



=over 2

=item * I<snapshots-max>  =>   B<integer>

=begin html

<br>Maximum number of snapshots available per aggregate on the filer. Range : [0..2^31-1].

=end html

=back



=head2 volume_get_language

[B<Family:> ontap-classic, vfiler]


=begin html

Get the given volume's language mapping.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume for which we want the language mapping.

=end html

=back



B<Outputs>

=over 2

=item * I<language>  =>   B<string>

=begin html

<br>Set to the volume's language mapping, in the form "LanguageCode (Full Name)" (e.g. "en_US (English (US))"). For more information on these values, see 'volume-create'.

=end html

=back



=over 2

=item * I<language-code>  =>   B<string>

=begin html

<br>Set to the volume's language code, suitable for use as an argument to other functions (e.g. "en_US"). For more information on these values, see 'volume-create'.

=end html

=back



=over 2

=item * I<nfs-character-set>  =>   B<string>

=begin html

<br>The NFS language mapping character set that is currently in effect for the volume. <p> This field is of the following format: "&lt;nfs-character-set&gt;|&lt;display-name&gt;|&lt;asctime&gt;" <br/> Note that "|" is not an OR syntax. <p> &lt;asctime&gt; is the timestamp in the language configuration file header and its format is based on the standard: "A la ISO/IEC 9945-1, ANSI/IEEE Std 1003.1, Second Edition, 1996-07-12." <p> It uses the C Programming Language Printf format: "%.3s %.3s%3d %02d:%02d:%02d %s %d" <p> This format takes the following parameters in order: &lt;weekday name&gt;, &lt;month name&gt;, &lt;month day&gt;, &lt;hour&gt;, &lt;minute&gt;, &lt;second&gt;, &lt;timezone&gt; OR &lt;""&gt;, &lt;year&gt; <p> E.g., If the volume language code is set to "en_US", the default NFS character set is as follows:<br/> "iso-8859-1|iso-8859-1|Thu Oct 1 15:00:53 PDT 1998"

=end html

=back



=over 2

=item * I<oem-character-set>  =>   B<string>

=begin html

<br>The OEM language mapping character set that is currently in effect for the volume. <p> This field is of the following format: "&lt;oem-code-page&gt;|&lt;display-name&gt;|&lt;asctime&gt;"<br/> Note that "|" is not an OR syntax. <p> &lt;asctime&gt; is the timestamp in the language configuration file header and its format is based on the standard: "A la ISO/IEC 9945-1, ANSI/IEEE Std 1003.1, Second Edition, 1996-07-12." <p> It uses the C Programming Language Printf format: "%.3s %.3s%3d %02d:%02d:%02d %s %d" <p> This format takes the following parameters in order: &lt;weekday name&gt;, &lt;month name&gt;, &lt;month day&gt;, &lt;hour&gt;, &lt;minute&gt;, &lt;second&gt;, &lt;timezone&gt; OR &lt;""&gt;, &lt;year&gt; <p> E.g., If the volume language code is set to "en_US", the default NFS character set is as follows:<br/> "cp437|cp437|Thu Oct 1 15:00:53 PDT 1998"

=end html

=back



=head2 volume_get_root_name

[B<Family:> ontap-classic, vfiler]


=begin html

Return the name of the "root" volume on the filer. If this request is executed in the context of a vfiler, the "root" volume of the vfiler will be returned. If this request is executed in the context of a Vserver the "namespace root" volume of the Vserver will be returned. If the "namespace root" volume of the Admin Vserver is requested, EVSERVER_OP_NOT_ALLOWED will be returned.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the root volume for the filer.

=end html

=back



=head2 volume_get_supported_guarantees

[B<Family:> ontap-classic, vfiler]


=begin html

Returns the list of guarantee types that are supported on this volume. This just does semantic checks and so enabling supported guarantees can still fail because of space checks.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume. Ex: flex1, vol0 etc.

=end html

=back



B<Outputs>

=over 2

=item * I<guarantee-types>  =>   B<L<"guarantee">[]>

=begin html

<br>List of guarantee types supported on this volume.

=end html

=back



=head2 volume_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Get volume status. Note that all RAID-related status items (e.g., 'raid-size', 'raid-status', 'checksum-style') reported for a flexible volume actually describe the state of its containing aggregate.

=end html



B<Inputs>

=over 2

=item * I<verbose>  =>   B<boolean, optional>

=begin html

<br>If set to "true", more detailed volume information is returned. If not supplied or set to "false", this extra information is not returned.

=end html

=back



=over 2

=item * I<volume>  =>   B<string, optional>

=begin html

<br>The name of the volume for which we want status information. If not supplied, then we want status for all volumes on the filer. Note that if status information for more than 20 volumes is desired, the volume-list-info-iter-* zapis will be more efficient and should be used instead.

=end html

=back



B<Outputs>

=over 2

=item * I<volumes>  =>   B<L<"volume-info">[]>

=begin html

<br>List of volumes and their status information.

=end html

=back



=head2 volume_list_info_iter_end

[B<Family:> ontap-classic, vfiler]


=begin html

Terminate a list iteration and clean up any saved info.

=end html



B<Inputs>

=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous volume-list-info-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_list_info_iter_next

[B<Family:> ontap-classic, vfiler]


=begin html

Continues an iteration through the list of volumes.

=end html



B<Inputs>

=over 2

=item * I<maximum>  =>   B<integer>

=begin html

<br>The maximum number of entries to retrieve.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous volume-list-info-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>This tells you how many records are being returned from this particular call to volume-list-info-iter-next. When this value is 0, you have retrieved everything.

=end html

=back



=over 2

=item * I<volumes>  =>   B<L<"volume-info">[]>

=begin html

<br>List of volumes and their status information. See volume-list-info for a description of type volume-info.

=end html

=back



=head2 volume_list_info_iter_start

[B<Family:> ontap-classic, vfiler]


=begin html

Starts an iteration through the list of volumes.

=end html



B<Inputs>

=over 2

=item * I<verbose>  =>   B<boolean, optional>

=begin html

<br>If set to "true", more detailed volume information is returned. If not supplied or set to "false", this extra information is not returned.

=end html

=back



=over 2

=item * I<volume>  =>   B<string, optional>

=begin html

<br>The name of the volume for which we want status information. If not supplied, then we want status for all volumes on the filer.

=end html

=back



B<Outputs>

=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>This tells you the number of items that have been saved for future retrieval with volume-list-info-iter-next.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag to be used in subsequent iterations.

=end html

=back



=head2 volume_mediascrub_list_info



=begin html

Get the RAID media scrubbing status on the named traditional volume, plex, or RAID group. If no name is given, then status is provided for all RAID groups currently undergoing media scrubbing.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string, optional>

=begin html

<br>Name of traditional volume, plex or RAID group for which media scrub status is desired. If no name is given, then status is provided for all RAID groups currently undergoing media scrubbing.

=end html

=back



B<Outputs>

=over 2

=item * I<mediascrub-details>  =>   B<L<"mediascrub-detail-info">[]>

=begin html

<br>List of RAID groups and their media scrub status.

=end html

=back



=head2 volume_mirror



=begin html

Turns an unmirrored traditional volume into a mirrored traditional volume by adding a plex to it. The plex is either newly formed from disks chosen from a spare pool or, if the "victim-volume" option is specified, is taken from another existing unmirrored volume. The volume must currently be unmirrored. Disks may be specified explicitly using the "mirror-disks" argument list option in the same way as with the 'volume-create' and 'volume-add' APIs. The number of disks specified must exactly match the number present in the existing traditional volume. If the disks to use are not explicitly specified, then the appropriate disks are automatically selected to match those already in the traditional volume's existing plex. It is not possible to directly mirror a flexible volume; if that is the goal, then consider using 'volume-container' to find the flexible volume's containing aggregate, then use 'aggr-mirror' to mirror that aggregate (which, of course, will case all other volumes contained in the given aggregate to become mirrored as well).

=end html



B<Inputs>

=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>Force the mirroring operation through, past the normal roadblocks that would otherwise cause it to be aborted. For example, disks in a plex are not normally permitted to span spare pools. This safety-drive behavior is overridden when the 'force' option is provided and set to 'true'.

=end html

=back



=over 2

=item * I<mirror-disks>  =>   B<L<"disk-info">[], optional>

=begin html

<br>Specific list of mirror disks to use. It must have the same number of disks as are present in the given traditional volume. The specified disks are not permitted to span disk pools; this behavior can be overridden with the "force" argument.

=end html

=back



=over 2

=item * I<victim-volume>  =>   B<string, optional>

=begin html

<br>The "victim" traditional volume to cannibalize in order to mirror the given traditional volume. The result is a mirrored traditional volume that is otherwise identical to the original volume before the operation. The "victim-volume" is effectively destroyed. "victim-volume" must have been previously mirrored with this volume, then separated via the "volume-split" command. "victim-volume" must be offline.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the traditional volume to be mirrored.

=end html

=back



B<Outputs>

=over 2

=item * I<bad-disks>  =>   B<L<"disk-info">[], optional>

=begin html

<br>List of disks that were not added. This is only returned if there are bad disks.

=end html

=back



=head2 volume_move_abort

[B<Family:> ontap-classic]


=begin html

Aborts the volume move operation of the specified source volume. This is a synchronous API.

=end html



B<Inputs>

=over 2

=item * I<source-volume>  =>   B<string>

=begin html

<br>Name of the volume whose move has to be aborted

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_move_cutover

[B<Family:> ontap-classic]


=begin html

Initiates a manual cutover operation on the specified source volume. This is a synchronous API. Cutover is the final phase of volume move operation after which destination volume takes the identity of the source volume. If cutover cannot be initiated or completed, the API will return with an error. The move will pause and an EMS message will be printed. The volume-move-status API will show the state of the move as move(paused). The user can resume or abort the move.

=end html



B<Inputs>

=over 2

=item * I<cutover-window>  =>   B<integer, optional>

=begin html

<br>Time interval to complete cutover in seconds. If not specified, then the existing value is maintained.

=end html

=back



=over 2

=item * I<source-volume>  =>   B<string>

=begin html

<br>Name of the volume, whose move is waiting for cutover to be initiated.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_move_pause

[B<Family:> ontap-classic]


=begin html

Pauses the volume move operation of the specified source volume. This is a synchronous API.

=end html



B<Inputs>

=over 2

=item * I<source-volume>  =>   B<string>

=begin html

<br>Name of the volume whose move must be paused

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_move_resume

[B<Family:> ontap-classic]


=begin html

Resumes a previously paused volume move operation of a specified source volume. This is an asynchronous API. It will run a series of checks to determine if the volume move can be resumed. If there are no errors or warnings, the API will return successfully. The move will be resumed. The status of the move can be obtained from the volume-move-status API. If any of the checks result in an error or warning, the API will return with an error. If the checks result in no errors but one or more warnings and is-override-warnings is set to true, the API will return successfully and the move will be resumed.

=end html



B<Inputs>

=over 2

=item * I<cutover-attempts>  =>   B<integer, optional>

=begin html

<br>Number of cutover attempts. If not specified, then the existing value is maintained.

=end html

=back



=over 2

=item * I<cutover-window>  =>   B<integer, optional>

=begin html

<br>Time interval to complete cutover in seconds. If not specified, then the existing value is maintained.

=end html

=back



=over 2

=item * I<is-keep-source>  =>   B<boolean, optional>

=begin html

<br>If specified, the source volume will not be destroyed after the move is complete.

=end html

=back



=over 2

=item * I<is-manual-cutover>  =>   B<boolean, optional>

=begin html

<br>If specified, user has to initiate cutover.

=end html

=back



=over 2

=item * I<is-override-warnings>  =>   B<boolean, optional>

=begin html

<br>If warnings are encountered during the resume, the default behavior is to pause. If is-override-warnings is true, the move will continue and return these warnings in the errors-warnings element.

=end html

=back



=over 2

=item * I<source-volume>  =>   B<string>

=begin html

<br>Name of the volume whose move must be resumed

=end html

=back



B<Outputs>

=over 2

=item * I<errors-warnings>  =>   B<L<"errors-warnings-info">[], optional>

=begin html

<br>Warnings when the move is resumed and is-override-warnings is set to true

=end html

=back



=head2 volume_move_start

[B<Family:> ontap-classic]


=begin html

This API is applicable to Data ONTAP 7-Mode as well as Data ONTAP Cluster-Mode. If the API is sent to a Data ONTAP 7-Mode controller, Vol Move will move a single 7-mode flexvol between two aggregates on the same controller. If the API is sent to the Admin Vserver LIF, the flexvol can be moved to any eligible aggregate in the cluster. The list of eligible aggregates can be obtained using the "volume-move-target-aggr-get-iter" API. This API will start the move. It will run a series of checks to determine if the volume can be moved. If any of the checks results in an error or warning, the API will return with an error. The user has to take the necessary corrective action before restarting the move. If all the checks pass, the API will return a success. If "perform-validation-only" is not true, the destination volume will be created and the move will start. By default, the move will cutover automatically. If "perform-validation-only" is set to true, all the errors and warnings encountered from the checks will be returned in the errors-warnings output element. The API will return successfully. The move will not be initiated. When the API is sent to a Data ONTAP 7-Mode controller, if "is-override-warnings" is set to true and the checks return no errors but one or more warnings, the API will return successfully. The warnings will be in the errors-warnings output element. If the API is sent to a Data ONTAP 7-Mode controller, the status of the move can be obtained using the "volume-move-status" API. If the move fails an EMS message will be generated. The reason for the failure can be obtained from the volume-move-status API. After a successful move, the source volume will be destroyed unless the user has specified the "is-keep-source" option. If cutover cannot be completed in the default or user specified number of attempts, an EMS message will be printed and the move will pause. The reason for the pause will be available in the "volume-move-status" API. The user can either resume or abort the move. This is an asynchronous API. If the API is sent to the Admin Vserver LIF, a background job will be created and the API returns immediately with the job ID information. The status of the move job can be obtained by using "job-get" or "job-get-iter" API.

=end html



B<Inputs>

=over 2

=item * I<cutover-attempts>  =>   B<integer, optional>

=begin html

<br>Number of cutover attempts. Default value is 3

=end html

=back



=over 2

=item * I<cutover-window>  =>   B<integer, optional>

=begin html

<br>Time interval to complete cutover in seconds. Default value for Data ONTAP Cluster-Mode volume move is 45 seconds. Default value for Data ONTAP 7-mode volume move is 60 seconds.

=end html

=back



=over 2

=item * I<dest-aggr>  =>   B<string>

=begin html

<br>Name of the destination aggregate

=end html

=back



=over 2

=item * I<is-keep-source>  =>   B<boolean, optional>

=begin html

<br>If specified, the source volume will not be destroyed after the move is complete. Default is false.

=end html

=back



=over 2

=item * I<is-manual-cutover>  =>   B<boolean, optional>

=begin html

<br>If specified, user has to initiate cutover. Default is false.

=end html

=back



=over 2

=item * I<is-override-warnings>  =>   B<boolean, optional>

=begin html

<br>If warnings are encountered during the move, the default behavior is to stop. If is-override-warnings is true, the move will continue and return these warnings in the errors-warnings element. Default is false.

=end html

=back



=over 2

=item * I<perform-validation-only>  =>   B<boolean, optional>

=begin html

<br>Run pre-checks for the move, return all the errors and warning messages encountered during the checks in the errors-warnings element and exit. The move will not be triggered. Default is false.

=end html

=back



=over 2

=item * I<source-volume>  =>   B<string>

=begin html

<br>Name of the volume that must be moved

=end html

=back



B<Outputs>

=over 2

=item * I<errors-warnings>  =>   B<L<"errors-warnings-info">[], optional>

=begin html

<br>Errors and warnings if perform-validation-only is set to true

=end html

=back



=head2 volume_move_status

[B<Family:> ontap-classic]


=begin html

Obtains the status of the volume move operation. This is a synchronous API.

=end html



B<Inputs>

=over 2

=item * I<is-verbose>  =>   B<boolean, optional>

=begin html

<br>If not supplied or set to "false", output shows source volume, destination aggregate, cutover window, cutover attempts and state of move. If set to "true", verbose output containing details about last and current snapmirror transfer in addition to above parameters is returned.

=end html

=back



=over 2

=item * I<source-volume>  =>   B<string, optional>

=begin html

<br>Name of the volume that is being moved. If source-volume is not provided, then the status of all active moves is listed. If it is provided the status of the move of source-volume is returned. Since this version will support only one move at a time, this input will not alter the output returned by this API.

=end html

=back



B<Outputs>

=over 2

=item * I<status>  =>   B<L<"vol-move-status-info">[]>

=begin html

<br>Status of the vol move

=end html

=back



=head2 volume_offline

[B<Family:> ontap-classic, vfiler]


=begin html

Take the specified volume or plex offline, making it unavailable for both user-level data access and RAID-level access (unless it's a flexible volume, at which time its containing aggregate is not affected in any way, and will remain fully online). The operation takes effect before the API returns except in maintenance mode, when the current root volume may not be taken offline. A volume marked to become the root cannot be taken offline. Taking a flexible volume offline does not affect its containing aggregate in any way. A number of operations being performed on the given volume (or its containing aggregate) can prevent this operation from succeeding, either at all or for various lengths of time. If such operations are found, the system waits up to one second for them to finish. If they don't, the command is aborted. A check is also made for files on the volume opened by internal ONTAP processes. The command is aborted if any are found. Plexes are not supported for Cluster-Mode volumes. <p> This API is not supported for Infinite Volumes.

=end html



B<Inputs>

=over 2

=item * I<cifs-delay>  =>   B<integer, optional>

=begin html

<br>If a volume contains CIFS shares, users should be warned before taking the volume offline. This argument specifies the number of minutes to delay before taking the volume offline, during which time CIFS users are warned of the pending loss of service. A 'cifs-delay' time of 0 means that the volume is to be taken offline immediately without issuing any warnings. CIFS users can lose data if they are not given a chance to terminate applications gracefully. By default, the value of 'cifs-delay' is 0.

=end html

=back



=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Name of an existing volume or plex. If a volume contains CIFS shares, users should be warned before taking the volume offline. Use "cifs-delay" to specify number of seconds to wait. If a plex is specified, the plex must be part of a mirrored volume, and both plexes must be online. Prior to offlining a plex, the system will flush all internally-buffered data associated with the plex and create a snapshot that is written out to both plexes. The snapshot allows for efficient resynchronization when the plex is subsequently brought back online.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_online

[B<Family:> ontap-classic, vfiler]


=begin html

Bring the specified volume or the plex online. This command takes effect immediately. If there are CIFS shares associated with the volume, they are enabled. Plexes are not supported for Cluster-Mode volumes. <p> This API is not supported for Infinite Volumes.

=end html



B<Inputs>

=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Name of an existing volume or plex. If a volume is specified, it must be currently offline, restricted, or foreign. If the volume is foreign, it will be made native before being brought online. A ``foreign'' volume is a traditional volume that consists of disks moved from another filer and that has never been brought online on the current filer. Traditional volumes that are not foreign are considered ``native.'' If the volume is inconsistent, but has not lost data, it is advisable to run WAFL_check or wafliron (or do a 'snapmirror initialize' in case of a replica volume) prior to bringing an inconsistent volume online. Bringing an inconsistent volume online increases the risk of further file system corruption. If the volume is inconsistent and has experienced possible loss of data, it cannot be brought online unless WAFL_check or wafliron (or 'snapmirror initialize') has been run on the volume. If a plex is specified, the plex must be part of an online mirrored traditional volume or aggregate. The system will initiate resynchronization of the plex as part of online processing.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_options_list_info

[B<Family:> ontap-classic, vfiler]


=begin html

Get the options that have been set for the specified volume.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the existing volume for which we want option information.

=end html

=back



B<Outputs>

=over 2

=item * I<options>  =>   B<L<"volume-option-info">[]>

=begin html

<br>List of options set for this volume.

=end html

=back



=head2 volume_rename

[B<Family:> ontap-classic, vfiler]


=begin html

Renames the specified volume to a new name specified by "new-volume-name". If the volume is referenced in the /etc/exports file, remember to make the name change in /etc/exports also so that the affected file system can be exported by the filer after the filer reboots. The "volume-rename" command does not automatically update the /etc/exports file. <p> This API is not supported for Infinite Volumes.

=end html



B<Inputs>

=over 2

=item * I<new-volume-name>  =>   B<string>

=begin html

<br>New volume name.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of an existing volume.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_restrict

[B<Family:> ontap-classic, vfiler]


=begin html

Restrict the specified volume, making it unavailable for user-level data access but leaving it (or its containing aggregate, if it's a flexible volume) available to internal OnTAP RAID-level access. <p> This API is not supported for Infinite Volumes. This API is not supported on Infinite Volume constituents.

=end html



B<Inputs>

=over 2

=item * I<cifs-delay>  =>   B<integer, optional>

=begin html

<br>If a volume contains CIFS shares, users should be warned before restricting the volume . This argument specifies the number of minutes to delay before restricting the volume, during which time CIFS users are warned of the pending loss of service. A 'cifs-delay' time of 0 means that the volume is to be restricted immediately without issuing any warnings. CIFS users can lose data if they are not given a chance to terminate applications gracefully. By default, the value of 'cifs-delay' is 0.

=end html

=back



=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Name of the volume to restrict.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_scrub_list_info



=begin html

Get the status of RAID parity scrubbing on the named traditional volume, plex, or RAID group. If no name is given, then status is provided for all RAID groups currently undergoing scrubbing. Scrubbing status includes a percent-complete value and its suspended status (if any).

=end html



B<Inputs>

=over 2

=item * I<name>  =>   B<string, optional>

=begin html

<br>Name of an existing traditional volume, plex, or RAID group. If no name is given, then status is generated for all RAID groups currently being scrubbed.

=end html

=back



=over 2

=item * I<verbose>  =>   B<boolean, optional>

=begin html

<br>If set to "true", this operation will be verbose. If not supplied or set to 'false', normal output levels will be used.

=end html

=back



B<Outputs>

=over 2

=item * I<scrub-details>  =>   B<L<"scrub-detail-info">[]>

=begin html

<br>List of RAID groups and their scrub status.

=end html

=back



=head2 volume_scrub_resume



=begin html

Resume RAID parity scrubbing on the named traditional volume, plex, or RAID group. If no name is given, then resume scrubbing on all RAID groups for which it is suspended.

=end html



B<Inputs>

=over 2

=item * I<name>  =>   B<string, optional>

=begin html

<br>Name of the existing traditional volume, plex, or RAID group for which the scrubbing is to resume.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_scrub_start



=begin html

Start RAID parity scrubbing on the named traditional volume, plex, or RAID group. RAID parity scrubbing compares the data disks to the parity disk in a RAID group, correcting the parity disk's contents as necessary. If a plex name is given, then scrubbing is started on all RAID groups contained in the plex. If a RAID group name is given, then scrubbing is started only in that RAID group. If no name is given, then scrubbing is started on the RAID groups within all online traditional volumes and aggregates. Use 'volume-scrub-list-info' to check scrub status.

=end html



B<Inputs>

=over 2

=item * I<name>  =>   B<string, optional>

=begin html

<br>Name of an existing traditional volume, plex, or RAID group.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_scrub_stop



=begin html

Stop RAID parity scrubbing on the named volume, plex, or group; if no name is given, on all RAID groups currently undergoing parity scrubbing.

=end html



B<Inputs>

=over 2

=item * I<name>  =>   B<string, optional>

=begin html

<br>Name of an existing volume, plex, or raid-group.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_scrub_suspend



=begin html

Suspend RAID parity scrubbing on the named traditional volume, plex, or RAID group. If no name is given, suspend scrubbing on all RAID groups currently being scrubbed.

=end html



B<Inputs>

=over 2

=item * I<name>  =>   B<string, optional>

=begin html

<br>Name of an existing traditional volume, plex, or RAID group.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_set_language

[B<Family:> ontap-classic, vfiler]


=begin html

Set the given volume's language mapping.

=end html



B<Inputs>

=over 2

=item * I<language-code>  =>   B<string>

=begin html

<br>The new language mapping for the volume. For a list of legal language mapping values, see 'volume-create'.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume that is to have its language mapping changed.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_set_option

[B<Family:> ontap-classic, vfiler]


=begin html

Set the option named 'option-name' to the value specified by 'option-value' in the specified volume. The change remains effective even after the filer is rebooted. Some options have values that are numbers or strings, and others have values that are 'on' (also expressible as 'yes', 'true', or '1' ) or "off" (also expressible as 'no', 'false', or '0'). A mixture of uppercase and lowercase characters may be used for an option's value. Note that the 'root' option is special in that it does not have an associated value. Also, note that some of these options can NOT be set for a flexible volume, as they relate only to aggregates (either free-standing ones or those embedded in traditional volumes). Other options may only apply for flexible volumes.

=end html



B<Inputs>

=over 2

=item * I<option-name>  =>   B<string>

=begin html

<br>Name of the option to be set. Possible values: <dl> <dt>"convert_ucode" (value: "on" | "off")</dt> <dd> Setting this option to "on" forces conversion of all directories to UNICODE format when accessed from both NFS and CIFS. By default, it is set to "off", in which case access from CIFS causes conversion of pre-4.0 and 4.0- format directories. Access from NFS causes conversion of 4.0 format directories. This option cannot be set on a Cluster-Mode volume unless it was transitioned from 7-Mode. </dd><br> <dt>"snapshot_clone_dependency" (value: "on" | "off")</dt> <dd> Setting this option "on" will unlock all initial and intermediate backing snapshots for all inactive LUN clones. For active LUN clones, only the backing snapshot will be locked. If the option is "off" the backing snapshot will remain locked until all intermediate backing snapshots are deleted. This option is not valid for a Cluster-Mode volume. </dd><br> <dt>"create_reserved"</dt> <dd> This option is no longer supported. </dd><br> <dt>"create_ucode" (value: "on" | "off")</dt> <dd> Setting this option to "on" forces UNICODE format directories to be created by default, both from NFS and CIFS. The default value is "off", in which case all directories are created in pre-4.0 format and only converted to UNICODE format upon the first CIFS access. This option cannot be set on a Cluster-Mode volume. </dd><br> <dt>"extent" (value: "on" | "space_optimized" | "off")</dt> <dd> Setting this option to "on" enables extents in the volume. This causes application writes to be written in the volume as a write of a larger group of related data blocks called an extent. Using extents may help workloads that perform many small random writes followed by large sequential reads. However, using extents may increase the amount of disk operations performed on the filer, so this option should only be used where applicable. The default value is "off", in which case extents are not used. The value "space_optimized" indicates extent updates will not duplicate snapshot blocks into the active file system, thereby using space conservatively. The "space_optimized" value may result in degraded snapshot read performance; and may only be used for <b>flexible</b> volumes. </dd><br> <dt>"fractional_reserve" (value: &lt number &gt)</dt> <dd> This option decreases the amount of space reserved for overwrites of reserved objects (LUNs, files) in a volume. The option is set to 100 by default and indicates that 100% of the required reserved space will actually be reserved so the objects are fully protected for overwrites. The value can vary from 0 to 100. Using a value of less than 100 indicates what percentage of the required reserved space should actually be reserved. This returns the extra space to the available space for the volume, decreasing the total amount of space used. However, this does leave the protected objects in the volume vulnerable to out of space errors since less than 100% of the required reserved space is actually reserved. If reserved space becomes exhausted this will cause disruptions on the hosts using the objects. If the percentage is decreased below 100%, it is highly recommended that the administrator actively monitor the space usage on the volume and take corrective action if the reserved space nears exhaustion. </dd><br> <dt>"fs_size_fixed" (value: "on" | "off")</dt> <dd> Setting this option to "on" causes the file system to remain the same size (and not grow) when a SnapMirror relationship is broken, or when a "vol/aggr add" is performed on it. This option is automatically set to be "on" when a volume becomes a SnapMirrored. It remains "on" after the "snapmirror break" command is issued for the volume. This option allows a volume to be SnapMirrored back to the source without needing grow the source volume. If the volume size is larger than the file system size, turning off this option forces the file system to grow to the size of the volume. </dd><br> <dt>"guarantee" (value: "none" | "file" | "volume")</dt> <dd> <b>Flexible</b> volumes only. Setting this option controls the type of space reservation for the named flexible volume. There are three possible settings. The first, "none", provides no guarantee that there will be enough blocks in the containing aggregate to meet the flexible volume's needs. The second, "file", guarantees there will be enough blocks in the containing aggregate to meet the needs of the specified files in the flexible volume. The third, "volume", is the default setting and guarantees there will be enough blocks available in the containing aggregate to meet the entire flexible volume's needs. An error will be returned if an attempt is made to set this option on a traditional volume. </dd><br> <dt>"ignore_inconsistent" (value: "on" | "off")</dt> <dd> This option can only be set in maintenance mode. If set to "on", then the root volume may be brought online when booting even if it is marked as inconsistent. The user is cautioned that bringing it online prior to running WAFL_check or wafliron may result in further file system inconsistency. </dd><br> <dt>"maxdirsize" (value: &lt number &gt)</dt> <dd> Set the maximum size (in KBytes) to which any directory can grow. The default setting of 10240 limits directory size to 10 MBytes and allows it to hold up to approximately 300,000 files. The number of files that the directory actually can hold varies depending on such things as the length of the names and whether it needs to use double-byte UNICODE characters. Most users should not need to change this option's setting. This option is useful for environments where system users may grow a directory to a size that starts impacting system performance. When a user tries to create a file in a directory that is at the limit, the system returns a ENOSPC error and fails the create. </dd><br> <dt>"max_write_alloc_blocks" (value: &lt number &gt)</dt> <dd> Set the maximum number of blocks used for write allocation. The default setting, 0, uses the system-wide default number of blocks, which should be optimal for most users. Some sequential read workloads may benefit from increasing this value. On rare occasions, some multi-stream sequential write workloads may benefit from decreasing this value. Range: [0..2048]. </dd><br> <dt>"minra" (value: "on" | "off")</dt> <dd> Setting this option to "on" causes the filer to perform minimal read-ahead on this volume. By default, this option is "off", causing the filer to perform very aggressive read-ahead on the volume. </dd><br> <dt>"no_atime_update" (value: "on" | "off")</dt> <dd> Setting this option to "on" prevents the update of inode access times when a file is read. This option is useful for volumes with extremely high read traffic, since it prevents writes to the inode file for the volume from contending with reads from other files. It should be used carefully. That is, use this option when you know in advance that the correct access time for inodes will not be needed for files on that volume. </dd><br> <dt>"no_i2p" (value: "on" | "off")</dt> <dd> Setting this option to "on" disables inode to parent pathname translations on the volume. The default setting is off. </dd><br> <dt>"nosnap" (value: "on" | "off")</dt> <dd> Setting this option to "on" disables automatic snapshots on the volume. This option is not supported for Cluster-Mode volumes. </dd><br> <dt>"nosnapdir" (value: "on" | "off")</dt> <dd> Setting this option to "on" disables the visible .snapshot directory that is normally present at system internal mount points. It also turns off access to all other .snapshot directories in the volume. </dd><br> <dt>"nvfail" (value : "on" | "off")</dt> <dd> If this option is on, the filer performs additional work at boot time if it finds that there has been any potential data loss due to an NVRAM failure. In such situations, it causes the invalidation of all NFS file handles on all volumes affected by the problem so that client-side users are forced to remount the affected file system (and thus not continue to use potentially incorrect data). It is also possible to specify a set of files per volume that are to be renamed out of the way in these cases. The filer sends error messages to the console whenever such problems are found. </dd><br> <dt>"raid_cv" (value: "on" | "off")</dt> <dd> <b>Traditional</b> volumes only. Setting the option to "off" disables block checksum protection on the volume. The default is "on". The user is cautioned that turning off the option exposes the filesystem to inconsistency that could be caused by a misbehaving hardware component in the system. </dd><br> <dt>"raid_zoned" (value: "on" | "off")</dt> <dd> <b>Traditional</b> volumes only. Setting the option to "off" disables zoned checksum protection on the volume. The default is "on". The user is cautioned that turning off the option exposes the filesystem to inconsistency that could be caused by a misbehaving hardware component in the system. </dd><br> <dt>"raidsize" (value: &lt number &gt)</dt> <dd> <b>Traditional</b> volumes only. The maximum size of a RAID group within the traditional volume. Changing this option doesn't cause existing RAID groups to grow or shrink. Rather, it only affects whether more disks will be added to the last existing RAID group in the future, and how large new RAID groups will be. </dd><br> <dt>"raidtype" (value: "raid4" | "raid_dp")</dt> <dd> <b>Traditional</b> volumes only. The type of RAID group used for this traditional volume. The "raid4" setting provides one parity disk per RAID group, while "raid_dp" provides two. Changing this option immediately changes the RAID group type for all RAID groups in the traditional volume. When upgrading RAID groups from "raid4" to "raid_dp", each RAID group begins reconstruction onto a spare disk allocated for the second "dparity" parity disk. </dd><br> <dt>"read_realloc" (value: "on" | "space_optimized" | "off")</dt> <dd> Setting this option to "on" enables read-reallocation in the volume. This causes application reads to optimize the layout of parts of a file or LUN after the data has been read from disk and is in the appliance memory. The default value is "off", in which case read-reallocate is not used. The value "space_optimized" indicates read-reallocate updates will not duplicate blocks into the active file system, thereby using space conservatively. The "space_optimized" value may result in degraded snapshot read performance; and may only be used for <b>flexible</b> volumes. </dd><br> <dt>"resyncsnaptime" (value: &lt number &gt)</dt> <dd> <b>Traditional</b> volumes only. Sets the RAID mirror resynchronization snapshot frequency to be the given number of minutes. The default value is '60' (minutes). </dd><br> <dt>"root" (value: &lt none &gt)</dt> <dd> The specified volume is to become the root volume for the filer on the next reboot. This option can be used on only one volume at any given time. The existing root volume will become a non-root volume after the reboot. Until the system is rebooted, the current root volume will continue to show 'root' as one of its options, and the new root volume will show 'diskroot' as an option. In general, the volume that has the 'diskroot' option value is the one that becomes the root volume following the next reboot. The only way to remove the root status of a volume is to set it on another one. </dd><br> <dt>"schedsnapname" (value: "create_time" | "ordinal")</dt> <dd> Setting the option to "ordinal" causes scheduled snapshots to be named in the hourly.n name format. Setting the value to "create_time" causes snapshots to use a hourly.yyyy-mm-dd_hhmm name format instead. The default is "ordinal". </dd><br> <dt>"snapmirrored" (value : "off")</dt> <dd> If SnapMirror is enabled, the filer automatically sets this option to "on". Set this option to "off" if SnapMirror should no longer be used to update the mirror. After setting this option to "off", the mirror becomes a regular writable volume. This option can only be set to "off" with this interface. Only the filer can change this option's value from "off" to "on". This option is not settable in Data ONTAP Cluster-Mode. Use "snapmirror-break" API instead. </dd><br> <dt>"try_first" (value : "volume_grow" | "snap_delete")</dt> <dd> If the flexible volume is configured to automatically reclaim space if the volume is running out of space, then setting this option to "volume_grow" will cause the volume to increase in size before deleting snapshots. If the option was set to "snap_delete", snapshots will be deleted before the volume size is increased. </dd><br> <dt>"svo_enable" (value: "on" | "off")</dt> <dd> Setting this option to "on" enables SnapValidator functionality on this volume. This option only applies to non-root volumes. This option is unsupported in Data ONTAP Cluster-Mode. </dd><br> <dt>"svo_allow_rman" (value: "on" | "off")</dt> <dd> Setting this option to "on" enables SnapValidator functionality on this volume to allow this volume to contain Oracle RMAN backup data. This option only applies to non-root volumes. This option is unsupported in Data ONTAP Cluster-Mode. </dd><br> <dt>"svo_checksum" (value: "on" | "off")</dt> <dd> Setting this option to "on" enables SnapValidator checksumming of all writes to this volume. This option only applies to non-root volumes. This option is unsupported in Data ONTAP Cluster-Mode. </dd><br> <dt>"svo_reject_errors" (value: "on" | "off")</dt> <dd> Setting this option to "on" enables SnapValidator functionality to reject any write to the volume which fails the SnapValidator checks. This option only applies to non-root volumes. This option is unsupported in Data ONTAP Cluster-Mode. </dd><br> <dt>"thorough_scrub" (value: "on" | "off")</dt> <dd> <b>Traditional</b> volumes only. Setting the option to "on" enables thorough scrub on a block checksum volume. That means that a scrub will initialize any zeroed checksum entries that it finds. If there are any checksum entries to be initialized, scrub will run slower than normal. </dd><br> <dt>"snaplock_autocommit_period" (value: "none" | <count> h|d|m|y)</dt> <dd> <b>SnapLock</b> volumes only. This option defines the criteria for committing files to WORM on a SnapLock volume by the autocommit scanner. h, d, m, y denote hours, days, months and years respectively. The default value of this option is "none" that corresponds to autocommit being disabled in the SnapLock volume. The minimum autocommit period on a SnapLock volume is 2h. Any valid value other than "none", specified in hours (h), days (d), months (m) or years (y) would trigger the autocommit scanner on the Snaplock volume. </dd><br> <dt> "snaplock_default_period" (value : min | max | infinite | <count>s|h|d|m|y)</dt> <dd> This option can be set only for <b>SnapLock</b> volumes and specifies the default retention period that will be applied to files committed to WORM state without an associated retention period. If this option value is <b>min</b> then snaplock_minimum_period is used as the default retention period. If this option value is <b>max</b> then snaplock_maximum_period is used as the default retention period. If this option value is <b>infinite</b> then infinite retention period will be used as the default retention period. WORM files with infinite retention period are retained forever. The retention period can also be explicitly specified as a number followed by a suffix. The valid suffixes are <b>s</b> for seconds, <b>h</b> for hours, <b>d</b> for days, <b>m</b> for months and <b>y</b> for years. For example, a value of <b>6m</b> represents a retention period of 6 months. The maximum valid retention period is 70 years. This option is not applicable while extending retention period of an already committed WORM file </dd><br> <dt> "snaplock_maximum_period" (value: infinite | <count>s|h|d|m|y)</dt> </dt> <dd> This option can be set only for <b>SnapLock</b> volumes and specifies the maximum allowed retention period for files committed to WORM state on the volume. Any file committed with a retention period longer than snaplock_maximum_period will be assigned a retention period equal to snaplock_maximum_period. If this option value is <b>infinite</b> then files can be committed for infinite retention period in the volume. WORM files with infinite retention period are retained forever. The retention period can also be explicitly specified as a number followed by a suffix. The valid suffixes are <b>s</b> for seconds, <b>h</b> for hours, <b>d</b> for days, <b>m</b> for months and <b>y</b> for years. For example, a value of <b>6m</b> represents a retention period of 6 months. The maximum valid retention period is 70 years. This option is not applicable while extending retention period of an already committed WORM file </dd><br> <dt> "snaplock_minimum_period" (value: infinite | <count>s|h|d|m|y)</dt> </dt> <dd> This option can only be set for <b>SnapLock</b> volumes and specifies the minimum allowed retention period for files committed to WORM state on the volume. Any file committed with a retention period shorter than snaplock_minimum_period will be assigned a retention period equal to snaplock_minimum_period. If this option value is <b>infinite</b> then every file committed to the volume will have a infinite retention period. WORM files with infinite retention period are retained forever. The retention period can also be explicitly specified as a number followed by a suffix. The valid suffixes are <b>s</b> for seconds, <b>h</b> for hours, <b>d</b> for days, <b>m</b> for months and <b>y</b> for years. For example, a value of <b>6m</b> represents a retention period of 6 months. The maximum valid retention period is 70 years. This option is not applicable while extending retention period of an already committed WORM file </dd><br> </dl>

=end html

=back



=over 2

=item * I<option-value>  =>   B<string>

=begin html

<br>The value to set the named option (except for option 'root', which has no associated value).

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume for which we want to set an option.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_set_total_files

[B<Family:> ontap-classic, vfiler]


=begin html

Set a volume's 'files-total' value to the given quantity. This specifies the maximum number of user-visible files that the given volume can hold, as reported by the 'files-total' value within: - the 'volumes' output parameter of the Data ONTAP 7-Mode 'volume-list-info' API, and - the 'attributes-list' output parameter of the Data ONTAP Cluster-Mode 'volume-get-iter' API. Note that this interface corresponds to the following Data ONTAP 7-Mode 'maxfiles' console command and Data ONTAP Cluster-Mode 'volume modify' console command: 'maxfiles &lt;vol-name&gt; &lt;requested_new_max&gt;' 'volume modify -vserver &lt;vserver-name&gt; -volume &lt;volume-name%gt -files &lt;requested_new_max&gt;'

=end html



B<Inputs>

=over 2

=item * I<force>  =>   B<boolean, optional>

=begin html

<br>Indicates whether the filer should reject a legal but "unreasonable" (seemingly too large) value for 'requested-total-files', or accept it without question. By default, legal but "unreasonable" values are rejected.

=end html

=back



=over 2

=item * I<requested-total-files>  =>   B<integer>

=begin html

<br>Specifies the new value for the volume's 'files-total' field. This value must be larger than the volume's current 'files-total' value, and can never be larger than the number of 4KB blocks in the volume. The filer may actually choose a smaller value so as to comply with certain internal accounting and alignment requirements. Once this value has been increased for a volume, it cannot be reduced below the value of 'inodefile-public-capacity' for that volume. Range : [0..2^31-1]

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>The name of the volume whose 'files-total' field we wish to set. The chosen volume must be online and not read-only for this operation to succeed.

=end html

=back



B<Outputs>

=over 2

=item * I<resulting-total-files>  =>   B<integer>

=begin html

<br>The quantity to which the given volume's 'files-total' field was actually set after all internal requirements and alignments were computed. This quantity will never be larger than 'requested-total-files', and never be smaller than the volume's 'inodefile-public-capacity' value before the request. Range : [0..2^31-1]

=end html

=back



=head2 volume_size

[B<Family:> ontap-classic, vfiler]


=begin html

Given the name of a flexible volume, either return its current size or set the volume's size to the stated amount. <p> This API is not supported for Infinite Volumes. Also, this API does not allow to set the volume's size from vFiler context.

=end html



B<Inputs>

=over 2

=item * I<new-size>  =>   B<string, optional>

=begin html

<br>Specify the flexible volume's new size using the following format: [+|-]&lt number &gt k|m|g|t] If a leading '+' or '-' appears, it indicates that the given flexible volume's size is to be increased or decreased (respectively) by the indicated amount, else the amount is the absolute size to set. The optional trailing 'k', 'm', 'g', and 't' indicates the desired units, namely 'kilobytes', 'megabytes', 'gigabytes', and 'terabytes' (respectively). If the trailing unit character doesn't appear, then &lt number &gt is interpreted as the number of bytes desired. The file system size of a readonly replica flexible volume, such as a snapmirror destination, is determined from the replica source. In such cases, the value set using "volume-size" is interpreted as an upper limit on the size. A flexible volume that's not a readonly replica which has the "fs_size_fixed" option set may have its size displayed, but not changed. Attempting to set the volume size in this case will result in failure and a EINTERNALERROR error code. Users must be able to adjust readonly replica flexible volume size in order to maintain enough capacity to accommodate transfers from the replica source. Attempting to set a readonly replica destination size to be less than that of its source will result in a failure indicated by the EONTAPI_ENOSPC error code. This option is not applicable from vFiler context. Attempting to set volume size from vfiler context will result in failure with EINTERNALERROR error code being returned.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>The name of the flexible volume for which we want to get or set its size.

=end html

=back



B<Outputs>

=over 2

=item * I<is-fixed-size-flex-volume>  =>   B<boolean, optional>

=begin html

<br>Is the flexible volume filesystem size fixed?

=end html

=back



=over 2

=item * I<is-readonly-flex-volume>  =>   B<boolean, optional>

=begin html

<br>Is this flexible volume read only?

=end html

=back



=over 2

=item * I<is-replica-flex-volume>  =>   B<boolean, optional>

=begin html

<br>Is this flexible volume a replica volume?

=end html

=back



=over 2

=item * I<volume-size>  =>   B<string>

=begin html

<br>Either the size we found the given volume to be or the size to which the volume was set (if we're setting its size via the 'new-size' argument above).

=end html

=back



=head2 volume_space_list_info

[B<Family:> ontap-classic]


=begin html

Return a list of volumes and a breakdown of their space usage. This information is only available for online volumes. If no volume is specified, status is displayed for all online volumes on the filer. Note that if space status information for more than 20 volumes is desired, the volume-space-list-info-iter-* ZAPIs will be more efficient and should be used instead.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string, optional>

=begin html

<br>The name of the volume for which we want status information. If not supplied, then we want status for all volumes on the filer.

=end html

=back



B<Outputs>

=over 2

=item * I<vol-space-infos>  =>   B<L<"vol-space-info">[]>

=begin html

<br>List of volumes and their space information.

=end html

=back



=head2 volume_space_list_info_iter_end

[B<Family:> ontap-classic]


=begin html

Terminate a list iteration and clean up any saved info.

=end html



B<Inputs>

=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous volume-space-list-info-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_space_list_info_iter_next

[B<Family:> ontap-classic]


=begin html

Continues an iteration through the list of volumes.

=end html



B<Inputs>

=over 2

=item * I<maximum>  =>   B<integer>

=begin html

<br>The maximum number of entries to retrieve.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag from a previous volume-space-list-info-iter-start.

=end html

=back



B<Outputs>

=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>This tells you how many records are being returned from this particular call to volume-space-list-info-iter-next. When this value is 0, you have retrieved everything.

=end html

=back



=over 2

=item * I<vol-space-infos>  =>   B<L<"vol-space-info">[]>

=begin html

<br>List of volumes and their status information. See volume-space- list-info for a description of type vol-space-info.

=end html

=back



=head2 volume_space_list_info_iter_start

[B<Family:> ontap-classic]


=begin html

Starts an iteration through the list of volumes.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string, optional>

=begin html

<br>The name of the volume for which we want space status information. If not supplied, then we display space status for all volumes on the filer.

=end html

=back



B<Outputs>

=over 2

=item * I<records>  =>   B<integer>

=begin html

<br>This tells you the number of items that have been saved for future retrieval with volume-space-list-info-iter-next.

=end html

=back



=over 2

=item * I<tag>  =>   B<string>

=begin html

<br>Tag to be used in subsequent iterations.

=end html

=back



=head2 volume_split



=begin html

Remove the specified plex from a mirrored traditional volume and create a new unmirrored traditional volume with the specified name that contains the split-off plex. The original mirrored traditional volume becomes unmirrored. The plex to be split from the original traditional volume must be functional (not partial), but it could be inactive, resyncing, or out-of-date. A 'volume-split' operation can therefore be used to gain access to a plex that is not up to date with respect to its partner plex if its partner plex is currently failed. If the plex is offline at the time of the split, the resulting traditional volume will also be offline. Otherwise, the resulting traditional volume will be in the same online/offline/restricted state as the original traditional volume. Note that a split mirror can be joined back together via the "victim-volume" option to "volume-mirror".

=end html



B<Inputs>

=over 2

=item * I<new-volume-name>  =>   B<string>

=begin html

<br>Name of the new traditional volume to create from the split plex.

=end html

=back



=over 2

=item * I<plex>  =>   B<string>

=begin html

<br>Name of the plex to split out of its traditional volume.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_verify_list_info



=begin html

Get the status of RAID mirror verification on the named traditional volume. Status includes percentage complete and whether it's currently suspended.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string, optional>

=begin html

<br>Name of an existing mirrored traditional volume. If no name is given, then mirror verification status is generated for all aggregates currently being verified (including the ones embedded in traditional volumes).

=end html

=back



B<Outputs>

=over 2

=item * I<verify-details>  =>   B<L<"verify-detail-info">[]>

=begin html

<br>List of aggregates (including the ones embedded in traditional volumes) and their RAID mirror verification status.

=end html

=back



=head2 volume_verify_resume



=begin html

Resume RAID mirror verification on the named traditional volume. If no name is given, then resume RAID mirror verification on all aggregates (including those embedded in traditional volumes) that have been suspended.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string, optional>

=begin html

<br>Name of the existing traditional volume for which RAID mirror verification is to resume.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_verify_start



=begin html

Start RAID mirror verification on the named traditional volume. RAID mirror verification compares the data in both plexes of a mirrored aggregate (whether it's free-standing or embedded in a traditional volume). In the default case, any blocks that differ are logged and no changes are made. The fix-plex option is used to fix any mismatches. It specifies which plex to fix. If no name is given, then RAID mirror verification is started on all online aggregates (including those embedded in traditional volumes). Use either the "aggr-verify-list-info" or "volume-verify-list-info" API to check RAID mirror verification status. If the fix-plex option is used, then a name must be specified.

=end html



B<Inputs>

=over 2

=item * I<fix-plex>  =>   B<integer, optional>

=begin html

<br>If provided, this specifies the plex to fix in case the two plexes do not match. The default is to log any discrepancies instead of fixing them.

=end html

=back



=over 2

=item * I<log-only>  =>   B<boolean, optional>

=begin html

<br>If provided, and if the value is "true", then simply log any discrepancies instead of fixing them. The default value is "true". If log-only is "false", then the fix-plex option must also be specified. If log-only is "true" and fix-plex is also specified, then the log-only option will be ignored.

=end html

=back



=over 2

=item * I<volume>  =>   B<string, optional>

=begin html

<br>Name of the mirrored traditional volume to verify.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_verify_stop



=begin html

Stop RAID mirror verification on the named traditional volume. If no name is given, stop RAID mirror verification on all aggregates (including those embedded in traditional volumes) currently being verified.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string, optional>

=begin html

<br>Name of the traditional volume for which we are to stop RAID mirror verification.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_verify_suspend



=begin html

Suspend RAID mirror verification on the named traditional volume. If no name is given, suspend mirror verification on all aggregates (including those embedded in traditional volumes) currently being verified.

=end html



B<Inputs>

=over 2

=item * I<volume>  =>   B<string, optional>

=begin html

<br>Name of the traditional volume for which we are to suspend RAID mirror verification.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head2 volume_wafl_info



=begin html

DEFINED HERE FOR BACKWARDS COMPATIBILITY ONLY. CHANGE OVER TO USING THE NEW 'volume-get-filer-info' AS SOON AS POSSIBLE. Get WAFL status information.

=end html



B<Inputs>

=over 2

=item * None

=back



B<Outputs>

=over 2

=item * I<checksum-types>  =>   B<string>

=begin html

<br>Checksum type. The possible values: <ul> <li> "zoned" - if all volumes are Fixed VBN, <li> "block" - if all volumes are Block Appended, <li> "mixed" - if volumes are mixed Fixed VBN and Block Appended and Advanced Zoned, <li> "none" - if no volumes have zoned or block or advanced_zoned checksum (azcs) or mixed, <li> "advanced_zoned" - if all volumes in the system have Advanced Zoned Checksum scheme. </ul>

=end html

=back



=over 2

=item * I<disk-types>  =>   B<string>

=begin html

<br>Type of disks. Possible values: 512, 520, 4096, mixed, none. "512" if all disks 512 BPS, "520" if all disks 520 BPS, "4096" if all disks 4096 BPS, "mixed" if disks are mixed 512 BPS, 520 BPS and 4096 BPS, "none" if no disks have 512 or 520 or 4096 BPS.

=end html

=back



=over 2

=item * I<root-volume>  =>   B<string>

=begin html

<br>Current root volume.

=end html

=back



=over 2

=item * I<snapshots-max>  =>   B<integer>

=begin html

<br>Maximum number of snapshots available. Range : [0..2^31-1].

=end html

=back



=head2 wafl_sync

[B<Family:> ontap-classic, vfiler]


=begin html

Forces a WAFL consistency point (CP) in order to reduce the time for succeeding fence and snapshot related operations. In Data ONTAP 7-Mode this call is synchronous and will not return until the CP has completed. In Data ONTAP Cluster-Mode this API is asynchronous and will return immediately as soon as the CP is scheduled. The wafl-get-sync-status API can be used to check status of the previously scheduled CP. Two uses of this API are <ul> <li> to predict how fast a successive consistency group based operation will finish,</li> <li> to improve performance of succeeding consistency group primitives.</li> </ul>

=end html



B<Inputs>

=over 2

=item * I<volumes>  =>   B<volume-name[], optional>

=begin html

<br>A list of volume names to take a CP on. In Data ONTAP 7-Mode, the CP operation will be performed on all the volumes on the controller if no volumes are specified. In Data ONTAP Cluster-Mode, "volumes" is a required input and all specified volumes must belong to the same Vserver. If an error is encountered when processing the sync request for a volume, the operation is aborted and sync operation will not be performed on the rest of the volumes specified.

=end html

=back



B<Outputs>

=over 2

=item * None

=back



=head1 TYPEDEFS



=head2 aggr-64bit-upgrade-check-info

=begin html

Information returned when upgrade-64bit-mode in aggr-add or aggr-64bit-upgrade-start is "check".

=end html



B<Fields>

=over 2

=item * I<added-space>  =>   B<integer, optional>

=begin html

<br>The effective total space to be added (in bytes), not including blocks used by the 64-bit upgrade of the aggregate and its contained flexible volumes. Range: [0..2^64-1].

=end html

=back



=over 2

=item * I<cookie>  =>   B<integer, optional>

=begin html

<br>The opaque cookie to uniquely identify a 64-bit upgrade transaction previously triggered on the aggregate. Range: [0..2^64-1].

=end html

=back



=over 2

=item * I<last-errno>  =>   B<integer, optional>

=begin html

<br>The error code of the last attempt to check for space usage on the specific aggregate. This field is present only if a 64-bit upgrade check was previously attempted. Possible values: 0 - indicates success EVOLUME_64BIT_UPGRADE_KIREETI_NOT_AVAIL Per-volume upgrade check results may be out of date if last-errno is not 0.

=end html

=back



=over 2

=item * I<space-estimate-complete>  =>   B<boolean, optional>

=begin html

<br>True if the space estimate has completed. Check "last-errno" to find out whether the space estimate was successful.

=end html

=back



=head2 aggr-64bit-upgrade-info

=begin html

Information related to 64-bit upgrade.

=end html



B<Fields>

=over 2

=item * I<check>  =>   B<L<"aggr-64bit-upgrade-check-info">, optional>

=begin html

<br>Information returned when upgrade-64bit-mode in aggr-add or aggr-64bit-upgrade-start is "check".

=end html

=back



=over 2

=item * I<start>  =>   B<L<"aggr-64bit-upgrade-start-info">, optional>

=begin html

<br>Information returned when upgrade-64bit-mode in aggr-add or aggr-64bit-upgrade-start is "grow_all", "grow_none", or "grow_reserved".

=end html

=back



=over 2

=item * I<status>  =>   B<L<"aggr-64bit-upgrade-status-info">>

=begin html

<br>Status information related to 64-bit upgrade. This information includes the block format of the aggregate and the progress of the 64-bit upgrade scanner.

=end html

=back



=head2 aggr-64bit-upgrade-start-info

=begin html

Information returned when upgrade-64bit-mode in aggr-add or aggr-64bit-upgrade-start is "grow_all", "grow_none", or "grow_reserved".

=end html



B<Fields>

=over 2

=item * I<last-errno>  =>   B<integer, optional>

=begin html

<br>The error code of the last attempt to start 64-bit upgrade on the specific aggregate. This field is present only if 64-bit upgrade was previously attempted. Possible values include: EAGGR_64BIT_UPGRADE_ENOSPC EOP_DISALLOWED_ON_AGGR_WITH_SPARSE_VOL EVOLUME_64BIT_UPGRADE_VVOL_ENOSPC EVOLUME_64BIT_UPGRADE_VVOL_ENOSPC_OVERWRITE EVOLUME_64BIT_UPGRADE_KIREETI_NOT_AVAIL EVOLUME_64BIT_UPGRADE_PREQUAL_NOT_AVAIL EVOLUME_IRON_NON_LOCAL_STATUS

=end html

=back



=over 2

=item * I<min-space-for-upgrade>  =>   B<integer, optional>

=begin html

<br>The minimum additional disk space (in bytes) required to trigger 64-bit upgrade. This field is present when the specified disks do not have sufficient space to upgrade the aggregate and its contained flexible volumes to 64-bit. Range: [0..2^64-1].

=end html

=back



=head2 aggr-64bit-upgrade-status-info

=begin html

Status information related to 64-bit upgrade. This information includes the block format of the aggregate and the progress of the 64-bit upgrade scanner.

=end html



B<Fields>

=over 2

=item * I<block-format>  =>   B<string>

=begin html

<br>The block format of the aggregate. Can be "32_bit", "64_bit", or "upgrading".

=end html

=back



=head2 aggr-info

=begin html

Aggregate status information.

=end html



B<Fields>

=over 2

=item * I<aggr-64bit-upgrade>  =>   B<L<"aggr-64bit-upgrade-info">, optional>

=begin html

<br>Information related to 64-bit upgrade. After 64-bit upgrade completes, this information is no longer available.

=end html

=back



=over 2

=item * I<aggregate-space-details>  =>   B<L<"aggregate-space-info">, optional>

=begin html

<br>Contains all size-related information for the aggr and its set of snapshots.

=end html

=back



=over 2

=item * I<block-type>  =>   B<string>

=begin html

<br>The indirect block format that the aggregate can have. It can be either 32_bit or 64_bit. A 64_bit value indicates that associated aggregates can be larger than 16TB. Possible values: 32_bit, 64_bit

=end html

=back



=over 2

=item * I<cache-raid-group-size>  =>   B<integer>

=begin html

<br>Current maximum cache RAID group size of hybrid aggregate. Range : [1..28]. RAID group size is the maximum number of disks that can be added to a RAID group. This information will only be returned for hybrid aggregate i.e. for the aggregates whose "is-hybrid" field is set to true.

=end html

=back



=over 2

=item * I<checksum-status>  =>   B<string>

=begin html

<br>Checksum status. Possible values: "active", "off", "reverting", "none", "unknown", "initializing", "reinitializing", "reinitialized", "upgrading_phase1", "upgrading_phase2"

=end html

=back



=over 2

=item * I<checksum-style>  =>   B<string>

=begin html

<br>Checksum style. The possible values: <ul> <li> "advanced_zoned" - advanced_zoned checksum (azcs), <li> "block" - block, <li> "mixed" - mixed, <li> "none" - none, <li> "unknown" - unknown <li> "wafl" - wafl, <li> "zoned" - zoned. </ul>

=end html

=back



=over 2

=item * I<disk-count>  =>   B<integer>

=begin html

<br>Number of disks in the aggregate. Range: [0..2^31-1].

=end html

=back



=over 2

=item * I<dr-home-id>  =>   B<integer, optional>

=begin html

<br>NVRAM ID of the DR (disaster recovery) node to which this aggregate's disks have been administratively assigned. This information derived from sanown information of aggregate's disk. See 'disk-sanown-detail-info'

=end html

=back



=over 2

=item * I<dr-home-name>  =>   B<string, optional>

=begin html

<br>Name of the DR node to which this aggregate's disks have been administratively assigned.

=end html

=back



=over 2

=item * I<files-private-used>  =>   B<integer>

=begin html

<br>Number of system (not user-visible) files used. Range: [0..2^64-1].

=end html

=back



=over 2

=item * I<files-total>  =>   B<integer>

=begin html

<br>Total count of user-visible files. Range: [0..2^64-1].

=end html

=back



=over 2

=item * I<files-used>  =>   B<integer>

=begin html

<br>Number of user-visible files used. Range: [0..2^64-1].

=end html

=back



=over 2

=item * I<free-space-realloc>  =>   B<string, optional>

=begin html

<br>Indicate if free space reallocation (continuous segment cleaning) is enabled on a specific aggregate. Possible values: on, off, no_redirect "on" (Free space reallocation enabled with automatically starting the redirect scanner) "off" (Free space reallocation disabled) "no_redirect" (Free space reallocation enabled without running the redirect scanner) The default value for this option is "off"

=end html

=back



=over 2

=item * I<fsid>  =>   B<integer, optional>

=begin html

<br>Aggregate's File System IDentifier. Range: [0..2^32-1]

=end html

=back



=over 2

=item * I<ha-policy>  =>   B<ha-policy-type, optional>

=begin html

<br>Aggregate's HA policy. Possible return values: "cfo", "sfo", "none"

=end html

=back



=over 2

=item * I<has-local-root>  =>   B<boolean>

=begin html

<br>Whether the aggregate (or tradvol) contains the local root volume.

=end html

=back



=over 2

=item * I<has-partner-root>  =>   B<boolean>

=begin html

<br>Whether the aggregate (or tradvol) contains the partner's root volume.

=end html

=back



=over 2

=item * I<home-id>  =>   B<integer, optional>

=begin html

<br>NVRAM ID of the node to which this aggregate's disks have been administratively assigned. This information derived from sanown information of aggregate's disk. See 'disk-sanown-detail-info' Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<home-name>  =>   B<string, optional>

=begin html

<br>Name of the node to which this aggregate's disks have been administratively assigned.

=end html

=back



=over 2

=item * I<inodefile-private-capacity>  =>   B<integer>

=begin html

<br>Number of inodes that can currently be stored on disk for system (not user-visible) files. This number will dynamically increase as more system files are created. Range: [0..2^64-1].

=end html

=back



=over 2

=item * I<inodefile-public-capacity>  =>   B<integer>

=begin html

<br>Number of inodes that can currently be stored on disk for user-visible files. This number will dynamically increase as more user-visible files are created. Range: [0..2^64-1].

=end html

=back



=over 2

=item * I<is-checksum-enabled>  =>   B<boolean>

=begin html

<br>Is checksumming enabled for the aggregate?

=end html

=back



=over 2

=item * I<is-hybrid>  =>   B<boolean, optional>

=begin html

<br>If true, aggregate currently contains both SSD and non-SSD RAID groups.

=end html

=back



=over 2

=item * I<is-hybrid-enabled>  =>   B<boolean, optional>

=begin html

<br>If true, aggregate is eligible to contain both SSD and non-SSD RAID groups.

=end html

=back



=over 2

=item * I<is-inconsistent>  =>   B<boolean>

=begin html

<br>Whether or not the aggregate is inconsistent.

=end html

=back



=over 2

=item * I<is-mirrored>  =>   B<boolean, optional>

=begin html

<br>If true, aggregate is mirrored.

=end html

=back



=over 2

=item * I<is-snaplock>  =>   B<boolean>

=begin html

<br>Whether or not it's a SnapLock aggregate.

=end html

=back



=over 2

=item * I<max-write-alloc-blocks>  =>   B<integer, optional>

=begin html

<br>The maximum number of blocks used for write allocation. Some sequential read workloads may benefit from increasing this value. Default value is 0 which uses the controller-wide default value of 64. The default is optimal for most users. The controller-wide default can be adjusted with the bootarg "wafl-max-write-alloc-blocks"

=end html

=back



=over 2

=item * I<mirror-status>  =>   B<string>

=begin html

<br>Aggregate's mirror status. Possible values: invalid, uninitialized, needs CP count check, CP count check in progress, unmirrored, mirrored, mirror degraded, mirror resynchronizing, failed, limbo, and <unknown mirror state>.

=end html

=back



=over 2

=item * I<mount-state>  =>   B<string, optional>

=begin html

<br>[not settable, always] This field shows the volume's mount state. Possible values: "unmounted", "online", "frozen", "destroying", "creating", "mounting", "unmounting", "inconsistent", "reverted", "quiescing", "quiesced", "iron_restricted"

=end html

=back



=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Aggregate name.

=end html

=back



=over 2

=item * I<owner-id>  =>   B<integer, optional>

=begin html

<br>NVRAM ID of node which currently owns this aggregate's disks. Normally, home-id matches owner-id. But these may be changed by SFO takeover to match the takeover node, and restored by SFO giveback to match home-id. CFO takeover and giveback do not affect owner-id. This information derived from sanown information of aggregate's disk. See 'disk-sanown-detail-info' Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<owner-name>  =>   B<string, optional>

=begin html

<br>Name of node which currently owns this aggregate's disks. Normally, home-name matches owner-name. But these may be changed by SFO takeover to match the takeover node, and restored by SFO giveback to match home-name. CFO takeover and giveback do not affect owner-name.

=end html

=back



=over 2

=item * I<plex-count>  =>   B<integer>

=begin html

<br>Number of plexes in the aggregate. This value tells us the size of the returned "plex" array. Range: [0..2^31-1].

=end html

=back



=over 2

=item * I<plexes>  =>   B<L<"plex-info">[]>

=begin html

<br>List of plexes in the aggregate.

=end html

=back



=over 2

=item * I<raid-lost-write-state>  =>   B<string, optional>

=begin html

<br>State of the RAID Lost Write feature for an aggregate. The possible values are: <ul> <li> "aborted" - The RAID Lost Write scrub is no longer running and was aborted on all RAID groups in this aggregate, possibly due to an error. </li> <li> "illegal" - The aggregate contains RAID groups with RAID Lost Write disabled and other RAID groups with RAID Lost Write enabled. This is an invalid state. </li> <li> "inoperative" - The RAID Lost Write scrub is allowed on the aggregate, but it cannot start because the system-wide RAID Lost Write option "raid.lost_write.enable" is set to "off".</li> <li> "off" - RAID Lost Write protection and scrub are disabled on this aggregate. </li> <li> "on" - The aggregate is RAID Lost Write protected and that the RAID Lost Write scrub completed successfully on all RAID groups in this aggregate. </li> <li> "partial" - The RAID Lost Write scrub completed successfully on some of the RAID groups in this aggregate, but was aborted on at least one of the RAID groups. </li> <li> "unknown" - The RAID Lost Write scrub status could not be determined. </li> <li> "upgrade_partial" - The RAID Lost Write scrub is still in progress on some of the RAID groups in this aggregate and was aborted on at least one of the RAID groups. </li> <li> "upgrading" - The RAID Lost Write scrub is still not completed or not yet started on at least one of the RAID groups in this aggregate. </li> </ul>

=end html

=back



=over 2

=item * I<raid-size>  =>   B<integer>

=begin html

<br>Current RAID group size. Range : [0..2^31-1].

=end html

=back



=over 2

=item * I<raid-status>  =>   B<string>

=begin html

<br>RAID status. Possible values: normal, verifying, SnapMirrored, copying, ironing, mirrored, resyncing, mirror degraded, invalid, needs check, initializing, growing, partial, noparity, degraded, reconstruct, out-of-date, foreign, raid4, raid0, raid_dp, mixed_raid_type. These values may appear by themselves or in combination separated by commas (e.g., "reconstruct,growing"). An aggregate could be of only one of the following RAID types: <ul> <li> "raid0" - All the raid groups in the aggregate are of type raid0,</li> <li> "raid4" - All the raid groups in the aggregate are of type raid4,</li> <li> "raid_dp" - All the raid groups in the aggregate are of type raid_dp,</li> <li> "mixed_raid_type" - This aggregate contains RAID groups of different RAID types (raid0, raid4, raid_dp).</li> </ul>

=end html

=back



=over 2

=item * I<size-available>  =>   B<integer>

=begin html

<br>Available bytes in the aggregate. Range: [0..2^64-1].

=end html

=back



=over 2

=item * I<size-percentage-used>  =>   B<integer, optional>

=begin html

<br>Percentage of aggregate used. This value is not returned if the aggregate is unusable (i.e., it's offline). Range : [0..100].

=end html

=back



=over 2

=item * I<size-total>  =>   B<integer>

=begin html

<br>Aggregate total usable size in bytes, not including WAFL reserve and aggregate snapshot reserve. If the aggregate is restricted or offline, a value of 0 is returned. Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<size-used>  =>   B<integer>

=begin html

<br>Aggregate bytes used. This value is not returned if the aggregate is unusable (i.e., it's offline). Range: [0..2^64-1].

=end html

=back



=over 2

=item * I<snaplock-type>  =>   B<string, optional>

=begin html

<br>The type of the snaplock aggregate. It is present for snaplock aggrs only, i.e. aggrs for which is-snaplock is "true". Possible values - "compliance" or "enterprise"

=end html

=back



=over 2

=item * I<state>  =>   B<string>

=begin html

<br>Aggregate state. The possible values: "creating", "destroying", "failed", "frozen", "inconsistent", "iron_restricted", "mounting", "offline", "online", "partial", "quiesced", "quiescing", "restricted", "reverted", "unknown", "unmounted", "unmounting".

=end html

=back



=over 2

=item * I<striping>  =>   B<striping-type, optional>

=begin html

<br>Specifies the striping information about the aggregate. Possible values are "striped", "not_striped" and "unknown" In unclustered environments, all aggregates are not striped. In clustered environments, aggregates can be either striped or not striped. When striping information is not known, "unknown" will be returned.

=end html

=back



=over 2

=item * I<type>  =>   B<string>

=begin html

<br>The type of aggregate. Possible values: aggr, trad "aggr" (for aggregates that can contain flexible volumes) "trad" (for aggregates embedded in traditional volumes)

=end html

=back



=over 2

=item * I<uuid>  =>   B<string>

=begin html

<br>Aggregate's Universal Unique IDentifier. UUIDs are 16-byte quantities that are typically displayed as having five hexadecimal fields separated by hyphens. For example: d2da3566-da53-11d7-a841-000100000529

=end html

=back



=over 2

=item * I<volume-count>  =>   B<integer>

=begin html

<br>Number of volumes in the aggregate. Range: [0..2^31-1].

=end html

=back



=over 2

=item * I<volume-count-collective>  =>   B<integer, optional>

=begin html

<br>Number of striped volume constituents in the aggregate which also represent a collective striped volume. This field is for internal use only. Range: [0..2^31-1].

=end html

=back



=over 2

=item * I<volume-count-mirrors>  =>   B<L<"mirror-count-info">, optional>

=begin html

<br>Various counts information for mirror volumes in the aggregate. This information is returned only when the aggregate contains mirror volumes.

=end html

=back



=over 2

=item * I<volume-count-not-online>  =>   B<integer, optional>

=begin html

<br>When present, this field indicates the number of volumes that are not online (offline and restricted volumes). <p> Range: [0..2^31-1]

=end html

=back



=over 2

=item * I<volume-count-quiesced>  =>   B<integer, optional>

=begin html

<br>When present, this field indicates the number of quiesced online volumes. <p> Range: [0..2^31-1]

=end html

=back



=over 2

=item * I<volume-count-striped>  =>   B<integer, optional>

=begin html

<br>Number of striped volume constituents in the aggregate. These volumes are also reported in the full volume-count value. This field is for internal use only. Range: [0..2^31-1].

=end html

=back



=over 2

=item * I<volumes>  =>   B<L<"contained-volume-info">[]>

=begin html

<br>List of volumes contained the aggregate.

=end html

=back



=over 2

=item * I<wafliron>  =>   B<L<"aggr-wafliron-info">, optional>

=begin html

<br>Information related to wafliron, the online WAFL file system check/repair tool. This information is returned only when wafliron specific information is available.

=end html

=back



=head2 aggr-option-info

=begin html

Option key and value. The possible values are described in the "aggr-set-option" API below.

=end html



B<Fields>

=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Option key.

=end html

=back



=over 2

=item * I<value>  =>   B<string>

=begin html

<br>Option value.

=end html

=back



=head2 aggr-space-info

=begin html

List of aggregates and their space usage information.

=end html



B<Fields>

=over 2

=item * I<aggregate-name>  =>   B<string>

=begin html

<br>Name of the aggregate.

=end html

=back



=over 2

=item * I<size-asis-used>  =>   B<integer>

=begin html

<br>Space used by A-SIS metafiles. Range : [0..2^64-1]

=end html

=back



=over 2

=item * I<size-bssm-nvlog-used>  =>   B<integer, optional>

=begin html

<br>Space used by bi-directional Synchronous SnapMirror for NVLOG files. This element will be returned only if the value is not zero. Range : [0..2^64-1]

=end html

=back



=over 2

=item * I<size-free>  =>   B<integer>

=begin html

<br>Total free space in the aggregate Range : [0..2^64-1]

=end html

=back



=over 2

=item * I<size-image-backup-used>  =>   B<integer>

=begin html

<br>Space used by Image Backup metafiles. Range : [0..2^64-1]

=end html

=back



=over 2

=item * I<size-metadata>  =>   B<integer>

=begin html

<br>Total space used by aggregates metadata. Range : [0..2^64-1]

=end html

=back



=over 2

=item * I<size-nominal>  =>   B<integer>

=begin html

<br>Total space contained in the aggreate minus the wafl reserve space. Range : [0..2^64-1]

=end html

=back



=over 2

=item * I<size-snap-used>  =>   B<integer>

=begin html

<br>Space used by aggregate snapshots. Range : [0..2^64-1]

=end html

=back



=over 2

=item * I<size-used>  =>   B<integer>

=begin html

<br>The total used space in the aggregate except the space used by snapshots. Range : [0..2^64-1]

=end html

=back



=over 2

=item * I<size-volume-allocated>  =>   B<integer>

=begin html

<br>Total space allocated to volumes in the aggregate. Range : [0..2^64-1]

=end html

=back



=over 2

=item * I<size-volume-used>  =>   B<integer>

=begin html

<br>Total space used by volumes in the aggregate. Range : [0..2^64-1]

=end html

=back



=over 2

=item * I<volume-count>  =>   B<integer>

=begin html

<br>Count of online virtual volumes in the aggregate. Range : [0..2^64-1]

=end html

=back



=over 2

=item * I<volumes>  =>   B<L<"volume-space-info">[]>

=begin html

<br>List of flexible volumes and their allocated space information.

=end html

=back



=head2 aggr-wafliron-info

=begin html

Information related to wafliron, the online WAFL file system check/repair tool.

=end html



B<Fields>

=over 2

=item * I<last-start-errno>  =>   B<integer, optional>

=begin html

<br>The error code of the last attempt to start wafliron on the specific aggregate or the traditional volume. This field is present only if 'wafliron start' was previously attempted.

=end html

=back



=over 2

=item * I<last-start-error-info>  =>   B<string, optional>

=begin html

<br>The error information of the last attempt to start wafliron on the specific aggregate or the traditional volume. This field is present only if 'wafliron start' was previously attempted.

=end html

=back



=over 2

=item * I<scan-percentage>  =>   B<integer, optional>

=begin html

<br>When present, this field indicates the percentage of blocks that have been scanned in the specified aggregate. This field is present only when wafliron is running and its state is "starting" or "scanning". <p> Range: [0..100]

=end html

=back



=over 2

=item * I<state>  =>   B<string>

=begin html

<br>When wafliron is run, it goes through different stages/states. This field indicates the current state of wafliron on the specified aggregate. <p> Possible values are: <p> "not_running" - wafliron is not running on this aggregate. <p> "starting" - wafliron is starting, allocating, and/or in the initial mounting phase. <p> "scanning" - wafliron is scanning inodes, and/or fixing file system inconsistencies. <p> "checking_lost_blocks" - wafliron is checking for lost blocks. <p> "checking_lost_inodes" - wafliron is checking link counts. <p> "finishing" - wafliron is cleaning up. <p> "aborting" - wafliron is aborting. <p> "unknown" - wafliron state could not be determined.

=end html

=back



=over 2

=item * I<summary-scan-percentage>  =>   B<integer, optional>

=begin html

<br>When present and the value is other than -1, this field indicates the percentage of summary blocks that have been scanned in the specified aggregate. This field is present only when wafliron is running and its state is "starting" or "scanning". <p> Range: [-1..100]

=end html

=back



=head2 aggregate-space-info

=begin html

A set of two structures returning size-related information for a given aggregate and its set of snapshots.

=end html



B<Fields>

=over 2

=item * I<aggregate-space>  =>   B<L<"fs-space-info">>

=begin html

<br>[not settable, online-only] A structure returning size-related information for a given aggregate.

=end html

=back



=over 2

=item * I<snapshot-space>  =>   B<L<"snapshot-space-info">>

=begin html

<br>[not settable, online-only] A structure returning size-related information for a set of snapshots of the given aggregate.

=end html

=back



=head2 contained-volume-info

=begin html

Information about a volume contained in the aggregate.

=end html



B<Fields>

=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Volume name.

=end html

=back



=head2 disk-info

=begin html

Information for each disk in the plex.

=end html



B<Fields>

=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Name of a member disk.

=end html

=back



=head2 filter-attrs-info

=begin html

List of filters based on attributes of an aggregate.

=end html



B<Fields>

=over 2

=item * I<all>  =>   B<boolean, optional>

=begin html

<br>If true, returns all aggregates owned by the local node and also taken over by the local node. Default is false.

=end html

=back



=over 2

=item * I<is-cfo>  =>   B<boolean, optional>

=begin html

<br>If true, returns aggregates with 'cfo' HA policy which includes local and taken over aggregates. Default is false.

=end html

=back



=over 2

=item * I<is-dr-auxiliary>  =>   B<boolean, optional>

=begin html

<br>If true, returns aggregates taken over by the local node but owned by the partner of DR (disaster recovery) partner (i.e. auxiliary partner). Default is false.

=end html

=back



=over 2

=item * I<is-dr-partner>  =>   B<boolean, optional>

=begin html

<br>If true, returns aggregates taken over by the local node but owned by the DR (disaster recovery) partner. Default is false.

=end html

=back



=over 2

=item * I<is-local>  =>   B<boolean, optional>

=begin html

<br>If true, returns aggregates owned by the local node. It includes taken over aggregates with 'sfo' policy. Default is false.

=end html

=back



=over 2

=item * I<is-partner>  =>   B<boolean, optional>

=begin html

<br>If true, returns aggregates taken over by the local node but owned by the partner. Default is false.

=end html

=back



=over 2

=item * I<is-sfo>  =>   B<boolean, optional>

=begin html

<br>If true, returns aggregates with 'sfo' HA policy which includes local and taken over aggregates. Default is false.

=end html

=back



=head2 fs-space-info

=begin html

A structure returning size-related information for a given aggregate.

=end html



B<Fields>

=over 2

=item * I<fs-aggregate-metadata>  =>   B<integer, optional>

=begin html

<br>This field represents space used by filesystem metadata of the aggregate in bytes. Range : [0..2^64-1]

=end html

=back



=over 2

=item * I<fs-files-private-used>  =>   B<integer>

=begin html

<br>[not settable, online-only] Number of system (not user-visible) files (inodes) used. If the referenced file system is restricted or offline, a value of 0 is returned. Range: [0 - 2^64-1]

=end html

=back



=over 2

=item * I<fs-files-total>  =>   B<integer>

=begin html

<br>[settable, online-only] Total user-visible file (inode) count, i.e., maximum number of user-visible files (inodes) that this referenced file system can currently hold. If the referenced file system is restricted or offline, a value of 0 is returned. Range: [0 - 2^64-1]

=end html

=back



=over 2

=item * I<fs-files-used>  =>   B<integer>

=begin html

<br>[not settable, online-only] Number of user-visible files (inodes) used in the referenced file system. If the referenced file system is restricted or offline, a value of 0 is returned. Range: [0 - 2^64-1]

=end html

=back



=over 2

=item * I<fs-hybrid-cache-size-total>  =>   B<integer, optional>

=begin html

<br>[not settable, online-only] Total cache size (in bytes) in a hybrid aggregate. If the referenced aggregate is restricted or offline, or if it is not a hybrid aggregate, a value of 0 is returned. Range: [0 - 2^64-1]

=end html

=back



=over 2

=item * I<fs-inodefile-private-capacity>  =>   B<integer>

=begin html

<br>[not settable, online-only] Number of inodes that can currently be stored on disk for system (not user-visible) files. This number will dynamically increase as more system files are created. Range: [0 - 2^64-1]

=end html

=back



=over 2

=item * I<fs-inodefile-public-capacity>  =>   B<integer>

=begin html

<br>[not settable, online-only] Number of inodes that can currently be stored on disk for user-visible files. This number will dynamically increase as more user-visible files are created. Range: [0 - 2^64-1]

=end html

=back



=over 2

=item * I<fs-maxfiles-available>  =>   B<integer>

=begin html

<br>[not settable, always] The count of the maximum number of user-visible files currently allowable on the referenced file system. Range: [0 - 2^64-1]

=end html

=back



=over 2

=item * I<fs-maxfiles-possible>  =>   B<integer>

=begin html

<br>[not settable, always] The largest value to which the fs-maxfiles-available parameter can be increased by reconfiguration, on the referenced file system. Range: [0 - 2^64-1] Range: [0 - 2^64-1]

=end html

=back



=over 2

=item * I<fs-maxfiles-used>  =>   B<integer>

=begin html

<br>[not settable, online-only] The number of user-visible files currently in use on the referenced file system. Range: [0 - 2^64-1]

=end html

=back



=over 2

=item * I<fs-percent-inode-used-capacity>  =>   B<integer>

=begin html

<br>[not settable, online-only] The percentage of disk space currently in use based on user-visible file (inode) count on the referenced file system. Range: [0...100]

=end html

=back



=over 2

=item * I<fs-percent-used-capacity>  =>   B<integer>

=begin html

<br>[not settable, online-only] The percentage of disk space currently in use on the referenced file system. Range: [0...100]

=end html

=back



=over 2

=item * I<fs-sis-percent-saved>  =>   B<integer>

=begin html

<br>[not settable, online-only] The percentage of disk space saved by eliminating the duplicated blocks on the referenced file system. Range: [0...100]

=end html

=back



=over 2

=item * I<fs-sis-saved-space>  =>   B<integer>

=begin html

<br>[not settable, online-only] The total disk space in bytes that is saved by storing only one copy of the duplicated blocks on the referenced file system. Range: [0 - 2^64-1]

=end html

=back



=over 2

=item * I<fs-sis-shared-space>  =>   B<integer>

=begin html

<br>[not settable, online-only] The amount of data in bytes that is shared by more than one instance on the referenced file system. Range: [0 - 2^64-1]

=end html

=back



=over 2

=item * I<fs-size-available>  =>   B<integer, optional>

=begin html

<br>[not settable, online-only] Number of bytes still available in the referenced file system. If the referenced file system is restricted or offline, a value of 0 is returned. Range: [0 - 2^64-1]

=end html

=back



=over 2

=item * I<fs-size-total>  =>   B<integer, optional>

=begin html

<br>[not settable, online-only] Total size (in bytes) of the referenced file system . If the referenced file system is restricted or offline, a value 0 is returned. Range: [0 - 2^64-1]

=end html

=back



=over 2

=item * I<fs-size-used>  =>   B<integer, optional>

=begin html

<br>[not settable, online-only] Number of bytes used in the referenced file system. If the referenced file system is restricted or offline, a value of 0 is returned. Range: [0 - 2^64-1]

=end html

=back



=over 2

=item * I<fs-total-reserved-space>  =>   B<integer, optional>

=begin html

<br>The total disk space in bytes that is reserved on the referenced file system. The reserved space is already counted in the used space, so this element can be used to see what portion of the used space represents space reserved for future use. Range: [0 - 2^64-1]

=end html

=back



=over 2

=item * I<fs-used-including-snapshot-reserve>  =>   B<integer, optional>

=begin html

<br>This field represents space used by the aggregate including the aggregate's Snapshot reserve in bytes. Range : [0..2^64-1]

=end html

=back



=over 2

=item * I<fs-volume-footprints>  =>   B<integer, optional>

=begin html

<br>This field represents space used by the sum of all data and metadata of all volumes in the aggregate in bytes. Range : [0..2^64-1]

=end html

=back



=head2 ha-policy-type

=begin html

HA Policy of aggregate. It can be controller failover or storage failover or unspecified. Allowed values are: <ul> <li>"cfo": Controller FailOver <li>"sfo": Storage FailOver <li>"none": Unspecified </ul>

=end html



B<Fields>

=over 2

=item * None

=back



=head2 mirror-count-info

=begin html

Various counts information for mirror volumes in the aggregate. This information is returned only when the aggregate contains mirror volumes. Currently, Vfiler owned mirror destination volumes are counted only if those volumes are online.

=end html



B<Fields>

=over 2

=item * I<dp-qtree-snapmirror-destinations>  =>   B<integer, optional>

=begin html

<br>When present, this field indicates the number of data protection (dp) qtree snapmirror destination volumes. <p> Range: [0..2^31-1]

=end html

=back



=over 2

=item * I<dp-snapmirror-destinations>  =>   B<integer, optional>

=begin html

<br>When present, this field indicates the number of data protection (dp) snapmirror destination volumes. <p> Range: [0..2^31-1]

=end html

=back



=over 2

=item * I<ls-snapmirror-destinations>  =>   B<integer, optional>

=begin html

<br>When present, this field indicates the number of load sharing (ls) snapmirror destination volumes. <p> Range: [0..2^31-1]

=end html

=back



=over 2

=item * I<move-snapmirror-destinations>  =>   B<integer, optional>

=begin html

<br>When present, this field indicates the number of move snapmirror destination volumes that are created for volume move operations. <p> Range: [0..2^31-1]

=end html

=back



=head2 node-name

=begin html

Name of the node.

=end html



B<Fields>

=over 2

=item * None

=back



=head2 plex-info

=begin html

Information for a plex.

=end html



B<Fields>

=over 2

=item * I<is-online>  =>   B<boolean>

=begin html

<br>"true" if the plex is online, "false" otherwise.

=end html

=back



=over 2

=item * I<is-resyncing>  =>   B<boolean>

=begin html

<br>"true" if the plex is currently resyncing, "false" otherwise.

=end html

=back



=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Plex name, e.g. /myvol/plex0

=end html

=back



=over 2

=item * I<plex-status>  =>   B<string, optional>

=begin html

<br>Plex status. Possible values: "normal", "failed", "empty", "invalid", "uninitialized", "failed assimilation", "limbo", "active", "inactive", "resyncing", These values may appear by themselves or in combination separated by commas (e.g., "normal,active")

=end html

=back



=over 2

=item * I<pool>  =>   B<integer, optional>

=begin html

<br>The pool to which the majority of disks in the plex belong.

=end html

=back



=over 2

=item * I<raid-groups>  =>   B<L<"raid-group-info">[], optional>

=begin html

<br>List of all RAID groups in the plex. This appears only if the "verbose" parameter above is set to "true".

=end html

=back



=over 2

=item * I<resync-level>  =>   B<integer, optional>

=begin html

<br>If the plex is currently being resynced, then the resync level.

=end html

=back



=over 2

=item * I<resyncing-percentage>  =>   B<integer, optional>

=begin html

<br>If the plex is currently being resynced, then the completion percentage. Range : [0..100].

=end html

=back



=head2 raid-group-info

=begin html

Information for a particular RAID group.

=end html



B<Fields>

=over 2

=item * I<checksum-style>  =>   B<string>

=begin html

<br>Checksum style. The possible values: <ul> <li> "advanced_zoned" - advanced_zoned checksum (azcs), <li> "block" - block, <li> "mixed" - mixed, <li> "none" - none, <li> "unknown" - unknown, <li> "wafl" - wafl, <li> "zoned" - zoned. </ul>

=end html

=back



=over 2

=item * I<disks>  =>   B<L<"disk-info">[]>

=begin html

<br>List of disks in this plex.

=end html

=back



=over 2

=item * I<is-cache-tier>  =>   B<boolean>

=begin html

<br>"true" if the RAID group is composed of SSDs and the owning aggregate is hybrid (group is not part of usable space).

=end html

=back



=over 2

=item * I<is-recomputing-parity>  =>   B<boolean>

=begin html

<br>"true" if the RAID group is currently recomputing parity.

=end html

=back



=over 2

=item * I<is-reconstructing>  =>   B<boolean>

=begin html

<br>"true" if the RAID group is currently reconstructing.

=end html

=back



=over 2

=item * I<is-scrub-suspended>  =>   B<boolean, optional>

=begin html

<br>Suspended state of the scrub on that RAID group.

=end html

=back



=over 2

=item * I<last-scrub-timestamp>  =>   B<integer, optional>

=begin html

<br>Time at which the last full scrub completed. If a scrub has never been performed, this value will not be returned. The time value is in seconds since January 1, 1970. Range : [0..2^31-1].

=end html

=back



=over 2

=item * I<name>  =>   B<string>

=begin html

<br>RAID group name.

=end html

=back



=over 2

=item * I<recomputing-parity-percentage>  =>   B<integer, optional>

=begin html

<br>The percentage of parity recomputation if is-recomputing-parity is set to true. Range : [0-100]

=end html

=back



=over 2

=item * I<reconstruction-percentage>  =>   B<integer, optional>

=begin html

<br>If reconstruction is going on, the the completion percentage. Range : [0-100]

=end html

=back



=over 2

=item * I<scrub-percentage-complete>  =>   B<integer, optional>

=begin html

<br>Scrub percentage complete. If scrub is not active, this value will not be returned. Range: [0..100].

=end html

=back



=head2 snapshot-space-info

=begin html

A structure returning consolidated size-related information for all snapshots of the given volume.

=end html



B<Fields>

=over 2

=item * I<snapshot-files-total>  =>   B<integer>

=begin html

<br>[settable, online-only] Total file (inode) count, i.e., current maximum number of files (inodes) that this referenced file system can currently hold. If the referenced file system is restricted or offline, a value of 0 is returned. Range: [0 - 2^64-1]

=end html

=back



=over 2

=item * I<snapshot-files-used>  =>   B<integer>

=begin html

<br>[not settable, online-only] Number of files (inodes) used in the referenced file system. If the referenced file system is restricted or offline, a value of 0 is returned. Range: [0 - 2^64-1]

=end html

=back



=over 2

=item * I<snapshot-maxfiles-available>  =>   B<integer>

=begin html

<br>[not settable, always] The count of the maximum number of files allowable on the referenced file system. Range: [0 - 2^64-1]

=end html

=back



=over 2

=item * I<snapshot-maxfiles-possible>  =>   B<integer>

=begin html

<br>[not settable, always] The largest value to which the maxfiles-available parameter can be increased by reconfiguration, on the referenced file system. Range: [0 - 2^64-1]

=end html

=back



=over 2

=item * I<snapshot-maxfiles-used>  =>   B<integer>

=begin html

<br>[not settable, online-only] The count of the number of files currently in use on the referenced file system. Range: [0 - 2^64-1]

=end html

=back



=over 2

=item * I<snapshot-percent-inode-used-capacity>  =>   B<integer>

=begin html

<br>[not settable, online-only] The percentage of disk space currently in use based on file (inode) count on the referenced file system. Range: [0...100]

=end html

=back



=over 2

=item * I<snapshot-percent-used-capacity>  =>   B<integer>

=begin html

<br>[not settable, online-only] The percentage of disk space currently in use on the referenced file system. Range: [0...100]

=end html

=back



=over 2

=item * I<snapshot-sis-percent-saved>  =>   B<integer>

=begin html

<br>[not settable, online-only] The percentage of disk space saved by eliminating the duplicated blocks on the referenced file system. Range: [0...100]

=end html

=back



=over 2

=item * I<snapshot-sis-saved-space>  =>   B<integer>

=begin html

<br>[not settable, online-only] The total disk space in bytes that is saved by storing only one copy of the duplicated blocks on the referenced file system. Range: [0 - 2^64-1]

=end html

=back



=over 2

=item * I<snapshot-sis-shared-space>  =>   B<integer>

=begin html

<br>[not settable, online-only] The amount of data in bytes that is shared by more than one instance on the referenced file system. Range: [0 - 2^64-1]

=end html

=back



=over 2

=item * I<snapshot-size-available>  =>   B<integer, optional>

=begin html

<br>[not settable, online-only] Number of bytes still available in the referenced file system. If the referenced file system is restricted or offline, a value of 0 is returned. Range: [0 - 2^64-1]

=end html

=back



=over 2

=item * I<snapshot-size-total>  =>   B<integer, optional>

=begin html

<br>[not settable, online-only] Total size (in bytes) of the referenced file system. If the referenced file system is restricted or offline, a value 0 is returned. Range: [0 - 2^64-1]

=end html

=back



=over 2

=item * I<snapshot-size-used>  =>   B<integer, optional>

=begin html

<br>[not settable, online-only] Number of bytes used in the referenced file system. If the referenced file system is restricted or offline, a value of 0 is returned. Range: [0 - 2^64-1]

=end html

=back



=head2 striping-type

=begin html

Striping information of aggregate. Allowed values are: <ul> <li>"striped": Member of stripe. <li>"not_striped": Not member of stripe. <li>"unknown": Not known. </ul>

=end html



B<Fields>

=over 2

=item * None

=back



=head2 verify-detail-info

=begin html

Information about mirror verification.

=end html



B<Fields>

=over 2

=item * I<is-suspended>  =>   B<boolean>

=begin html

<br>Is mirror verification suspended for this aggregate?

=end html

=back



=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Name of the aggregate.

=end html

=back



=over 2

=item * I<percentage-complete>  =>   B<integer, optional>

=begin html

<br>Mirror verification percentage complete. If verification isn't active, this value won't be returned. Range: [0..100].

=end html

=back



=head2 volume-space-info

=begin html

List of flexible volumes in the aggregate and their space usage.

=end html



B<Fields>

=over 2

=item * I<guarantee>  =>   B<string>

=begin html

<br>Type of guarantee option set on this volume. Possible values: none, file, volume

=end html

=back



=over 2

=item * I<volume-allocated>  =>   B<integer>

=begin html

<br>Total space allocated for this volume in the aggregate. Range : [0..2^64-1]

=end html

=back



=over 2

=item * I<volume-name>  =>   B<string>

=begin html

<br>Name of the volume

=end html

=back



=over 2

=item * I<volume-used>  =>   B<integer>

=begin html

<br>Total space used by this volume. Range : [0..2^64-1]

=end html

=back



=head2 warning-code

=begin html

Warning codes for pre-check mode.

=end html



B<Fields>

=over 2

=item * I<code>  =>   B<integer>

=begin html

<br>Warning code.

=end html

=back



=head2 volume-name

=begin html

The name of a volume. The maximum string length is 255 characters.

=end html



B<Fields>

=over 2

=item * None

=back



=head2 access-rights-info

=begin html

Access rights of single user or single Unix group.

=end html



B<Fields>

=over 2

=item * I<access-rights>  =>   B<string>

=begin html

<br>User access rights. The format of the rights can be Unix-style combinations of r w x - or NT-style "No Access", "Read", "Change", and "Full Control".

=end html

=back



=over 2

=item * I<unix-group-name>  =>   B<string, optional>

=begin html

<br>Name of the Unix group.

=end html

=back



=over 2

=item * I<user-name>  =>   B<string, optional>

=begin html

<br>Name of the user.

=end html

=back



=head2 address-info

=begin html

Structure containing address information of servers.

=end html



B<Fields>

=over 2

=item * I<has-nossl>  =>   B<boolean, optional>

=begin html

<br>If true, the protocol SSL is not supported.

=end html

=back



=over 2

=item * I<hostname>  =>   B<string, optional>

=begin html

<br>The resolved hostname of the IP address.

=end html

=back



=over 2

=item * I<ip-address>  =>   B<string, optional>

=begin html

<br>The IP address in canonical form.

=end html

=back



=over 2

=item * I<is-broken>  =>   B<boolean, optional>

=begin html

<br>If true, the address is not responding.

=end html

=back



=over 2

=item * I<is-multihomed>  =>   B<boolean, optional>

=begin html

<br>If true, the address is a multi-homed server.

=end html

=back



=over 2

=item * I<is-primary>  =>   B<boolean, optional>

=begin html

<br>If true, the address is a primary server.

=end html

=back



=head2 cifs-functional-level

=begin html

null

=end html



B<Fields>

=over 2

=item * None

=back



=head2 cifs-session-info

=begin html

Information about a single cifs session.

=end html



B<Fields>

=over 2

=item * I<change-notifies>  =>   B<integer>

=begin html

<br>Number of active ChangeNotify requests.

=end html

=back



=over 2

=item * I<dirs>  =>   B<integer>

=begin html

<br>Number of open directories.

=end html

=back



=over 2

=item * I<files>  =>   B<integer>

=begin html

<br>Number of open files.

=end html

=back



=over 2

=item * I<host-ip>  =>   B<ip-address>

=begin html

<br>IP address, in dotted-decimal format, of the CIFS client.

=end html

=back



=over 2

=item * I<host-name>  =>   B<string, optional>

=begin html

<br>NetBios name of the CIFS client. This may be unavailable in certain situations. In such cases, the ONTAPI element 'host-ip' alone provides identity of the host.

=end html

=back



=over 2

=item * I<shares>  =>   B<integer>

=begin html

<br>Number of open shares.

=end html

=back



=over 2

=item * I<user>  =>   B<string, optional>

=begin html

<br>Name of the user.

=end html

=back



=over 2

=item * I<volumes-list>  =>   B<L<"volumes-list-info">[]>

=begin html

<br>List of volumes being accessed during the session.

=end html

=back



=head2 cifs-setup-ou

=begin html

The fully qualified name of a single joinable organizational unit.

=end html



B<Fields>

=over 2

=item * None

=back



=head2 cifs-setup-site

=begin html

The fully qualified name of a single joinable organizational unit.

=end html



B<Fields>

=over 2

=item * None

=back



=head2 cifs-share-acl-info

=begin html

Information about single share.

=end html



B<Fields>

=over 2

=item * I<share-name>  =>   B<string>

=begin html

<br>Name of the share.

=end html

=back



=over 2

=item * I<user-acl-info>  =>   B<L<"access-rights-info">[]>

=begin html

<br>List of users or Unix groups that have access to this share.

=end html

=back



=head2 cifs-share-info

=begin html

Information about a single cifs share.

=end html



B<Fields>

=over 2

=item * I<caching>  =>   B<string, optional>

=begin html

<br>String specifying the type of caching: "no_caching", "auto_document_caching", "auto_program_caching" and "manual_caching".

=end html

=back



=over 2

=item * I<description>  =>   B<string, optional>

=begin html

<br>description of the share.

=end html

=back



=over 2

=item * I<dir-umask>  =>   B<integer, optional>

=begin html

<br>File mode creation mask for a share in qtrees with Unix or mixed security styles. The mask restricts the initial permissions setting of a newly created directory. This mask overrides one set with "umask".

=end html

=back



=over 2

=item * I<file-umask>  =>   B<integer, optional>

=begin html

<br>File mode creation mask for a share in qtrees with Unix or mixed security styles. The mask restricts the initial permissions setting of a newly created file. This mask overrides one set with "umask".

=end html

=back



=over 2

=item * I<forcegroup>  =>   B<string, optional>

=begin html

<br>name of the group to which files to be created in the share belong to.

=end html

=back



=over 2

=item * I<is-access-based-enum>  =>   B<boolean, optional>

=begin html

<br>If true Access Based Enumeration (ABE) is enabled, else it is disabled. ABE filtered shared folders are visible to a user based on that individual user's access rights, preventing the display of folders or other shared resources that the user does not have rights to access. Its value is returned only if it is non-default value. Its default value is false.

=end html

=back



=over 2

=item * I<is-browse>  =>   B<boolean, optional>

=begin html

<br>if true, this share can be browsed. Its values is returned only if it is non-default value. Its default value is true.

=end html

=back



=over 2

=item * I<is-namespace-caching-allowed>  =>   B<boolean, optional>

=begin html

<br>If true, namespace caching is enabled on the share. If false or not specified, namespace caching is disabled. If namespace caching is enabled on a share, clients are allowed to cache the directory enumeration results for better performance.

=end html

=back



=over 2

=item * I<is-symlink-strict-security>  =>   B<boolean, optional>

=begin html

<br>If true or not specified, strict symlink security is enabled. If false, allows clients to follow symbolic links to destinations on this filer but outside of the current share. Its value is returned only if it is non-default value. Its default value is true.

=end html

=back



=over 2

=item * I<is-vol-offline>  =>   B<boolean, optional>

=begin html

<br>If true, volume is offline and the shares are not available. Its value is returned only if it is non-default value. Its default value is false.

=end html

=back



=over 2

=item * I<is-vscan>  =>   B<boolean, optional>

=begin html

<br>If true or not specified, virus scan is done when clients open files on this share. Its value is returned only if it is non-default value. Its default value is true.

=end html

=back



=over 2

=item * I<is-vscanread>  =>   B<boolean, optional>

=begin html

<br>If true or not specified, virus scan is done when clients open files on this share for read access. Its value is returned only if it is non-default value. Its defalut value is true.

=end html

=back



=over 2

=item * I<is-widelink>  =>   B<boolean, optional>

=begin html

<br>If true, allows clients to follow absolute symbolic links outside of this share, subject to NT security. Its value is returned only if it is non-default value. Its default value is false.

=end html

=back



=over 2

=item * I<maxusers>  =>   B<integer, optional>

=begin html

<br>max no. of simultaneous connections to the share.

=end html

=back



=over 2

=item * I<mount-point>  =>   B<string>

=begin html

<br>mount point of the share.

=end html

=back



=over 2

=item * I<share-name>  =>   B<string>

=begin html

<br>name of the cifs share.

=end html

=back



=over 2

=item * I<umask>  =>   B<integer, optional>

=begin html

<br>File mode creation mask for a share in qtrees with Unix or mixed security styles. The mask restricts the initial permissions setting of newly created files and directories. This field is ignored when both dir-umask and file-umask are present.

=end html

=back



=head2 cifs-top-info

=begin html

Information about a single cifs top.

=end html



B<Fields>

=over 2

=item * I<ops-per-sec>  =>   B<integer>

=begin html

<br>The number of operations of any type per second.

=end html

=back



=over 2

=item * I<read-ops>  =>   B<integer>

=begin html

<br>The number of read requests.

=end html

=back



=over 2

=item * I<read-size>  =>   B<integer>

=begin html

<br>The size in kbytes per second of data of read requests.

=end html

=back



=over 2

=item * I<suspicious-per-sec>  =>   B<integer>

=begin html

<br>The number of "suspicious" events per second due to the following conditions: ACCESS-DENIED returned for FindFirst ACCESS-DENIED returned for Open/CreateFile ACCESS-DENIED returned for DeleteFile SUCCESS returned for DeleteFile SUCCESS returned for TruncateFile

=end html

=back



=over 2

=item * I<user-info>  =>   B<string>

=begin html

<br>Information on the client with its IP address and user account.

=end html

=back



=over 2

=item * I<write-ops>  =>   B<integer>

=begin html

<br>The number of write requests.

=end html

=back



=over 2

=item * I<write-size>  =>   B<integer>

=begin html

<br>The size in kbytes per second of data of write requests.

=end html

=back



=head2 connection-info

=begin html

Structure containing information on the connection.

=end html



B<Fields>

=over 2

=item * I<connected-address>  =>   B<L<"address-info">[], optional>

=begin html

<br>An address list of currently connected servers.

=end html

=back



=over 2

=item * I<favored-address>  =>   B<L<"address-info">[], optional>

=begin html

<br>An address list of favored servers.

=end html

=back



=over 2

=item * I<other-address>  =>   B<L<"address-info">[], optional>

=begin html

<br>An address list of other servers.

=end html

=back



=over 2

=item * I<preferred-address>  =>   B<L<"address-info">[], optional>

=begin html

<br>An address list of preferred servers.

=end html

=back



=head2 homedir-path-info

=begin html

path to user home directory paths Unix style path to user home directories, example: /vol/vol1/users1 The paths are listed in the same order that the filer will use to evaluate whether a user has a cifs home directory.

=end html



B<Fields>

=over 2

=item * None

=back



=head2 nbalias-name-info

=begin html

NetBIOS alias for the filer

=end html



B<Fields>

=over 2

=item * None

=back



=head2 path-error-info

=begin html

Error description

=end html



B<Fields>

=over 2

=item * I<error-path>  =>   B<string>

=begin html

<br>Homedir path, if any, which had the error. This value is set to NULL if there is no path associated with the error.

=end html

=back



=over 2

=item * I<error-path-desc>  =>   B<string>

=begin html

<br>A description of the error.

=end html

=back



=head2 volumes-list-info

=begin html

Information about a single volume.

=end html



B<Fields>

=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume.

=end html

=back



=head2 block-range

=begin html

Structure containing source and destination block range for sub-file/sub-LUN cloning.

=end html



B<Fields>

=over 2

=item * I<block-count>  =>   B<integer>

=begin html

<br>Number of blocks to be cloned.

=end html

=back



=over 2

=item * I<destination-block-number>  =>   B<integer>

=begin html

<br>Starting file block number of destination block range.

=end html

=back



=over 2

=item * I<source-block-number>  =>   B<integer>

=begin html

<br>Starting file block number of source block range. Block size is 4096 bytes.

=end html

=back



=head2 clone-id-info

=begin html

Structure containing clone ID information.

=end html



B<Fields>

=over 2

=item * I<clone-op-id>  =>   B<integer>

=begin html

<br>ID of the clone operation.

=end html

=back



=over 2

=item * I<volume-uuid>  =>   B<string>

=begin html

<br>uuid of the volume.

=end html

=back



=head2 ops-info

=begin html

Structure containing information of a clone operation.

=end html



B<Fields>

=over 2

=item * I<block-ranges>  =>   B<L<"block-range">[], optional>

=begin html

<br>List of block ranges specified for sub-file/sub-LUN cloning. In case of complete file cloning there will be no output corresponding to this.

=end html

=back



=over 2

=item * I<blocks-copied>  =>   B<integer, optional>

=begin html

<br>Number of blocks that have been copied so far for running clone operation. The cloning operation shares destination blocks with source block. But if source block has already reached maximum number of sharing supported by WAFL, then block is copied for destination. It is recommended that if blocks are being copied, then user should change the source for next clone operation.

=end html

=back



=over 2

=item * I<clone-id>  =>   B<L<"clone-id-info">, optional>

=begin html

<br>Unique ID information of the clone operation.

=end html

=back



=over 2

=item * I<clone-state>  =>   B<string>

=begin html

<br>State of the clone operation. It could be 'running', 'failed' or 'completed'. For 'completed' state there will be no other field in ops-info output.

=end html

=back



=over 2

=item * I<clone-type>  =>   B<string, optional>

=begin html

<br>Type of clone. Possible types are 'file', 'sub_file', 'lun' and 'sub_lun'.

=end html

=back



=over 2

=item * I<destination-file>  =>   B<string, optional>

=begin html

<br>Destination file path. For sub-file/sub-LUN cloning within the same file/LUN, source-file and destination file will be same.

=end html

=back



=over 2

=item * I<error>  =>   B<integer, optional>

=begin html

<br>Error code corresponding to reason of failure. If error code is EDENSE_SHUTDOWN or EDENSE_FAILOVER, the clone operation will be restarted automatically after giveback/takeover or next reboot. If user has not aborted the clone operation using clone-stop, then for any other error code user should do clone-clear.

=end html

=back



=over 2

=item * I<percent-done>  =>   B<integer, optional>

=begin html

<br>Percentage cloning completed for running clone operation.

=end html

=back



=over 2

=item * I<reason>  =>   B<string, optional>

=begin html

<br>Reason of failure if clone operation could not complete successfully.

=end html

=back



=over 2

=item * I<source-file>  =>   B<string, optional>

=begin html

<br>Source file path.

=end html

=back



=over 2

=item * I<total-blocks>  =>   B<integer, optional>

=begin html

<br>Total number of blocks to be cloned for running clone operation.

=end html

=back



=head2 copyoffload-status-info

=begin html

Copy offload status information

=end html



B<Fields>

=over 2

=item * I<bytes-copied>  =>   B<integer>

=begin html

<br>Number of bytes copied thus far.

=end html

=back



=over 2

=item * I<copy-id>  =>   B<string>

=begin html

<br>Unique identifier assigned to this copy operation.

=end html

=back



=over 2

=item * I<copyoffload-error>  =>   B<integer, optional>

=begin html

<br>Error code corresponding to reason for failure: error codes are listed in the copyoffload-copy-status description. This field is used when state is "failure".

=end html

=back



=over 2

=item * I<copyoffload-state>  =>   B<string>

=begin html

<br>State of the copy operation. Values may be "running", "failed", "completed", or "aborted".

=end html

=back



=over 2

=item * I<destination-path>  =>   B<string>

=begin html

<br>Full path of the destination file to where the data will be copied, in /vol/<volume-name>/<file-path> format.

=end html

=back



=over 2

=item * I<length>  =>   B<integer>

=begin html

<br>Requested number of bytes to copy from the source file to the destination file. A value of 0 is interpreted as "copy from source offset to end of file".

=end html

=back



=over 2

=item * I<source-path>  =>   B<string>

=begin html

<br>Full path of the source file from where the data will be copied, in /vol/<volume-name>/<file-path> format.

=end html

=back



=head2 datetime

=begin html

The number of seconds since January 1, 1970. Range : [0..2^31-1].

=end html



B<Fields>

=over 2

=item * None

=back



=head2 date

=begin html

Date (in seconds since Jan. 1, 1970 12:00:00) Range : [0..2^31-1].

=end html



B<Fields>

=over 2

=item * None

=back



=head2 diagnosis-alert-definition-info

=begin html

System Health Alert Definition When returned as part of the output, all elements of this typedef are reported, unless limited by a set of desired attributes specified by the caller. <p> When used as input to specify desired attributes to return, omitting a given element indicates that it shall not be returned in the output. In contrast, by providing an element (even with no value) the caller ensures that a value for that element will be returned, given that the value can be retrieved. <p> When used as input to specify queries, any element can be omitted in which case the resulting set of objects is not constrained by any specific value of that attribute.

=end html



B<Fields>

=over 2

=item * I<additional-information>  =>   B<string, optional>

=begin html

<br>Additional information about the alert. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<alert-id>  =>   B<string, optional>

=begin html

<br>Alert identification. Attributes: key, non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<alert-type>  =>   B<hm-alert-type, optional>

=begin html

<br>Type of alert (other,communications,quality-of-service,processing-error,device,environmental,model-change,security). Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<corrective-actions>  =>   B<string, optional>

=begin html

<br>Recommended actions to correct the problem reported by alert. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<monitor>  =>   B<hm-type, optional>

=begin html

<br>Type of health monitor (e.g. node_connect, system_connect, system). Attributes: key, non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<node>  =>   B<string, optional>

=begin html

<br>Node hosting this health monitor. Attributes: key, non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<perceived-severity>  =>   B<hm-perceived-sev, optional>

=begin html

<br>Severity of alert (Unknown,Other,Information,Degraded,Minor,Major,Critical,Fatal). Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<possible-effect>  =>   B<string, optional>

=begin html

<br>Detailed description of the possible effect of the condition. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<probable-cause>  =>   B<hm-probable-cause, optional>

=begin html

<br>Probable cause for alert generation. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<probable-cause-description>  =>   B<string, optional>

=begin html

<br>Detailed description of probable cause for alert generation. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<subsystem>  =>   B<hm-subsystem, optional>

=begin html

<br>Type of subsystem being monitored (e.g. sas_connect). Attributes: non-creatable, non-modifiable

=end html

=back



=head2 diagnosis-alert-info

=begin html

System Health Alert When returned as part of the output, all elements of this typedef are reported, unless limited by a set of desired attributes specified by the caller. <p> When used as input to specify desired attributes to return, omitting a given element indicates that it shall not be returned in the output. In contrast, by providing an element (even with no value) the caller ensures that a value for that element will be returned, given that the value can be retrieved. <p> When used as input to specify queries, any element can be omitted in which case the resulting set of objects is not constrained by any specific value of that attribute.

=end html



B<Fields>

=over 2

=item * I<acknowledge>  =>   B<boolean, optional>

=begin html

<br>Acknowledge the alert condition. Attributes: non-creatable, modifiable

=end html

=back



=over 2

=item * I<acknowledger>  =>   B<string, optional>

=begin html

<br>Person who acknowledged this alert Attributes: non-creatable, modifiable

=end html

=back



=over 2

=item * I<additional-info>  =>   B<string[], optional>

=begin html

<br>Additional information from the resource that generated this alert Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<alert-id>  =>   B<string, optional>

=begin html

<br>Alert identification. Attributes: key, non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<alerting-resource>  =>   B<string, optional>

=begin html

<br>Unique name of resource that generated the alert. Attributes: key, non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<alerting-resource-name>  =>   B<string, optional>

=begin html

<br>Display name of resource that generated the alert. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<corrective-actions>  =>   B<string, optional>

=begin html

<br>Recommended actions to correct the problem reported by alert. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<indication-time>  =>   B<date, optional>

=begin html

<br>Time of alert generation. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<monitor>  =>   B<hm-type, optional>

=begin html

<br>Type of health monitor (e.g. node_connect, system_connect, system). Attributes: key, non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<node>  =>   B<string, optional>

=begin html

<br>Node hosting this health monitor. Attributes: key, non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<perceived-severity>  =>   B<hm-perceived-sev, optional>

=begin html

<br>Severity of alert. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<policy>  =>   B<string, optional>

=begin html

<br>Policy rule responsible for creating this alert. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<possible-effect>  =>   B<string, optional>

=begin html

<br>Possible effect seen due to this problem. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<probable-cause>  =>   B<hm-probable-cause, optional>

=begin html

<br>Probable cause for alert generation. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<probable-cause-description>  =>   B<string, optional>

=begin html

<br>Detailed description of probable cause for alert generation. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<subsystem>  =>   B<hm-subsystem, optional>

=begin html

<br>Type of subsystem being monitored (e.g. sas_connect). Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<suppress>  =>   B<boolean, optional>

=begin html

<br>Suppress this alert. Attributes: non-creatable, modifiable

=end html

=back



=over 2

=item * I<suppressor>  =>   B<string, optional>

=begin html

<br>Person who suppressed this alert Attributes: non-creatable, modifiable

=end html

=back



=head2 diagnosis-config-info

=begin html

System Health Config When returned as part of the output, all elements of this typedef are reported, unless limited by a set of desired attributes specified by the caller. <p> When used as input to specify desired attributes to return, omitting a given element indicates that it shall not be returned in the output. In contrast, by providing an element (even with no value) the caller ensures that a value for that element will be returned, given that the value can be retrieved. <p> When used as input to specify queries, any element can be omitted in which case the resulting set of objects is not constrained by any specific value of that attribute.

=end html



B<Fields>

=over 2

=item * I<aggregator>  =>   B<hm-type, optional>

=begin html

<br>Aggregating health monitor that aggregates status from this health monitor. Attributes: non-creatable, non-modifiable Possible values: <ul> <li> "node_connect" ... node scope health monitor , <li> "system_connect" ... cluster scope health monitor , <li> "system" ... aggregator of health monitor status , </ul>

=end html

=back



=over 2

=item * I<context>  =>   B<hm-scope, optional>

=begin html

<br>Scope of health monitor (node-context, cluster-context). Attributes: non-creatable, non-modifiable Possible values: <ul> <li> "node_context" , <li> "cluster_context" </ul>

=end html

=back



=over 2

=item * I<health>  =>   B<hm-status, optional>

=begin html

<br>Status of health monitor (ok, ok-with-suppressed, degraded). Attributes: non-creatable, non-modifiable Possible values: <ul> <li> "ok" , <li> "ok_with_suppressed" , <li> "degraded" , <li> "unreachable" , <li> "unknown" </ul>

=end html

=back



=over 2

=item * I<init-state>  =>   B<hm-subsystem-discovery-state, optional>

=begin html

<br>Subsystem initialization state of health monitor Attributes: non-creatable, non-modifiable Possible values: <ul> <li> "invalid" , <li> "initializing" , <li> "initialized" , <li> "start_discovery" , <li> "start_rediscovery" , <li> "discovered_partially" , <li> "discovery_done" , <li> "discovery_max" </ul>

=end html

=back



=over 2

=item * I<mon-version>  =>   B<string, optional>

=begin html

<br>Health Monitor version. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<monitor>  =>   B<hm-type, optional>

=begin html

<br>Type of health monitor. Attributes: key, non-creatable, non-modifiable Possible values: <ul> <li> "node_connect" ... node scope health monitor , <li> "system_connect" ... cluster scope health monitor , <li> "system" ... aggregator of health monitor status , </ul>

=end html

=back



=over 2

=item * I<node>  =>   B<string, optional>

=begin html

<br>Node hosting this health monitor. Attributes: key, non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<pol-version>  =>   B<string, optional>

=begin html

<br>Policy file version. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<resources>  =>   B<string[], optional>

=begin html

<br>Resources monitored by this health monitor. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<sub-pol-versions>  =>   B<string, optional>

=begin html

<br>Subordinate policy file versions. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<subsystem>  =>   B<hm-subsystem[], optional>

=begin html

<br>Type of subsystem being monitored (e.g. sas_connect). Attributes: non-creatable, non-modifiable Possible values: <ul> <li> "sas_connect" , <li> "ha_health" , </ul>

=end html

=back



=head2 diagnosis-policy-definition-info

=begin html

System Health Policy Definition When returned as part of the output, all elements of this typedef are reported, unless limited by a set of desired attributes specified by the caller. <p> When used as input to specify desired attributes to return, omitting a given element indicates that it shall not be returned in the output. In contrast, by providing an element (even with no value) the caller ensures that a value for that element will be returned, given that the value can be retrieved. <p> When used as input to specify queries, any element can be omitted in which case the resulting set of objects is not constrained by any specific value of that attribute.

=end html



B<Fields>

=over 2

=item * I<alert-count>  =>   B<integer, optional>

=begin html

<br>Count of alerts created as a result of this policy. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<alert-id>  =>   B<string, optional>

=begin html

<br>Alert identifier for alert to be generated on policy rule match. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<creation-time>  =>   B<datetime, optional>

=begin html

<br>Time when the previous alert was created due to this policy. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<enable>  =>   B<boolean, optional>

=begin html

<br>Enable/disable this policy. Attributes: non-creatable, modifiable

=end html

=back



=over 2

=item * I<monitor>  =>   B<hm-type, optional>

=begin html

<br>Type of health monitor (e.g. node_connect, system_connect, system). Attributes: key, non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<node>  =>   B<string, optional>

=begin html

<br>Node hosting this health monitor. Attributes: key, non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<policy-id>  =>   B<string, optional>

=begin html

<br>Policy identifier. Attributes: key, non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<responsible-resource-info>  =>   B<string, optional>

=begin html

<br>The resource responsible for creating this alert Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<rule-expression>  =>   B<string, optional>

=begin html

<br>Arithmetic expression which defines alerts to be created as a result of this policy. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<where>  =>   B<string, optional>

=begin html

<br>Where clause of Arithmetic expression. Attributes: non-creatable, non-modifiable

=end html

=back



=head2 diagnosis-status

=begin html

System Health Status When returned as part of the output, all elements of this typedef are reported, unless limited by a set of desired attributes specified by the caller. <p> When used as input to specify desired attributes to return, omitting a given element indicates that it shall not be returned in the output. In contrast, by providing an element (even with no value) the caller ensures that a value for that element will be returned, given that the value can be retrieved. <p> When used as input to specify queries, any element can be omitted in which case the resulting set of objects is not constrained by any specific value of that attribute.

=end html



B<Fields>

=over 2

=item * I<status>  =>   B<hm-status, optional>

=begin html

<br>Overall system health (ok,ok-with-suppressed,degraded,unreachable) as determined by the diagnosis framework. Attributes: non-creatable, non-modifiable

=end html

=back



=head2 diagnosis-subscriptions-info

=begin html

System Health Subscriptions When returned as part of the output, all elements of this typedef are reported, unless limited by a set of desired attributes specified by the caller. <p> When used as input to specify desired attributes to return, omitting a given element indicates that it shall not be returned in the output. In contrast, by providing an element (even with no value) the caller ensures that a value for that element will be returned, given that the value can be retrieved. <p> When used as input to specify queries, any element can be omitted in which case the resulting set of objects is not constrained by any specific value of that attribute.

=end html



B<Fields>

=over 2

=item * I<class-name>  =>   B<string, optional>

=begin html

<br>Class name of changed resource. Attributes: key, required-for-create, non-modifiable

=end html

=back



=over 2

=item * I<creation-time>  =>   B<datetime, optional>

=begin html

<br>Time at which this subscription was created. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<event-type>  =>   B<hm-event-type, optional>

=begin html

<br>Type of event (rm-add, rm-del, rm-mod) for which notification is to be generated. Attributes: key, required-for-create, non-modifiable

=end html

=back



=over 2

=item * I<fail-thresh>  =>   B<integer, optional>

=begin html

<br>Failure threshold for notification. Attributes: optional-for-create, modifiable

=end html

=back



=over 2

=item * I<instance-name>  =>   B<string, optional>

=begin html

<br>Instance name of changed resource. Attributes: optional-for-create, modifiable

=end html

=back



=over 2

=item * I<max-notify-period>  =>   B<integer, optional>

=begin html

<br>Maximum expected time for Notification to complete. Attributes: optional-for-create, modifiable

=end html

=back



=over 2

=item * I<monitor>  =>   B<hm-type, optional>

=begin html

<br>Type of source health monitor (e.g. node_connect, system_connect, system). Attributes: key, required-for-create, non-modifiable

=end html

=back



=over 2

=item * I<node>  =>   B<string, optional>

=begin html

<br>Node hosting this health monitor and sends out notifications Attributes: key, non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<notify-dest-hm>  =>   B<hm-type, optional>

=begin html

<br>Health monitor subsribing for notification. Attributes: key, required-for-create, non-modifiable

=end html

=back



=over 2

=item * I<notify-dest-node>  =>   B<node-name, optional>

=begin html

<br>Node hosting the health monitor that is subscribing for notification. Attributes: key, required-for-create, non-modifiable

=end html

=back



=over 2

=item * I<notify-fptr>  =>   B<integer, optional>

=begin html

<br>Function pointer to be invoked. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<notify-table>  =>   B<string, optional>

=begin html

<br>Table name for DSMF notification. Attributes: optional-for-create, modifiable

=end html

=back



=over 2

=item * I<notify-type>  =>   B<hm-notify-type, optional>

=begin html

<br>Type of notification (dsmf-type, fptr-type). Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<psc-option>  =>   B<boolean, optional>

=begin html

<br>Enable/Disable periodic status confirmation. Attributes: optional-for-create, modifiable

=end html

=back



=over 2

=item * I<subscription-id>  =>   B<string, optional>

=begin html

<br>Subscription identifier. Attributes: key, required-for-create, non-modifiable

=end html

=back



=over 2

=item * I<time-gap-notify>  =>   B<integer, optional>

=begin html

<br>Time Period between two notifications. Attributes: optional-for-create, modifiable

=end html

=back



=head2 diagnosis-subsystem-config-info

=begin html

System Health Subsystem Status When returned as part of the output, all elements of this typedef are reported, unless limited by a set of desired attributes specified by the caller. <p> When used as input to specify desired attributes to return, omitting a given element indicates that it shall not be returned in the output. In contrast, by providing an element (even with no value) the caller ensures that a value for that element will be returned, given that the value can be retrieved. <p> When used as input to specify queries, any element can be omitted in which case the resulting set of objects is not constrained by any specific value of that attribute.

=end html



B<Fields>

=over 2

=item * I<health>  =>   B<hm-status, optional>

=begin html

<br>Health of Subsystem. Attributes: non-creatable, non-modifiable Possible values: <ul> <li> "ok" , <li> "ok_with_suppressed" , <li> "degraded" , <li> "unreachable" , <li> "unknown" </ul>

=end html

=back



=over 2

=item * I<init-state>  =>   B<hm-subsystem-discovery-state, optional>

=begin html

<br>Initialization State of Subsystem. Attributes: non-creatable, non-modifiable Possible values: <ul> <li> "invalid" , <li> "initializing" , <li> "initialized" , <li> "start_discovery" , <li> "start_rediscovery" , <li> "discovered_partially" , <li> "discovery_done" , <li> "discovery_max" </ul>

=end html

=back



=over 2

=item * I<outstanding-alert-count>  =>   B<integer, optional>

=begin html

<br>Number of outstanding alerts. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<subsystem>  =>   B<hm-subsystem, optional>

=begin html

<br>Type of subsystem being monitored <p> Possible values: <ul> <li> 'sas_connect', <li> 'ha_health', </ul> Attributes: key, non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<suppressed-alert-count>  =>   B<integer, optional>

=begin html

<br>Number of suppressed alerts. Attributes: non-creatable, non-modifiable

=end html

=back



=head2 hm-alert-type

=begin html

Type of alert

=end html



B<Fields>

=over 2

=item * None

=back



=head2 hm-event-type

=begin html

Event type

=end html



B<Fields>

=over 2

=item * None

=back



=head2 hm-notify-type

=begin html

Notify type

=end html



B<Fields>

=over 2

=item * None

=back



=head2 hm-perceived-sev

=begin html

Alert severity

=end html



B<Fields>

=over 2

=item * None

=back



=head2 hm-probable-cause

=begin html

Probable cause for alert generation

=end html



B<Fields>

=over 2

=item * None

=back



=head2 hm-scope

=begin html

Node or Cluster context of Health Monitor Possible values: <ul> <li> "node_context" , <li> "cluster_context" </ul>

=end html



B<Fields>

=over 2

=item * None

=back



=head2 hm-status

=begin html

Health Monitor Status Possible values: <ul> <li> "ok" , <li> "ok_with_suppressed" , <li> "degraded" , <li> "unreachable" , <li> "unknown" </ul>

=end html



B<Fields>

=over 2

=item * None

=back



=head2 hm-subsystem

=begin html

Health Monitor Subsystem

=end html



B<Fields>

=over 2

=item * None

=back



=head2 hm-subsystem-discovery-state

=begin html

Health Monitor Subsystem State Possible values: <ul> <li> "invalid" , <li> "initializing" , <li> "initialized" , <li> "start_discovery" , <li> "start_rediscovery" , <li> "discovered_partially" , <li> "discovery_done" , <li> "discovery_max" </ul>

=end html



B<Fields>

=over 2

=item * None

=back



=head2 hm-type

=begin html

Type of Health Monitor

=end html



B<Fields>

=over 2

=item * None

=back



=head2 disk-detail-info

=begin html

Disk status information.

=end html



B<Fields>

=over 2

=item * I<aggregate>  =>   B<string, optional>

=begin html

<br>Aggregate that the disk resides on. Returned for disks contained on a flexible volume. Not returned for traditional volumes.

=end html

=back



=over 2

=item * I<bay>  =>   B<string>

=begin html

<br>Disk bay. If disk bay can't be determined, value will be "?".

=end html

=back



=over 2

=item * I<blocks-read>  =>   B<integer>

=begin html

<br>Number of blocks read since the controller was powered on last. Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<blocks-written>  =>   B<integer>

=begin html

<br>Number of blocks written since the controller was powered on last. Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<broken-details>  =>   B<string, optional>

=begin html

<br>Reason for the disk failure, if raid-state is 'broken'. Possible values are 'unknown', 'failed', 'admin failed', 'labeled broken', 'init failed', 'admin removed', 'not responding', 'pulled', 'bad label', 'bypassed', 'SFO Disk' and 'not failed'. If raid-state is not 'broken', broken-details will be omitted in the ouput.

=end html

=back



=over 2

=item * I<bytes-per-sector>  =>   B<integer>

=begin html

<br>Bytes per sector. Range : [0..2^31-1].

=end html

=back



=over 2

=item * I<checksum-compatibility>  =>   B<string>

=begin html

<br>An indication of the checksum types that this disk is capable of supporting. Each possible return value represents one or more checksum types. <p> Starting in Data ONTAP 8.1, "zoned/block" is no longer supported. <p> Possible values are: <ul> <li> "advanced_zoned" - Supports advanced_zoned checksum. <li> "block" - Supports block checksum. <li> "none" - No checksum support. <li> "zoned/advanced_zoned" - Supports zoned and advanced_zoned checksum. <li> "zoned/block" - Supports zoned and block checksum. </ul>

=end html

=back



=over 2

=item * I<copy-destination>  =>   B<string, optional>

=begin html

<br>The name of the disk selected as the destination to copy this disk when it must be replaced (is-prefailed or is-replacing is true). This element is not returned if the destination is not selected. The destination might not be present even when is-prefailed or is-replacing is true, if there is no appropriate spare, or other disk copy is in progress, or the destination was not yet selected, including immediately after disk-replace-start.

=end html

=back



=over 2

=item * I<copy-percent>  =>   B<integer, optional>

=begin html

<br>Percent of disk copy done, if disk is involved in Rapid RAID Recovery, either as the source (is-prefailed or is-replacing is true) or as the destination (raid-state is 'copy') of disk copy. This element is not returned if the destination is not selected yet. Range : [0..100].

=end html

=back



=over 2

=item * I<disk-model>  =>   B<string>

=begin html

<br>Disk model.

=end html

=back



=over 2

=item * I<disk-type>  =>   B<string>

=begin html

<br>Type of disk: ATA, BSAS, EATA, FCAL, FSAS, LUN, MSATA, SAS, SATA, SCSI, SSD, XATA, XSAS, or unknown.

=end html

=back



=over 2

=item * I<disk-uid>  =>   B<string>

=begin html

<br>Disk unique identifier. Maximum length of 90 characters.

=end html

=back



=over 2

=item * I<effective-disk-type>  =>   B<string>

=begin html

<br>Disks with same effective-disk-type are compatible, and they can be used in the same aggregate, even though their physical disk type, as reported by disk-type may be different. Possible values are the same as for disk-type: ATA, BSAS, EATA, FCAL, FSAS, LUN, MSATA, SAS, SATA, SCSI, SSD, XATA, XSAS, or unknown.

=end html

=back



=over 2

=item * I<firmware-revision>  =>   B<string>

=begin html

<br>Firmware revision of disk. The format of the firmware revision will vary depending on the type of disk and its vendor.

=end html

=back



=over 2

=item * I<grown-defect-list-count>  =>   B<integer>

=begin html

<br>Number of entries in the drive's grown defect list. Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<host-adapter>  =>   B<string>

=begin html

<br>Host adapter.

=end html

=back



=over 2

=item * I<id>  =>   B<integer>

=begin html

<br>internal Id of disk. Range : [-2^31..2^31-1].

=end html

=back



=over 2

=item * I<is-dynamically-qualified>  =>   B<boolean>

=begin html

<br>True if the drive was dynamically qualified.

=end html

=back



=over 2

=item * I<is-offline>  =>   B<boolean, optional>

=begin html

<br>True if the disk is offline. If the disk is not offline, this element will not be included with the output.

=end html

=back



=over 2

=item * I<is-prefailed>  =>   B<boolean, optional>

=begin html

<br>True if the disk is prefailed and undergoing disk copy (as the source) or waiting for such disk copy to be started, false otherwise.

=end html

=back



=over 2

=item * I<is-replacing>  =>   B<boolean, optional>

=begin html

<br>True if the disk is marked to be replaced with another disk and undergoing disk copy (as the source) or waiting for such disk copy to be started, false otherwise.

=end html

=back



=over 2

=item * I<is-zeroed>  =>   B<boolean, optional>

=begin html

<br>True if the disk is a spare and has already been zeroed, false otherwise. If disk is not a spare or if it is currently being zeroed, this element will not be included with the output.

=end html

=back



=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Name of the disk, e.g. v1.1

=end html

=back



=over 2

=item * I<node>  =>   B<string>

=begin html

<br>Controller supplying this disk record.

=end html

=back



=over 2

=item * I<physical-blocks>  =>   B<integer>

=begin html

<br>Number of 512-byte blocks on disk. Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<physical-space>  =>   B<integer>

=begin html

<br>Physical disk size in bytes. Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<plex>  =>   B<string, optional>

=begin html

<br>Plex the disk belongs. Not returned if disk doesn't belong to any plex. Example : plex0.

=end html

=back



=over 2

=item * I<pool>  =>   B<string, optional>

=begin html

<br>Pool the disk is in. Example : pool0.

=end html

=back



=over 2

=item * I<port>  =>   B<string>

=begin html

<br>Port of disk, e.g. A.

=end html

=back



=over 2

=item * I<port-name>  =>   B<string>

=begin html

<br>The port name of the disk object, e.g. FC:A.

=end html

=back



=over 2

=item * I<poweron-hours>  =>   B<integer, optional>

=begin html

<br>Number of hours the drive has been powered on. Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<raid-group>  =>   B<string, optional>

=begin html

<br>Raid group disk belongs. Not returned if disk doesn't belong to any raid group.

=end html

=back



=over 2

=item * I<raid-state>  =>   B<string>

=begin html

<br>Raid state. Possible values are : partner, broken, zeroing, spare, copy, pending, reconstructing, present and unknown.

=end html

=back



=over 2

=item * I<raid-type>  =>   B<string>

=begin html

<br>Raid type. Possible values are : pending, parity, dparity, data, and unowned.

=end html

=back



=over 2

=item * I<raw-disk-sectors>  =>   B<integer>

=begin html

<br>Number of sectors on disk (as reported by the read capacity command). Range: [0..2^64-1].

=end html

=back



=over 2

=item * I<reconstruction-percent>  =>   B<integer, optional>

=begin html

<br>Percent of reconstruction done, if the disk is undergoing reconstruction (raid-state is 'reconstructing'). This element is not returned if the disk is not being reconstructed. Range : [0..100].

=end html

=back



=over 2

=item * I<rpm>  =>   B<integer, optional>

=begin html

<br>Rotational speed in revolutions per minute. Possible values are: 5400, 7200, 10000, and 15000. This element is not returned when the value is not known, or when it does not apply.

=end html

=back



=over 2

=item * I<scrub-count>  =>   B<integer>

=begin html

<br>Number of times the drive was scrubbed since the controller was powered on last. Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<scrub-last-done>  =>   B<integer>

=begin html

<br>Number of seconds since the last time scrub was completed. Range: [0-2^64-1]

=end html

=back



=over 2

=item * I<secondary-host-adapter>  =>   B<string>

=begin html

<br>Secondary Host adapter.

=end html

=back



=over 2

=item * I<secondary-name>  =>   B<string>

=begin html

<br>Secondary name.

=end html

=back



=over 2

=item * I<secondary-port>  =>   B<string>

=begin html

<br>Secondary port.

=end html

=back



=over 2

=item * I<serial-number>  =>   B<string>

=begin html

<br>Disk serial number. Maximum length of 129 characters.

=end html

=back



=over 2

=item * I<shelf>  =>   B<string>

=begin html

<br>Disk shelf. If disk shelf can't be determined, value will be "?".

=end html

=back



=over 2

=item * I<shm-time-interval>  =>   B<integer>

=begin html

<br>Number of seconds we have been counting errors from SHM (Storage Health Monitor). Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<ssd-info>  =>   B<L<"storage-ssd-info">, optional>

=begin html

<br>Info block for solid-state storage devices.

=end html

=back



=over 2

=item * I<used-blocks>  =>   B<integer>

=begin html

<br>Number of 512-byte blocks used. Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<used-space>  =>   B<integer>

=begin html

<br>Used space in bytes. Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<v-series-detail-info>  =>   B<L<"v-series-detail-info">, optional>

=begin html

<br>Lists LUN status from RAID array LUNs

=end html

=back



=over 2

=item * I<vendor-id>  =>   B<string>

=begin html

<br>Vendor of this disk.

=end html

=back



=over 2

=item * I<volume>  =>   B<string, optional>

=begin html

<br>Volume the disks is used in. Not returned if disk isn't used in any volume or if the disk belongs to a partner or if the disk is in an aggregate.

=end html

=back



=over 2

=item * I<zeroing-percent>  =>   B<integer, optional>

=begin html

<br>Zeroing percentage done, if disk is being zeroed. Element is not returned if disk is not being zeroed. Range : [0..100].

=end html

=back



=head2 disk-name

=begin html

name of a disk.

=end html



B<Fields>

=over 2

=item * None

=back



=head2 disk-sanown-detail-info

=begin html

Disk sanown information.

=end html



B<Fields>

=over 2

=item * I<checksum>  =>   B<string, optional>

=begin html

<br>Only returned on RAID array LUNs. The possible values: <ul> <li> "advanced_zoned" - advanced_zoned checksum (azcs), <li> "block" - block, <li> "zoned" - zoned. </ul>

=end html

=back



=over 2

=item * I<home>  =>   B<string, optional>

=begin html

<br>The home of the disk. On NG will be different than owner if the home node has been taken over. On Classic this will be the same as owner. If the disk has no owner, this will not be returned.

=end html

=back



=over 2

=item * I<home-id>  =>   B<integer, optional>

=begin html

<br>ID (NVRAM ID) of disk home. Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<is-failed>  =>   B<boolean>

=begin html

<br>'true' if the disk is failed, 'false' otherwise.

=end html

=back



=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Name of the disk, e.g. v1.1 Wildcarding for disk string is suuported, e.g. v1.*

=end html

=back



=over 2

=item * I<owner>  =>   B<string, optional>

=begin html

<br>Current owner of the disk. If disk has no owner, this will not be returned.

=end html

=back



=over 2

=item * I<owner-id>  =>   B<integer, optional>

=begin html

<br>ID (NVRAM ID) of owner if there is one. Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<pool>  =>   B<integer, optional>

=begin html

<br>Pool the disk belongs to, if it has a owner.

=end html

=back



=over 2

=item * I<reserved-by>  =>   B<integer>

=begin html

<br>ID (NVRAM ID) of node with the reservation on this disk, 0 if there is none. Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<serial-no>  =>   B<string>

=begin html

<br>Serial number of the disk.

=end html

=back



=over 2

=item * I<type>  =>   B<string, optional>

=begin html

<br>Indicates the type of disk or device being being reported. Values are one of following: "SCSI", "FCAL", "D_ATA", "E_ATA", "LUN", "MSATA", "SSD", "UNKNOWN"

=end html

=back



=head2 disk-sanown-filer-detail-info

=begin html

Disk sanown filer information.

=end html



B<Fields>

=over 2

=item * I<filer-id>  =>   B<integer>

=begin html

<br>ID (NVRAM ID) of owner. Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<filer-name>  =>   B<string, optional>

=begin html

<br>Name of the filer. If the filer name hasn't been written to the disks, this will not be returned.

=end html

=back



=head2 storage-ssd-info

=begin html

Storage info block for solid-state storage devices.

=end html



B<Fields>

=over 2

=item * I<percent-rated-life-used>  =>   B<integer, optional>

=begin html

<br>An estimate of the percentage of device life that has been used, based on the actual device usage and the manufacturer's prediction of device life. A value greater than 99 indicates that the estimated endurance has been consumed, but may not indicate a device failure. Omitted if value is unknown.

=end html

=back



=over 2

=item * I<percent-spares-consumed>  =>   B<integer, optional>

=begin html

<br>Percentage of device spare blocks that have been used. Each device has a number of spare blocks that will be used when a data block can no longer be used to store data. This value reports what percentage of the spares have already been consumed. Omitted if value is unknown.

=end html

=back



=over 2

=item * I<percent-spares-consumed-limit>  =>   B<integer, optional>

=begin html

<br>Spares consumed percentage limit reported by the device. Omitted if value is unknown.

=end html

=back



=head2 v-series-detail-info

=begin html

LUN status from RAID array LUNs

=end html



B<Fields>

=over 2

=item * I<alternate-array-node-wwn>  =>   B<string>

=begin html

<br>The RAID array LUN alternate path is the path that can be used to communicate with the LUN, but not currently used. This is the WWNN (World Wide Node Name) of the array FC port used as the secondary path.

=end html

=back



=over 2

=item * I<alternate-array-port-wwn>  =>   B<string>

=begin html

<br>The RAID array LUN alternate path is the path that can be used to communicate with the LUN, but not currently used. This is the WWPN (World Wide Port Name) of the array FC port used as the secondary path.

=end html

=back



=over 2

=item * I<alternate-array-switch-port-wwn>  =>   B<string, optional>

=begin html

<br>The RAID array LUN alternate path is the path that can be used to communicate with the LUN, but not currently used. This is the WWN of the switch FC port connected to the array FC port used as primary path. This field is present in switch attached configrations only.

=end html

=back



=over 2

=item * I<alternate-controller-port-wwn>  =>   B<string>

=begin html

<br>The RAID array LUN alternate path is the path that can be used to communicate with the LUN, but not currently used. This is the WWN of the FC port controller used as secondary path.

=end html

=back



=over 2

=item * I<alternate-lun-number>  =>   B<integer>

=begin html

<br>LUN number on the alternate path Range: [0..65535]

=end html

=back



=over 2

=item * I<alternate-switch-name>  =>   B<string, optional>

=begin html

<br>Switch name of the alternate path. Present for switch attached configurations only.

=end html

=back



=over 2

=item * I<alternate-switch-port>  =>   B<integer, optional>

=begin html

<br>Switch port of the alternate path. Present for switch attached configurations only. Range: [0..1024].

=end html

=back



=over 2

=item * I<alternate-vseries-port-wwn>  =>   B<string>

=begin html

<br>This is the same as alternate-controller-port-wwn, presented for backwards compatibility.

=end html

=back



=over 2

=item * I<primary-array-node-wwn>  =>   B<string>

=begin html

<br>The RAID array LUN primary path is the path that is currently used to communicate with the LUN. This is the WWNN (World Wide Node Name) of the array FC port used as primary path.

=end html

=back



=over 2

=item * I<primary-array-port-wwn>  =>   B<string>

=begin html

<br>The RAID array LUN primary path is the path that is currently used to communicate with the LUN. This is the WWPN (World Wide Port Name) of the array FC port used as primary path.

=end html

=back



=over 2

=item * I<primary-array-switch-port-wwn>  =>   B<string, optional>

=begin html

<br>The RAID array LUN primary path is the path that is currently used to communicate with the LUN. This is the WWN of the switch FC port connected to the array FC port used as primary path. This field is present in switch attached configrations only.

=end html

=back



=over 2

=item * I<primary-controller-port-wwn>  =>   B<string>

=begin html

<br>The RAID array LUN primary path is the path that is currently used to communicate with the LUN. This is the WWN of the FC port controller used as primary path.

=end html

=back



=over 2

=item * I<primary-lun-number>  =>   B<integer>

=begin html

<br>LUN number on the primary path Range: [0..65535]

=end html

=back



=over 2

=item * I<primary-switch-name>  =>   B<string, optional>

=begin html

<br>Switch name of the primary path. Present for switch attached configurations only.

=end html

=back



=over 2

=item * I<primary-switch-port>  =>   B<integer, optional>

=begin html

<br>Switch port of the primary path. Present for switch attached configurations only. Range: [0..1024].

=end html

=back



=over 2

=item * I<primary-vseries-port-wwn>  =>   B<string>

=begin html

<br>This is the same as primary-controller-port-wwn, presented for backwards compatibility.

=end html

=back



=over 2

=item * I<product-id>  =>   B<string>

=begin html

<br>Product id string of the raid array lun resides on.

=end html

=back



=head2 param

=begin html

one parameter required by the event.

=end html



B<Fields>

=over 2

=item * None

=back



=head2 fc-config-info

=begin html

null

=end html



B<Fields>

=over 2

=item * I<adapter-name>  =>   B<string>

=begin html

<br>FC adapter name (e.g. 0c)

=end html

=back



=over 2

=item * I<adapter-state>  =>   B<string>

=begin html

<br>Indicates what the adapter configuration state is. Possible values:<br> &nbsp; "UNDEFINED" - The default state. The adapter has never been configured.<br> &nbsp; "CONFIGURED" - The adapter port is configured and the adapter is operational.<br> &nbsp; "UNCONFIGURED" - The adapter is unconfigured. The initiator driver is attached, but the adapter is not operational.<br> &nbsp; "PENDING" - The adapter is waiting for a filer reboot to effect an fc-type change.<br> While in the PENDING state the adapter can not be used

=end html

=back



=over 2

=item * I<adapter-status>  =>   B<string>

=begin html

<br>Possible values:<br> &nbsp; "online" - adapter driver is enabled<br> &nbsp; "offline" - adapter driver is disabled<br>

=end html

=back



=over 2

=item * I<adapter-type>  =>   B<string>

=begin html

<br>Indicates which driver is attached to the adapter. Possible values:<br> &nbsp; "initiator" - the storage Initiator driver (default)<br> &nbsp; "vi" - the FC-VI cluster interconnect driver<br> &nbsp; "target" - the FCP Target driver<br>

=end html

=back



=over 2

=item * I<pending-fc-type>  =>   B<string, optional>

=begin html

<br>If adapter-state is PENDING, this value tells what the last fc-config-set-adapter-fc-type command was.<br>

=end html

=back



=head2 aliases-info

=begin html

A list of WWPNs and their aliases generated according to the input - alias, WWPN or nothing.

=end html



B<Fields>

=over 2

=item * I<aliases-alias>  =>   B<string>

=begin html

<br>The 32-character alias for a given FCP WWPN

=end html

=back



=over 2

=item * I<aliases-wwpn>  =>   B<string>

=begin html

<br>The FCP WWPN for which the alias is given

=end html

=back



=head2 fcp-adapter-initiators-info

=begin html

A list of initiators currently connected to the FC adapter or FCP data LIF.

=end html



B<Fields>

=over 2

=item * I<adapter>  =>   B<string>

=begin html

<br>In Data ONTAP 7-Mode, the name of the physical FC adapter. In Data ONTAP Cluser-Mode, the name of the FCP data LIF.

=end html

=back



=over 2

=item * I<fcp-connected-initiators>  =>   B<L<"fcp-connected-initiator-info">[]>

=begin html

<br>Information about the connected initiators

=end html

=back



=head2 fcp-adapter-nameserver-object-info

=begin html

Information about a nameserver object entry.

=end html



B<Fields>

=over 2

=item * I<adapter>  =>   B<string>

=begin html

<br>The adapter this nameserver object is visible through.

=end html

=back



=over 2

=item * I<class-service>  =>   B<string, optional>

=begin html

<br>Registered class of services as defined in the FC-FS standard. This element is omitted if the device has not registered a class of service. Comma separated possible values: "F", "1", "2", "3", "4", and "6".

=end html

=back



=over 2

=item * I<fabric-port-name>  =>   B<string, optional>

=begin html

<br>Fabric world wide port name (WWPN) of this entry. This element is omitted if the fabric WWPN is not registered.

=end html

=back



=over 2

=item * I<fc4-type>  =>   B<string, optional>

=begin html

<br>Registered FC4 Types. This element is omitted if the device has not registered an FC4 Type. Comma separated possible values: "llc/snap", "ipfc", "fcp", "gpp", "ipi-3m", "ipi-3s", "ipi-3p", "sbccs-ch", "sbccs-cu", "fc-sb-3_ch2cu", "fc-sb-3_cu2ch", "fc-gs", "fc-sw", "fc-al", "snmp", "hippi-fp", "mil-std-1553", "asm", "fc-vi", and "fc-av".

=end html

=back



=over 2

=item * I<node-name>  =>   B<string, optional>

=begin html

<br>World wide node name (WWNN) of this entry. This element is omitted if the device has not registered a WWNN.

=end html

=back



=over 2

=item * I<port-id>  =>   B<integer>

=begin html

<br>Assigned port identifier of this entry. Range: [0..2^24-1]

=end html

=back



=over 2

=item * I<port-name>  =>   B<string, optional>

=begin html

<br>World wide port name (WWPN) of this entry. This element is omitted if the device has not registered a WWPN.

=end html

=back



=over 2

=item * I<port-type>  =>   B<string>

=begin html

<br>Port type of this entry. Possible values: "n-port", "nl-port", "fnl-port", "nx-port", "f-port", "fl-port", "e-port", "b-port", "nv-port", "fv-port", "sd-port", "te-port", "tl-port", and "none".

=end html

=back



=over 2

=item * I<symbolic-node-name>  =>   B<string, optional>

=begin html

<br>Registered symbolic node name. If the device has not registered one, this element will be omitted.

=end html

=back



=over 2

=item * I<symbolic-port-name>  =>   B<string, optional>

=begin html

<br>Registered symbolic port name. If the device has not registered one, this element will be omitted.

=end html

=back



=head2 fcp-adapter-stats-info

=begin html

Statistics for one FC adapter.

=end html



B<Fields>

=over 2

=item * I<adapter>  =>   B<string>

=begin html

<br>Which FC adapter.

=end html

=back



=over 2

=item * I<adapter-resets>  =>   B<integer>

=begin html

<br>Number of adapter resets occurred.

=end html

=back



=over 2

=item * I<crc-errors>  =>   B<integer>

=begin html

<br>Total CRC errors occurred.

=end html

=back



=over 2

=item * I<discarded-frames>  =>   B<integer>

=begin html

<br>Number of frames discarded by the target HBA. Range [0..2^31-1]

=end html

=back



=over 2

=item * I<frame-overruns>  =>   B<integer>

=begin html

<br>Number of frame overruns detected by the adapter during write requests.

=end html

=back



=over 2

=item * I<frame-underruns>  =>   B<integer>

=begin html

<br>Number of frame underruns detected by the adapter during read requests.

=end html

=back



=over 2

=item * I<initiators-connected>  =>   B<integer>

=begin html

<br>Total number of initiators connected to this target adapter.

=end html

=back



=over 2

=item * I<invalid-xmit-words>  =>   B<integer>

=begin html

<br>Number of invalid words transmitted. Range [0..2^31-1]

=end html

=back



=over 2

=item * I<is-sfp-diagnostics-internally-calibrated>  =>   B<boolean>

=begin html

<br>Indicates if the SFP diagnostics are internally calibrated or not. The optional SFP rx/tx fields are invalid (and therefore not provided) if the SFP diagnostics are not internally calibrated.

=end html

=back



=over 2

=item * I<is-sfp-optical-transceiver-valid>  =>   B<boolean>

=begin html

<br>Validity of the optical transceiver. Until Data ONTAP 8.0.0, this field was incorrectly named "is-spf-optical-transceiver-valid". While that field is also returned for backward compatibility, all new applications must use the current version.

=end html

=back



=over 2

=item * I<is-sfp-rx-power-in-range>  =>   B<boolean, optional>

=begin html

<br>Flag to indicate received optical power is in range.

=end html

=back



=over 2

=item * I<is-sfp-tx-power-in-range>  =>   B<boolean, optional>

=begin html

<br>Flag to indicate transmitted optical power is in range.

=end html

=back



=over 2

=item * I<link-breaks>  =>   B<integer>

=begin html

<br>Number of times that the link breaks.

=end html

=back



=over 2

=item * I<lip-resets>  =>   B<integer>

=begin html

<br>Number of times that a selective Reset LIP (Loop Initialization Primitive) occurred. LIP reset is used to preform a verndorspecific reset at the loop port specified by the AL-PA value.

=end html

=back



=over 2

=item * I<lr-received>  =>   B<integer>

=begin html

<br>Number of LRs (Link Reset) received by the target HBA. Range [0..2^31-1]

=end html

=back



=over 2

=item * I<lr-sent>  =>   B<integer>

=begin html

<br>Number of LRs (Link Reset) sent from the target HBA. Range [0..2^31-1]

=end html

=back



=over 2

=item * I<nos-received>  =>   B<integer>

=begin html

<br>Number of NOSs (Not_Operational Primitive Sequence)received by the target HBA. Range [0..2^31-1]

=end html

=back



=over 2

=item * I<ols-received>  =>   B<integer>

=begin html

<br>Number of OLSs (Offline Primitive Sequence) received by the target HBA. Range [0..2^31-1]

=end html

=back



=over 2

=item * I<protocol-errors>  =>   B<integer>

=begin html

<br>Number of protocol errors occured. Range [0..2^31-1]

=end html

=back



=over 2

=item * I<queue-depth>  =>   B<integer>

=begin html

<br>Counts the queue depth on the target HBA.

=end html

=back



=over 2

=item * I<scsi-requests-dropped>  =>   B<integer>

=begin html

<br>Number of SCSI requests being dropped.

=end html

=back



=over 2

=item * I<sfp-connector>  =>   B<string>

=begin html

<br>Connector used with the optical transceiver.

=end html

=back



=over 2

=item * I<sfp-date-code>  =>   B<string>

=begin html

<br>Date code for the optical transceiver.

=end html

=back



=over 2

=item * I<sfp-encoding>  =>   B<string>

=begin html

<br>Encoding used with the optical transceiver. Possible values ["8B10B", "?????"]

=end html

=back



=over 2

=item * I<sfp-fc-speedcapabilities>  =>   B<string>

=begin html

<br>FC speed capabilities for the optical transceiver. Possible values [1, 2, 4, 8 in Gbps]

=end html

=back



=over 2

=item * I<sfp-formfactor>  =>   B<string>

=begin html

<br>Form factor of the optical transceiver. Possible values: "SFP" (for Small FormFactor).

=end html

=back



=over 2

=item * I<sfp-part-number>  =>   B<string>

=begin html

<br>Part number for the optical transceiver.

=end html

=back



=over 2

=item * I<sfp-rev>  =>   B<string>

=begin html

<br>Revision for the optical transceiver.

=end html

=back



=over 2

=item * I<sfp-rx-power>  =>   B<string, optional>

=begin html

<br>SFP received optical power, reported to tenth decimal in uWatts.

=end html

=back



=over 2

=item * I<sfp-serial-number>  =>   B<string>

=begin html

<br>Serial number for the optical transceiver.

=end html

=back



=over 2

=item * I<sfp-tx-power>  =>   B<string, optional>

=begin html

<br>SFP transmitted optical power, reported to tenth decimal in uWatts.

=end html

=back



=over 2

=item * I<sfp-vendor-name>  =>   B<string>

=begin html

<br>Vendor name for the optical transceiver.

=end html

=back



=over 2

=item * I<sfp-vendor-oui>  =>   B<string>

=begin html

<br>Vendor OUI (The IEEE Organizationally Unique Identifier) for the optical transceiver.

=end html

=back



=over 2

=item * I<sfp-wavelength>  =>   B<integer>

=begin html

<br>Wavelength for the optical transceiver. Measured in nanometers. Range [830..860]

=end html

=back



=over 2

=item * I<spurious-interrupts>  =>   B<integer>

=begin html

<br>Count of spurious interrupts.

=end html

=back



=over 2

=item * I<total-logins>  =>   B<integer>

=begin html

<br>Counts the times of initiators added. Each time a new initiator is added, the total logins is incremented by 1. Each time an initiator is removed, the total logouts is incremented by 1.

=end html

=back



=over 2

=item * I<total-logouts>  =>   B<integer>

=begin html

<br>Counts the times of initiators removed. Each time a new initiator is added, the total logins is incremented by 1. Each time an initiator is removed, the total logouts is incremented by 1.

=end html

=back



=head2 fcp-adapter-topology-attached-port-info

=begin html

Information about the attached device.

=end html



B<Fields>

=over 2

=item * I<is-visible>  =>   B<boolean>

=begin html

<br>Visibility of this device through this adapter from a zoning perspective.

=end html

=back



=over 2

=item * I<port-id>  =>   B<integer>

=begin html

<br>Assigned port identifier of the attached device. A value of 0 indicates no value has been assigned. Range: [0..2^24-1]

=end html

=back



=over 2

=item * I<port-name>  =>   B<string>

=begin html

<br>World wide port name (WWPN) of the attached device. The format is: XX:XX:XX:XX:XX:XX:XX:XX where X is a hexadecimal digit.

=end html

=back



=head2 fcp-adapter-topology-switch-info

=begin html

Information about an FC switch connected to an FC adapter.

=end html



B<Fields>

=over 2

=item * I<adapter>  =>   B<string>

=begin html

<br>The name of the adapter this switch is visible through.

=end html

=back



=over 2

=item * I<domain>  =>   B<integer>

=begin html

<br>The domain identifier of the FC switch. Range: [1..255]

=end html

=back



=over 2

=item * I<fcp-adapter-topology-switch-ports>  =>   B<L<"fcp-adapter-topology-switch-port-info">[], optional>

=begin html

<br>List of ports for the FC switch. This is only returned if verbose is set to true.

=end html

=back



=over 2

=item * I<logical-name>  =>   B<string>

=begin html

<br>The logical name of the FC switch. The maximum length is 64.

=end html

=back



=over 2

=item * I<node-name>  =>   B<string>

=begin html

<br>Node name of the FC switch. The format is: XX:XX:XX:XX:XX:XX:XX:XX where X is a hexadecimal digit.

=end html

=back



=over 2

=item * I<port-count>  =>   B<integer>

=begin html

<br>The number of ports discovered on the FC switch. Range: [0..2^32-1]

=end html

=back



=over 2

=item * I<release>  =>   B<string>

=begin html

<br>The release version of the FC switch. The maximum length is 64.

=end html

=back



=over 2

=item * I<vendor>  =>   B<string>

=begin html

<br>The name of the FC switch vendor. The maximum length is 64.

=end html

=back



=head2 fcp-adapter-topology-switch-port-info

=begin html

Information about the FC switch port.

=end html



B<Fields>

=over 2

=item * I<fcp-adapter-topology-attached-ports>  =>   B<L<"fcp-adapter-topology-attached-port-info">[]>

=begin html

<br>List of devices attached to this port.

=end html

=back



=over 2

=item * I<port-name>  =>   B<string>

=begin html

<br>World wide port name (WWPN) of the port. The format is: XX:XX:XX:XX:XX:XX:XX:XX where X is a hexadecimal digit.

=end html

=back



=over 2

=item * I<port-number>  =>   B<integer>

=begin html

<br>Port index number. Range: [0..2^32-1]

=end html

=back



=over 2

=item * I<port-state>  =>   B<string>

=begin html

<br>Port state. Possible values: "online", "offline", "testing", "fault", and "unknown".

=end html

=back



=over 2

=item * I<port-type>  =>   B<string>

=begin html

<br>Port type. Possible values: "n-port", "nl-port", "fnl-port", "nx-port", "f-port", "fl-port", "e-port", "b-port", "nv-port", "fv-port", "sd-port", "te-port", "tl-port", and "none".

=end html

=back



=head2 fcp-adapter-zone-info

=begin html

Information about a zone.

=end html



B<Fields>

=over 2

=item * I<adapter>  =>   B<string>

=begin html

<br>The adapter this zone is visible through.

=end html

=back



=over 2

=item * I<fcp-adapter-zone-members>  =>   B<L<"fcp-adapter-zone-member-info">>

=begin html

<br>List of zone members.

=end html

=back



=over 2

=item * I<zone-name>  =>   B<string>

=begin html

<br>The name of the zone. The maximum length is 64.

=end html

=back



=over 2

=item * I<zone-set-name>  =>   B<string>

=begin html

<br>The name of the zone set containing this zone. The maximum length is 64.

=end html

=back



=head2 fcp-adapter-zone-member-info

=begin html

Information about a zone member.

=end html



B<Fields>

=over 2

=item * I<domain-id>  =>   B<integer, optional>

=begin html

<br>Domain identifier of the switch. This element is returned if the zone-member-type is "domain-id-port". Range: [0..2^32-1]

=end html

=back



=over 2

=item * I<fabric-port-name>  =>   B<string, optional>

=begin html

<br>World wide port name (WWPN) of the fabric port. This element is returned if the zone-member-type is "fabric-port-name". The format is: XX:XX:XX:XX:XX:XX:XX:XX where X is a hexadecimal digit.

=end html

=back



=over 2

=item * I<node-name>  =>   B<string, optional>

=begin html

<br>World wide node name (WWNN) of the N-port. This element is returned if the zone-member-type is "node-name". The format is: XX:XX:XX:XX:XX:XX:XX:XX where X is a hexadecimal digit.

=end html

=back



=over 2

=item * I<port>  =>   B<integer, optional>

=begin html

<br>Port number on the switch. This element is returned if the zone-member-type is "domain-id-port". Range: [0..2^32-1]

=end html

=back



=over 2

=item * I<port-id>  =>   B<integer, optional>

=begin html

<br>Assigned port identifier. This element is returned if the zone-member-type is "port-id". Range: [0..2^24-1]

=end html

=back



=over 2

=item * I<port-name>  =>   B<string, optional>

=begin html

<br>World wide port name (WWPN) of the N-port. This element is returned if the zone-member-type is "port-name". The format is: XX:XX:XX:XX:XX:XX:XX:XX where X is a hexadecimal digit.

=end html

=back



=over 2

=item * I<zone-member-type>  =>   B<string>

=begin html

<br>The type of zone member. Possible values are: "port-name", "domain-id-port", "port-id", "node-name", "fabric-port-name", and "unknown".

=end html

=back



=over 2

=item * I<zone-member-value>  =>   B<integer, optional>

=begin html

<br>Uninterpreted value. This element is returned if the zone-member-type is "unknown". Range: [0..2^32-1]

=end html

=back



=head2 fcp-config-adapter-info

=begin html

Configuration information for one physical FC adapter.

=end html



B<Fields>

=over 2

=item * I<adapter>  =>   B<string>

=begin html

<br>The slot name of the FC adapter.

=end html

=back



=over 2

=item * I<adapter-type>  =>   B<string, optional>

=begin html

<br>Type of the adapter. Possible values are "physical", "local", "standby", "partner". If an error occured while retrieving info for this adapter, this will not be returned. Starting with Data ONTAP 8.0, only single_image cfmode is supported. Outputs related to other cfmodes are deprecated and no longer returned by this api.

=end html

=back



=over 2

=item * I<cache-line-size>  =>   B<integer, optional>

=begin html

<br>Cache line size of adapter. verbose only. This field is obsolete and no longer returned beginning with Data ONTAP 8.1.1.

=end html

=back



=over 2

=item * I<connection-established>  =>   B<string, optional>

=begin html

<br>Type of connection established, "ptp" or "loop".

=end html

=back



=over 2

=item * I<data-link-rate>  =>   B<integer, optional>

=begin html

<br>Data Link Rate in Gbits. verbose only.

=end html

=back



=over 2

=item * I<error-msg>  =>   B<string, optional>

=begin html

<br>Error message, if an error occured while retrieving info for this adapter. This will only be used if listing all adapters. If an error occurred while retrieving info for a specific adapter, the API will fail with error message.

=end html

=back



=over 2

=item * I<external-gbic-enabled>  =>   B<boolean, optional>

=begin html

<br>"true" if enabled, "false" otherwise. verbose only. This field is obsolete and no longer returned beginning with Data ONTAP 8.1.1.

=end html

=back



=over 2

=item * I<fabric-established>  =>   B<boolean, optional>

=begin html

<br>"true" if fabric is established to this adapter, "false" otherwise. verbose only.

=end html

=back



=over 2

=item * I<firmware-rev>  =>   B<string, optional>

=begin html

<br>Firmware revision of adapter. verbose only.

=end html

=back



=over 2

=item * I<hardware-rev>  =>   B<string, optional>

=begin html

<br>Hardware revision of adapter. verbose only.

=end html

=back



=over 2

=item * I<info-name>  =>   B<string, optional>

=begin html

<br>Info name given to this adapter. verbose only.

=end html

=back



=over 2

=item * I<loop-id>  =>   B<integer, optional>

=begin html

<br>Loop address of adapter. If an error occured while retrieving info for this adapter, this will not be returned. This value lies between 0 and 255. Starting with Data ONTAP 8.0, only single_image cfmode is supported. Outputs related to other cfmodes are deprecated and no longer returned by this api.

=end html

=back



=over 2

=item * I<media-type>  =>   B<string, optional>

=begin html

<br>Media configured for this adapter, "ptp", "loop", or "auto". If an error occured while retrieving info for this adapter, this will not be returned.

=end html

=back



=over 2

=item * I<mpi-firmware-rev>  =>   B<string, optional>

=begin html

<br>MPI Firmware revision of adapter. verbose only. This is only available for converged network adapters (CNA).

=end html

=back



=over 2

=item * I<node-name>  =>   B<string, optional>

=begin html

<br>FCP World Wide Node Name (WWNN) of the adapter. If an error occured while retrieving info for this adapter, this will not be returned.

=end html

=back



=over 2

=item * I<packet-size>  =>   B<integer, optional>

=begin html

<br>FC packet size of adapter. verbose only. This field is obsolete and no longer returned beginning with Data ONTAP 8.2.

=end html

=back



=over 2

=item * I<partner-adapter>  =>   B<string, optional>

=begin html

<br>Name of partner adapter for takeover if configured. Value of "none" indicates no partner set for this adapter. If an error occured while retrieving info for this adapter, this will not be returned. Starting with Data ONTAP 8.0, only single_image cfmode is supported. Outputs related to other cfmodes are deprecated and no longer returned by this api.

=end html

=back



=over 2

=item * I<pci-bus-width>  =>   B<integer, optional>

=begin html

<br>PCI bus width in bits. verbose only. This field is obsolete and no longer returned beginning with Data ONTAP 8.1.1.

=end html

=back



=over 2

=item * I<pci-clock-speed>  =>   B<integer, optional>

=begin html

<br>PCI clock speed in MHz. verbose only. This field is obsolete and no longer returned beginning with Data ONTAP 8.1.1.

=end html

=back



=over 2

=item * I<phy-firmware-rev>  =>   B<string, optional>

=begin html

<br>PHY Firmware revision of adapter. verbose only. This is only available for converged network adapters (CNA).

=end html

=back



=over 2

=item * I<physical-data-link-rate>  =>   B<integer, optional>

=begin html

<br>Physical Data Link Rate in Gbits. verbose only. This is only available for converged network adapters (CNA).

=end html

=back



=over 2

=item * I<physical-link-state>  =>   B<string, optional>

=begin html

<br>Physical Status of the adapter. verbose only. Possible values are "link up", "link down". This is only available for converged network adapters (CNA).

=end html

=back



=over 2

=item * I<port-address>  =>   B<integer, optional>

=begin html

<br>Host port address of adapter. If an error occured while retrieving info for this adapter, this will not be returned.

=end html

=back



=over 2

=item * I<port-id>  =>   B<integer, optional>

=begin html

<br>Port address of adapter. If an error occured while retrieving info for this adapter, this will not be returned. Starting with Data ONTAP 8.0, only single_image cfmode is supported. Outputs related to other cfmodes are deprecated and no longer returned by this api.

=end html

=back



=over 2

=item * I<port-name>  =>   B<string, optional>

=begin html

<br>FCP World Wide Port Name (WWPN) of adapter. If an error occured while retrieving info for this adapter, this will not be returned.

=end html

=back



=over 2

=item * I<preload-table-rev>  =>   B<string, optional>

=begin html

<br>Flash preload revision for FC adapter. verbose only.

=end html

=back



=over 2

=item * I<speed>  =>   B<string, optional>

=begin html

<br>Speed configured for this adapter. Possible values: "auto", "1Gb", "2Gb", "4Gb", "8Gb", "10Gb". If an error occured while retrieving info for this adapter, this will not be returned.

=end html

=back



=over 2

=item * I<sram-parity-enabled>  =>   B<boolean, optional>

=begin html

<br>"true" if enabled, "false" otherwise. verbose only. This field is obsolete and no longer returned beginning with Data ONTAP 8.1.1.

=end html

=back



=over 2

=item * I<standby>  =>   B<boolean, optional>

=begin html

<br>"true" if adapter is on standby, "false" otherwise. If an error occured while retrieving info for this adapter, this will not be returned. Starting with Data ONTAP 8.0, only single_image cfmode is supported. Outputs related to other cfmodes are deprecated and no longer returned by this api.

=end html

=back



=over 2

=item * I<state>  =>   B<string, optional>

=begin html

<br>Status of the adapter. Possible values are "startup", "uninitialized", "initializing firmware", "link not connected", "waiting for link up", "online", "link disconnected", "resetting", "offline", "offlined by user/system". If an error occured while retrieving info for this adapter, this will not be returned.

=end html

=back



=over 2

=item * I<switch-port>  =>   B<string, optional>

=begin html

<br>Switch and port this adapter is connected to. The string will be of the form X:Y where X is the name of the switch and Y is the port value. verbose only.

=end html

=back



=over 2

=item * I<vlan-id>  =>   B<integer, optional>

=begin html

<br>Assigned FC VLAN ID. verbose only. This is only available for converged network adapters (CNA).

=end html

=back



=head2 fcp-connected-initiator-info

=begin html

Information about an initiator connected to an FC adapter.

=end html



B<Fields>

=over 2

=item * I<initiator-group-list>  =>   B<L<"initiator-group-list-info">[], optional>

=begin html

<br>List of initiator groups this initiator belongs to.

=end html

=back



=over 2

=item * I<node-name>  =>   B<string>

=begin html

<br>World Wide Node Name (WWNN) of initiator.

=end html

=back



=over 2

=item * I<port-address>  =>   B<integer>

=begin html

<br>Fibre Channel host address it is connected to.

=end html

=back



=over 2

=item * I<port-name>  =>   B<string>

=begin html

<br>World Wide Port Name (WWPN) of the initiator.

=end html

=back



=over 2

=item * I<portname-alias-list>  =>   B<L<"portname-alias-name">[], optional>

=begin html

<br>List of aliases for the WWPN.

=end html

=back



=head2 fcp-port-name-info

=begin html

Information for one valid local port name.

=end html



B<Fields>

=over 2

=item * I<fcp-adapter>  =>   B<string, optional>

=begin html

<br>Only if this WWPN is being used by a Fibre Channel interface, the name of the interface is returned. In Data ONTAP 7-Mode, the name of a local adapter. In Data ONTAP Cluster-Mode, the name of an FCP data LIF.

=end html

=back



=over 2

=item * I<is-used>  =>   B<boolean>

=begin html

<br>This indicates whether this WWPN is being used by a Fibre Channel target interface.

=end html

=back



=over 2

=item * I<port-name>  =>   B<string>

=begin html

<br>A Fibre Channel WWPN in the form XX:XX:XX:XX:XX:XX:XX:XX where X is a hexadecimal digit.

=end html

=back



=head2 portname-alias-name

=begin html

Aliases for this WWPN

=end html



B<Fields>

=over 2

=item * I<portname-alias>  =>   B<string>

=begin html

<br>Alias for the WWPN

=end html

=back



=head2 fc-ports

=begin html

Information about the ports belonging to the fiber channel adapter

=end html



B<Fields>

=over 2

=item * I<port-number>  =>   B<string, optional>

=begin html

<br>This represents the physical port number of the FC port. Field is not present when port-type is "l-port"

=end html

=back



=over 2

=item * I<port-type>  =>   B<string>

=begin html

<br>Type of port. Possible values: "l-port", loop port, node port used to connect a node to a Fibre Channel loop. "nl-port", network+loop port, node port which connects to both loops and switches. "n-port", network port, node port used to connect a node to a Fibre Channel switch.

=end html

=back



=over 2

=item * I<switch-name>  =>   B<string, optional>

=begin html

<br>Thsi is the switch name, if any, connected to the FC port. Field is not present when port-type is "l-port"

=end html

=back



=over 2

=item * I<switch-wwn>  =>   B<string, optional>

=begin html

<br>This is the world wide name of the switch, if any, connected to the FC port. Field is not present when port-type is "l-port"

=end html

=back



=head2 link-state-info

=begin html

list link-state info of a specific adapter channel

=end html



B<Fields>

=over 2

=item * I<adapter-name>  =>   B<string>

=begin html

<br>The adapter name is either a slot number, or, if a port letter is also presented, a slot number and port letter concatenated into a single name.

=end html

=back



=over 2

=item * I<fc-port-info>  =>   B<L<"fc-ports">, optional>

=begin html

<br>fiber channel port information. Present only when link-state field value is "up".

=end html

=back



=over 2

=item * I<link-state>  =>   B<string>

=begin html

<br>Possible values: "initing", "down", "up", "offline-physical", "offline-logical", or "zombified", which the adapter has stopped sending I/O and is ignoring link events. This state may occur when shelf firmware is being updated.

=end html

=back



=head2 managed-feature

=begin html

A managed feature in ONTAP. Possible values: <ul> <li> "cifs" <li> "nfs" <li> "iscsi" <li> "fcp" <li> "dedupe" <li> "flexclone" <li> "compression" <li> "snaprestore" <li> "snaplock" <li> "snaplock_enterprise" <li> "snapvault_primary" <li> "snapvault_secondary" <li> "snapmirror" <li> "syncmirror" <li> "flexcache" <li> "ndmp" <li> "multistore" <li> "cdmi" <li> "snapdrive_windows" <li> "snapmanager_exchange" <li> "snapmanager_sql" <li> "snapmanager_sharepoint" <li> "snapmanager_hyperv" <li> "snapdrive_unix" <li> "snapmanager_oracle" <li> "snapmanager_sap" </ul>

=end html



B<Fields>

=over 2

=item * None

=back



=head2 managed-feature-status

=begin html

Represents the status of a managed feature. Possible values: <ul> <li> "on" - feature is entitled and turned on, <li> "available" - feature is entitled and available to be turned on. Its current on/off status is unknown, <li> "on_not_configurable" - feature is no longer entitled but it was turned on before and remains to be on. Feature is not configurable at the moment, <li> "off" - feature is entitled but turned off, <li> "not_available" - feature is not entitled, licensing infrastructure is unavailable, or other configuration check prevents feature use. The field notes can provide additional information. </ul>

=end html



B<Fields>

=over 2

=item * None

=back



=head2 managed-feature-status-info

=begin html

Status information about a managed feature. When returned as part of the output, all elements of this typedef are reported, unless limited by a set of desired attributes specified by the caller. <p> When used as input to specify desired attributes to return, omitting a given element indicates that it shall not be returned in the output. In contrast, by providing an element (even with no value) the caller ensures that a value for that element will be returned, given that the value can be retrieved. <p> When used as input to specify queries, any element can be omitted in which case the resulting set of objects is not constrained by any specific value of that attribute.

=end html



B<Fields>

=over 2

=item * I<feature-name>  =>   B<managed-feature, optional>

=begin html

<br>Managed feature name. Attributes: key, non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<notes>  =>   B<string, optional>

=begin html

<br>Additional information about the managed feature status. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<status>  =>   B<managed-feature-status, optional>

=begin html

<br>Status of a managed feature. Attributes: non-creatable, non-modifiable

=end html

=back



=head2 digest-algorithm

=begin html

Digest algorithm used for fingerprint computation. Possible values: "sha-256" or "md5".

=end html



B<Fields>

=over 2

=item * None

=back



=head2 file-fingerprint-info

=begin html

Fingerprint information about single file.

=end html



B<Fields>

=over 2

=item * I<access-time>  =>   B<integer, optional>

=begin html

<br>Last access time of the file attributes in seconds in the standard UNIX format since January 1, 1970 00:00:00. The field is included for regular files and files on Non-Snaplock volumes. Time is taken out of system clock. Range : [0..2^64-1]

=end html

=back



=over 2

=item * I<changed-time>  =>   B<integer>

=begin html

<br>Last changed time of the file attributes in seconds in the standard UNIX format since January 1, 1970 00:00:00. For WORM files last change time for file attributes occurs when file is committed to WORM. Time is taken out of system clock for regular files and time is taken out of Compliance Clock when file is committed to worm. The changed-time can be in wraparound format for WORM files. The flag is-changed-time-wraparound indicates that changed time is in the wraparound format. The wraparound format indicates that dates after 01/19/2038 are mapped from 01/01/1970 - 12/31/2002 to 01/19/2038 - 01/19/2071 Range : [0..2^64-1]

=end html

=back



=over 2

=item * I<creation-time>  =>   B<integer>

=begin html

<br>Creation time of the file in seconds in the standard UNIX format since January 1, 1970 00:00:00. Time is taken out of system clock. Range : [0..2^64-1]

=end html

=back



=over 2

=item * I<data-fingerprint>  =>   B<string, optional>

=begin html

<br>The digest value of data of the file. The fingerprint is base64 encoded. This field is not included if scope is 'metadata_only'.

=end html

=back



=over 2

=item * I<file-size>  =>   B<integer>

=begin html

<br>The size of the file in bytes. Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<file-type>  =>   B<string>

=begin html

<br>Type of the file. Possible values: "worm", "worm_appendable", "worm_log" and "regular".

=end html

=back



=over 2

=item * I<fileid>  =>   B<integer>

=begin html

<br>A unique number within filesystem identifying the file for fingerprint. Range : [0..2^31-1]

=end html

=back



=over 2

=item * I<formatted-access-time>  =>   B<string>

=begin html

<br>Last access time of the file formatted in a human-readable format <day> <month> <day of month> <hour>:<min>:<sec> <year> in GMT timezone. The field is included for regular files and files on Non-Snaplock volumes.

=end html

=back



=over 2

=item * I<formatted-changed-time>  =>   B<string>

=begin html

<br>Last changed time of the file formatted in a human-readable format <day> <month> <day of month> <hour>:<min>:<sec> <year> in GMT timezone.

=end html

=back



=over 2

=item * I<formatted-creation-time>  =>   B<string>

=begin html

<br>Creation time of the file formatted in a human-readable format <day> <month> <day of month> <hour>:<min>:<sec> <year> in GMT timezone.

=end html

=back



=over 2

=item * I<formatted-modified-time>  =>   B<string>

=begin html

<br>Last modification time of the file formatted in a human-readable format <day> <month> <day of month> <hour>:<min>:<sec> <year> in GMT timezone.

=end html

=back



=over 2

=item * I<formatted-retention-time>  =>   B<string, optional>

=begin html

<br>Expiry date of the worm file formatted in a human-readable format. This takes care of wraparound dates and prints the expiry date of the file in the format <day> <month> <day of month> <hour>:<min>:<sec> <year> in GMT timezone. A value of "infinite" indicates that this file has infinite retention time. This field is not included for regular files and files on Non-Snaplock volumes.

=end html

=back



=over 2

=item * I<fsid>  =>   B<integer>

=begin html

<br>Filesystem ID. Range : [0..2^31-1]

=end html

=back



=over 2

=item * I<group-id>  =>   B<integer>

=begin html

<br>The integer id of the group owner of the file. Range : [0..2^31-1]

=end html

=back



=over 2

=item * I<is-changed-time-wraparound>  =>   B<boolean, optional>

=begin html

<br>This field is included for WORM files when changed-time is in wraparound format. This field is true if the date represented in changed-time is in wraparound format and false if changed-time is not is not in wraparound format. The wraparound format indicates that dates after 01/19/2038 are mapped from 01/01/1970 - 12/31/2002 to 01/19/2038 - 01/19/2071. This field is not included for regular files.

=end html

=back



=over 2

=item * I<is-wraparound>  =>   B<boolean, optional>

=begin html

<br>True if the date represented in retention-time is in wraparound format. The wraparound format indicates that dates after 01/19/2038 are mapped from 01/01/1970 - 12/31/2002 to 01/19/2038 - 01/19/2071. This field is not included if retention-time is not included.

=end html

=back



=over 2

=item * I<metadata-fingerprint>  =>   B<string, optional>

=begin html

<br>The digest value of metadata of the file The metadata fingerprint is calculated for file size, file ctime, file mtime, file crtime, file retention time, file uid, gid and file type. The fingerprint is base64 encoded. This field is not included if scope is 'data_only'.

=end html

=back



=over 2

=item * I<modified-time>  =>   B<integer>

=begin html

<br>Last modification time of the file in seconds in the standard UNIX format since January 1, 1970 00:00:00. Time is taken out of system clock. Range : [0..2^64-1]

=end html

=back



=over 2

=item * I<owner-id>  =>   B<integer>

=begin html

<br>The integer id of the owner of the file. Range : [0..2^31-1]

=end html

=back



=over 2

=item * I<owner-sid>  =>   B<string>

=begin html

<br>The owner SID of the file. This field is included in the case when file has NTFS security style.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Full path of the file that is fingerprinted. The value begins with /vol/<volumename>.

=end html

=back



=over 2

=item * I<retention-time>  =>   B<integer, optional>

=begin html

<br>Retention time of the file in seconds in the standard UNIX format since January 1, 1970 00:00:00. This field is not included for regular files, files on Non-Snaplock volumes and files with infinite retention. The flag is-wraparound indicates that retention is in the wraparound format. The wraparound format indicates that dates after 01/19/2038 are mapped from 01/01/1970 - 12/31/2002 to 01/19/2038 - 01/19/2071 The time is taken out of Compliance Clock. Range : [0..2^64-1]

=end html

=back



=head2 file-info

=begin html

Information about a single file.

=end html



B<Fields>

=over 2

=item * I<accessed-timestamp>  =>   B<integer>

=begin html

<br>Last asscess time of the file. The value is in seconds since January 1, 1970.

=end html

=back



=over 2

=item * I<acl-type>  =>   B<string>

=begin html

<br>The type of access control list (acl) on the file. Possible values are: "no_acl", "nt_acl", "nfs_acl", and goddess forbid, "unknown".

=end html

=back



=over 2

=item * I<bytes-used>  =>   B<integer, optional>

=begin html

<br>returns the number of bytes actually used on disk by this file

=end html

=back



=over 2

=item * I<changed-timestamp>  =>   B<integer>

=begin html

<br>Last changed time of the file. The value is in seconds since January 1, 1970.

=end html

=back



=over 2

=item * I<creation-timestamp>  =>   B<integer>

=begin html

<br>Creation time of the file. The value is in seconds since January 1, 1970.

=end html

=back



=over 2

=item * I<file-size>  =>   B<integer>

=begin html

<br>The size of the file in bytes.

=end html

=back



=over 2

=item * I<file-type>  =>   B<string>

=begin html

<br>Type of the file. Possible values: file, directory, blockdev, chardev, symlink, socket, fifo, stream, lun.

=end html

=back



=over 2

=item * I<group-id>  =>   B<integer>

=begin html

<br>The integer id of the group owner of the file.

=end html

=back



=over 2

=item * I<hard-links-count>  =>   B<integer>

=begin html

<br>The number of hard links to the file.

=end html

=back



=over 2

=item * I<inode-gen-number>  =>   B<integer, optional>

=begin html

<br>Inode generation number

=end html

=back



=over 2

=item * I<inode-number>  =>   B<integer>

=begin html

<br>The file node number.

=end html

=back



=over 2

=item * I<is-empty>  =>   B<boolean, optional>

=begin html

<br>This element tells whether directory is empty or not. Directory is considered empty if it only contains entries for "." and "..". This element is present if file is directory. In some special error cases like volume goes offline in between or directory is moved in the middle of getting this info, this field might not get set.

=end html

=back



=over 2

=item * I<is-junction>  =>   B<boolean, optional>

=begin html

<br>Returns true if the directory is a junction.

=end html

=back



=over 2

=item * I<is-vm-aligned>  =>   B<boolean, optional>

=begin html

<br>Returns true if the file is vm-aligned. A vm-aligned file is a file which is padded with zero-filled data at the beginning so that it's actual data starts at a different offset instead of zero. This is done in VM environments so that reads/writes to this file are aligned to WAFL's 4k block boundary. The amount by which the start offset is adjusted depends on the vm-align setting of the hosting volume. Use the volume-list-info or the volume-get-iter API to get this information.

=end html

=back



=over 2

=item * I<modified-timestamp>  =>   B<integer>

=begin html

<br>Last modification time of the file. The value is in seconds since January 1, 1970.

=end html

=back



=over 2

=item * I<name>  =>   B<string, optional>

=begin html

<br>Name of the file.

=end html

=back



=over 2

=item * I<owner-id>  =>   B<integer>

=begin html

<br>The integer id of the owner of the file.

=end html

=back



=over 2

=item * I<perm>  =>   B<string>

=begin html

<br>File permission bits. It's similar to Unix style permission bits: 0755 gives read/write/execute permissions to owner and read/execute to group and other users. It consists of 4 octal digits derived by adding up bits 4, 2 and 1. Omitted digits are assumed to be zeros. First digit selects the set user ID(4), set group ID (2) and sticky (1) attributes. The second digit selects permission for the owner of the file: read (4), write (2) and execute (1); the third selects permissions for other users in the same group; the fourth for other users not in the group.

=end html

=back



=head2 file-scope

=begin html

Part of the file for which fingerprint is computed. Possible values: "metadata_only", "data_only", "data_and_metadata".

=end html



B<Fields>

=over 2

=item * None

=back



=head2 fingerprint-info

=begin html

Fingerprint information.

=end html



B<Fields>

=over 2

=item * I<aggregate-uuid>  =>   B<string, optional>

=begin html

<br>Universal unique identifier (UUID) for the aggregate containing volume. The field is included for flexible volumes only.

=end html

=back



=over 2

=item * I<filer-id>  =>   B<string>

=begin html

<br>ID (NVRAM ID) of owner.

=end html

=back



=over 2

=item * I<filer-name>  =>   B<string, optional>

=begin html

<br>Name of the filer. If the filer name has not been written to the disks, this will not be returned.

=end html

=back



=over 2

=item * I<fingerprint-algorithm>  =>   B<digest-algorithm>

=begin html

<br>null

=end html

=back



=over 2

=item * I<fingerprint-end-time>  =>   B<integer>

=begin html

<br>End time of fingerprint computation in seconds since January 1, 1970. Time is taken out of system clock. Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<fingerprint-input-path>  =>   B<string>

=begin html

<br>Full path of the file to be fingerprinted. The value begins with /vol/<volumename>.

=end html

=back



=over 2

=item * I<fingerprint-scope>  =>   B<file-scope>

=begin html

<br>null

=end html

=back



=over 2

=item * I<fingerprint-start-time>  =>   B<integer>

=begin html

<br>Start time of fingerprint computation in seconds since January 1, 1970. Time is taken out of system clock. Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<fingerprint-version>  =>   B<string>

=begin html

<br>Version of the fingerprint output format.

=end html

=back



=over 2

=item * I<formatted-fingerprint-end-time>  =>   B<string>

=begin html

<br>End time of fingerprint computation in a human readable format <day> <month> <day of month> <hour>:<min>:<sec> <year> in GMT timezone. Time is taken out of system clock.

=end html

=back



=over 2

=item * I<formatted-fingerprint-start-time>  =>   B<string>

=begin html

<br>Start time of fingerprint computation in a human readable format <day> <month> <day of month> <hour>:<min>:<sec> <year> in GMT timezone. Time is taken out of system clock.

=end html

=back



=over 2

=item * I<formatted-snaplock-system-compliance-clock>  =>   B<string, optional>

=begin html

<br>If System Compliance Clock is initialized then human readable time <day> <month> <day of month> <hour>:<min>:<sec> <year> in GMT timezone. A value of "not_initalized" indicates that System Compliance Clock has not been initialized.

=end html

=back



=over 2

=item * I<formatted-snaplock-volume-compliance-clock>  =>   B<string, optional>

=begin html

<br>Volume Compliance Clock time for SnapLock volumes in human readable format <day> <month> <day of month> <hour>:<min>:<sec> <year> in GMT timezone. This field is not included for Non-SnapLock volumes.

=end html

=back



=over 2

=item * I<formatted-volume-expiry-date>  =>   B<string, optional>

=begin html

<br>Expiry date of the SnapLock volume in a human-readable format <day> <month> <day of month> <hour>:<min>:<sec> <year> in GMT timezone. A value of "infinite" indicates that the volume has an infinite expiry date. A value of "scan_in_progress" indicates that expiry date is not displayed since worm scan on the volume is in progress. A value of "no_expiry_date" indicates that expiry date is not displayed since the SnapLock volume has no WORM files and WORM snapshots. This field is not included if the volume is offline or the volume is regular volume.

=end html

=back



=over 2

=item * I<is-volume-expiry-date-wraparound>  =>   B<boolean, optional>

=begin html

<br>True if the date represented in the field volume-expiry-date is a wraparound format. The wraparound format indicates that dates after 01/19/2038 are mapped from 01/01/1970 - 12/31/2002 to 01/19/2038 - 01/19/2071. The field is not included if volume-expiry-date is not included.

=end html

=back



=over 2

=item * I<metadata-files>  =>   B<L<"file-fingerprint-info">[]>

=begin html

<br>List of files and their fingerprint related information.

=end html

=back



=over 2

=item * I<snaplock-license>  =>   B<string, optional>

=begin html

<br>Type of SnapLock license installed. Possible values: "compliance" that applies to SnapLock compliance restrictions and "enterprise" that applies to SnapLock enterprise restrictions and value "compliance and enterprise" if there are both licenses installed. This field is not included if SnapLock license is not installed.

=end html

=back



=over 2

=item * I<snaplock-system-compliance-clock>  =>   B<integer, optional>

=begin html

<br>If System Compliance Clock is initialized then time in seconds in the standard UNIX format (since 01/01/1970 00:00:00) in GMT timezone. Range:[0..2^64-1].

=end html

=back



=over 2

=item * I<snaplock-volume-compliance-clock>  =>   B<integer, optional>

=begin html

<br>Volume Compliance Clock time in seconds for the SnapLock volumes. The time is in the standard UNIX format (since 01/01/1970 00:00:00) in GMT timezone. This field is not included for Non-SnapLock volumes. Range:[0..2^64-1].

=end html

=back



=over 2

=item * I<volume-containing-aggregate>  =>   B<string, optional>

=begin html

<br><b>Flexible</b> volumes only. The name of the aggregate in which the given flexible volume resides.

=end html

=back



=over 2

=item * I<volume-expiry-date>  =>   B<integer, optional>

=begin html

<br>Expiry date of the SnapLock volume in seconds in the standard UNIX format (since 01/01/1970 00:00:00). Range:[0..2^64-1]. This field is not included if 1. Volume is non Snaplock volume, or 2. Snaplock volume has an infinite expiry date, or 3. Snaplock volume has no worm files or snapshots, or 4. Snaplock volume has worm scanner in progress The volume expiry date can be in wraparound format. The wraparound format indicates that dates after 01/19/2038 are mapped from 01/01/1970 - 12/31/2002 to 01/19/2038 - 01/19/2071.

=end html

=back



=over 2

=item * I<volume-name>  =>   B<string>

=begin html

<br>Name of the volume.

=end html

=back



=over 2

=item * I<volume-snaplock-type>  =>   B<string, optional>

=begin html

<br>The type of the Snaplock volume. It is present for Snaplock volumes only. Possible values: "compliance" or "enterprise"

=end html

=back



=over 2

=item * I<volume-type>  =>   B<string>

=begin html

<br>The type of volume. Possible values: "flexible" for flexible volumes, and "traditional" for traditional volumes.

=end html

=back



=over 2

=item * I<volume-uuid>  =>   B<string>

=begin html

<br>Universal unique identifier (UUID) for the volume.

=end html

=back



=head2 hole-range-info

=begin html

The hole start need not be an integral multiple of the block size. It will be rounded up to the start of the next block. The hole-size does not need to be the size of a block. It will be rounded down to the beginning of the block. It is possible that after the adjustments there is nothing to punch. That is ok and will be treated as success. Note that presently in WAFL small files are entirely within the inode. It is possible to "hole punch" those however nothing happens. The data is left alone. Considering the use case fot this ZAPI and the amount of effort to code the "correct" solution this is deemed an acceptable condition. If the file is vm-aligned then the range chosen to hole-punch could be rounded down by a block to ensure that we don't punch block containing valid user data.

=end html



B<Fields>

=over 2

=item * I<hole-size>  =>   B<integer>

=begin html

<br>Size of the hole in terms of bytes. If punching a hole WAFL presently limits this value to 4MB. Range : [0..2^63-1]

=end html

=back



=over 2

=item * I<hole-start>  =>   B<integer>

=begin html

<br>Starting offset of the hole. Range : [0..2^63-1]

=end html

=back



=head2 inode-parent-info

=begin html

Inode's path and parent information.

=end html



B<Fields>

=over 2

=item * I<inode-name>  =>   B<string, optional>

=begin html

<br>Name of inode in parent directory.

=end html

=back



=over 2

=item * I<inode-parent-cookie>  =>   B<integer, optional>

=begin html

<br>The opaque readdir cookie to determine the index of the inode in the parent directory tree. Note that this value is used as a testing hook, we do not plan to support its semantics and those semantics might change over time.

=end html

=back



=over 2

=item * I<inode-parent-inode-number>  =>   B<integer, optional>

=begin html

<br>Inode number of the parent directory.

=end html

=back



=over 2

=item * I<inode-path>  =>   B<string, optional>

=begin html

<br>Full path to inode

=end html

=back



=head2 flash-device-info

=begin html

Flash device information.

=end html



B<Fields>

=over 2

=item * I<average-erase-cycle-count>  =>   B<integer>

=begin html

<br>Average number of executed erase cycles.

=end html

=back



=over 2

=item * I<capacity>  =>   B<integer>

=begin html

<br>Advertised capacity of the device, in gigabytes.

=end html

=back



=over 2

=item * I<firmware-revision>  =>   B<string>

=begin html

<br>Firmware revision of FPGA on the flash device.

=end html

=back



=over 2

=item * I<last-change-time>  =>   B<integer>

=begin html

<br>Seconds since Midnight 1/1/1970 UTC when status changed.

=end html

=back



=over 2

=item * I<model-name>  =>   B<string>

=begin html

<br>Model name of the flash device in XXXXXX-XX format.

=end html

=back



=over 2

=item * I<part-number>  =>   B<string>

=begin html

<br>Part number of the flash device in XXX-XXXXX format.

=end html

=back



=over 2

=item * I<percent-online>  =>   B<integer>

=begin html

<br>Percentage of device capacity that is currently online.

=end html

=back



=over 2

=item * I<serial-number>  =>   B<string>

=begin html

<br>10-digit serial number of the flash device.

=end html

=back



=over 2

=item * I<service-time>  =>   B<integer>

=begin html

<br>Total number of hours the device was operational.

=end html

=back



=over 2

=item * I<slot-number>  =>   B<integer>

=begin html

<br>PCI-e slot number of the flash device.

=end html

=back



=over 2

=item * I<status>  =>   B<string>

=begin html

<br>The current status of the device. Possible values: "online", "offline_failed", or "offline_threshold".

=end html

=back



=over 2

=item * I<threshold-profile>  =>   B<string>

=begin html

<br>The name of the threshold profile being used for this flash device.

=end html

=back



=head2 flash-threshold

=begin html

A definition for a threshold element. Each threshold specifies what level of errors or failures the specified domain can sustain before the specified action is taken.

=end html



B<Fields>

=over 2

=item * I<action>  =>   B<string>

=begin html

<br>Action to be taken if this threshold is exceeded. Possible values: "log an EMS event", "log an EMS_event, and disable the 'domain'", "log an EMS event, and send an AutoSupport message", "log an EMS event, send an AutoSupport message, and disable the 'domain'"

=end html

=back



=over 2

=item * I<domain>  =>   B<string>

=begin html

<br>The type of domain. Possible values: "card", "bank", "chip" (in Data ONTAP 7.3.x to 8.1) or "lun" (from Data ONTAP 8.2 onwards).

=end html

=back



=over 2

=item * I<threshold-units>  =>   B<string>

=begin html

<br>The metric for threshold. Possible values: "count", or "percentage".

=end html

=back



=over 2

=item * I<threshold-value>  =>   B<integer>

=begin html

<br>Threshold value in 'threshold-units'.

=end html

=back



=over 2

=item * I<time-slice>  =>   B<string>

=begin html

<br>The time slice. Available if the 'threshold-unit' is "count". If not, output will say 'none'. Possible values: "none", "seconds", "minutes", or "hours".

=end html

=back



=head2 flash-threshold-profile

=begin html

A definition for a threshold element

=end html



B<Fields>

=over 2

=item * I<flash-threshold>  =>   B<L<"flash-threshold">[]>

=begin html

<br>The list of threshold entries for this profile.

=end html

=back



=over 2

=item * I<profile>  =>   B<string>

=begin html

<br>The name of the profile in plain text.

=end html

=back



=head2 extension-list-info

=begin html

Structure containing extension information.

=end html



B<Fields>

=over 2

=item * I<name-spec>  =>   B<string>

=begin html

<br>Extension specification (including wild cards). Allowed are only DOS like, three character long extensions. The extensions are case insensitive. Supported wild card values: "???" to match any extension and "?" to match any character. Examples of allowed extension specifications: EXE ??? ?XT P??

=end html

=back



=head2 fpolicy-volumes-list-info

=begin html

Structure containing volumes information.

=end html



B<Fields>

=over 2

=item * I<volume-spec>  =>   B<string>

=begin html

<br>Volume specification (including wild cards). The volumes are case insensitive. If no volume-spec is provided, then the list will be reset to an empty list. Supported wild card values: "?" to match any character and "*" to match any number of characters. Example specifications: vol0 vol? users*

=end html

=back



=head2 monitored-operation-info

=begin html

Structure containing information pertaining to monitored operations.

=end html



B<Fields>

=over 2

=item * I<operation>  =>   B<string>

=begin html

<br>Supported values: "file-create", "file- delete", "file-open", "file-close", "file-rename", "directory-create", "directory-delete", "directory-rename", "getattr", "setattr", "lookup", "read", "write", "link", "symlink"

=end html

=back



=head2 monitored-protocol-info

=begin html

Structure containing information pertaining to monitored operations' protocols.

=end html



B<Fields>

=over 2

=item * I<protocol>  =>   B<string>

=begin html

<br>Supported values: "nfs", "cifs".

=end html

=back



=head2 policy-info

=begin html

Structure containing information pertaining to policy.

=end html



B<Fields>

=over 2

=item * I<is-ads-monitored>  =>   B<boolean>

=begin html

<br>True if the policy monitors the cifs operations on Alternate Data Streams.

=end html

=back



=over 2

=item * I<is-enabled>  =>   B<boolean>

=begin html

<br>True if the policy is enabled. No matter whether the policy is enabled or disabled, values returned in other elements for the policy are always valid.

=end html

=back



=over 2

=item * I<is-i2p-enabled>  =>   B<boolean>

=begin html

<br>True if inode to pathname translation for NFS requests is supported and enabled.If enabled fpolicy requests to fpolicy server will carry full file path for NFS requests. The fields which will carry full file path are AccessPath and RenamePath for FP_ScreenRequest RPC call and sr_accesspath for FP_ScreenRequest2 RPC call.

=end html

=back



=over 2

=item * I<is-offline-files-only>  =>   B<boolean, optional>

=begin html

<br>True if the file policy monitors only offlines files. Default is false.

=end html

=back



=over 2

=item * I<monitored-operations>  =>   B<L<"monitored-operation-info">[]>

=begin html

<br>List of monitored operations.

=end html

=back



=over 2

=item * I<monitored-protocols>  =>   B<L<"monitored-protocol-info">[]>

=begin html

<br>List of monitored protocols.

=end html

=back



=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Policy name.

=end html

=back



=over 2

=item * I<number-of-requests-blocked-locally>  =>   B<integer>

=begin html

<br>Number of locally blocked(denied) screen requests. This value is reset each time the filer is rebooted or the policy is disabled. Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<number-of-screen-failures>  =>   B<integer>

=begin html

<br>Number of failed (denied) screen requests. This value is reset each time the filer is rebooted or the policy is disabled. Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<number-of-screened-files>  =>   B<integer>

=begin html

<br>Number of screened files since policy has been enabled. This value is reset each time the filer is rebooted or the policy is disabled. Range : [0..2^32-1].

=end html

=back



=head2 secondary-server-info

=begin html

Structure containing information pertaining to secondary servers.

=end html



B<Fields>

=over 2

=item * I<server-ip>  =>   B<ip-address>

=begin html

<br>The ip address, in dotted-decimal format, of the server.

=end html

=back



=head2 server-info

=begin html

Structure containing information pertaining to servers.

=end html



B<Fields>

=over 2

=item * I<idl-version>  =>   B<integer>

=begin html

<br>Version of the Interface Definition Language(IDL) used by the Fpolicy server. Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<is-asynchronous>  =>   B<boolean, optional>

=begin html

<br>Shows if the server is registered as asynchronous, i.e. doesn't send reply to the filer.

=end html

=back



=over 2

=item * I<is-size-and-owner-required>  =>   B<boolean, optional>

=begin html

<br>True if the server is registered to receive file size and file owner information with every Fpolicy request.

=end html

=back



=over 2

=item * I<is-snapid-required>  =>   B<boolean, optional>

=begin html

<br>True if the server is registered to receive file snapshot ID with every Fpolicy request.

=end html

=back



=over 2

=item * I<is-version2>  =>   B<boolean, optional>

=begin html

<br>True if the server is registered with version2 support enabled. version2 refers to the version of the FP_ScreenRequest(). When version2 is true the FPolicy server is enabled to receive FP_ScreenRequest2() RPC.

=end html

=back



=over 2

=item * I<number-of-screen-failures>  =>   B<integer>

=begin html

<br>Number of failed (denied) screens since server registrations. Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<number-of-screened-files>  =>   B<integer>

=begin html

<br>Number of screened files since server registration. Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<offline-filter-bit>  =>   B<string, optional>

=begin html

<br>Shows the setting of offline filter. Supported values: "none", "on-set".

=end html

=back



=over 2

=item * I<server-id>  =>   B<integer>

=begin html

<br>The unique server ID assigned to the Fpolicy server at the time of Fpolicy server registration. Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<server-ip>  =>   B<ip-address>

=begin html

<br>The ip address, in dotted-decimal format, of the server.

=end html

=back



=over 2

=item * I<smb-req-pipe-name>  =>   B<string>

=begin html

<br>The name of the FPolicy request pipe name on which FPolicy server is recieving the screen requests from the storage system. This name is sent by the FPolicy server at the time of the FPolicy server registration.

=end html

=back



=head2 ic-config-details

=begin html

Details on HA configuration

=end html



B<Fields>

=over 2

=item * I<ic-rlib-if>  =>   B<L<"ic-rlib-if-info">[], optional>

=begin html

<br>Interface configuration info for rlib (RDMA, Remote Direct Memory Access library) interconnects.

=end html

=back



=over 2

=item * I<ic-system-id>  =>   B<L<"ic-system-id-info">[]>

=begin html

<br>Per node information.

=end html

=back



=over 2

=item * I<interconnect-type>  =>   B<string>

=begin html

<br>The type of HA interconnect present. Possible value: "iwarp", "infiniband".

=end html

=back



=over 2

=item * I<interface-config>  =>   B<L<"interface-config-info">[], optional>

=begin html

<br>Interface configuration info only for interfaces used by iWarp.

=end html

=back



=head2 ic-counter

=begin html

IC counters

=end html



B<Fields>

=over 2

=item * I<counter-name>  =>   B<string>

=begin html

<br>Name of the counter

=end html

=back



=over 2

=item * I<counter-value>  =>   B<integer>

=begin html

<br>Value of the counter Range : [0..2^64-1]

=end html

=back



=head2 ic-rlib-if-info

=begin html

Interface information for each rlib interface.

=end html



B<Fields>

=over 2

=item * I<interface-ip>  =>   B<string>

=begin html

<br>Interface IP Address.

=end html

=back



=over 2

=item * I<interface-name>  =>   B<string>

=begin html

<br>Name of the interface.

=end html

=back



=head2 ic-system-id-info

=begin html

Per node information.

=end html



B<Fields>

=over 2

=item * I<is-connection-initiator>  =>   B<boolean>

=begin html

<br>If set to true, the node is the server node with the larger sysid.

=end html

=back



=over 2

=item * I<node>  =>   B<string>

=begin html

<br>Whether local or partner node.

=end html

=back



=over 2

=item * I<system-id>  =>   B<integer>

=begin html

<br>System ID of the node. Range : [0..2^64-1]

=end html

=back



=head2 nvram-per-port-counters-info

=begin html

List of port counters for an nvram port

=end html



B<Fields>

=over 2

=item * I<counter-list>  =>   B<L<"ic-counter">[], optional>

=begin html

<br>list of counters for a port.

=end html

=back



=over 2

=item * I<port-number>  =>   B<integer>

=begin html

<br>Numerical Id of the port. Range : [0..2^32-1]

=end html

=back



=head2 per-link-parameters-info

=begin html

Per link parameters

=end html



B<Fields>

=over 2

=item * I<link-number>  =>   B<integer>

=begin html

<br>The link id. Range : [0..2^32-1]

=end html

=back



=over 2

=item * I<link-state>  =>   B<string>

=begin html

<br>State of the link Possible values: "up", "down"

=end html

=back



=over 2

=item * I<num-mad-received>  =>   B<integer>

=begin html

<br>Number of Management Datagram (MAD) packets received Range : [0..2^32-1]

=end html

=back



=over 2

=item * I<num-mad-sent>  =>   B<integer>

=begin html

<br>Number of Management Datagram (MAD) packets sent Range : [0..2^32-1]

=end html

=back



=over 2

=item * I<num-recv-desc>  =>   B<integer>

=begin html

<br>Number of receive descriptors posted Range : [0..2^32-1]

=end html

=back



=over 2

=item * I<port-mtu>  =>   B<integer>

=begin html

<br>Port Max Transfer Unit Range : [0..2^32-1]

=end html

=back



=over 2

=item * I<port-state>  =>   B<string>

=begin html

<br>Port state Possible values: "port down", "port initialize", "port armed", "port active"

=end html

=back



=head2 queue-info

=begin html

Information about the Descriptors on the Queue

=end html



B<Fields>

=over 2

=item * I<id>  =>   B<integer>

=begin html

<br>Id of the last descriptor posted on this Queue. Range : [0..2^64-1]

=end html

=back



=over 2

=item * I<last-complete-id>  =>   B<integer>

=begin html

<br>Id of the last descriptor completed on this Queue. Range : [0..2^64-1]

=end html

=back



=over 2

=item * I<last-polled-id>  =>   B<integer>

=begin html

<br>Id of the last descriptor polled on this Queue. Range : [0..2^64-1]

=end html

=back



=head2 virtual-interface-socket-stat-info

=begin html

Per channel Virtual Interface socket statistics

=end html



B<Fields>

=over 2

=item * I<channel-number>  =>   B<integer>

=begin html

<br>The channel for which the statistics are being reported Possible values: 0, 1. Range : [0..2^32-1]

=end html

=back



=over 2

=item * I<per-channel-counters>  =>   B<L<"ic-counter">[]>

=begin html

<br>Per channel Virtual Interface socket counters.

=end html

=back



=head2 initiator-group-info

=begin html

Information about an initiator group.

=end html



B<Fields>

=over 2

=item * I<initiator-group-alua-enabled>  =>   B<boolean>

=begin html

<br>Boolean value to indicate if this initiator group has ALUA (Asymmetric Logical Unit Access) features enabled for luns mapped to this initiator group.

=end html

=back



=over 2

=item * I<initiator-group-name>  =>   B<string>

=begin html

<br>Name of this initiator group.

=end html

=back



=over 2

=item * I<initiator-group-os-type>  =>   B<initiator-group-os-type>

=begin html

<br>OS type of the initiator group

=end html

=back



=over 2

=item * I<initiator-group-portset-name>  =>   B<string, optional>

=begin html

<br>Name of the portset that is bound to the initiator group, if any.

=end html

=back



=over 2

=item * I<initiator-group-report-scsi-name-enabled>  =>   B<boolean, optional>

=begin html

<br>Boolean value to indicate whether to report or hide SCSI Name String (8h) Descriptor to initiator's INQUIRY VPD 0x83 page command. This field is available in Data ONTAP 8.1.0 and later.

=end html

=back



=over 2

=item * I<initiator-group-throttle-borrow>  =>   B<boolean>

=begin html

<br>Boolean value to indicate that the igroups throttle reserve may be exceeded if the igroup attempts to use more than it has reserved.

=end html

=back



=over 2

=item * I<initiator-group-throttle-reserve>  =>   B<integer>

=begin html

<br>Percentage of filer SCSI command blocks reserved for this initiator group's exclusive usage.

=end html

=back



=over 2

=item * I<initiator-group-type>  =>   B<string>

=begin html

<br>Type of the initiators in this group. Possible values: "iscsi", "fcp", "mixed".

=end html

=back



=over 2

=item * I<initiator-group-use-partner>  =>   B<boolean, optional>

=begin html

<br>Boolean value to indicate if this initiator group is configured for its luns to require the use of host multi-pathing software for correct high-availability failover operation. In Data ONTAP 7-Mode, this value is optional and is only returned for FCP initiator groups on an storage system in an HA pair. In Data ONTAP Cluster-Mode, this field will always be 'true'.

=end html

=back



=over 2

=item * I<initiator-group-uuid>  =>   B<string, optional>

=begin html

<br>This value is Universally-unique identifier (UUID) of this initiator group. <p> The UUIDs are formatted as 36-character strings. These strings are composed of 32 hexadecimal characters broken up into five groupings separated by '-'s. The first grouping has 8 hexadecimal characters, the second through fourth groupings have four hexadecimal characters each, and the fifth and final grouping has 12 hexadecimal characters. Note that a leading '0x' is not used. <p> This field is available in Data ONTAP 7-mode 7.3.6, 8.0.2, 8.1.0 and later for the igroup-list-info API. This field is available in Data ONTAP Cluster-Mode 8.1.0 and later for the igroup-get-iter and lun-map-list-info APIs. <p> Here is an example of an actual UUID: <p> <dl> <dt><dd> 35d6ca90-c759-11df-8b6d-00a098132c6c </dd><br></dt> </dl>

=end html

=back



=over 2

=item * I<initiator-group-vsa-enabled>  =>   B<boolean>

=begin html

<br>Boolean value to indicate if this initiator group has Volume Set Addressing (VSA) enabled or disabled.

=end html

=back



=over 2

=item * I<initiators>  =>   B<L<"initiator-info">[], optional>

=begin html

<br>List of initiators belonging to this group.

=end html

=back



=over 2

=item * I<lun-id>  =>   B<integer, optional>

=begin html

<br>LUN identifier to which the LUN is mapped at the host. This value is optional and is only returned for the lun-map-list-info api.

=end html

=back



=head2 initiator-group-list-info

=begin html

Initiator group this initiator belogs to.

=end html



B<Fields>

=over 2

=item * I<initiator-group-name>  =>   B<string>

=begin html

<br>Name of initiator group.

=end html

=back



=head2 initiator-group-os-type

=begin html

The operating system of the initiator group. This value modifies the finer details of SCSI protocol interaction for initiators in the group. Possible values: <ul> <li> "aix" The initiators belong to an AIX host, <li> "default" The initiators belong to an unknown host type, <li> "hpux" The initiators belong to an HP-UX host, <li> "hyper_v" The initiators belong to a Hyper-V parent host, <li> "linux" The initiators belong to a Linux host, <li> "netware" The initators belong to a NetWare host, <li> "openvms" The initiators belong to an OpenVMS host, <li> "solaris" The initiators belong to a Solaris host, <li> "vmware" The initiators belong to a VMware ESX host, <li> "windows" The initiators belong to a Windows host, <li> "xen" The initiators belong to a Xen hypervisor host. </ul>

=end html



B<Fields>

=over 2

=item * None

=back



=head2 initiator-info

=begin html

Information about one initiator.

=end html



B<Fields>

=over 2

=item * I<initiator-name>  =>   B<string>

=begin html

<br>Name of the initiator.

=end html

=back



=head2 interface-info

=begin html

Information about one interface

=end html



B<Fields>

=over 2

=item * I<interface>  =>   B<string>

=begin html

<br>Name of the interface that is recognizable by "ifconfig" command like "e0" or a VIF (virtual interface) name.

=end html

=back



=head2 ipspace-info

=begin html

This is information about one ipspace

=end html



B<Fields>

=over 2

=item * I<interfaces>  =>   B<L<"interface-info">[]>

=begin html

<br>List of all interfaces belonging to this ipspace.

=end html

=back



=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Ipspace name.

=end html

=back



=head2 interface-list-entry-info

=begin html

Information about a single interface

=end html



B<Fields>

=over 2

=item * I<interface-name>  =>   B<string>

=begin html

<br>Name of network interface. In Data ONTAP 7-Mode, this is the name of a physical or virtual ethernet interface, for example: "e0c" or "vif0". In Data ONTAP Cluster-Mode, this is the name of an iSCSI data LIF in the Vserver.

=end html

=back



=head2 ipaddress-list-entry-info

=begin html

Information about a single IP Address

=end html



B<Fields>

=over 2

=item * I<ip-address>  =>   B<string>

=begin html

<br>IP address

=end html

=back



=head2 iscsi-adapter-initiators-info

=begin html

A list of initiators currently connected to the adapter.

=end html



B<Fields>

=over 2

=item * I<iscsi-connected-initiators>  =>   B<L<"iscsi-connected-initiator-info">[]>

=begin html

<br>Information about the connected initiators

=end html

=back



=over 2

=item * I<name>  =>   B<string>

=begin html

<br>The name this adapter is given.

=end html

=back



=head2 iscsi-cdb-stats-info

=begin html

Counts for Command Descriptor Blocks processed

=end html



B<Fields>

=over 2

=item * I<data-in-blocks>  =>   B<integer>

=begin html

<br>Count of data in blocks.

=end html

=back



=over 2

=item * I<data-out-blocks>  =>   B<integer>

=begin html

<br>Count of data out blocks.

=end html

=back



=over 2

=item * I<error-status>  =>   B<integer>

=begin html

<br>Count of errors.

=end html

=back



=over 2

=item * I<success-status>  =>   B<integer>

=begin html

<br>Count of successes.

=end html

=back



=over 2

=item * I<total>  =>   B<integer>

=begin html

<br>Total Command Descriptor Blocks processed.

=end html

=back



=head2 iscsi-config-adapter-info

=begin html

Configuration information about a single iscsi adapter.

=end html



B<Fields>

=over 2

=item * I<name>  =>   B<string>

=begin html

<br>The name this adapter is given.

=end html

=back



=over 2

=item * I<portal-addresses>  =>   B<L<"iscsi-portal-address-info">[]>

=begin html

<br>A list of portal group address + port that this adapter is listening on.

=end html

=back



=over 2

=item * I<state>  =>   B<string>

=begin html

<br>State of the adapter, either "online", "offline", "local", "partner", "error". " online" and "offline" is used when the adapter is used for the current host. "local" if the adapter is operating on behalf of the local host, and "partner" if the adapter is operating on behalf of the partner host. "error" is used if some an internal error occurred when tring to load this adapter info.

=end html

=back



=over 2

=item * I<status>  =>   B<string, optional>

=begin html

<br>A short status message explaining the state. i.e. if the adapter is offline, the reason for it, or if its "error" what the error is. This will not be returned if the state of the adapter is "online".

=end html

=back



=head2 iscsi-connected-initiator-info

=begin html

Information about an initiator connected to an iSCSI adapter.

=end html



B<Fields>

=over 2

=item * I<initiator-name>  =>   B<string>

=begin html

<br>Name of initiator.

=end html

=back



=over 2

=item * I<isid>  =>   B<string>

=begin html

<br>ISID in form of "xx:xx:xx:xx:xx:xx".

=end html

=back



=over 2

=item * I<portal-group-id>  =>   B<integer>

=begin html

<br>Target portal group number to which the initiator is connected.

=end html

=back



=head2 iscsi-connection-list-entry-info

=begin html

Information about an iSCSI connection. In Data ONTAP 7-Mode, connections are uniquely identified by the combination of 'session-id' and 'connection-id'. In Data ONTAP Cluster-Mode, sessions are uniquely identified within a Vserver by the combination of 'tpgroup-name', 'session-id' and 'connection-id'.

=end html



B<Fields>

=over 2

=item * I<connection-id>  =>   B<integer>

=begin html

<br>Connection id

=end html

=back



=over 2

=item * I<connection-state>  =>   B<string>

=begin html

<br>Current state of this connection. Possible values: <ul> <li> "New_Connection", <li> "Waiting_Tpgtag_Assignment", <li> "Login_Waiting_Req", <li> "Login_Req_Rcvd", <li> "Login_Waiting_Auth", <li> "Login_OK_New_Session_Requested", <li> "Login_New_Session_Waiting_Reinstatement", <li> "Login_OK_New_Conn_Requested", <li> "Login_New_Conn_Waiting_Reinstatement", <li> "Login_Send_Final_Resp", <li> "Full_Feature_Phase", <li> "Shutdown_Start", <li> "Shutdown_Waiting_Sockio_Shutdown", <li> "Shutdown_Sockio_Shutdown_Done", <li> "Shutdown_Waiting_ImmDeliv_FFPCmds_Done", <li> "Shutdown_ImmDeliv_FFPCmds_Done", <li> "Shutdown_Recovery_Waiting_FFPCmds_Ready", <li> "Shutdown_Recovery_Waiting_Logout_Rcvd", <li> "Shutdown_Recovery_Logout_Rcvd", <li> "Shutdown_Recovery_Waiting_FFPCmds_Reassigned", <li> "Shutdown_Terminate_Abort_Seq_FFPCmds", <li> "Shutdown_Terminate_Waiting_Seq_FFPCmds_Done", <li> "Shutdown_Terminate_Seq_FFPCmds_Done". </ul>

=end html

=back



=over 2

=item * I<has-session>  =>   B<boolean>

=begin html

<br>True if this connection is associated to a session, false otherwise.

=end html

=back



=over 2

=item * I<interface-name>  =>   B<string>

=begin html

<br>Name of the network interface hosting this connection. In Data ONTAP 7-Mode, this is the name of a physical ethernet interface, for example: "e0c". In Data ONTAP Cluster-Mode, this is the name of an iSCSI data LIF in the Vserver.

=end html

=back



=over 2

=item * I<local-ip-address>  =>   B<string>

=begin html

<br>Storage System iSCSI Target IP address.

=end html

=back



=over 2

=item * I<local-ip-port>  =>   B<integer>

=begin html

<br>Storage System iSCSI Target TCP port.

=end html

=back



=over 2

=item * I<remote-ip-address>  =>   B<string>

=begin html

<br>Remote initiator IP address.

=end html

=back



=over 2

=item * I<remote-ip-port>  =>   B<integer>

=begin html

<br>Remote initiator TCP port.

=end html

=back



=over 2

=item * I<session-id>  =>   B<integer>

=begin html

<br>Session id for the associated session, or 0 if this connection is not yet associated to a session.

=end html

=back



=over 2

=item * I<tpgroup-tag>  =>   B<integer>

=begin html

<br>The tag of the target portal group associated with this session.

=end html

=back



=head2 iscsi-error-stats-info

=begin html

Counts for iSCSI errors.

=end html



B<Fields>

=over 2

=item * I<data-digest>  =>   B<integer>

=begin html

<br>Count of digest errors.

=end html

=back



=over 2

=item * I<failed-logins>  =>   B<integer>

=begin html

<br>Count of failed logins.

=end html

=back



=over 2

=item * I<failed-logouts>  =>   B<integer>

=begin html

<br>Count of failed logouts.

=end html

=back



=over 2

=item * I<failed-task-mgt>  =>   B<integer>

=begin html

<br>Count of failed management tasks.

=end html

=back



=over 2

=item * I<failed-text-cmd>  =>   B<integer>

=begin html

<br>Count of failed text commands.

=end html

=back



=over 2

=item * I<hdr-digest>  =>   B<integer>

=begin html

<br>Count of digest errors.

=end html

=back



=over 2

=item * I<invalid-header>  =>   B<integer>

=begin html

<br>Count of PDU discards due to invalid PDU header.

=end html

=back



=over 2

=item * I<outside-cmd-sn-window>  =>   B<integer>

=begin html

<br>Count of PDU discards due to PDU being outside of command sequence number window.

=end html

=back



=over 2

=item * I<protocol>  =>   B<integer>

=begin html

<br>Count of protocol errors.

=end html

=back



=over 2

=item * I<total>  =>   B<integer>

=begin html

<br>Total errors.

=end html

=back



=head2 iscsi-initiator-list-entry-info

=begin html

Information about a single initiator.

=end html



B<Fields>

=over 2

=item * I<initiator-aliasname>  =>   B<string, optional>

=begin html

<br>User-friendly name assigned to initiator. This field is only present if the initiator provided an alias during login.

=end html

=back



=over 2

=item * I<initiator-group-list>  =>   B<L<"initiator-group-list-info">[], optional>

=begin html

<br>List of initiator groups containing this iSCSI initiator.

=end html

=back



=over 2

=item * I<initiator-nodename>  =>   B<string>

=begin html

<br>Name of initiator. The initiator name must conform to RFC 3720, for example: "iqn.1987-06.com.initvendor1:appsrv.sn.2346".

=end html

=back



=over 2

=item * I<isid>  =>   B<string>

=begin html

<br>ISID for this session selected by initiator represented as 6 hexadecimal octets separated by colons, for example: "40:01:37:00:00:00".

=end html

=back



=over 2

=item * I<target-session-id>  =>   B<integer>

=begin html

<br>iSCSI session identifier assigned by the target.

=end html

=back



=over 2

=item * I<tpgroup-tag>  =>   B<integer>

=begin html

<br>Tag of target portal group associated with this session.

=end html

=back



=head2 iscsi-interface-list-entry-info

=begin html

Information about a single interface

=end html



B<Fields>

=over 2

=item * I<interface-name>  =>   B<string>

=begin html

<br>Name of interface. In Data ONTAP 7-Mode, this is the name of a physical ethernet interface, for example: "e0c". In Data ONTAP Cluster-Mode, this is the name of an iSCSI data LIF in the Vserver.

=end html

=back



=over 2

=item * I<is-interface-enabled>  =>   B<boolean>

=begin html

<br>"true" if interface enabled for iSCSI, "false" otherwise.

=end html

=back



=over 2

=item * I<tpgroup-name>  =>   B<string>

=begin html

<br>Name of target portal group interface is associated with.

=end html

=back



=over 2

=item * I<tpgroup-tag>  =>   B<integer>

=begin html

<br>Id of target portal group interface is associated with.

=end html

=back



=head2 iscsi-iptpgroup-list-entry-info

=begin html

Information about a single portal group

=end html



B<Fields>

=over 2

=item * I<ipaddress-list-entries>  =>   B<L<"ipaddress-list-entry-info">[]>

=begin html

<br>List of IP Addresses associated with this iptpgroup

=end html

=back



=over 2

=item * I<tpgroup-name>  =>   B<string>

=begin html

<br>Portal group name

=end html

=back



=over 2

=item * I<tpgroup-tag>  =>   B<integer>

=begin html

<br>Portal group tag

=end html

=back



=head2 iscsi-portal-address-info

=begin html

Configuration information about an inet-addres and port pair for a portal group.

=end html



B<Fields>

=over 2

=item * I<id>  =>   B<integer>

=begin html

<br>ID of this portal group.

=end html

=back



=over 2

=item * I<inet-address>  =>   B<ip-address>

=begin html

<br>inet-address.

=end html

=back



=over 2

=item * I<port>  =>   B<integer>

=begin html

<br>The port that is being listened on for that address.

=end html

=back



=head2 iscsi-portal-list-entry-info

=begin html

information about a single portal

=end html



B<Fields>

=over 2

=item * I<interface-name>  =>   B<string>

=begin html

<br>Name of network interface exporting this portal

=end html

=back



=over 2

=item * I<ip-address>  =>   B<string>

=begin html

<br>portal IP address

=end html

=back



=over 2

=item * I<ip-port>  =>   B<integer>

=begin html

<br>portal listening port

=end html

=back



=over 2

=item * I<tpgroup-tag>  =>   B<integer>

=begin html

<br>tag of portal group this portal is associated with

=end html

=back



=head2 iscsi-received-stats-info

=begin html

Counts for PDUs received.

=end html



B<Fields>

=over 2

=item * I<data-out>  =>   B<integer>

=begin html

<br>Count of data out requests.

=end html

=back



=over 2

=item * I<login-req>  =>   B<integer>

=begin html

<br>Count of login requests.

=end html

=back



=over 2

=item * I<logout-req>  =>   B<integer>

=begin html

<br>Count of logout requests.

=end html

=back



=over 2

=item * I<nop-out>  =>   B<integer>

=begin html

<br>Count of NOP Out.

=end html

=back



=over 2

=item * I<scsi-cmd>  =>   B<integer>

=begin html

<br>Count of SCSI commands.

=end html

=back



=over 2

=item * I<scsi-task-mgt-cmd>  =>   B<integer>

=begin html

<br>Count of SCSI task management commands.

=end html

=back



=over 2

=item * I<snack>  =>   B<integer>

=begin html

<br>Count of SNACK requests.

=end html

=back



=over 2

=item * I<text-req>  =>   B<integer>

=begin html

<br>Count of text requests.

=end html

=back



=over 2

=item * I<total>  =>   B<integer>

=begin html

<br>Total PDUs received.

=end html

=back



=over 2

=item * I<unknown>  =>   B<integer>

=begin html

<br>Count of unknown PDUs.

=end html

=back



=head2 iscsi-security-entry-info

=begin html

Information about a single authentication entry.

=end html



B<Fields>

=over 2

=item * I<auth-chap-policy>  =>   B<string, optional>

=begin html

<br>CHAP authentication path. Possible values: "local", "radius".

=end html

=back



=over 2

=item * I<auth-type>  =>   B<string>

=begin html

<br>Authentication type. Possible values: "CHAP", "none", "deny".

=end html

=back



=over 2

=item * I<initiator>  =>   B<string>

=begin html

<br>Name of initiator. The initiator name must conform to RFC 3720, for example: "iqn.1987-06.com.initvendor1:appsrv.sn.2346", or "default" if this is a default auth entry.

=end html

=back



=over 2

=item * I<outbound-user-name>  =>   B<string, optional>

=begin html

<br>Outbound CHAP user name, returned only if auth-type is CHAP, and outbound authentication is set for initiator.

=end html

=back



=over 2

=item * I<user-name>  =>   B<string, optional>

=begin html

<br>Inbound CHAP user name, returned only if auth-type is CHAP.

=end html

=back



=head2 iscsi-session-connection-list-entry-info

=begin html

Information about a single tcp connection

=end html



B<Fields>

=over 2

=item * I<authentication-method>  =>   B<string>

=begin html

<br>Authentication method of this connection. Possible values: "CHAP", "none".

=end html

=back



=over 2

=item * I<connection-id>  =>   B<integer>

=begin html

<br>Connection id within the session.

=end html

=back



=over 2

=item * I<data-digest-enabled>  =>   B<boolean>

=begin html

<br>True if data digests are enabled on this connection, false otherwise.

=end html

=back



=over 2

=item * I<header-digest-enabled>  =>   B<boolean>

=begin html

<br>True if header digests are enabled on this connection, false otherwise.

=end html

=back



=over 2

=item * I<initiator-max-rcv-data-segment-length>  =>   B<integer>

=begin html

<br>Initiator's MaxRecvDataSegmentLength as defined in RFC 3720, in bytes.

=end html

=back



=over 2

=item * I<interface-name>  =>   B<string>

=begin html

<br>Name of network interface hosting this connection. In Data ONTAP 7-Mode, this is the name of a physical ethernet interface, for example: "e0c". In Data ONTAP Cluster-Mode, this is the name of an iSCSI data LIF in the Vserver.

=end html

=back



=over 2

=item * I<local-ip-address>  =>   B<string>

=begin html

<br>Local storage system iSCSI target interface address.

=end html

=back



=over 2

=item * I<local-ip-port>  =>   B<integer>

=begin html

<br>Local storage system iSCSI target TCP port.

=end html

=back



=over 2

=item * I<rcv-window-size>  =>   B<integer>

=begin html

<br>TCP/IP receive window size, in octets.

=end html

=back



=over 2

=item * I<remote-ip-address>  =>   B<string>

=begin html

<br>Remote initiator IP address.

=end html

=back



=over 2

=item * I<remote-ip-port>  =>   B<integer>

=begin html

<br>Remote initiator TCP port.

=end html

=back



=over 2

=item * I<target-max-rcv-data-segment-length>  =>   B<integer>

=begin html

<br>Target's MaxRecvDataSegmentLength as defined in RFC 3720, in bytes.

=end html

=back



=head2 iscsi-session-list-entry-info

=begin html

Information about a single iSCSI session. In Data ONTAP 7-Mode, sessions are uniquely identified by the 'target-session-id'. In Data ONTAP Cluster-Mode, sessions are uniquely identified within a Vserver by the combination of 'tpgroup-name' and 'target-session-id'.

=end html



B<Fields>

=over 2

=item * I<cmd-window-size>  =>   B<integer>

=begin html

<br>Command window size.

=end html

=back



=over 2

=item * I<data-pdu-in-order>  =>   B<boolean>

=begin html

<br>The DataPDUInOrder of the session as defined in RFC 3720.

=end html

=back



=over 2

=item * I<data-sequence-in-order>  =>   B<boolean>

=begin html

<br>The DataSequenceInOrder of the session as defined in RFC 3720.

=end html

=back



=over 2

=item * I<default-time-to-retain>  =>   B<integer>

=begin html

<br>The DefaultTime2Retain of the session as defined in RFC 3720, in seconds.

=end html

=back



=over 2

=item * I<default-time-to-wait>  =>   B<integer>

=begin html

<br>The DefaultTime2Wait of the session as defined in RFC 3720, in seconds.

=end html

=back



=over 2

=item * I<error-recovery-level>  =>   B<integer>

=begin html

<br>iSCSI ErrorRecoveryLevel as defined in RFC 3720.

=end html

=back



=over 2

=item * I<first-burst-length>  =>   B<integer>

=begin html

<br>The FirstBurstLength of the session as defined in RFC 3720, in bytes.

=end html

=back



=over 2

=item * I<immediate-data-enabled>  =>   B<boolean>

=begin html

<br>True if this session has immediate data enabled, false otherwise.

=end html

=back



=over 2

=item * I<initial-r2t-enabled>  =>   B<boolean>

=begin html

<br>True if this session has R2T enabled, false otherwise.

=end html

=back



=over 2

=item * I<initiator-aliasname>  =>   B<string, optional>

=begin html

<br>The user-friendly name assigned to initiator. This field is only present if the initiator provided an alias during login.

=end html

=back



=over 2

=item * I<initiator-nodename>  =>   B<string>

=begin html

<br>Name of initiator. The initiator name must conform to RFC 3720, for example: "iqn.1987-06.com.initvendor1:appsrv.sn.2346".

=end html

=back



=over 2

=item * I<iscsi-session-connection-list-entries>  =>   B<L<"iscsi-session-connection-list-entry-info">[]>

=begin html

<br>List of TCP/IP connections associated with this session

=end html

=back



=over 2

=item * I<iscsi-sesssion-cmd-list-entries>  =>   B<L<"iscsi-sesssion-cmd-list-entry-info">[], optional>

=begin html

<br>List of active commands associated with this session

=end html

=back



=over 2

=item * I<isid>  =>   B<string>

=begin html

<br>ISID for this session selected by initiator represented as 6 hexadecimal octets separated by colons, for example: "40:01:37:00:00:00".

=end html

=back



=over 2

=item * I<max-burst-length>  =>   B<integer>

=begin html

<br>The MaxBurstLength of the session as defined in RFC 3720, in bytes.

=end html

=back



=over 2

=item * I<max-connections>  =>   B<integer>

=begin html

<br>Maximum number of connections for this session.

=end html

=back



=over 2

=item * I<max-outstanding-r2t>  =>   B<integer>

=begin html

<br>The MaxOutstandingR2T of the session as defined in RFC 3720.

=end html

=back



=over 2

=item * I<session-type>  =>   B<string>

=begin html

<br>Possible values: "normal" or "discovery".

=end html

=back



=over 2

=item * I<target-session-id>  =>   B<integer>

=begin html

<br>The iSCSI session identifier assigned by the storage system.

=end html

=back



=over 2

=item * I<tpgroup-tag>  =>   B<integer>

=begin html

<br>The tag of the target portal group associated with this session.

=end html

=back



=head2 iscsi-sesssion-cmd-list-entry-info

=begin html

information about a particular command

=end html



B<Fields>

=over 2

=item * I<cmd-state>  =>   B<string>

=begin html

<br>State of iSCSI command. Possible values: <ul> <li> "FREE" - Free, <li> "Logout_Begin" - Logout - Begin, <li> "Logout_Wait_For_Other_Conn" - Logout - Wait For Other Conn, <li> "Logout_Build_and_Send_Resp" - Logout - Build and Send Resp, <li> "Logout_Waiting_StatSN_ACK" - Logout - Waiting StatSN ACK, <li> "Logout_Done" - Logout - Done, <li> "Nopout_Begin" - Nopout - Begin, <li> "Nopout_Build_And_Send_Resp" - Nopout - Build And Send Resp, <li> "Nopout_Waiting_Resp_Sockio_Comp" - Nopout - Waiting Resp Sockio Comp, <li> "Nopout_Resp_Sockio_Comp" - Nopout - Resp Sockio Comp, <li> "Nopout_Waiting_StatSN_ACK" - Nopout - Waiting StatSN ACK, <li> "Nopout_Done" - Nopout - Done, <li> "Taskmgmt_Begin" - Taskmgmt - Begin, <li> "Taskmgmt_Waiting_FFPCmds_Rcvd" - Taskmgmt - Waiting FFPCmds Rcvd, <li> "Taskmgmt_FFPCmds_Rcvd" - Taskmgmt - FFPCmds Rcvd, <li> "Taskmgmt_Waiting_FFPCmds_Complete" - Taskmgmt - Waiting FFPCmds Complete, <li> "Taskmgmt_Build_And_Send_Resp" - Taskmgmt - Build And Send Resp, <li> "Taskmgmt_Waiting_StatSN_ACK" - Taskmgmt - Waiting StatSN ACK, <li> "Taskmgmt_Done" - Taskmgmt - Done, <li> "Text_Begin" - Text - Begin, <li> "Text_Waiting_Portal_List_Notify" - Text - Waiting Portal List Notify, <li> "Text_Build_And_Send_Resp" - Text - Build And Send Resp, <li> "Text_Waiting_Resp_Sockio_Comp" - Text - Waiting Resp Sockio Comp, <li> "Text_Resp_Sockio_Comp" - Text - Resp Sockio Comp, <li> "Text_Waiting_StatSN_ACK" - Text - Waiting StatSN ACK, <li> "Text_Done" - Text - Done, <li> "Scsicdb_Begin" - Scsicdb - Begin, <li> "Scsicdb_Claim_Early_Udata" - Scsicdb - Claim Early Udata, <li> "Scsicdb_Waiting_Udata_Rcvd" - Scsicdb - Waiting Udata Rcvd, <li> "Scsicdb_Udata_Rcvd" - Scsicdb - Udata Rcvd, <li> "Scsicdb_Ready_For_STSubmit" - Scsicdb - Ready For STSubmit, <li> "Scsicdb_Udata_Not_Rcvd" - Scsicdb - Udata Not Rcvd, <li> "Scsicdb_Udata_Waiting_Task_Reassignment" - Scsicdb - Udata Waiting Task Reassignment, <li> "Scsicdb_Udata_Task_Reassigned" - Scsicdb - Udata Task Reassigned, <li> "Scsicdb_Waiting_STLayer" - Scsicdb - Waiting STLayer, <li> "Scsicdb_RD_STLayer_Called" - Scsicdb - RD STLayer Called, <li> "Scsicdb_RD_Build_And_Send_R2T" - Scsicdb - RD Build And Send R2T, <li> "Scsicdb_RD_Waiting_Burst" - Scsicdb - RD Waiting Burst, <li> "Scsicdb_RD_Burst_Rcvd" - Scsicdb - RD Burst Rcvd, <li> "Scsicdb_RD_Done" - Scsicdb - RD Done, <li> "Scsicdb_RD_Burst_Not_Rcvd" - Scsicdb - RD Burst Not Rcvd, <li> "Scsicdb_RD_Waiting_Task_Reassignment" - Scsicdb - RD Waiting Task Reassignment, <li> "Scsicdb_RD_Task_Reassigned" - Scsicdb - RD Task Reassigned, <li> "Scsicdb_SD_STLayer_Called" - Scsicdb - SD STLayer Called, <li> "Scsicdb_SD_XDI_Done" - Scsicdb - SD XDI Done, <li> "Scsicdb_SD_Waiting_DataSN_ACK" - Scsicdb - SD Waiting DataSN ACK, <li> "Scsicdb_SD_Done" - Scsicdb - SD Done, <li> "Scsicdb_SD_SNACK_Rcvd" - Scsicdb - SD SNACK Rcvd, <li> "Scsicdb_SD_Task_Reassigned" - Scsicdb - SD Task Reassigned, <li> "Scsicdb_SR_STLayer_Called" - Scsicdb - SR STLayer Called, <li> "Scsicdb_SR_Build_And_Send_Resp" - Scsicdb - SR Build And Send Resp, <li> "Scsicdb_SR_Waiting_StatSN_ACK" - Scsicdb - SR Waiting StatSN ACK, <li> "Scsicdb_SR_Done" - Scsicdb - SR Done, <li> "Scsicdb_SR_SNACK_Rcvd" - Scsicdb - SR SNACK Rcvd, <li> "Scsicdb_SR_Task_Reassigned" - Scsicdb - SR Task Reassigned, <li> "Scsicdb_SR_XDI_Done" - Scsicdb - SR XDI Done, <li> "Scsicdb_SDR_STLayer_Called" - Scsicdb - SDR STLayer Called, <li> "Scsicdb_SDR_XDI_Done" - Scsicdb - SDR XDI Done, <li> "Scsicdb_SDR_Waiting_StatSN_ACK" - Scsicdb - SDR Waiting StatSN ACK, <li> "Scsicdb_SDR_Done" - Scsicdb - SDR Done, <li> "Scsicdb_SDR_SNACK_Rcvd" - Scsicdb - SDR SNACK Rcvd, <li> "Scsicdb_SDR_Task_Reassigned" - Scsicdb - SDR Task Reassigned, <li> "Scsicdb_Abort_Begin" - Scsicdb - Abort Begin, <li> "Scsicdb_Abort_Build_And_Send_Resp" - Scsicdb - Abort Build And Send Resp, <li> "Scsicdb_Abort_Waiting_StatSN_ACK" - Scsicdb - Abort Waiting StatSN ACK, <li> "Scsicdb_Abort_Done" - Scsicdb - Abort Done, <li> "Scsicdb_Abort_SNACK_Rcvd" - Scsicdb - Abort SNACK Rcvd, <li> "Scsicdb_Abort_Task_Reassigned" - Scsicdb - Abort Task Reassigned, <li> "Scsicdb_Abort_XDI_Done" - Scsicdb - Abort XDI Done, <li> "Scsicdb_QFull_Begin" - Scsicdb - QFull Begin, <li> "Scsicdb_QFull_Build_And_Send_Resp" - Scsicdb - QFull Build And Send Resp, <li> "Scsicdb_QFull_Waiting_StatSN_ACK" - Scsicdb - QFull Waiting StatSN ACK, <li> "Scsicdb_QFull_Done" - Scsicdb - QFull Done, <li> "Scsicdb_XDI_Start" - Scsicdb - XDI Start, <li> "Scsicdb_XDI_Waiting_Data_In_Sockio_Comp" - Scsicdb - XDI Waiting Data In Sockio Comp, <li> "Scsicdb_Waiting_Scsitgt_Abort" - Scsicdb - Waiting Scsitgt Abort, <li> "Done" - Done. </ul>

=end html

=back



=over 2

=item * I<cmd-sub-id>  =>   B<integer>

=begin html

<br>Variety specific sub-id.

=end html

=back



=over 2

=item * I<cmd-type>  =>   B<string>

=begin html

<br>Type of command being executed. Possible values: <ul> <li> "Seq", <li> "ITM", <li> "Oth", <li> "UNK". </ul>

=end html

=back



=head2 iscsi-stats-info

=begin html

Statistics block

=end html



B<Fields>

=over 2

=item * I<iscsi-cdb-stats>  =>   B<L<"iscsi-cdb-stats-info">>

=begin html

<br>Statistics of Command Descriptor Blocks.

=end html

=back



=over 2

=item * I<iscsi-error-stats>  =>   B<L<"iscsi-error-stats-info">>

=begin html

<br>Statistics of errors.

=end html

=back



=over 2

=item * I<iscsi-received-stats>  =>   B<L<"iscsi-received-stats-info">>

=begin html

<br>Statistics of PDUs received.

=end html

=back



=over 2

=item * I<iscsi-transmitted-stats>  =>   B<L<"iscsi-transmitted-stats-info">>

=begin html

<br>Statistics of PDUs transmitted.

=end html

=back



=head2 iscsi-tpgroup-list-entry-info

=begin html

Information about a single portal group

=end html



B<Fields>

=over 2

=item * I<interface-list-entries>  =>   B<L<"interface-list-entry-info">[], optional>

=begin html

<br>List of interfaces associated with this tpgroup.

=end html

=back



=over 2

=item * I<tpgroup-alua-preferred>  =>   B<boolean, optional>

=begin html

<br>True if target portal group is the preferred group for ALUA enabled initiator groups, false otherwise.

=end html

=back



=over 2

=item * I<tpgroup-alua-state>  =>   B<string, optional>

=begin html

<br>Possible values: "optimized", "non-optimized".

=end html

=back



=over 2

=item * I<tpgroup-name>  =>   B<string>

=begin html

<br>Portal group name.

=end html

=back



=over 2

=item * I<tpgroup-tag>  =>   B<integer>

=begin html

<br>Portal group tag.

=end html

=back



=head2 iscsi-transmitted-stats-info

=begin html

Counts for PDUs transmitted.

=end html



B<Fields>

=over 2

=item * I<async-msg>  =>   B<integer>

=begin html

<br>Count of asynchronous iSCSI messages.

=end html

=back



=over 2

=item * I<data-in>  =>   B<integer>

=begin html

<br>Count of data in PDUs.

=end html

=back



=over 2

=item * I<login-rsp>  =>   B<integer>

=begin html

<br>Count of login responses.

=end html

=back



=over 2

=item * I<logout-rsp>  =>   B<integer>

=begin html

<br>Count of logout responses.

=end html

=back



=over 2

=item * I<nop-in>  =>   B<integer>

=begin html

<br>Count of NOP In.

=end html

=back



=over 2

=item * I<ready-to-transmit>  =>   B<integer>

=begin html

<br>Count of ready to transmit PDUs

=end html

=back



=over 2

=item * I<reject>  =>   B<integer>

=begin html

<br>Count of reject PDUs.

=end html

=back



=over 2

=item * I<scsi-rsp>  =>   B<integer>

=begin html

<br>Count of scsi responses.

=end html

=back



=over 2

=item * I<scsi-task-mgt-rsp>  =>   B<integer>

=begin html

<br>Count of scsi task management responses.

=end html

=back



=over 2

=item * I<text-rsp>  =>   B<integer>

=begin html

<br>Count of text responses.

=end html

=back



=over 2

=item * I<total>  =>   B<integer>

=begin html

<br>Total PDUs transmitted.

=end html

=back



=head2 license-info

=begin html

Information about a single licensable service.

=end html



B<Fields>

=over 2

=item * I<code>  =>   B<string, optional>

=begin html

<br>license code of the service. This information is returned only if "is-licensed" is true or "is-expired" is true. For features that are enabled automatically due to platform based business policies, the code value returned is "ENABLED". For more details see the description for the is-auto-enabled element below.

=end html

=back



=over 2

=item * I<count>  =>   B<integer>

=begin html

<br>number of times a promotional license code has been installed. 0 for non-promotional licenses.

=end html

=back



=over 2

=item * I<expiration-timestamp>  =>   B<integer, optional>

=begin html

<br>expected expiration timestamp in seconds since January 1, 1970, if it's a promotional/time-expiring license. 0 for all other licenses.

=end html

=back



=over 2

=item * I<installation-timestamp>  =>   B<integer, optional>

=begin html

<br>installation timestamp of the service license code in seconds since January 1, 1970. A value of 0 is returned if there is no installation timestamp, but there is a valid code. This is probably an error, or corruption.

=end html

=back



=over 2

=item * I<is-auto-enabled>  =>   B<boolean>

=begin html

<br>"true" if is-licensed is true because this feature was automatically enabled based on the platform type and current business packaging policies. The code element will also return "ENABLED". In all other cases this will return false.

=end html

=back



=over 2

=item * I<is-demo>  =>   B<boolean>

=begin html

<br>"true" if the license is a promotional/time-expiring/demo license, "false" otherwise.

=end html

=back



=over 2

=item * I<is-expired>  =>   B<boolean>

=begin html

<br>"true" if the promotional/time-expiring/demo license has expired, "false" otherwise.

=end html

=back



=over 2

=item * I<is-licensed>  =>   B<boolean>

=begin html

<br>"true" if the service is licensed and has not expired, "false" otherwise.

=end html

=back



=over 2

=item * I<is-site>  =>   B<boolean>

=begin html

<br>"true" if the license is a site license, "false" otherwise.

=end html

=back



=over 2

=item * I<length>  =>   B<integer, optional>

=begin html

<br>length of the promotional/time-expiring license in days. 0 for non-promotional licenses.

=end html

=back



=over 2

=item * I<node-count>  =>   B<integer, optional>

=begin html

<br>number of nodes for which the license is valid.

=end html

=back



=over 2

=item * I<package-list>  =>   B<package-master[], optional>

=begin html

<br>List of package master feature names for the the packages to which this feature belongs. Returned if this feature is a member of at least one package on the current platform.

=end html

=back



=over 2

=item * I<platform>  =>   B<string, optional>

=begin html

<br>indicates the type of the platform for which the license is valid. Possible values are : filer and netcache, gateway, nearstore, and simulator.

=end html

=back



=over 2

=item * I<service>  =>   B<string>

=begin html

<br>name of the service.

=end html

=back



=over 2

=item * I<storage-count>  =>   B<integer, optional>

=begin html

<br>number of terabytes allowed if it's a Gateway platform ("gateway_storage") license.

=end html

=back



=head2 package-master

=begin html

The license name of the feature that is considered to be the master of the package.

=end html



B<Fields>

=over 2

=item * None

=back



=head2 license-code-v2

=begin html

License Code version 2

=end html



B<Fields>

=over 2

=item * None

=back



=head2 license-v2-info

=begin html

Information about a licensable package. When returned as part of the output, all elements of this typedef are reported, unless limited by a set of desired attributes specified by the caller. <p> When used as input to specify desired attributes to return, omitting a given element indicates that it shall not be returned in the output. In contrast, by providing an element (even with no value) the caller ensures that a value for that element will be returned, given that the value can be retrieved. <p> When used as input to specify queries, any element can be omitted in which case the resulting set of objects is not constrained by any specific value of that attribute.

=end html



B<Fields>

=over 2

=item * I<customer-id>  =>   B<string, optional>

=begin html

<br>Customer Identification. This field is used to track site licenses issued to Enterprise Level Agreement customers. It will typical be set to "none" unless a unique customer id has been assigned. This value is reported in Auto Support, and can be used to correlate licensing information with backend business systems for tracking purposes. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<description>  =>   B<string, optional>

=begin html

<br>Description of the licensed package. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<expiration-time>  =>   B<datetime, optional>

=begin html

<br>License expiration time. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<grace-period-expiration>  =>   B<datetime, optional>

=begin html

<br>The grace period expiration date/time. This is only provided if is-in-grace-period is returned. If is-in-grace-period is true, then this is the expiration date/time of the grace period. If is-in-grace-period is false then this value will be 0. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<is-in-grace-period>  =>   B<boolean, optional>

=begin html

<br>The system serial number grace period. Returns true if a system serial number change was detected and the system is currently in the grace period. During this grace period serial number checking for currently installed licenses will be ignored. The serial-number element for various package licenses may differ while valid licenses are being installed. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<legacy>  =>   B<boolean, optional>

=begin html

<br>Legacy License. A legacy license indicates that the license was previously installed prior to this release. Returns true if the license was installed prior to this release and false otherwise.

=end html

=back



=over 2

=item * I<owner>  =>   B<string, optional>

=begin html

<br>Controller or Cluster that owns the serial number. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<package>  =>   B<licensed-package, optional>

=begin html

<br>Name of the licensed package. Attributes: key, required-for-create, non-modifiable Possible values: <ul> <li> "base" - Cluster Base License, <li> "nfs" - NFS License, <li> "cifs" - CIFS License, <li> "iscsi" - iSCSI License, <li> "fcp" - FCP License, <li> "cdmi" - CDMI License, <li> "snaprestore" - SnapRestore License, <li> "snapmirror" - SnapMirror License, <li> "flexclone" - FlexClone License, <li> "snapvault" - SnapVault License, <li> "snaplock" - SnapLock License, <li> "snapmanagersuite" - SnapManagerSuite License, <li> "snapprotectapps" - SnapProtectApp License, <li> "v_storageattach" - Virtual Attached Storage License </ul>

=end html

=back



=over 2

=item * I<serial-number>  =>   B<node-serial-number, optional>

=begin html

<br>Serial number of the controller or cluster. The license serial-number is reported in Auto Support also and can be used to correlate controller or cluster wide licensing information. Attributes: key, required-for-create, non-modifiable

=end html

=back



=over 2

=item * I<type>  =>   B<license-v2-type, optional>

=begin html

<br>License type. Attributes: non-creatable, non-modifiable Possible values: <ul> <li> "license" , <li> "site" , <li> "demo" </ul>

=end html

=back



=head2 license-v2-op-status

=begin html

License Operation Status Possible values: <ul> <li> "license_success" - Operation Completed Successfully, <li> "license_invalid" - Failed: Invalid License Key, <li> "license_expired" - Failed: License Expired, <li> "license_notallowed" - Failed: Operation Not Allowed, <li> "license_unavailable" - Failed: License NOT Available, <li> "license_internal" - Failed: Internal Error, <li> "license_err_unknown" - Failed: Unknown Error </ul>

=end html



B<Fields>

=over 2

=item * None

=back



=head2 license-v2-result

=begin html

License operation result When returned as part of the output, all elements of this typedef are reported, unless limited by a set of desired attributes specified by the caller. <p> When used as input to specify desired attributes to return, omitting a given element indicates that it shall not be returned in the output. In contrast, by providing an element (even with no value) the caller ensures that a value for that element will be returned, given that the value can be retrieved. <p> When used as input to specify queries, any element can be omitted in which case the resulting set of objects is not constrained by any specific value of that attribute.

=end html



B<Fields>

=over 2

=item * I<description>  =>   B<string, optional>

=begin html

<br>Additional information of the failure. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<entry>  =>   B<license-code-v2, optional>

=begin html

<br>Failed license entry. Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<errcode>  =>   B<license-v2-op-status, optional>

=begin html

<br>Failure error code. Attributes: non-creatable, non-modifiable

=end html

=back



=head2 license-v2-type

=begin html

This field indicates the type of a license. A typical license will be of "license" type, which indicates that it's associated with a specific controller. A "site" license is a special license provided under Enterprise Level Agreements. A "demo" license is a temporary license with an expiration time. It is usually issued for trial purposes only. Possible values: <ul> <li> "license" , <li> "site" , <li> "demo" </ul>

=end html



B<Fields>

=over 2

=item * None

=back



=head2 licensed-package

=begin html

Licensable Package Possible values: <ul> <li> "base" - Cluster Base License, <li> "nfs" - NFS License, <li> "cifs" - CIFS License, <li> "iscsi" - iSCSI License, <li> "fcp" - FCP License, <li> "cdmi" - CDMI License, <li> "snaprestore" - SnapRestore License, <li> "snapmirror" - SnapMirror License, <li> "flexclone" - FlexClone License, <li> "snapvault" - SnapVault License, <li> "snaplock" - SnapLock License, <li> "snapmanagersuite" - SnapManagerSuite License, <li> "snapprotectapps" - SnapProtectApp License, <li> "v_storageattach" - Virtual Attached Storage License </ul>

=end html



B<Fields>

=over 2

=item * None

=back



=head2 node-serial-number

=begin html

Assigned Node serial-number

=end html



B<Fields>

=over 2

=item * None

=back



=head2 break-error

=begin html

Information about a single error encountered by specific protocol(s).

=end html



B<Fields>

=over 2

=item * I<err>  =>   B<string>

=begin html

<br>The error string.

=end html

=back



=head2 cifs-lock

=begin html

Information about a single CIFS lock.

=end html



B<Fields>

=over 2

=item * I<absolute-path>  =>   B<string, optional>

=begin html

<br>Name of the absolute ("/vol/volX" style) path corresponding to the CIFS path present in the ONTAPI output element, <b>path</b>. <br> NOTE: In certain cases, the absolute path is unavailable (e.g., due to insufficient memory or if the lock is a Delete-on-close lock.)

=end html

=back



=over 2

=item * I<bytelock-length>  =>   B<integer, optional>

=begin html

<br>Number of bytes (from bytelock-offset) that are locked.

=end html

=back



=over 2

=item * I<bytelock-offset>  =>   B<integer, optional>

=begin html

<br>Starting offset in file that gets bytelocked.

=end html

=back



=over 2

=item * I<dh-state>  =>   B<string, optional>

=begin html

<br>Durable state of the lock, which can be "DH_GRANTED" (durability granted), "DH_ACTIVE" (lock is currently durable), "DH_PURGED" (lock has been purged), or "DH_NONE" (durability is not granted). For lease locks, dh-state is unavailable.

=end html

=back



=over 2

=item * I<fileid>  =>   B<integer, optional>

=begin html

<br>A unique number (withing filesystem) identifying the file associated with the lock.

=end html

=back



=over 2

=item * I<fsid>  =>   B<integer, optional>

=begin html

<br>Filesystem ID.

=end html

=back



=over 2

=item * I<host-ip>  =>   B<ip-address>

=begin html

<br>IP address, in dotted-decimal format, of the CIFS client.

=end html

=back



=over 2

=item * I<host-name>  =>   B<string, optional>

=begin html

<br>NetBios name of the CIFS client. This may be unavailable in certain situations. In such cases, the ONTAPI element 'host-ip' alone provides identity of the host.

=end html

=back



=over 2

=item * I<is-bytelock-exclusive>  =>   B<boolean, optional>

=begin html

<br>Is true for exclusive bytelock, else false.

=end html

=back



=over 2

=item * I<lock-error>  =>   B<string, optional>

=begin html

<br>Error messages issued, e.g., low system memory or if the input syntax is not applicable to this protocol (but maybe applicable to other protocols), or else if this protocol is specified by the "protocol" input but the syntax of host, owner, or file parameters is wrong.<br> NOTE: New error messages may be added in the future.

=end html

=back



=over 2

=item * I<mode>  =>   B<string, optional>

=begin html

<br>File access mode that can be one of the following:<br> DelOnClose: Delete-on-close lock<br> DelOnCloseWait: Waiting Delete-on-close lock<br> SuperLock: Super lock, eg, used by antivirus scanner<br> Oplock-Excl: Exclusive Oplock<br> Oplock-Lvl2: Level-II Oplock<br> or a string of form "AccessMode-ShareMode" with:<br> AccessMode: RdWr(Read-Write), Read(Read-only) Writ(Write), None(No access)<br> ShareMode: denyA(deny all), denyR(deny Read access) denyW(deny Write access), denyN(deny none)

=end html

=back



=over 2

=item * I<oplock-level>  =>   B<string, optional>

=begin html

<br>Oplock level (for non-Delete-on-close lock), which is "Excl" (Exclusive Oplock), "lvl2" (Level-II Oplock), "RWH" (Read-Write-Handle Lease), "RW" (Read-Write Lease), "RH" (Read-Handle Lease), "R" (Read Lease), or "None" (No oplock).

=end html

=back



=over 2

=item * I<owner>  =>   B<string, optional>

=begin html

<br>Name of the lock owner: a username prefixed by an optional domain (and a backslash) for CIFS protocol ([domain\]username).

=end html

=back



=over 2

=item * I<path>  =>   B<string, optional>

=begin html

<br>Name of the path for a file or directory or NT stream.<br> NOTE: In certain cases, the path is unavailable (e.g., due to insufficient memory)

=end html

=back



=over 2

=item * I<pid>  =>   B<integer, optional>

=begin html

<br>Process-ID of SMB client holding the lock.

=end html

=back



=over 2

=item * I<state>  =>   B<string>

=begin html

<br>State of the lock, being one of:<br> GRANTED: The lock is granted and is not being revoked. Locks in this state are on the share-grant or byte-grant lists, depending on the lock type. <br> REVOKING: The lock has just begun revocation. Locks in this state are also on share-grant or byte-grant lists, depending on the lock type. <br> REVOKED: The lock is undergoing revocation and the protocol has marked it to be released. This is a transient state whereby the protocol indicates the results of lock revocation to the generic lock manager code. Locks in this state are on the share-grant or byte-grants lists, but are removed immediately.<br> GWAITING: The lock is waiting to be granted. Locks in this state are on the share-wait list or one of the wait lists associated with a granted byte lock. Locks enter this state when they can't be granted because of a conflict and the lock parameters indicate that the caller is prepared to wait.<br> EWAITING: The lock is waiting either to be granted or denied. Locks in this state are on the share-wait list or one of the wait lists associated with a granted byte lock. Locks enter this state when they can't be granted because of a conflict with a soft lock and lock parameters indicate they the caller is not prepared to wait. Generally, in this situation, the protocol is prepared to wait for a limited time to allow the revocation to be resolved so that it can be determined whether the lock is to be granted or denied. <br> ADJUSTED: The lock is undergoing revocation and the protocol has marked it to be replaced by a hard lock which is equal to it or weaker. This is a transient state whereby the protocol indicates the results of lock revocation to the generic lock manager code. Locks in this state are on the share-grant or byte-grant lists, but are transitioned back to the granted state once the changes in the lock have been dealt with.<br> DENIED: The lock has been denied. This is a temporary state used to mark locks that have, after waiting, been denied. This is so that when the lock state is noticed by a WAFL operation, appropriate information about the state of the request, including the denial status, will be available. Locks in this state are not in any of the per-file lists.<br> TIMEDOUT: The wait for the lock has timed out. This is a temporary state used to mark locks that have, after waiting, had the wait timed out. This is so that when the lock state is noticed by a WAFL operation, appropriate information about the state of the request, including the fact that it could not be granted due to a timeout, will be available. Locks in this state are not in any of the per-file lists. <br> SUBSUMED: Kept in reserve by protocol while protected by an encompassing soft lock. This is a transient state used for locks which are one of a set of locks that will take the place of a lock being revoked. Locks in this state are in an internal list and not in any of the per-file lists. They are converted to the GRANTED state and put in the share-grant list as part of completing the revocation operation .<br> GONE: About to be returned. This is a temporary state for lock objects that are to be freed as soon as any potential references to them are gone. Locks in this state are not on any of the per-file lists .<br> UNUSED: The lock was just allocated. This is a temporary state for lock objects that have been allocated but have not yet been dealt with (i.e. granted, denied, set up to wait). Locks in this state are not on any of the per-file lists.<br> <br> NOTE: Future releases may have new lock states.

=end html

=back



=over 2

=item * I<type>  =>   B<string, optional>

=begin html

<br>Type of lock, either "share-level" or "byte-range".<br> NOTE: Future releases might have new values.

=end html

=back



=head2 lock-status-info

=begin html

Information about a single lock.

=end html



B<Fields>

=over 2

=item * I<cifs-lock>  =>   B<L<"cifs-lock">, optional>

=begin html

<br>Information about CIFS lock.

=end html

=back



=over 2

=item * I<nfsv4-lock>  =>   B<L<"nfsv4-lock">, optional>

=begin html

<br>Information about NFSv4 lock.

=end html

=back



=over 2

=item * I<nlm-lock>  =>   B<L<"nlm-lock">, optional>

=begin html

<br>Information about NLM(Nfsv2/Nfsv3) lock.

=end html

=back



=over 2

=item * I<pfs-lock>  =>   B<L<"pfs-lock">, optional>

=begin html

<br>Information about PFS locks

=end html

=back



=head2 nfsv4-lock

=begin html

Information about a single NFSv4 lock.

=end html



B<Fields>

=over 2

=item * I<bytelock-length>  =>   B<integer, optional>

=begin html

<br>Number of bytes (from bytelock-offset) that are locked.

=end html

=back



=over 2

=item * I<bytelock-offset>  =>   B<integer, optional>

=begin html

<br>Starting offset in file that gets bytelocked.

=end html

=back



=over 2

=item * I<fileid>  =>   B<integer, optional>

=begin html

<br>A unique number (withing filesystem) identifying the file associated with the lock.

=end html

=back



=over 2

=item * I<fsid>  =>   B<integer, optional>

=begin html

<br>Filesystem ID.

=end html

=back



=over 2

=item * I<host-ip>  =>   B<ip-address, optional>

=begin html

<br>IP address, in dotted-decimal format, of the NFSv4 host.

=end html

=back



=over 2

=item * I<is-bytelock-exclusive>  =>   B<boolean, optional>

=begin html

<br>Is true for exclusive bytelock, else false.

=end html

=back



=over 2

=item * I<lock-error>  =>   B<string, optional>

=begin html

<br>Error messages issued, e.g., if the input syntax is not applicable to this protocol (but maybe applicable to other protocols), or else if this protocol is specified by the "protocol" input but the syntax of host, owner, or file is wrong.

=end html

=back



=over 2

=item * I<mode>  =>   B<string, optional>

=begin html

<br>File access mode that can be one of the following:<br> Deleg-Read: Read delegation<br> Deleg-Wrt: Write delegation<br> or a string of form "AccessMode-ShareMode" with: AccessMode: RdWr(Read-Write), Read(Read-only) Writ(Write), None(No access)<br> ShareMode: denyA(deny all), denyR(deny Read access) denyW(deny Write access), denyN(deny none)

=end html

=back



=over 2

=item * I<owner>  =>   B<string, optional>

=begin html

<br>Name of the owner.

=end html

=back



=over 2

=item * I<path>  =>   B<string, optional>

=begin html

<br>Name of the path for a file or directory.

=end html

=back



=over 2

=item * I<pid>  =>   B<integer, optional>

=begin html

<br>Process-ID of NFSv4 client.

=end html

=back



=over 2

=item * I<state>  =>   B<string>

=begin html

<br>State of the lock. See cifs-lock for description of all state values.<br> NOTE: Future releases may have new lock states.

=end html

=back



=over 2

=item * I<state-index-table>  =>   B<integer, optional>

=begin html

<br>This is an index into a state table that contains entire NFSv4 state information of the filer.

=end html

=back



=over 2

=item * I<type>  =>   B<string, optional>

=begin html

<br>Type of lock, either "share-level" or "byte-range".<br> NOTE: Future releases might have new values.

=end html

=back



=head2 nlm-lock

=begin html

Information about a single NLM(Nfsv2/Nfsv3) lock.

=end html



B<Fields>

=over 2

=item * I<bytelock-length>  =>   B<integer, optional>

=begin html

<br>Number of bytes (from bytelock-offset) that are locked.

=end html

=back



=over 2

=item * I<bytelock-offset>  =>   B<integer, optional>

=begin html

<br>Starting offset in file that gets bytelocked.

=end html

=back



=over 2

=item * I<fileid>  =>   B<integer, optional>

=begin html

<br>A unique number (withing filesystem) identifying the file associated with the lock.

=end html

=back



=over 2

=item * I<fsid>  =>   B<integer, optional>

=begin html

<br>Filesystem ID.

=end html

=back



=over 2

=item * I<host>  =>   B<string, optional>

=begin html

<br>IP address (in dotted decimal format) or a fully qualified domain name.

=end html

=back



=over 2

=item * I<is-bytelock-exclusive>  =>   B<boolean, optional>

=begin html

<br>Is true for exclusive bytelock, else false.

=end html

=back



=over 2

=item * I<last-hop-caching-filer>  =>   B<string, optional>

=begin html

<br>Name of the last-hop downstream caching filer used to obtain this lock. Note that this filer is not the actual lock owner.

=end html

=back



=over 2

=item * I<lock-error>  =>   B<string, optional>

=begin html

<br>Error messages issued, e.g., if the input syntax is not applicable to this protocol (but maybe applicable to other protocols), or else if this protocol is specified by the "protocol" input but the syntax of host, owner, or file parameters is wrong.

=end html

=back



=over 2

=item * I<mode>  =>   B<string, optional>

=begin html

<br>File access mode of form "AccessMode-denyN" with:<br> Access mode: RdWr(Read-Write), Read(Read-only) Writ(Write), None(No access)

=end html

=back



=over 2

=item * I<owner>  =>   B<integer, optional>

=begin html

<br>Name of the owner.

=end html

=back



=over 2

=item * I<path>  =>   B<string, optional>

=begin html

<br>Name of the path for a file or directory.

=end html

=back



=over 2

=item * I<state>  =>   B<string>

=begin html

<br>State of the lock. See cifs-lock for description of all state values.<br> NOTE: Future releases may have new lock states.

=end html

=back



=over 2

=item * I<type>  =>   B<string, optional>

=begin html

<br>Type of lock, either "share-level" or "byte-range".<br> NOTE: Future releases might have new values.

=end html

=back



=head2 pfs-lock

=begin html

Information about a single PFS lock.

=end html



B<Fields>

=over 2

=item * I<fileid>  =>   B<integer, optional>

=begin html

<br>A unique number (withing filesystem) identifying the file, associated with the lock, on the origin filer.

=end html

=back



=over 2

=item * I<fsid>  =>   B<integer, optional>

=begin html

<br>Filesystem ID of the filesystem on the origin filier holding the PFS lock.

=end html

=back



=over 2

=item * I<host-ip>  =>   B<ip-address, optional>

=begin html

<br>IP address, in dotted-decimal format, of the PFS host.

=end html

=back



=over 2

=item * I<host-name>  =>   B<string, optional>

=begin html

<br>Fully qualified domain name of PFS host holding the lock.

=end html

=back



=over 2

=item * I<lock-error>  =>   B<string, optional>

=begin html

<br>Error messages issued, e.g., if the input syntax is not applicable to this protocol (but maybe applicable to other protocols), or else if this protocol is specified by the "protocol" input but the syntax of host, owner, or file parameters is wrong.

=end html

=back



=over 2

=item * I<mode>  =>   B<string, optional>

=begin html

<br>File access mode that can be one of the following:<br> Deleg-PfsRead: Read delegation<br> or a string of form "AccessMode-ShareMode" with:<br> AccessMode: RdWr(Read-Write), Read(Read-only) Writ(Write), None(No access)<br> ShareMode: denyA(deny all), denyR(deny Read access) denyW(deny Write access), denyN(deny none)

=end html

=back



=over 2

=item * I<owner>  =>   B<string, optional>

=begin html

<br>Name of the lock owner: IP address (of the caching filer holding the PFS lock), suffixed by a colon, and filesystem ID (of the caching filesystem holding the PFS lock). Syntax is: "IP:fsid".

=end html

=back



=over 2

=item * I<path>  =>   B<string, optional>

=begin html

<br>Name of the path for a file or directory.

=end html

=back



=over 2

=item * I<state>  =>   B<string>

=begin html

<br>State of the lock. See cifs-lock for description of all state values.<br> NOTE: Future releases may have new lock states.

=end html

=back



=over 2

=item * I<type>  =>   B<string, optional>

=begin html

<br>Type of lock, which can only be "share-level".<br> NOTE: Future releases might have new values.

=end html

=back



=head2 alua-setting-mismatch-initiator-group

=begin html

Information about an initiator group that has an ALUA (Asymmetric Logical Unit Access) setting mismatch on local and partner filers.

=end html



B<Fields>

=over 2

=item * I<initiator-group-name>  =>   B<string>

=begin html

<br>name of the initiator group.

=end html

=back



=over 2

=item * I<local-alua-is-enabled>  =>   B<boolean>

=begin html

<br>true if ALUA (Asymmetric Logical Unit Access) is enabled for initiator-group-name on the local filer.

=end html

=back



=over 2

=item * I<partner-alua-is-enabled>  =>   B<boolean>

=begin html

<br>true if ALUA (Asymmetric Logical Unit Access) is enabled for initiator-group-name

=end html

=back



=head2 alua-setting-mismatch-initiator-info

=begin html

Information about an initiator that is a member of igroups that have an alua setting mismatch. Also detectes partner alua mismatch issues.

=end html



B<Fields>

=over 2

=item * I<alua-is-enabled>  =>   B<boolean>

=begin html

<br>true if ALUA (Asymmetric Logical Unit Access) is enabled for initiator-group-name.

=end html

=back



=over 2

=item * I<initiator-group-name>  =>   B<string>

=begin html

<br>name of the initiator group name that the initiator belongs to.

=end html

=back



=over 2

=item * I<initiator-name>  =>   B<string>

=begin html

<br>name of the initiator.

=end html

=back



=head2 clone-status-info

=begin html

Status of a cloning.

=end html



B<Fields>

=over 2

=item * I<blocks-completed>  =>   B<integer>

=begin html

<br>Number of blocks completed.

=end html

=back



=over 2

=item * I<blocks-total>  =>   B<integer>

=begin html

<br>Total blocks to clone. The percentage complete is (completed * 100) / total

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>LUN path being cloned.

=end html

=back



=head2 conflict-wwpn

=begin html

WWPN that has the conflict.

=end html



B<Fields>

=over 2

=item * None

=back



=head2 conflicting-initiator-info

=begin html

Fibre channel initiator that belongs to igroups on the local filer which have a different OS type than the initiator groups that this initiator belongs to on the partner filer. This conflict can produce unexpected host behavior and must be fixed.

=end html



B<Fields>

=over 2

=item * I<initiator-local-os-type>  =>   B<initiator-group-os-type>

=begin html

<br>OS type of the initiator on the local filer

=end html

=back



=over 2

=item * I<initiator-name>  =>   B<string>

=begin html

<br>Fibre channel initiator nodename that has a different OS type on the local filer than the partner filer.

=end html

=back



=over 2

=item * I<initiator-partner-os-type>  =>   B<initiator-group-os-type>

=begin html

<br>OS type of the initiator on the partner filer

=end html

=back



=head2 conflicting-luns-list

=begin html

List of the conflicting luns.

=end html



B<Fields>

=over 2

=item * I<conflict-lun-path>  =>   B<string>

=begin html

<br>Path of the lun that has the conflict. The format is: /vol/<volume>/<lun> or /vol/<volume>/<qtree>/<lun>

=end html

=back



=head2 conflicting-map-info

=begin html

lun mapping conflict.

=end html



B<Fields>

=over 2

=item * I<initiator-name>  =>   B<string>

=begin html

<br>Fibre channel initiator nodename that has a lun mapped from both filers in the cluster using the same LUN-id.

=end html

=back



=over 2

=item * I<lun-id>  =>   B<integer>

=begin html

<br>lun-id used in mappings to the initiator from both filers in the cluster.

=end html

=back



=head2 fcp-down-hba-info

=begin html

Information about a down FCP HBA

=end html



B<Fields>

=over 2

=item * I<adapter>  =>   B<string>

=begin html

<br>Which FC adapter.

=end html

=back



=over 2

=item * I<state>  =>   B<string>

=begin html

<br>Description of HBAs state. Possible values: STARTUP UNINITIALIZED INITIALIZING FIRMWARE LINK NOT CONNECTED WAITING FOR LINK UP ONLINE LINK DISCONNECTED RESETTING OFFLINE OFFLINED BY USER/SYSTEM Unknown state

=end html

=back



=head2 fcp-pr-nexus

=begin html

Information about fcp nexus owning the persistent reservation These two componients identify the relationship between the FCP initiator and the target.

=end html



B<Fields>

=over 2

=item * I<initiator-port>  =>   B<string>

=begin html

<br>FCP initiator port part of I_T_Nexus owning the persistent reservation key.

=end html

=back



=over 2

=item * I<target-port>  =>   B<string, optional>

=begin html

<br>FCP target port part of I_T_Nexus owning the persistent reservation key.

=end html

=back



=head2 invalid-cfmode-setting-info

=begin html

local and partner cfmode settings

=end html



B<Fields>

=over 2

=item * I<local-fcp-cfmode>  =>   B<string>

=begin html

<br>cfmode setting of the local filer Possible values: dual_fabric, mixed, partner, standby, single_image

=end html

=back



=over 2

=item * I<partner-fcp-cfmode>  =>   B<string>

=begin html

<br>cfmode setting of the partner filer Possible values: dual_fabric, mixed, partner, standby, single_image

=end html

=back



=head2 invalid-nodename-setting-info

=begin html

Information about different fcp nodenames

=end html



B<Fields>

=over 2

=item * I<local-fcp-node-name>  =>   B<string>

=begin html

<br>fcp nodename for the local filer

=end html

=back



=over 2

=item * I<partner-fcp-node-name>  =>   B<string>

=begin html

<br>fcp nodename for the partner filer

=end html

=back



=head2 invalid-ostype-cfmode-setting-info

=begin html

Information about an invalid initiator group ostype and cfmode combination

=end html



B<Fields>

=over 2

=item * I<initiator-group-name>  =>   B<string>

=begin html

<br>Name of this initiator group.

=end html

=back



=over 2

=item * I<initiator-group-os-type>  =>   B<initiator-group-os-type>

=begin html

<br>OS type of the initiator group

=end html

=back



=head2 invalid-use-partner-cfmode-setting-info

=begin html

Information about an invalid initiator group use_partner and cfmode

=end html



B<Fields>

=over 2

=item * I<initiator-group-name>  =>   B<string>

=begin html

<br>Name of this initiator group.

=end html

=back



=over 2

=item * I<is-use-partner-enabled>  =>   B<boolean>

=begin html

<br>If true this initiator group's members are allowed to use the partner port.

=end html

=back



=head2 invalid-use-partner-ostype-setting-info

=begin html

Information about an invalid initiator group ostype and use_partner combination

=end html



B<Fields>

=over 2

=item * I<initiator-group-name>  =>   B<string>

=begin html

<br>Name of this initiator group.

=end html

=back



=over 2

=item * I<initiator-group-os-type>  =>   B<initiator-group-os-type>

=begin html

<br>OS type of the initiator group

=end html

=back



=over 2

=item * I<is-use-partner-enabled>  =>   B<boolean>

=begin html

<br>If true this initiator group's members are allowed to use the partner port.

=end html

=back



=head2 invalid-vsa-setting-info

=begin html

Information about an initiator group with an invalid Volume Set Addressing (VSA) setting for its ostype. Only 'hpux' initiator groups should have VSA enabled. All other initiator groups should have it disabled. Incorrect settings can cause hosts to not be able to access some or all of their luns.

=end html



B<Fields>

=over 2

=item * I<initiator-group-name>  =>   B<string>

=begin html

<br>Name of this initiator group.

=end html

=back



=over 2

=item * I<initiator-group-os-type>  =>   B<initiator-group-os-type>

=begin html

<br>OS type of the initiator group

=end html

=back



=over 2

=item * I<is-vsa-enabled>  =>   B<boolean>

=begin html

<br>If true this initiator groups's member will use VSA on the filer

=end html

=back



=head2 iscsi-pr-nexus

=begin html

Information about iscsi nexus owning the persistent reservation These three componients identify the relationship between the iSCSI initiator and the target.

=end html



B<Fields>

=over 2

=item * I<initiator>  =>   B<string>

=begin html

<br>Name of initiator holding the reservation i.e. iqn.1987-06.com.initvendor1:appsrv.sn.2346.

=end html

=back



=over 2

=item * I<isid>  =>   B<string>

=begin html

<br>The Initiator Session ID for the persistent reservation owner. The ISID is a numeric Initiator Session ID assigned by the initiator which acts as part of the initiators identity.

=end html

=back



=over 2

=item * I<tpgtag>  =>   B<string, optional>

=begin html

<br>The target portal group tag of the persistent reservation owner. For historical reasons, the value is represented as a 4-byte hexadecimal number in little-endian byte order.

=end html

=back



=head2 lun-clone-lists-info

=begin html

Details of the LUN clone in the specified snapshot.

=end html



B<Fields>

=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN clone.

=end html

=back



=head2 lun-info

=begin html

Information of a LUN.

=end html



B<Fields>

=over 2

=item * I<alignment>  =>   B<string, optional>

=begin html

<br>Alignment of the LUN. Possible values: "aligned", "misaligned", "partial_writes" or "indeterminate".

=end html

=back



=over 2

=item * I<backing-snapshot>  =>   B<string, optional>

=begin html

<br>Path to the backing snapshot file for a LUN, if there is one. Only returned if it has one. Note: This element is not returned for LUNs which are in snapshots.

=end html

=back



=over 2

=item * I<block-size>  =>   B<integer, optional>

=begin html

<br>Disk block size of the LUN in bytes. This field is unavailable while the LUN is fenced for a restore operation.

=end html

=back



=over 2

=item * I<clone-backing-snapshot>  =>   B<string>

=begin html

<br>null

=end html

=back



=over 2

=item * I<device-id>  =>   B<integer, optional>

=begin html

<br>SCSI Peripheral Device Identifying Information returned in response to the vendor unique SCSI command GET DEV ID. Only present if a Peripheral Device Identifying Information value appropriate for GET DEV ID has been set on the LUN.

=end html

=back



=over 2

=item * I<is-space-reservation-enabled>  =>   B<boolean, optional>

=begin html

<br>Whether or not the LUN has space reservation enabled. This field is unavailable when the LUN is in a snapshot or while fenced for a restore operation

=end html

=back



=over 2

=item * I<mapped>  =>   B<boolean, optional>

=begin html

<br>Whether or not the LUN is mapped to any initiators. "true" if mapped, "false" otherwise. This field is not applicable to LUNs where the class attribute is set to 'vvol'.

=end html

=back



=over 2

=item * I<multiprotocol-type>  =>   B<lun-os-type, optional>

=begin html

<br>OS type of the LUN This field is unavailable while the LUN is fenced for a restore operation.

=end html

=back



=over 2

=item * I<online>  =>   B<boolean>

=begin html

<br>State of the LUN, ("online" or "offline"). "true" if online, "false" otherwise.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN.

=end html

=back



=over 2

=item * I<prefix-size>  =>   B<integer, optional>

=begin html

<br>Size of the prefix stream for this LUN in bytes. This is either the default value for the OS type of the LUN or value specified in lun-create-by-size API. This field is unavailable while the LUN is fenced for a restore operation. This field is available in Data ONTAP 8.1 and later.

=end html

=back



=over 2

=item * I<read-only>  =>   B<boolean, optional>

=begin html

<br>"true" if the LUN is read only, "false" if read/write. This field is unavailable while the LUN is fenced for a restore operation.

=end html

=back



=over 2

=item * I<serial-number>  =>   B<string, optional>

=begin html

<br>Serial number of the LUN. Prior to Data ONTAP 8.1 release, the serial number is a 12-character string formed of upper and lower-case letters, numbers, and slash (/) and hyphen (-) characters. Starting Data ONTAP 8.1 release, the serial number is a 12-character string formed of upper and lower-case letters, numbers, and the characters /-#$%&*+<=>?[!]^~@ . This field is unavailable when the LUN is in a snapshot.

=end html

=back



=over 2

=item * I<share-state>  =>   B<string>

=begin html

<br>Share state of the LUN. Possible values: "all", "none", read", "unkown", "write". In the very rare case that the share state can not be determined, "unknown" is returned.

=end html

=back



=over 2

=item * I<size>  =>   B<integer, optional>

=begin html

<br>Size of this LUN in bytes in the active FS. This field is unavailable while the LUN is fenced for a restore operation.

=end html

=back



=over 2

=item * I<size-used>  =>   B<integer, optional>

=begin html

<br>Number of bytes used by this LUN. This field is unavailable while the LUN is fenced for a restore operation.

=end html

=back



=over 2

=item * I<staging>  =>   B<boolean>

=begin html

<br>"true" if the LUN is a temporary staging LUN, "false" otherwise.

=end html

=back



=over 2

=item * I<suffix-size>  =>   B<integer, optional>

=begin html

<br>Size of the suffix stream for this LUN in bytes. This value is determined by the OS type of the LUN at creation time. This field is unavailable while the LUN is fenced for a restore operation. This field is available in Data ONTAP 8.1 and later.

=end html

=back



=over 2

=item * I<uuid>  =>   B<string, optional>

=begin html

<br>Universal unique identifier (UUID) for the LUN. This field is unavailable when the LUN is in a snapshot.

=end html

=back



=head2 lun-map-info

=begin html

Information about a lun mapping

=end html



B<Fields>

=over 2

=item * I<initiator-group>  =>   B<string>

=begin html

<br>Initiator group used to map the lun to the requested initiator.

=end html

=back



=over 2

=item * I<lun-id>  =>   B<integer>

=begin html

<br>Logical Unit Number which the lun is mapped to for the requested initiator.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN which is mapped to the requested initiator.

=end html

=back



=head2 lun-os-type

=begin html

The image type of the lun. This value determines the proper alignment settings for the desired host filesystem layout. Possible values: <ul> <li> "aix" The LUN will be used to store an AIX filesystem, <li> "hpux" The LUN will be used to store an HP-UX filesystem, <li> "hyper_v" The LUN will be used to store Hyper-V VHDs (Virtual Hard Disks), <li> "image" The default type indicating no assumptions will be made about the data stored in the LUN, <li> "linux" The LUN will be used to store a Linux filesystem with no partition table, <li> "netware" The LUN will be used to store a Netware filesystem, <li> "openvms" The LUN will be used to store an OpenVMS filesystem, <li> "solaris" The LUN will be used to store a Solaris filesystem, in a single slice partition, <li> "solaris_efi" The LUN will be used to store a Solaris filesystem with an EFI partition table, <li> "vmware" The LUN will be used to store a VMware Virtual Machine File System (VMFS) containing Virtual Machine Disk Files (VMDKs), <li> "windows" The LUN will be used to store a Windows filesystem with a Master Boot Record (MBR) partition table. <li> "windows_2008" The LUN will be used to store a Windows filesystem with a Master Boot Record (MBR) partition table on Windows 2008 or later, <li> "windows_gpt" The LUN will be used to store a Windows filesystem with a GUID Partition Table (GPT). </ul>

=end html



B<Fields>

=over 2

=item * None

=back



=head2 lun-snap-usage-lun-info

=begin html

Details of the LUN backed by specified snapshot.

=end html



B<Fields>

=over 2

=item * I<backing-store>  =>   B<string>

=begin html

<br>Path of the LUN serving as the backing store.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the LUN.

=end html

=back



=over 2

=item * I<snapshot>  =>   B<string>

=begin html

<br>Name of the snapshot in which the LUN exists.

=end html

=back



=head2 lun-stats-info

=begin html

Stats for a LUN.

=end html



B<Fields>

=over 2

=item * I<block-size>  =>   B<integer, optional>

=begin html

<br>Disk block size for this LUN in bytes. This attribute is unavailable when the LUN is fenced for a restore operation.

=end html

=back



=over 2

=item * I<last-zeroed>  =>   B<integer, optional>

=begin html

<br>Total number of seconds since the statistics for this lun were last zeroed.

=end html

=back



=over 2

=item * I<other-ops>  =>   B<integer>

=begin html

<br>Total number of other SCSI ops executed.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>path of the LUN. (for example, "/vol/vol0/lun1")

=end html

=back



=over 2

=item * I<read-blocks>  =>   B<integer, optional>

=begin html

<br>Number of disk blocks read. This attribute is unavailable when the LUN is fenced for a restore operation.

=end html

=back



=over 2

=item * I<read-ops>  =>   B<integer>

=begin html

<br>Total number of SCSI read ops executed.

=end html

=back



=over 2

=item * I<write-blocks>  =>   B<integer, optional>

=begin html

<br>Number of disk blocks written. This attribute is unavailable when the LUN is fenced for a restore operation.

=end html

=back



=over 2

=item * I<write-ops>  =>   B<integer>

=begin html

<br>Total number of SCSI write ops executed.

=end html

=back



=head2 mixed-ostype-initiator-info

=begin html

Information about an initiator which is a member of initiator groups of differing ostypes. An initiator can only be a member of initiator groups which have the same ostype across all the initiator groups it is a member of.

=end html



B<Fields>

=over 2

=item * I<initiator-group-name-1>  =>   B<string>

=begin html

<br>Name of this initiator group.

=end html

=back



=over 2

=item * I<initiator-group-name-2>  =>   B<string>

=begin html

<br>Name of this initiator group.

=end html

=back



=over 2

=item * I<initiator-group-os-type-1>  =>   B<initiator-group-os-type>

=begin html

<br>OS type of the initiator group

=end html

=back



=over 2

=item * I<initiator-group-os-type-2>  =>   B<initiator-group-os-type>

=begin html

<br>OS type of the initiator group

=end html

=back



=over 2

=item * I<initiator-name>  =>   B<string>

=begin html

<br>Name of the initiator.

=end html

=back



=head2 mixed-vsa-initiator-info

=begin html

Information about an initiator which is a member of initiator groups with differing Volume Set Addressing (VSA) settings. This will cause unexpected problems with the initiator.

=end html



B<Fields>

=over 2

=item * I<initiator-group-name-1>  =>   B<string>

=begin html

<br>Name of this initiator group.

=end html

=back



=over 2

=item * I<initiator-group-name-2>  =>   B<string>

=begin html

<br>Name of this initiator group.

=end html

=back



=over 2

=item * I<initiator-name>  =>   B<string>

=begin html

<br>Name of the initiator.

=end html

=back



=over 2

=item * I<is-vsa-enabled-1>  =>   B<boolean>

=begin html

<br>If true this initiator groups's member will use VSA on the filer

=end html

=back



=over 2

=item * I<is-vsa-enabled-2>  =>   B<boolean>

=begin html

<br>If true this initiator groups's member will use VSA on the filer

=end html

=back



=head2 persistent-reservation-info

=begin html

Information about the persistent reservation

=end html



B<Fields>

=over 2

=item * I<fcp-pr-nexus>  =>   B<L<"fcp-pr-nexus">, optional>

=begin html

<br>This is the I_T_Nexus info for an fcp type reservation.

=end html

=back



=over 2

=item * I<iscsi-pr-nexus>  =>   B<L<"iscsi-pr-nexus">, optional>

=begin html

<br>This is the I_T_Nexus info for an iscsi type reservation.

=end html

=back



=over 2

=item * I<reservation-key>  =>   B<string, optional>

=begin html

<br>Value of persistent reservation key that is registered for the given lun.

=end html

=back



=over 2

=item * I<reservation-type>  =>   B<string>

=begin html

<br>Type of persistent reservation. Possible values: "fcp", "iscsi".

=end html

=back



=over 2

=item * I<reservation-type-code>  =>   B<string, optional>

=begin html

<br>Type of persistent reservation held by the I_T_Nexus, if any. Please refer to the SCSI Primary Command (SPC) specification for full details on reservation types. Possible values: <ul> <li> "read shared",</li> <li> "write exclusive",</li> <li> "exclusive access",</li> <li> "write exclusive registrants only",</li> <li> "exclusive access registrants only",</li> <li> "write exclusive all registrants",</li> <li> "exclusive access all registrants".</li> </ul>

=end html

=back



=head2 address-info-family

=begin html

Denotes protocol family of the address. Possible values: { af_unspec | af_local | af_unix |af_inet | af_implink | af_pup | af_chaos | af_ns | af_iso | af_osi | af_ecma | af_datakit | af_ccitt | af_sna | af_decnet | af_dli |af_lat | af_hylink | af_appletalk | af_route | af_link | pseudo_af_xtp | af_coip | af_cnt | pseudo_af_rtip | af_ipx | af_sip | pseudo_af_pip | af_inet6 } "af_unspec" - ipv4 or ipv6 address family. "af_local" - local to host (pipes, portals). "af_unix" - same as af_local backward compatibility "af_inet" - internetwork: udp, tcp, etc. "af_implink" - arpanet imp addresses "af_pup" - pup protocols: e.g. bsp "af_chaos" - mit chaos protocols "af_ns" - xerox ns protocols "af_iso" - iso protocols "af_osi" - same as af_iso backward compatibility "af_ecma" - european computer manufacturers "af_datakit" - datakit protocols "af_ccitt" - ccitt protocols, x.25 etc/ "af_sna" - ibm sna "af_decnet" - decnet "af_dli" - dec direct data link interface "af_lat" - lat "af_hylink" - nsc hyperchannel "af_appletalk" - apple talk "af_route" - internal routing protocol "af_link" - link layer interface "pseudo_af_xtp" - express transfer protocol (no af) "af_coip" - connection-oriented ip "af_cnt" - computer network technology "pseudo_af_rtip" - help identify rtip packets "af_ipx" - novell internet protocol "af_sip" - simple internet protocol "pseudo_af_pip" - help identify pip packets "af_inet6" - ipv6 address family

=end html



B<Fields>

=over 2

=item * None

=back



=head2 address-info-flag

=begin html

Each flag represents a filter criteria. For example if the "passive" flag is used then the returned address information shall be suitable for use in binding a socket for accepting incoming connections for the specified service. If the "canonical_name" flag is specified and the host-name argument is not null, the function shall attempt to determine the canonical name corresponding to host-name argument. Possible values are: { ai_passive | ai_canonname ai_numerichost | ai_all | ai_addrconfig | ai_vp4mapped | ai_addrconfig | ai_default }. "ai_passive" - get address to use bind(). "ai_canonname" - fill ai_canonname. "ai_numerichost" - prevent name resolution. "ai_all" - IPv6 and IPv4-mapped (with AI_V4MAPPED). "ai_vp4mapped_cfg" - accept IPv4-mapped if kernel supports. "ai_addrconfig" - only if any address is assigned. "ai_vp4mapped" - accept IPv4-mapped IPv6 address. "ai_default" - ( ai_vp4mapped_cfg | ai_addrconfig ). "numeric_host" can appear in any combination along with "all", "ip4_mapped_configuration", "address_configuration", and "ip4_mapped".

=end html



B<Fields>

=over 2

=item * None

=back



=head2 address-info-socket-type

=begin html

Denotes the type of socket for which address will be used. For example: stream socket/datagram socket. Possible values are: { sock_stream | sock_dgram | sock_raw | sock_rdm | sock_seqpacket | sock_stream_nonblk } "sock_stream" - stream socket. "sock_dgram" - datagram socket. "sock_raw" - raw protocol interface. "sock_rdm" - reliably delivered message. "sock_seqpacket" - sequenced packet stream. "sock_stream_nonblk" - sequenced packet stream non block.

=end html



B<Fields>

=over 2

=item * None

=back



=head2 address-info-transport-protocol

=begin html

Denotes the type of transport protocol for which address will be used. Possible values are: { ipproto_ip | iproto_hopopts | iproto_icmp | ipproto_igmp | ipproto_ggp | ipproto_ipv4 | ipproto_ipip | iproto_tcp | ipproto_egp | ipproto_pup | iprpoto_udp | ipproto_idp | ipproto_tp | ipproto_ipv6 | ipproto_routing | ipproto_fragment | ipproto_gre | iprpoto_esp | ipproto_ah | ipproto_icmpv6 | ipproto_none | ipproto_dstopts | ipproto_eon | ipproto_encap | ipproto_ssl | ipproto_ipcomp | ipproto_raw | ipproto_done } "ipproto_ip" - dummy for IP protocol type. "ipproto_hopopts" - IPv6 hop-by-hop options. "ipproto_icmp" - control message protocol. "ipproto_igmp" - group mgmt protocol "ipproto_ggp" - gateway protocol "ipproto_ipv4" - IPv4 encapsulation "ipproto_ipip" - for compatibility with IPV4 "ipproto_tcp" - transport control protocol "ipproto_egp" - Exterior gateway protocol "ipproto_pup" - pup "iprpoto_udp" - user datagram protocol "ipproto_idp" - xns idp "ipproto_tp" - tp-4 class negotiation "ipproto_ipv6" - IPv6 header "ipproto_routing" - IPv6 routing header "ipproto_fragment" - IPv6 fragmentation header "ipproto_gre" - Generic Routing Encapsulation "iprpoto_esp" - IPv6 Encap Sec. Payload "ipproto_ah" -IPv6 Auth Header "ipproto_icmpv6" ICMP6 "ipproto_none" - IPv6 no next header "ipproto_dstopts" - IPv6 destination option "ipproto_eon" - ISO cnlp "ipproto_encap" - encapsulation header "ipproto_ssl" ssl protocol "ipproto_ipcomp" - IP Payload Compression Protocol "ipproto_raw" - raw protocl "ipproto_done" - all job for this pkt is done

=end html



B<Fields>

=over 2

=item * None

=back



=head2 config-status-info

=begin html

status of net-config-info object being returned used to return non-fatal errors encountered

=end html



B<Fields>

=over 2

=item * I<operation>  =>   B<string>

=begin html

<br>Operation where error was encountered.

=end html

=back



=over 2

=item * I<status>  =>   B<string>

=begin html

<br>Error status of config object.

=end html

=back



=head2 host-info

=begin html

Contains name of the host to be resolved, hints will be provided in order to return more appropriate types of addresses, service name.

=end html



B<Fields>

=over 2

=item * I<hints>  =>   B<L<"net-address-info">, optional>

=begin html

<br>Hints given to the name resolution server in order to return the right kind of socket that the caller supports or wishes to use.

=end html

=back



=over 2

=item * I<host-name>  =>   B<string, optional>

=begin html

<br>Name of the host that needs to be resolved.

=end html

=back



=over 2

=item * I<service-port>  =>   B<integer, optional>

=begin html

<br>This parameter is represents the port number of the service for which resolved address is intended to be used for. It can be a port number 80 for the service "http". Range:[0-65535]

=end html

=back



=head2 host-name

=begin html

Host name

=end html



B<Fields>

=over 2

=item * None

=back



=head2 ifgrp-info

=begin html

ifgrp name, type, and components.

=end html



B<Fields>

=over 2

=item * I<favored>  =>   B<string, optional>

=begin html

<br>interface that is favored. Only applies if ifgrp-type = single.

=end html

=back



=over 2

=item * I<ifgrp-policy>  =>   B<string, optional>

=begin html

<br>Possible values: [rr|mac|ip|port|single]. Default is ip.

=end html

=back



=over 2

=item * I<ifgrp-type>  =>   B<string>

=begin html

<br>Possible values: [single|multi|lacp].

=end html

=back



=over 2

=item * I<interface-name>  =>   B<string>

=begin html

<br>The interface name.

=end html

=back



=over 2

=item * I<links>  =>   B<link[], optional>

=begin html

<br>array of interface names in interface group. An ifgrp with no members is possible.

=end html

=back



=over 2

=item * I<nofavored>  =>   B<string, optional>

=begin html

<br>interface that is not favored. Only applies if ifgrp-type = single.

=end html

=back



=head2 interface-config-info

=begin html

Configuration for one interface.

=end html



B<Fields>

=over 2

=item * I<aliases>  =>   B<L<"ip-address-info">[], optional>

=begin html

<br>List of interface IP aliases. Cannot include ipv4 addresses if v4-primary-address is empty, and cannot include ipv6 addresses if v6_primary-address is empty (except for autoconfigured ipv6 addresses).

=end html

=back



=over 2

=item * I<dad-attempts>  =>   B<integer, optional>

=begin html

<br>Number of IPv6 Duplicate Address Detection attempts for this interface.

=end html

=back



=over 2

=item * I<flowcontrol>  =>   B<string, optional>

=begin html

<br>Specifies the flow control type. Possible values: {none | receive | send | full} The meaning of these values is: "none" (no flow control), "receive" (only receive flow control frames), "send" (only send flow control frames), and "full" (send and receive flow control frames). If the flowcontrol option is not specified, the default value is interface-dependent. Fiber Interfaces: If the interface detects that the link partner auto-negotiates, then the operational flow control setting is negotiated (and the configured or default setting for flow control is ignored). Not all interfaces have a flowcontrol (e.g. loopback does not) Default is NIC-specific.

=end html

=back



=over 2

=item * I<interface-name>  =>   B<string>

=begin html

<br>Name of the interface.

=end html

=back



=over 2

=item * I<ipspace-name>  =>   B<string>

=begin html

<br>Name of ipspace that the interface belongs to.

=end html

=back



=over 2

=item * I<is-enabled>  =>   B<boolean, optional>

=begin html

<br>Administrative status. (true: interface is administratively up). Default is true.

=end html

=back



=over 2

=item * I<is-nfo-enabled>  =>   B<boolean, optional>

=begin html

<br>true: network failover is configured for this interface. Default is false;

=end html

=back



=over 2

=item * I<is-trusted>  =>   B<boolean, optional>

=begin html

<br>true: interface is trusted. Default is true.

=end html

=back



=over 2

=item * I<is-wins-enabled>  =>   B<boolean, optional>

=begin html

<br>true: interface is advertised to the WINS server. Default is true.

=end html

=back



=over 2

=item * I<mac-address>  =>   B<string, optional>

=begin html

<br>Interface mac address. Not provided for "lo" or "vh" interfaces

=end html

=back



=over 2

=item * I<mediatype>  =>   B<string, optional>

=begin html

<br>Specifies the Ethernet media type used. Possible values: {tp | tp-fd | 100tx | 100tx-fd | 1000fx | 10g-sr | auto} 10/100, 100/1000, and 10/100/1000 Mbps Copper Interfaces: The acceptable types (which vary from card to card) are "tp" (Half-duplex 10BaseT RJ-45 twisted-pair), "tp-fd" (Full duplex 10Base-T RJ-45 twisted-pair), "100tx" (Half-duplex 100Base-T RJ-45 twisted-pair), "100tx-fd" (Full duplex 100Base-T RJ-45 twisted-pair), and "auto" (Auto RJ-45 twisted-pair). The default media type is set to "tp" or to "auto" where applicable. 1000 Mbps Fiber Interfaces: The Gigabit Ethernet Controllers only support the mediatype "auto". The Gigabit Ethernet Controllers only support full-duplex. 10G bps Fiber Interfaces: The 10G TOE/Ethernet Controllers support the mediatype "10g-sr" and "auto". The interface does not do auto-negotiatition, it only supports 10Gb speed, full duplex. Not all interfaces have a mediatype (e.g. loopback does not)

=end html

=back



=over 2

=item * I<mtusize>  =>   B<integer, optional>

=begin html

<br>Maximum Transfer Unit (MTU) of an interface. Range: 296-9196 Default is 1500.

=end html

=back



=over 2

=item * I<partner>  =>   B<string, optional>

=begin html

<br>Name of CFO partner interface that will failover to this interface. Default is no partner.

=end html

=back



=over 2

=item * I<port-role>  =>   B<string, optional>

=begin html

<br>Possible values: [mgmt|storage-acp|cluster|data]. Default is data. Mgmt role cannot be modified in 7Mode.

=end html

=back



=over 2

=item * I<v4-primary-address>  =>   B<L<"ip-address-info">, optional>

=begin html

<br>The primary ipv4 address for this interface If missing, it means the interface has no ipv4 addresses.

=end html

=back



=over 2

=item * I<v6-primary-address>  =>   B<L<"ip-address-info">, optional>

=begin html

<br>The primary ipv6 address for this interface If missing, it means the interface has no statically configured ipv6 addresses.

=end html

=back



=head2 interface-dcb-entry-info

=begin html

DCB configuration information about a priority group.

=end html



B<Fields>

=over 2

=item * I<application>  =>   B<string>

=begin html

<br>Application assigned to the specified priority group.

=end html

=back



=over 2

=item * I<bandwidth-percentage>  =>   B<integer>

=begin html

<br>Bandwidth assigned to the specified priority group. Range: [0..100]

=end html

=back



=over 2

=item * I<priority-entries>  =>   B<L<"priority-entry-info">[]>

=begin html

<br>A list of DCB priorities associated to the specified priority group.

=end html

=back



=over 2

=item * I<priority-group-id>  =>   B<integer>

=begin html

<br>The Priority Group ID. A priority group is a group of priorities bound together by management for the purpose of bandwidth allocation. All priorities in a single group are expected to have similar traffic handling requirements (e.g. latency or frame loss). Range: [0..15]

=end html

=back



=head2 interface-dcb-priority-entry-info

=begin html

DCB configuration information about a priority.

=end html



B<Fields>

=over 2

=item * I<application>  =>   B<string>

=begin html

<br>Application assigned to a specified priority group.

=end html

=back



=over 2

=item * I<is-flow-control-enabled>  =>   B<boolean>

=begin html

<br>TRUE: the flow control is enabled on a specific priority.

=end html

=back



=over 2

=item * I<priority>  =>   B<integer>

=begin html

<br>The DCB priority. Range: [0..7]

=end html

=back



=over 2

=item * I<priority-group-id>  =>   B<integer>

=begin html

<br>The priority group ID. A priority group is a group of priorities bound together by management for the purpose of bandwidth allocation. All priorities in a single group are expected to have similar traffic handling requirements (e.g. latency or frame loss). Range: [0..15]

=end html

=back



=head2 ip-address

=begin html

One ip address, in dotted-decimal format (for example, "192.168.11.12").

=end html



B<Fields>

=over 2

=item * None

=back



=head2 ip-address-info

=begin html

A configured IP Address

=end html



B<Fields>

=over 2

=item * I<addr-family>  =>   B<string>

=begin html

<br>Address family. Possible values: {af-inet6 | af-inet}.

=end html

=back



=over 2

=item * I<address>  =>   B<ip-address-or-hostname>

=begin html

<br>IP address.

=end html

=back



=over 2

=item * I<broadcast>  =>   B<ip-address, optional>

=begin html

<br>broadcast address. Default if not specified is computed from IP address and netmask. Not used for IPV6. Must be consistent with netmask.

=end html

=back



=over 2

=item * I<creator>  =>   B<string>

=begin html

<br>Entity responsible for creation of address. "vfiler:<vfiler name>" if created by d-blade for vfiler. "vserver:<vserver name>" if created by n-blade with cluster-wide scope.

=end html

=back



=over 2

=item * I<lif-type>  =>   B<string, optional>

=begin html

<br>type of LIF. Possible values are 7G, Data, Cluster, Mgmt, ClusMgmt, InterCluster

=end html

=back



=over 2

=item * I<netmask-or-prefix>  =>   B<netmask-or-prefix, optional>

=begin html

<br>netmask or prefix Default if not specified is autogenerated classful.

=end html

=back



=over 2

=item * I<no-ddns>  =>   B<boolean, optional>

=begin html

<br>true: the address is not advertised to ddns. Default if not specified is true.

=end html

=back



=head2 ip-address-or-hostname

=begin html

IP address string. For example, 198.18.100.12, or "`hostname`-e0c" (backquoted hostname is allowed) or "toaster" (assuming toaster resolves to an IP address) or fd20:8b1e:b255:104:230:48ff:fe8c:6326

=end html



B<Fields>

=over 2

=item * None

=back



=head2 ipspace-config-info

=begin html

An IPSpace.

=end html



B<Fields>

=over 2

=item * I<interface-list>  =>   B<string[], optional>

=begin html

<br>List of interface names in the ipspace. An ipspace with no members is possible.

=end html

=back



=over 2

=item * I<ipspace-name>  =>   B<string>

=begin html

<br>IPSpace name.

=end html

=back



=head2 link

=begin html

ifgrp sub-interface name

=end html



B<Fields>

=over 2

=item * None

=back



=head2 net-address-info

=begin html

Holds host address information.

=end html



B<Fields>

=over 2

=item * I<address-info-family>  =>   B<address-info-family, optional>

=begin html

<br>Denotes protocol family of the address.

=end html

=back



=over 2

=item * I<address-info-flags>  =>   B<address-info-flag[], optional>

=begin html

<br>Specifies how returned sockaddr should be treated and how 'hostname' be treated.

=end html

=back



=over 2

=item * I<address-info-socket-type>  =>   B<address-info-socket-type, optional>

=begin html

<br>Denotes the type of socket for which address will be used. For example:stream socket/datagram socket.

=end html

=back



=over 2

=item * I<address-info-transport-protocol>  =>   B<address-info-transport-protocol, optional>

=begin html

<br>Denotes the type of transport protocol for which address will be used.

=end html

=back



=over 2

=item * I<canonical-name>  =>   B<string, optional>

=begin html

<br>Canonical name for hostname.

=end html

=back



=over 2

=item * I<ip-address>  =>   B<string>

=begin html

<br>Resolved IP address string. May be IPv4 or IPv6. For example, 198.18.100.12 or fd20:8b1e:b255:104:230:48ff:fe8c:6326. No hostname resolution.

=end html

=back



=head2 net-config-info

=begin html

interface configurations and routes

=end html



B<Fields>

=over 2

=item * I<config-status>  =>   B<L<"config-status-info">[], optional>

=begin html

<br>status of net-config-info object, details of non-fatal errors Note: all the net zapis make a best effort and will return a successful result as long as they are partially successful. It is up to the client to inspect this status field and warn the user if problems were encountered.

=end html

=back



=over 2

=item * I<ifgrps>  =>   B<L<"ifgrp-info">[], optional>

=begin html

<br>List of ifgrp interfaces.

=end html

=back



=over 2

=item * I<interfaces>  =>   B<L<"interface-config-info">[]>

=begin html

<br>List of interface configurations.

=end html

=back



=over 2

=item * I<routes>  =>   B<L<"route-info">[], optional>

=begin html

<br>List of static routes.

=end html

=back



=over 2

=item * I<vlans>  =>   B<L<"vlan-info">[], optional>

=begin html

<br>List of vlan interfaces.

=end html

=back



=head2 net-dcb-entry-info

=begin html

DCB configuration information about a single network interface.

=end html



B<Fields>

=over 2

=item * I<interface-dcb-entries>  =>   B<L<"interface-dcb-entry-info">[]>

=begin html

<br>A list of priority group associated DCB configuration parameters for a single network interface.

=end html

=back



=over 2

=item * I<interface-name>  =>   B<string>

=begin html

<br>The network interface name.

=end html

=back



=head2 net-dcb-priority-entry-info

=begin html

DCB configuration information indexed by the priority about a single network interface.

=end html



B<Fields>

=over 2

=item * I<interface-dcb-priority-entries>  =>   B<L<"interface-dcb-priority-entry-info">[]>

=begin html

<br>A list of DCB configuration parameters indexed by the priority.

=end html

=back



=over 2

=item * I<interface-name>  =>   B<string>

=begin html

<br>The network interface name.

=end html

=back



=head2 netmask-or-prefix

=begin html

netmask. Possible values: dotted decimal or hex integer (range: 0x1 .. 0xffffffff) or '/' followed by hex integer (range: 0x1 .. 0x40) Default if not specified is classful: Class A address - 255.0.0.0 or 0xff000000 or /8 Class B address - 255.255.0.0 or 0xffff0000 or /16 Class C address - 255.255.255.0 or 0xffffff00 or /24 IPV6 address prefix - /1 through /128

=end html



B<Fields>

=over 2

=item * None

=back



=head2 priority-entry-info

=begin html

A priority associated to the specified priority group.

=end html



B<Fields>

=over 2

=item * I<priority>  =>   B<integer>

=begin html

<br>The priority associated with the specified priority group. Range: [0..7]

=end html

=back



=head2 route-info

=begin html

A kernel route.

=end html



B<Fields>

=over 2

=item * I<addr-family>  =>   B<string>

=begin html

<br>Address family. Possible values: {af-inet6 | af-inet}.

=end html

=back



=over 2

=item * I<creator>  =>   B<string>

=begin html

<br>Entity responsible for creation of route. Possible values: "filer" if created by d-blade for default vfiler. "vfiler: <vfiler name>" if created by d-blade for vfiler. "vserver: <vserver name>" if created by n-blade with cluster-wide scope.

=end html

=back



=over 2

=item * I<destination>  =>   B<ip-address-or-hostname>

=begin html

<br>Destination of route. Possible values: An IP address, hostname, or "default".

=end html

=back



=over 2

=item * I<ipspace-name>  =>   B<string>

=begin html

<br>IPSpace name. Must match the ipspace assigned to the creator.

=end html

=back



=over 2

=item * I<metric>  =>   B<integer>

=begin html

<br>The route metric. Range: 0-10

=end html

=back



=over 2

=item * I<next-hop>  =>   B<ip-address>

=begin html

<br>Next hop (router) IP address.

=end html

=back



=over 2

=item * I<prefixlen>  =>   B<integer, optional>

=begin html

<br>Prefix length (netmask) for destination. Range: 1..32 for af-inet and 1..128 for af-inet6.

=end html

=back



=over 2

=item * I<route-type>  =>   B<string, optional>

=begin html

<br>Possible values: "net" or "host".

=end html

=back



=head2 vlan-info

=begin html

vlan

=end html



B<Fields>

=over 2

=item * I<gvrp-enabled>  =>   B<boolean, optional>

=begin html

<br>true: GVRP is enabled. Default is false. GVRP is deprecated and this attribute is ignored in cluster mode. GVRP is a standard vlan trunking protocol that enables a port to advertise which vlans it trunks, thereby decreasing traffic over the trunk. This protocol eliminates the need to manually configure vlan information on each switch in the network.

=end html

=back



=over 2

=item * I<interface-name>  =>   B<string, optional>

=begin html

<br>Name of vlan interface. The name must be of the format &lt;parent-inteface&gt;-&lt;vlanid&gt;

=end html

=back



=over 2

=item * I<parent-interface>  =>   B<string>

=begin html

<br>The interface that hosts the vlan interface.

=end html

=back



=over 2

=item * I<vlanid>  =>   B<integer>

=begin html

<br>The vlan id. Range: 1..4094.

=end html

=back



=head2 exports-hostname-info

=begin html

Structure containing information pertaining to a host.

=end html



B<Fields>

=over 2

=item * I<all-hosts>  =>   B<boolean, optional>

=begin html

<br>Default value is false. If true, enables all hosts to have this rule's access rights. A hostname of 'all-hosts' must exist as the only non-negated element in a hostname array.

=end html

=back



=over 2

=item * I<name>  =>   B<string, optional>

=begin html

<br>A hostname can be ONE of the following formats. If 'all-hosts' is true, 'name' must not have a value. machine-name: Alphanumeric string based on DNS. netgroup: Alphanumeric string describing a group of &nbsp; machine names ip: An IP address in dotted decimal format AAA.BBB.CCC.DDD subnet: "[network] subnet [netmask] netmask" ip-subnet: IP/numbits. The IP is a subnet number and the &nbsp; numbits specifies the size of the subnet by the &nbsp; number of leading bits of the netmask. dns: A DNS domain. An Alphanumeric starting with a '.'

=end html

=back



=over 2

=item * I<negate>  =>   B<boolean, optional>

=begin html

<br>In Data ONTAP 7-Mode, default is false. If true, the rule applies to every host but this one. Used most commonly when adding a group minus a few hosts. In Data ONTAP Cluster-Mode, negations are not supported. An error will be returned if true.

=end html

=back



=head2 exports-rule-info

=begin html

Information necessary to create a new rule in the etc/exports file or for just adding a rule similar to the exportfs command. ORDER MATTERS for the hostnames in 'read-only' and 'read-write' privileges. Please see documentation for exportfs command or etc/exports file for complete details.

=end html



B<Fields>

=over 2

=item * I<actual-pathname>  =>   B<string, optional>

=begin html

<br>In Data ONTAP 7-Mode, it must be pathname inside of the filer which is being exported. The default for this is value in 'pathname'. In Data ONTAP Cluster-Mode, this value must be an empty string.

=end html

=back



=over 2

=item * I<anon>  =>   B<string, optional>

=begin html

<br>All hosts with this user-id or username have root access to this directory.

=end html

=back



=over 2

=item * I<nosuid>  =>   B<boolean, optional>

=begin html

<br>If true, causes the server file system to silently ignore any attempt to enable the setuid or setgid mode bits. Default value is false.

=end html

=back



=over 2

=item * I<pathname>  =>   B<string>

=begin html

<br>In Data ONTAP 7-Mode, it must be directory name or file to export. In Data ONTAP Cluster-Mode, it must be a junction path of the volume to be exported.

=end html

=back



=over 2

=item * I<read-only>  =>   B<L<"exports-hostname-info">[], optional>

=begin html

<br>An array of hostnames which only have read privileges.

=end html

=back



=over 2

=item * I<read-write>  =>   B<L<"exports-hostname-info">[], optional>

=begin html

<br>An array of hostnames which have read and write privileges. Any hostname in read-only must not be in read-write also. By default, if no 'read-only' or 'read-write' hosts are given, then 'read-write' contains a hostname of 'all-hosts'.

=end html

=back



=over 2

=item * I<root>  =>   B<L<"exports-hostname-info">[], optional>

=begin html

<br>Array of hostnames which have roots with 'read-write' or 'read-only' privileges.

=end html

=back



=over 2

=item * I<sec-flavor>  =>   B<L<"sec-flavor-info">[], optional>

=begin html

<br>List of possible security flavors this rule supports. Default security is &quot;sys&quot;. In Data ONTAP Cluster-Mode, all the security flavors supported by 7-Mode are not supported. Hence the security flavors supported in both the ONTAP versions [for reference: 'none','sys','krb5'] will be considered valid.

=end html

=back



=head2 exports-rule-info-2

=begin html

Information necessary to create a new rule in the etc/exports file or for just adding a rule similar to the exportfs command.

=end html



B<Fields>

=over 2

=item * I<actual-pathname>  =>   B<string, optional>

=begin html

<br>In Data ONTAP 7-Mode, it must be pathname inside of the filer which is being exported. The default for this is value in 'pathname'. In Data ONTAP Cluster-Mode, this value must be an empty string.

=end html

=back



=over 2

=item * I<pathname>  =>   B<string>

=begin html

<br>In Data ONTAP 7-Mode, it must be directory name or file to export. In Data ONTAP Cluster-Mode, it must be a junction path of the volume to be exported.

=end html

=back



=over 2

=item * I<security-rules>  =>   B<L<"security-rule-info">[]>

=begin html

<br>Access block information for lists of hosts.

=end html

=back



=head2 hostaddr

=begin html

the individual client hosts. could be a hostname or an IP address.

=end html



B<Fields>

=over 2

=item * None

=back



=head2 nfs-stats-info

=begin html

structure containing statistics for each NFS version

=end html



B<Fields>

=over 2

=item * I<badcalls-total>  =>   B<integer>

=begin html

<br>total bad NFS calls Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<calls-total>  =>   B<integer>

=begin html

<br>total NFS calls Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<nfsv2-client-stats>  =>   B<L<"nfsv2-client-stats-info">>

=begin html

<br>detailed statistics for NFSv2 operations

=end html

=back



=over 2

=item * I<nfsv3-client-stats>  =>   B<L<"nfsv3-client-stats-info">>

=begin html

<br>detailed statistics for NFSv3 operations

=end html

=back



=over 2

=item * I<nfsv4-client-stats>  =>   B<L<"nfsv4-client-stats-info">>

=begin html

<br>detailed statistics for NFSv4 operations

=end html

=back



=head2 nfs-top-info

=begin html

Information about a single nfs top.

=end html



B<Fields>

=over 2

=item * I<client-info>  =>   B<string>

=begin html

<br>Client IP address

=end html

=back



=over 2

=item * I<create-ops>  =>   B<integer>

=begin html

<br>The number of nfs CREATE operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<getattr-ops>  =>   B<integer>

=begin html

<br>The number of nfs GETATTR operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<lookup-ops>  =>   B<integer>

=begin html

<br>The number of nfs LOOKUP operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<read-ops>  =>   B<integer>

=begin html

<br>The number of nfs READ operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<readdir-ops>  =>   B<integer>

=begin html

<br>The number of nfs READDIR and READIDRPLUS operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<readlink-ops>  =>   B<integer>

=begin html

<br>The number of nfs READLINK operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<remove-ops>  =>   B<integer>

=begin html

<br>The number of nfs REMOVE operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<total-ops>  =>   B<integer>

=begin html

<br>The number of nfs operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<write-ops>  =>   B<integer>

=begin html

<br>The number of nfs WRITE operations Range : [0..2^64-1].

=end html

=back



=head2 nfsv2-client-stats-info

=begin html

structure containing statistics for NFSv2 operations

=end html



B<Fields>

=over 2

=item * I<create-ops>  =>   B<integer>

=begin html

<br>total 'create' NFSv2 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<getattr-ops>  =>   B<integer>

=begin html

<br>total 'getattr' NFSv2 operation Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<link-ops>  =>   B<integer>

=begin html

<br>total 'link' NFSv2 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<lookup-ops>  =>   B<integer>

=begin html

<br>total 'lookup' NFSv2 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<mkdir-ops>  =>   B<integer>

=begin html

<br>total 'mkdir' NFSv2 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<null-ops>  =>   B<integer>

=begin html

<br>total 'null' NFSv2 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<read-ops>  =>   B<integer>

=begin html

<br>total 'read' NFSv2 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<readdir-ops>  =>   B<integer>

=begin html

<br>total 'readdir' NFSv2 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<readlink-ops>  =>   B<integer>

=begin html

<br>total 'readlink' NFSv2 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<remove-ops>  =>   B<integer>

=begin html

<br>total 'remove' NFSv2 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<rename-ops>  =>   B<integer>

=begin html

<br>total 'rename' NFSv2 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<rmdir-ops>  =>   B<integer>

=begin html

<br>total 'rmdir' NFSv2 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<root-ops>  =>   B<integer>

=begin html

<br>total 'root' NFSv2 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<setattr-ops>  =>   B<integer>

=begin html

<br>total 'setattr' NFSv2 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<statfs-ops>  =>   B<integer>

=begin html

<br>total 'statfs' NFSv2 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<symlink-ops>  =>   B<integer>

=begin html

<br>total 'symlink' NFSv2 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<wrcache-ops>  =>   B<integer>

=begin html

<br>total 'wrcache' NFSv2 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<write-ops>  =>   B<integer>

=begin html

<br>total 'write' NFSv2 operations Range : [0..2^64-1].

=end html

=back



=head2 nfsv3-client-stats-info

=begin html

structure containing statistics for NFSv3 operations

=end html



B<Fields>

=over 2

=item * I<access-ops>  =>   B<integer>

=begin html

<br>total 'access' NFSv3 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<commit-ops>  =>   B<integer>

=begin html

<br>total 'commit' NFSv3 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<create-ops>  =>   B<integer>

=begin html

<br>total 'create' NFSv3 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<fsinfo-ops>  =>   B<integer>

=begin html

<br>total 'fsinfo' NFSv3 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<fsstat-ops>  =>   B<integer>

=begin html

<br>total 'fsstat' NFSv3 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<getattr-ops>  =>   B<integer>

=begin html

<br>total 'getattr' NFSv3 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<link-ops>  =>   B<integer>

=begin html

<br>total 'link' NFSv3 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<lookup-ops>  =>   B<integer>

=begin html

<br>total 'lookup' NFSv3 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<mkdir-ops>  =>   B<integer>

=begin html

<br>total 'mkdir' NFSv3 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<mknod-ops>  =>   B<integer>

=begin html

<br>total 'mknod' NFSv3 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<null-ops>  =>   B<integer>

=begin html

<br>total 'null' NFSv3 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<pathconf-ops>  =>   B<integer>

=begin html

<br>total 'pathconf' NFSv3 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<read-ops>  =>   B<integer>

=begin html

<br>total 'read' NFSv3 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<readdir-ops>  =>   B<integer>

=begin html

<br>total 'readdir' NFSv3 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<readdirplus-ops>  =>   B<integer>

=begin html

<br>total 'readdirplus' NFSv3 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<readlink-ops>  =>   B<integer>

=begin html

<br>total 'readlink' NFSv3 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<remove-ops>  =>   B<integer>

=begin html

<br>total 'remove' NFSv3 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<rename-ops>  =>   B<integer>

=begin html

<br>total 'rename' NFSv3 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<rmdir-ops>  =>   B<integer>

=begin html

<br>total 'rmdir' NFSv3 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<setattr-ops>  =>   B<integer>

=begin html

<br>total 'setattr' NFSv3 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<symlink-ops>  =>   B<integer>

=begin html

<br>total 'symlink' NFSv3 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<write-ops>  =>   B<integer>

=begin html

<br>total 'write' NFSv3 operations Range : [0..2^64-1].

=end html

=back



=head2 nfsv4-client-stats-info

=begin html

structure containing statistics for NFSv4 operations

=end html



B<Fields>

=over 2

=item * I<access-ops>  =>   B<integer, optional>

=begin html

<br>total 'access' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<acls-set-total>  =>   B<integer, optional>

=begin html

<br>number of ACLs set on files Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<badproc2-ops>  =>   B<integer, optional>

=begin html

<br>total 'badproc2' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<close-ops>  =>   B<integer, optional>

=begin html

<br>total 'close' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<commit-ops>  =>   B<integer, optional>

=begin html

<br>total 'commit' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<compound-ops>  =>   B<integer, optional>

=begin html

<br>total 'compound' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<create-ops>  =>   B<integer, optional>

=begin html

<br>total 'create' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<delegpurge>  =>   B<integer, optional>

=begin html

<br>total 'delegpurge' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<delegret-ops>  =>   B<integer, optional>

=begin html

<br>total 'delegret' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<getattr-ops>  =>   B<integer, optional>

=begin html

<br>total 'getattr' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<getfh-ops>  =>   B<integer, optional>

=begin html

<br>total 'getfh' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<link-ops>  =>   B<integer, optional>

=begin html

<br>total 'link' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<lock-ops>  =>   B<integer, optional>

=begin html

<br>total 'lock' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<lockt-ops>  =>   B<integer, optional>

=begin html

<br>total 'lockt' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<locku-ops>  =>   B<integer, optional>

=begin html

<br>total 'locku' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<lookup-ops>  =>   B<integer, optional>

=begin html

<br>total 'lookup' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<lookupp-ops>  =>   B<integer, optional>

=begin html

<br>total 'lookupp' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<no-delegation-total>  =>   B<integer, optional>

=begin html

<br>total calls where a delegation could not be granted Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<null-ops>  =>   B<integer, optional>

=begin html

<br>total 'null' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<nverify-ops>  =>   B<integer, optional>

=begin html

<br>total 'nverify' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<open-confirm-ops>  =>   B<integer, optional>

=begin html

<br>total 'open_confirm' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<open-downgrade-ops>  =>   B<integer, optional>

=begin html

<br>total 'open_downgrade' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<open-ops>  =>   B<integer, optional>

=begin html

<br>total 'open' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<openattr-ops>  =>   B<integer, optional>

=begin html

<br>total 'openattr' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<putfh-ops>  =>   B<integer, optional>

=begin html

<br>total 'putfh' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<putpubfh-ops>  =>   B<integer, optional>

=begin html

<br>total 'putpubfh' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<putrootfh-ops>  =>   B<integer, optional>

=begin html

<br>total 'putrootfh' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<read-delegation-total>  =>   B<integer, optional>

=begin html

<br>total calls where a read delegation was granted Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<read-ops>  =>   B<integer, optional>

=begin html

<br>total 'read' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<readdir-ops>  =>   B<integer, optional>

=begin html

<br>total 'readdir' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<readlink-ops>  =>   B<integer, optional>

=begin html

<br>total 'readlink' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<remove-ops>  =>   B<integer, optional>

=begin html

<br>total 'remove' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<rename-ops>  =>   B<integer, optional>

=begin html

<br>total 'rename' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<renew-ops>  =>   B<integer, optional>

=begin html

<br>total 'renew' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<restorefh-ops>  =>   B<integer, optional>

=begin html

<br>total 'restorefh' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<rlsowner-ops>  =>   B<integer, optional>

=begin html

<br>total 'rlsowner' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<savefh-ops>  =>   B<integer, optional>

=begin html

<br>total 'savefh' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<secinfo-ops>  =>   B<integer, optional>

=begin html

<br>total 'secinfo' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<setattr-ops>  =>   B<integer, optional>

=begin html

<br>total 'setattr' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<setclntid-cfm-ops>  =>   B<integer, optional>

=begin html

<br>total 'setclntid_cfm' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<setclntid-ops>  =>   B<integer, optional>

=begin html

<br>total 'setclntid' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<verify-ops>  =>   B<integer, optional>

=begin html

<br>total 'verify' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<write-delegation-total>  =>   B<integer, optional>

=begin html

<br>total calls where a write delegation was granted Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<write-ops>  =>   B<integer, optional>

=begin html

<br>total 'write' NFSv4 operations Range : [0..2^64-1].

=end html

=back



=head2 owner-info

=begin html

Information about the client host and the owner process on the client host whose locks have to be removed.

=end html



B<Fields>

=over 2

=item * I<client-host>  =>   B<string>

=begin html

<br>client host on which the locks have to be removed.

=end html

=back



=over 2

=item * I<client-host-pid>  =>   B<string>

=begin html

<br>process owner on the above client host whose locks have to be removed.

=end html

=back



=head2 pathname-info

=begin html

Information about a pathname.

=end html



B<Fields>

=over 2

=item * I<name>  =>   B<string>

=begin html

<br>In Data ONTAP 7-Mode, it must be the name of the path, such as &quot;/vol/vol0&quot;. In Data ONTAP Cluster-Mode, it must be the junction path of the volume.

=end html

=back



=head2 rpc-data-info

=begin html

structure containing statisticcs for RPC operations

=end html



B<Fields>

=over 2

=item * I<badcalls-total>  =>   B<integer>

=begin html

<br>total bad RPC calls Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<badlen-total>  =>   B<integer>

=begin html

<br>total badlen RPC calls Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<calls-total>  =>   B<integer>

=begin html

<br>total RPC calls Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<nullrecv-total>  =>   B<integer>

=begin html

<br>total nullrecv RPC calls Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<xdrcall-total>  =>   B<integer>

=begin html

<br>total badhdr RPC calls Range : [0..2^32-1].

=end html

=back



=head2 rpc-stats-info

=begin html

structure containing statistics for RPC operations

=end html



B<Fields>

=over 2

=item * I<tcp-info>  =>   B<L<"rpc-data-info">>

=begin html

<br>detailed statistics for RPC over TCP operations

=end html

=back



=over 2

=item * I<udp-info>  =>   B<L<"rpc-data-info">>

=begin html

<br>detailed statistics for RPC over UDP operations

=end html

=back



=head2 sec-flavor-info

=begin html

Security flavor information for RPC. Only hosts connecting using the proper security can access the directory.

=end html



B<Fields>

=over 2

=item * I<flavor>  =>   B<string>

=begin html

<br>Current possible values can be found using the 'nfs-get-supported-sec-flavors' command. For reference: In Data ONTAP 7-Mode, 'none', 'sys', 'Krb5', 'Krb5i', 'Krb5p' are all supported. In Data ONTAP Cluster-Mode, 'none', 'sys', 'krb5', 'ntlm', 'any', 'never', 'spinauth' are supported.

=end html

=back



=head2 security-rule-info

=begin html

Information on hostnames and security availability for the hosts. ORDER MATTERS for the hostnames in 'read-only' and 'read-write' privileges. Please see documentation for exportfs command or etc/exports file for complete details.

=end html



B<Fields>

=over 2

=item * I<anon>  =>   B<string, optional>

=begin html

<br>All hosts with this user-id or username have root access to this directory.

=end html

=back



=over 2

=item * I<nosuid>  =>   B<boolean, optional>

=begin html

<br>If true, causes the server file system to silently ignore any attempt to enable the setuid or setgid mode bits. Default value is false.

=end html

=back



=over 2

=item * I<read-only>  =>   B<L<"exports-hostname-info">[], optional>

=begin html

<br>An array of hostnames which only have read privileges for all the security flavors found in the sec-flavor list.

=end html

=back



=over 2

=item * I<read-write>  =>   B<L<"exports-hostname-info">[], optional>

=begin html

<br>An array of hostnames which have read and write privileges for all the security flavors found in the 'sec-flavor list'. Any hostname in 'read-only' must not be in 'read-write' also. By default, if no 'read-only' or 'read-write' hosts are given, then 'read-write' contains a hostname of 'all-hosts'.

=end html

=back



=over 2

=item * I<root>  =>   B<L<"exports-hostname-info">[], optional>

=begin html

<br>Array of hostnames which have roots with 'read-write' or 'read-only' privileges.

=end html

=back



=over 2

=item * I<sec-flavor>  =>   B<L<"sec-flavor-info">[], optional>

=begin html

<br>List of possible security flavors this rule supports. Default security is &quot;sys&quot;. In Data ONTAP Cluster-Mode, all the security flavors supported by 7-Mode are not supported. Hence the security flavors supported in both the ONTAP versions [for reference: 'none','sys','krb5'] will be considered valid.

=end html

=back



=head2 tcp-flowcontrol-stats-info

=begin html

structure containing statistics for tcp flowcontrol

=end html



B<Fields>

=over 2

=item * I<receive-out-total>  =>   B<integer>

=begin html

<br>total number of times output was flow controlled on receive Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<receive-total>  =>   B<integer>

=begin html

<br>total number of times input was flow controlled on receive Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<transmit-out-total>  =>   B<integer>

=begin html

<br>total number of times output was flow controlled on transmit Range : [0..2^32-1].

=end html

=back



=over 2

=item * I<transmit-total>  =>   B<integer>

=begin html

<br>total number of times input was flow controlled on transmit Range : [0..2^32-1].

=end html

=back



=head2 option-info

=begin html

null

=end html



B<Fields>

=over 2

=item * I<cluster-constraint>  =>   B<string, optional>

=begin html

<br>Indicates the cluster-specific constraints of option. <ul> <li> "none" - no constraint. <li> "same_preferred" - same value should be used on both nodes of a HA pair. <li> "same_required" - same value must be used on both nodes of a HA pair. <li> "only_one" - value is used for both nodes of a HA pair, when in takeover mode. <li> "unknown" - value is not valid. </ul> In Data ONTAP Cluster-Mode, this field will always be "none". This field is optional in Data ONTAP Cluster-Mode, but required in Data ONTAP 7-Mode.

=end html

=back



=over 2

=item * I<name>  =>   B<string, optional>

=begin html

<br>Name of the option. This field is optional in Data ONTAP Cluster-Mode, but required in Data ONTAP 7-Mode.

=end html

=back



=over 2

=item * I<value>  =>   B<string, optional>

=begin html

<br>Value of the option. This field is optional in Data ONTAP Cluster-Mode, but required in Data ONTAP 7-Mode.

=end html

=back



=head2 counter

=begin html

Counter name.

=end html



B<Fields>

=over 2

=item * None

=back



=head2 counter-data

=begin html

Value of a single counter of an instance of an object at the time of the call.

=end html



B<Fields>

=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Name of the counter

=end html

=back



=over 2

=item * I<value>  =>   B<string>

=begin html

<br>Value of the counter. If the counter type is array, this is a comma separated list of values. The counter properties and units must be known in order to interpret this value. Refer to the perf API discussion for details on how raw counter values are interpreted.

=end html

=back



=head2 counter-info

=begin html

Information about a single counter.

=end html



B<Fields>

=over 2

=item * I<base-counter>  =>   B<string, optional>

=begin html

<br>Name of the counter used as the denominator to calculate values of counters involving averages and percentages.

=end html

=back



=over 2

=item * I<desc>  =>   B<string>

=begin html

<br>Description of the counter

=end html

=back



=over 2

=item * I<is-key>  =>   B<boolean, optional>

=begin html

<br>True if the counter is a key counter. A set of key counters for an object can be used to uniquely identify instances of an object.

=end html

=back



=over 2

=item * I<labels>  =>   B<label-info[], optional>

=begin html

<br>List of labels of an array type counter.

=end html

=back



=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Name of the counter.

=end html

=back



=over 2

=item * I<privilege-level>  =>   B<string>

=begin html

<br>Privilege level of the counter. Any counter with a privilege level of "diag" is not guaranteed to work, to exist in future releases, or to remain unchanged. <br> Possible values: basic, admin, advanced or diag.

=end html

=back



=over 2

=item * I<properties>  =>   B<string, optional>

=begin html

<br>Comma separated list of properties of the counter. The counter properties determine how raw counter values should be interpreted. <br> Possible values: raw, rate, delta, percent, string, no-display and no-zero-values.

=end html

=back



=over 2

=item * I<type>  =>   B<string, optional>

=begin html

<br>Indicator for whether counter is a scalar or array. If this element is absent,the counter is a scalar.<br> Possible values: array

=end html

=back



=over 2

=item * I<unit>  =>   B<string, optional>

=begin html

<br>Unit of the counter<br> Possible values: per_sec, b_per_sec (bytes/s), kb_per_sec (Kbytes/s), mb_per_sec (Mbytes/s), percent, millisec, microsec, sec, or none

=end html

=back



=head2 instance

=begin html

Instance name.

=end html



B<Fields>

=over 2

=item * None

=back



=head2 instance-data

=begin html

Instance name and counter values.

=end html



B<Fields>

=over 2

=item * I<counters>  =>   B<L<"counter-data">[]>

=begin html

<br>List of counter values of this instance. Each element of this list contains the value of a single counter.

=end html

=back



=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Name of the instance

=end html

=back



=head2 instance-info

=begin html

Description of an instance of an object.

=end html



B<Fields>

=over 2

=item * I<name>  =>   B<string, optional>

=begin html

<br>Name of the instance

=end html

=back



=head2 label-info

=begin html

Comma separated list of labels of an array type counter.

=end html



B<Fields>

=over 2

=item * None

=back



=head2 object-info

=begin html

Description of a performance object.

=end html



B<Fields>

=over 2

=item * I<description>  =>   B<string, optional>

=begin html

<br>Description of the object

=end html

=back



=over 2

=item * I<get-instances-preferred-counter>  =>   B<string, optional>

=begin html

<br>Name of the counter, either instance_name or instance_uuid, which should be used for perf-object-get-instances ZAPI for optimal performance. If this element is absent for an object, the value of this element defaults to instance_name counter. This element is a performance hint for getting optimal performance for the perf-object-get-instances ZAPI. If the value of this element is set to instance UUID counter of an object, using the instance UUID counter in the perf-object-get-instances query will return the counter information faster than using instance name counter. Otherwise, instance_name will yield faster results.

=end html

=back



=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Name of the object

=end html

=back



=over 2

=item * I<privilege-level>  =>   B<string>

=begin html

<br>The object privilege level. Any object with a privilege level of "diag" is not guaranteed to work, to exist in future releases, or to remain unchanged. <br> Possible values: basic, admin, advanced or diag.

=end html

=back



=head2 initiator-group-name

=begin html

The name of an initiator group

=end html



B<Fields>

=over 2

=item * None

=back



=head2 portset-info

=begin html

Information about a port set.

=end html



B<Fields>

=over 2

=item * I<initiator-group-info>  =>   B<initiator-group-name[], optional>

=begin html

<br>Information about the initiator group(s) that are bound to the portset.

=end html

=back



=over 2

=item * I<portset-name>  =>   B<string>

=begin html

<br>Name of this port set.

=end html

=back



=over 2

=item * I<portset-port-info>  =>   B<portset-port-name[], optional>

=begin html

<br>Information about the ports belonging to the set.

=end html

=back



=over 2

=item * I<portset-port-total>  =>   B<integer>

=begin html

<br>Total number of ports in the port set.

=end html

=back



=over 2

=item * I<portset-type>  =>   B<string>

=begin html

<br>Possible values: "fcp", "iscsi", "mixed".

=end html

=back



=head2 portset-port-name

=begin html

String representing a member of a portset. In Data ONTAP 7-Mode, the port name is of the format "filer:slotletter" or "slotletter". In Data ONTAP Cluster-Mode, the port name is the name of an FCP data lif or iSCSI target portal group.

=end html



B<Fields>

=over 2

=item * None

=back



=head2 priority-volume-info

=begin html

Information about a priority schedule for a volume.

=end html



B<Fields>

=over 2

=item * I<cache-policy>  =>   B<string>

=begin html

<br>The cache policy, as described in priority-set-volume.

=end html

=back



=over 2

=item * I<level>  =>   B<integer>

=begin html

<br>The priority level, as described in priority-set-volume.

=end html

=back



=over 2

=item * I<nvlog-limit>  =>   B<integer>

=begin html

<br>The limit on nvlog consumption during a consistency point. 0 means a system-created default is being applied.

=end html

=back



=over 2

=item * I<service>  =>   B<string>

=begin html

<br>The priority service state for the volume, "on" or "off"

=end html

=back



=over 2

=item * I<system>  =>   B<integer>

=begin html

<br>The system/user priority, as described in priority-set-volume.

=end html

=back



=over 2

=item * I<system-read-limit>  =>   B<integer>

=begin html

<br>The limit on system reads, 0 means an automatic system default is being applied.

=end html

=back



=over 2

=item * I<user-read-limit>  =>   B<integer>

=begin html

<br>The limit on user reads, 0 means an automatic system default is being applied.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume.

=end html

=back



=head2 qtree-info

=begin html

Information about a single qtree.

=end html



B<Fields>

=over 2

=item * I<id>  =>   B<integer>

=begin html

<br>Id of the qtree (unique within the volume), which is 0 if qtree is the volume itself.

=end html

=back



=over 2

=item * I<oplocks>  =>   B<string>

=begin html

<br>Indicates whether opportunistic locks are enabled on the qtree. Possible values: "enabled", "disabled".

=end html

=back



=over 2

=item * I<owning-vfiler>  =>   B<string, optional>

=begin html

<br>Name of the vfiler which owns this qtree. This value will be returned only if the request is coming to vfiler0 and MultiStore is licensed.

=end html

=back



=over 2

=item * I<qtree>  =>   B<string>

=begin html

<br>Name of the qtree, blank if qtree is the volume itself

=end html

=back



=over 2

=item * I<security-style>  =>   B<string>

=begin html

<br>Security style of the qtree. Possible values are "unix", "ntfs", or "mixed".

=end html

=back



=over 2

=item * I<status>  =>   B<string>

=begin html

<br>Status of the qtree. Possible values include: "snapvaulted", "snapmirrored", "normal", and "readonly".

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume containing the qtree

=end html

=back



=head2 error

=begin html

Information about a single error.

=end html



B<Fields>

=over 2

=item * I<errno>  =>   B<integer>

=begin html

<br>The error number.

=end html

=back



=over 2

=item * I<reason>  =>   B<string>

=begin html

<br>A human-readable readable error message.

=end html

=back



=over 2

=item * I<status>  =>   B<string>

=begin html

<br>Either 'passed' or 'failed'.

=end html

=back



=head2 quota

=begin html

Information about a single quota.

=end html



B<Fields>

=over 2

=item * I<disk-limit>  =>   B<string>

=begin html

<br>Maximum amount of disk space, in kilobytes, allowed for the quota target (hard disk space limit). The value is "-" if the limit is unlimited.

=end html

=back



=over 2

=item * I<disk-used>  =>   B<string>

=begin html

<br>Current amount of disk space, in kilobytes, used by the quota target. The value is "-" if the limit is unlimited.

=end html

=back



=over 2

=item * I<file-limit>  =>   B<string>

=begin html

<br>Maximum number of files allowed for the quota target (hard files limit). The value is "-" if the limit is unlimited.

=end html

=back



=over 2

=item * I<files-used>  =>   B<string>

=begin html

<br>Current number of files used by the quota target. The value is "-" if the limit is unlimited.

=end html

=back



=over 2

=item * I<quota-target>  =>   B<string>

=begin html

<br>For an explicit quota, this value is a fully qualified quota target which is the quota target specified in the /etc/quotas file and the domain in the QUOTA_TARGET_DOMAIN directive is in effect. See na_quotas(5) for more information. Mulitple targets are comma separated. For a derived quota, the field is blank.

=end html

=back



=over 2

=item * I<quota-type>  =>   B<string>

=begin html

<br>The type of quota: user, group, or tree.

=end html

=back



=over 2

=item * I<quota-users>  =>   B<L<"quota-user">[], optional>

=begin html

<br>A list of quota users and group.

=end html

=back



=over 2

=item * I<soft-disk-limit>  =>   B<string>

=begin html

<br>Soft disk space limit, in kilobytes, for the quota target. The value is "-" if the limit is unlimited.

=end html

=back



=over 2

=item * I<soft-file-limit>  =>   B<string>

=begin html

<br>Soft file limit, in number of files, for the quota target. The value is "-" if the limit is unlimited.

=end html

=back



=over 2

=item * I<threshold>  =>   B<string>

=begin html

<br>Disk space threshold, in kilobytes, for the quota target. The value is "-" if the limit is unlimited.

=end html

=back



=over 2

=item * I<tree>  =>   B<string>

=begin html

<br>Name of the qtree to which the quota is applied.

=end html

=back



=over 2

=item * I<vfiler>  =>   B<string, optional>

=begin html

<br>Name of the vfiler to which the quota applies, if vfilers are in use.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume to which the quota is applied.

=end html

=back



=head2 quota-entry

=begin html

Information about a single quota rule.

=end html



B<Fields>

=over 2

=item * I<line>  =>   B<string, optional>

=begin html

<br>The raw line from /etc/quotas. This is only returned when the <include-output-entry> input element is set to true. It is returned whether there is an error or not.

=end html

=back



=over 2

=item * I<qtree>  =>   B<string, optional>

=begin html

<br>Name of the qtree for the quota. It can be the qtree name or "" if no qtree. If there is an error in the quota entry, this value might not present. For tree rules, this field will be "".

=end html

=back



=over 2

=item * I<quota-error>  =>   B<L<"quota-error">, optional>

=begin html

<br>This value is only present if there is an error, and gives complete details for an error for a specific quota entry.

=end html

=back



=over 2

=item * I<quota-target>  =>   B<string, optional>

=begin html

<br>The quota target of the type specified. The value will be one of: &lt;name&gt;, &lt;number&gt;, or &lt;path name&gt;. Mulitple targets can be specified by a comma-separated list. Quota directives in /etc/quotas are used to form the quota target. If there is an error in the quota entry, this value might not present. For explicit tree rules, this field will indicate the qtree name in the format "/vol/< volume name >/ < qtree name >".

=end html

=back



=over 2

=item * I<quota-type>  =>   B<string, optional>

=begin html

<br>The type of quota rule. Possible values are "user", "group", or "tree". If there is an error in the quota entry, this value might not present.

=end html

=back



=over 2

=item * I<volume>  =>   B<string, optional>

=begin html

<br>Name of the volume for the quota. If there is an error in the quota entry, this value might not present.

=end html

=back



=head2 quota-error

=begin html

Information about a single quota error.

=end html



B<Fields>

=over 2

=item * I<detail>  =>   B<string>

=begin html

<br>More details about the error.

=end html

=back



=over 2

=item * I<errno>  =>   B<integer>

=begin html

<br>The error number.

=end html

=back



=over 2

=item * I<reason>  =>   B<string>

=begin html

<br>A human-readable concise reason for the error.

=end html

=back



=head2 quota-info

=begin html

Information about a single quota.

=end html



B<Fields>

=over 2

=item * I<disk-limit>  =>   B<string>

=begin html

<br>Maximum amount of disk space, in kilobytes, allowed for the quota target (hard disk space limit). The value is "-" if the limit is unlimited.

=end html

=back



=over 2

=item * I<disk-used>  =>   B<string>

=begin html

<br>Current amount of disk space, in kilobytes, used by the quota target. The value is "-" if the limit is unlimited.

=end html

=back



=over 2

=item * I<file-limit>  =>   B<string>

=begin html

<br>Maximum number of files allowed for the quota target (hard files limit). The value is "-" if the limit is unlimited.

=end html

=back



=over 2

=item * I<files-used>  =>   B<string>

=begin html

<br>Current number of files used by the quota target. The value is "-" if the limit is unlimited.

=end html

=back



=over 2

=item * I<qtree>  =>   B<string>

=begin html

<br>Name of qtree to which the quota is applied.

=end html

=back



=over 2

=item * I<quota-target>  =>   B<string>

=begin html

<br>For an explicit quota, this value is a fully qualified quota target which is the quota target specified in the /etc/quotas file and the domain in the QUOTA_TARGET_DOMAIN directive is in effect. See na_quotas(5) for more information. Mulitple targets are comma separated. For a derived quota, the field is blank.

=end html

=back



=over 2

=item * I<quota-type>  =>   B<string>

=begin html

<br>Quota type, which can be user, group, or tree

=end html

=back



=over 2

=item * I<quota-users>  =>   B<L<"quota-user">[]>

=begin html

<br>A list of quota users.

=end html

=back



=over 2

=item * I<soft-disk-limit>  =>   B<string>

=begin html

<br>Soft disk space limit, in kilobytes, for the quota target. The value is "-" if the limit is unlimited.

=end html

=back



=over 2

=item * I<soft-file-limit>  =>   B<string>

=begin html

<br>Soft file limit, in number of files, for the quota target. The value is "-" if the limit is unlimited.

=end html

=back



=over 2

=item * I<threshold>  =>   B<string>

=begin html

<br>Disk space threshold, in kilobytes, for the quota target. The value is "-" if the limit is unlimited.

=end html

=back



=over 2

=item * I<vfiler>  =>   B<string, optional>

=begin html

<br>Name of the vfiler to which the quota applies.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of volume to which the quota is applied.

=end html

=back



=head2 quota-user

=begin html

Information about a quota user or group.

=end html



B<Fields>

=over 2

=item * I<quota-user-id>  =>   B<string>

=begin html

<br>The id of the user. The quota-user-type determines the format. For uid and gid, the format is an integer. For sid, the format is the usual "S-*" style.

=end html

=back



=over 2

=item * I<quota-user-name>  =>   B<string>

=begin html

<br>Name of the user, group, or sid.

=end html

=back



=over 2

=item * I<quota-user-type>  =>   B<string>

=begin html

<br>The type of quota user. There are two possible values: sid (for Windows users), uid (for UNIX users), and gid (for UNIX groups).

=end html

=back



=head2 radius-server-list-entry-info

=begin html

Configuration information about a radius server.

=end html



B<Fields>

=over 2

=item * I<radius-server-info>  =>   B<string>

=begin html

<br>Ordering information of the radius server.

=end html

=back



=over 2

=item * I<radius-server-ip>  =>   B<ip-address>

=begin html

<br>The IP address of the radius server.

=end html

=back



=over 2

=item * I<radius-server-port>  =>   B<integer>

=begin html

<br>The UDP port number of the radius server.

=end html

=back



=head2 radius-stats-info

=begin html

Statistics block

=end html



B<Fields>

=over 2

=item * I<access-accepted-packets>  =>   B<integer>

=begin html

<br>Count of access-accept radius packets Range: [0..2^32-1]

=end html

=back



=over 2

=item * I<access-challenged-packets>  =>   B<integer>

=begin html

<br>Count of access-challenge radius packets Range: [0..2^32-1]

=end html

=back



=over 2

=item * I<access-rejected-packets>  =>   B<integer>

=begin html

<br>Count of access-reject radius packets Range: [0..2^32-1]

=end html

=back



=over 2

=item * I<authentication-requests>  =>   B<integer>

=begin html

<br>Count of radius authentication requests Range: [0..2^32-1]

=end html

=back



=over 2

=item * I<denied-packets>  =>   B<integer>

=begin html

<br>Count of denied radius packets Range: [0..2^32-1]

=end html

=back



=over 2

=item * I<late-packets>  =>   B<integer>

=begin html

<br>Count of late reply radius packets Range: [0..2^32-1]

=end html

=back



=over 2

=item * I<retransmitted-packets>  =>   B<integer>

=begin html

<br>Count of retransmission of access-request packets Range: [0..2^32-1]

=end html

=back



=over 2

=item * I<short-packets>  =>   B<integer>

=begin html

<br>Count of short radius packets Range: [0..2^32-1]

=end html

=back



=over 2

=item * I<timed-out-packets>  =>   B<integer>

=begin html

<br>Count of timed-out access-request packets Range: [0..2^32-1]

=end html

=back



=over 2

=item * I<unknown-packets>  =>   B<integer>

=begin html

<br>Count of unknown radius packets Range: [0..2^32-1]

=end html

=back



=over 2

=item * I<unknown-server-packets>  =>   B<integer>

=begin html

<br>Count of radius packets from unknown server Range: [0..2^32-1]

=end html

=back



=head2 reallocate-job-info

=begin html

Information about a specific reallocation job.

=end html



B<Fields>

=over 2

=item * I<flags>  =>   B<string, optional>

=begin html

<br>Flags associated with a reallocation job (verbose only). This is for internal use only.

=end html

=back



=over 2

=item * I<interval>  =>   B<string>

=begin html

<br>Interval between reallocation jobs The format for this value is as described in reallocate-start, above.

=end html

=back



=over 2

=item * I<layout-factor>  =>   B<integer>

=begin html

<br>Current allocation layout factor, if known. The range is from 1 (ideal layout) upwards. A value of -1 is returned if the current layout factor is unknown.

=end html

=back



=over 2

=item * I<measure-logfile>  =>   B<string, optional>

=begin html

<br>For a measure-only job the logfile, if any.

=end html

=back



=over 2

=item * I<measure-only>  =>   B<boolean>

=begin html

<br>True if the reallocate job is measure-only, false otherwise.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>The path for the reallocation job.

=end html

=back



=over 2

=item * I<scan-detail>  =>   B<string>

=begin html

<br>If a reallocation job is running, detail on the current scan, including the progress when known.

=end html

=back



=over 2

=item * I<schedule>  =>   B<string>

=begin html

<br>Schedule for reallocation. The format for this value is as described in reallocate-schedule-set, above.

=end html

=back



=over 2

=item * I<state>  =>   B<string>

=begin html

<br>The current state of the reallocation job. The states are Idle, Checking, Reallocating, Deleting or Quiesce.

=end html

=back



=over 2

=item * I<threshold>  =>   B<integer, optional>

=begin html

<br>The reallocation threshold (verbose only), as described above in reallocate-start, above.

=end html

=back



=head2 rsh-session-info

=begin html

null

=end html



B<Fields>

=over 2

=item * I<audit-log>  =>   B<string, optional>

=begin html

<br>The current auditlog buffer for the command.

=end html

=back



=over 2

=item * I<audit-shell>  =>   B<string, optional>

=begin html

<br>Protocol name in the auditlog. Possible values are: "rsh shell", "ssh1 shell" and "ssh2 shell".

=end html

=back



=over 2

=item * I<command>  =>   B<string>

=begin html

<br>ONTAP command the rsh session is executing.

=end html

=back



=over 2

=item * I<command-time>  =>   B<integer>

=begin html

<br>How long in milliseconds the rsh session is actively executing the command.

=end html

=back



=over 2

=item * I<connection-time>  =>   B<integer>

=begin html

<br>How long in milliseconds it is taking the rsh session to do the protocol connection.

=end html

=back



=over 2

=item * I<get-host-time>  =>   B<integer>

=begin html

<br>How long in milliseconds it is taking for the rsh session to obtain client information.

=end html

=back



=over 2

=item * I<ip-addr>  =>   B<string>

=begin html

<br>IP address of the client invoking the command.

=end html

=back



=over 2

=item * I<session-id>  =>   B<integer>

=begin html

<br>rsh session identifier.

=end html

=back



=over 2

=item * I<vfiler>  =>   B<string>

=begin html

<br>Name of the vfiler on which the rsh session is active

=end html

=back



=head2 alternate-control-path-info

=begin html

Available information on the alternate control path (ACP) to the shelf.

=end html



B<Fields>

=over 2

=item * I<acp-element-no>  =>   B<integer>

=begin html

<br>ACP element number

=end html

=back



=over 2

=item * I<controller-acp-connection-status>  =>   B<string, optional>

=begin html

<br>Storage controller's ACP connection status. Possible values: "no_connectivity", "partial_connectivity", "full_connectivity", "additional_connectivity", "unknown", "not_available", "not_applicable".

=end html

=back



=over 2

=item * I<controller-acp-domain>  =>   B<string, optional>

=begin html

<br>This fields presents the ACP's domain on the storage controller. Example: 255.255.255.0

=end html

=back



=over 2

=item * I<controller-acp-ethernet-port>  =>   B<string, optional>

=begin html

<br>This fields presents the ACP's ethernet port on the storage controller. Example: e0a, e4d.

=end html

=back



=over 2

=item * I<controller-acp-ip-address>  =>   B<string, optional>

=begin html

<br>This fields presents the ACP's IP address on the storage controller. Example: 172.168.4.4

=end html

=back



=over 2

=item * I<controller-acp-netmask>  =>   B<string, optional>

=begin html

<br>This fields presents the ACP's netmask on the storage controller. Example: 172.168.4.1

=end html

=back



=over 2

=item * I<is-acp-element-error>  =>   B<boolean, optional>

=begin html

<br>Indicates if there has been a failure in the ACP block. Will not be present if an ACP element is not installed.

=end html

=back



=over 2

=item * I<is-acp-element-not-installed>  =>   B<boolean, optional>

=begin html

<br>Indicates if ACP element has been installed. Will be present only if the element is not installed, in which case no further information will be provided.

=end html

=back



=over 2

=item * I<is-controller-acp-active>  =>   B<boolean, optional>

=begin html

<br>Indicates whether the ACP function is active on the storage controller. Inactive ACP unually means there is configuration or connection error that needs to be resolved.

=end html

=back



=over 2

=item * I<is-controller-acp-enabled>  =>   B<boolean, optional>

=begin html

<br>Indicates if ACP functionality is enabled in the storage controller. If the ACP funtion is not enalbed the following fields will not be presented.

=end html

=back



=over 2

=item * I<module-firmware-revision>  =>   B<string, optional>

=begin html

<br>Firmware version of the ACP controller. This field will not be present if the value is unknown or not available, or if an ACP element is not installed.

=end html

=back



=over 2

=item * I<module-ip-address>  =>   B<string, optional>

=begin html

<br>IP address that is used by this ACP shelf module. This field will not be present if the IP address is unknown or not available, or if an ACP element is not installed.

=end html

=back



=over 2

=item * I<module-mac-address>  =>   B<string, optional>

=begin html

<br>MAC address that is used by this module's ACPP. This field will not be present if the MAC address is unknown or not available, or if an ACP element is not installed.

=end html

=back



=over 2

=item * I<module-name>  =>   B<string, optional>

=begin html

<br>Shelf module for this ACPP. Possible Values: "A", "B" This field will not be present if it is unknown or not available, or if an ACP element is not installed.

=end html

=back



=over 2

=item * I<module-reset-count>  =>   B<integer, optional>

=begin html

<br>Number of times the corresponding shelf I/O module has been reset using this ACPP. This field will not be present if it is unknown or not available, or if an ACP element is not installed.

=end html

=back



=over 2

=item * I<module-status>  =>   B<string, optional>

=begin html

<br>ACP status of this shelf module. This field will not be present if it is unknown or not available, or if an ACP element is not installed. Possible values: "active", "inactive_not_ready", "inactive_waiting_for_inband_info", "inactive_no_inband_connectivity", "inactive_not_responding", "inactive_updating_firmware", "inactive_initializing", "inactive_unknown".

=end html

=back



=over 2

=item * I<module-status-time>  =>   B<string, optional>

=begin html

<br>Time of last contact with the ACP controller. This is only valid if the value of module-status field is inactive_not_responding.

=end html

=back



=head2 ariodata-specific-info

=begin html

Vendor specific enclosure system information for Ariodata shelf.

=end html



B<Fields>

=over 2

=item * I<ariodata-serial-no>  =>   B<string>

=begin html

<br>Serial number for Ariodata shelf.

=end html

=back



=head2 bay-info

=begin html

A list of shelf bay numbers which have disks.

=end html



B<Fields>

=over 2

=item * I<lun>  =>   B<integer, optional>

=begin html

<br>The logical unit number within the target. This field will be present in some storage configurations. In some cases, devices with a logical unit number will have LEDs that can be affected. Range : [0..255]

=end html

=back



=over 2

=item * I<shelf-bay>  =>   B<integer>

=begin html

<br>A shelf-bay number indicates the presence of a drive in that bay. Shelf bays are numbered starting at 0 which is the right most drive bay in the shelf when viewing the shelf from the front. Range: [0..255]

=end html

=back



=head2 connector-info

=begin html

Information on cables and/or connectors connected to the shelf

=end html



B<Fields>

=over 2

=item * I<sas-connector-list>  =>   B<L<"sas-connector-info">[], optional>

=begin html

<br>Information on SAS connectors & cables.

=end html

=back



=head2 cooling-element-info

=begin html

Information on individual cooling elements (fans).

=end html



B<Fields>

=over 2

=item * I<cooling-element-is-error>  =>   B<boolean, optional>

=begin html

<br>Indicated whether cooling elements has failed or reported any errors. Will not be present if cooling element is not installed.

=end html

=back



=over 2

=item * I<cooling-element-is-not-installed>  =>   B<boolean, optional>

=begin html

<br>Indicates the cooling elements is not installed. This will only be present if the element is missing, in such case no further data for this element will be presented.

=end html

=back



=over 2

=item * I<cooling-element-number>  =>   B<integer>

=begin html

<br>Cooling element number.

=end html

=back



=over 2

=item * I<rpm>  =>   B<integer, optional>

=begin html

<br>Current RPM (revolutions per minutes) of the fan. Will not be present if RPM is not available at the time API is executed or if RPM detection hardware is not supported by the shelf or if cooling element is not installed.

=end html

=back



=head2 current-sensor-info

=begin html

Presents the electrical current sensor information, if implemented on the system.

=end html



B<Fields>

=over 2

=item * I<current-sensor-no>  =>   B<integer>

=begin html

<br>Current sensor number.

=end html

=back



=over 2

=item * I<is-sensor-error>  =>   B<boolean, optional>

=begin html

<br>Will indicate whether the sensor has encountered an error.

=end html

=back



=over 2

=item * I<is-sensor-not-installed>  =>   B<boolean, optional>

=begin html

<br>Indicates the current sensor elements is not installed. This will only be present if the element is missing, in such case no further data for this element will be presented.

=end html

=back



=over 2

=item * I<sensor-condition>  =>   B<string, optional>

=begin html

<br>A Text string describing whether the sensor-reading field is within normal operating range. This field is present only if sensor-reading field is also present. Possible values are: "overcurrent_failure", "overcurrent_warning", "normal_operating_range".

=end html

=back



=over 2

=item * I<sensor-reading>  =>   B<string, optional>

=begin html

<br>Current reading of the sensor. This field will be not be present if unable to read the sensor value properly.

=end html

=back



=head2 dongle-info

=begin html

dongle information

=end html



B<Fields>

=over 2

=item * I<disable-reason>  =>   B<string, optional>

=begin html

<br>If phy-state is "disabled", then this will give explanation as to the reason. Possible values: "manual", "no_drive", "brst_los", "los", "brst_rdd", "rdd", "brst_idd", "idd", "brst_prp", "prp", "brst_pcd", "pcd", "brst_crc", "crc", "osc", "mir", "rsrv", "man_smp", "clk_flt", "unknown".

=end html

=back



=over 2

=item * I<dongle-firmware-revision>  =>   B<string, optional>

=begin html

<br>Dongle firmware revision. Will be missing if not supported or not available.

=end html

=back



=over 2

=item * I<dongle-type>  =>   B<string, optional>

=begin html

<br>Dongle type. Possible values: "ss1300b", "sas", "sps3g", Will be missing if not supported or not available.

=end html

=back



=head2 enclosure-info

=begin html

Information on the enclosure type. This information will be presented for ESH and SAS shelves only.

=end html



B<Fields>

=over 2

=item * I<enclosure-type>  =>   B<string>

=begin html

<br>Enclosure type. Possible values: "sas_expander_module", "embedded_switching_hub".

=end html

=back



=over 2

=item * I<module-list>  =>   B<L<"module-info">[]>

=begin html

<br>Information on the enclosure modules.

=end html

=back



=head2 es-electronics-info

=begin html

Information on the installed enclosure services (ES) electronics.

=end html



B<Fields>

=over 2

=item * I<es-electronics-element-no>  =>   B<integer>

=begin html

<br>Enclosure services electronics element number.

=end html

=back



=over 2

=item * I<es-electronics-is-error>  =>   B<boolean, optional>

=begin html

<br>indicates whether this enclosure services electronics has reported any errors. Will not be present if the element is not installed.

=end html

=back



=over 2

=item * I<es-electronics-is-not-installed>  =>   B<string, optional>

=begin html

<br>Indicates this enclosure services electronics is not installed. This will only be presented when the element is missing, no further data for this element will be presented.

=end html

=back



=over 2

=item * I<es-electronics-is-reporting-element>  =>   B<boolean, optional>

=begin html

<br>Indicated whether this is the element reporting. Even though there might be more than one element installed, only will be reporting at any time. Will not be present if the element is not installed.

=end html

=back



=over 2

=item * I<es-electronics-serial-no>  =>   B<string, optional>

=begin html

<br>Serial number for the enclosure services electronics. Will not be present if the element is not installed.

=end html

=back



=over 2

=item * I<es-part-number>  =>   B<string, optional>

=begin html

<br>Part number for the ES electronics. Field will be missing if the information is not available or if the element is not installed.

=end html

=back



=over 2

=item * I<es-revision>  =>   B<string, optional>

=begin html

<br>CPLD revision of the ES electronics, if applicable. This field will not be present if the information is not available, not implemented, or if the element is not installed.

=end html

=back



=over 2

=item * I<es-swap-count>  =>   B<integer, optional>

=begin html

<br>Number of times, since last boot, that this ES electronics elements has been swapped. Will not be present if the element is not installed.

=end html

=back



=over 2

=item * I<esh-list>  =>   B<L<"esh-info">[], optional>

=begin html

<br>Information on attached embedded switched hub, if any.

=end html

=back



=head2 esh-info

=begin html

Information on individual ESH modules in the shelf.

=end html



B<Fields>

=over 2

=item * I<esh-element-no>  =>   B<integer>

=begin html

<br>ESH element number of installed ESH module

=end html

=back



=over 2

=item * I<esh-is-error>  =>   B<string>

=begin html

<br>Indicates whether the ESH module has reported any errors.

=end html

=back



=head2 eurologic-specific-info

=begin html

Vendor specific enclosure system information for Eurologic shelf.

=end html



B<Fields>

=over 2

=item * I<eurologic-application-version>  =>   B<string>

=begin html

<br>Application version for Eurologic shelf.

=end html

=back



=over 2

=item * I<eurologic-backplane-byte>  =>   B<string>

=begin html

<br>Backplane byte for Eurologic shelf.

=end html

=back



=over 2

=item * I<eurologic-backplane-function>  =>   B<string>

=begin html

<br>Backplane function for Eurologic shelf.

=end html

=back



=over 2

=item * I<eurologic-backplane-id>  =>   B<string>

=begin html

<br>Backplane identifier for Eurologic shelf.

=end html

=back



=over 2

=item * I<eurologic-cabinet-id>  =>   B<string>

=begin html

<br>Cabinet id for the Eurologic shelf.

=end html

=back



=over 2

=item * I<eurologic-kernel-version>  =>   B<string>

=begin html

<br>Kernel version for Eurologic shelf.

=end html

=back



=over 2

=item * I<eurologic-serial-no>  =>   B<string, optional>

=begin html

<br>Serial number for the Eurologic shelf.

=end html

=back



=head2 module-info

=begin html

Shelf enclosure module info.

=end html



B<Fields>

=over 2

=item * I<is-module-error>  =>   B<boolean>

=begin html

<br>Indicated whether this module has encountered an error.

=end html

=back



=over 2

=item * I<is-sas-expander-master-module>  =>   B<boolean, optional>

=begin html

<br>When the value of enclosure-type field of enclosure-type-info is sas-expander-module, then this field indicates whether this module is the SAS expander master module. This field will only be present for sas-expander-module values.

=end html

=back



=over 2

=item * I<module-number>  =>   B<integer>

=begin html

<br>shelf module number.

=end html

=back



=head2 phy-expander-info

=begin html

Expander PHY (physical layer) information of an individual port.

=end html



B<Fields>

=over 2

=item * I<bay-number>  =>   B<integer, optional>

=begin html

<br>Bay port number. Unique bay-number for each type of phy-type. Present when multiple phy's for a phy-type exist in the shelf, such as phy-type "disk", "P0", "P1".

=end html

=back



=over 2

=item * I<crc-error-count>  =>   B<integer>

=begin html

<br>This field presents the number of CRC errors that have been seen in any address or data frames. The value will be the count kept by the expander since either power-on or since the counts have been reset.

=end html

=back



=over 2

=item * I<dongle-data>  =>   B<L<"dongle-info">, optional>

=begin html

<br>dongle information, if there's a dongle installed. Will be missing if not supported or not available. Present for drive phy only.

=end html

=back



=over 2

=item * I<invalid-dword-count>  =>   B<integer>

=begin html

<br>The number of invalid double words seen outside of the phy reset sequence. The value will be the count kept by the expander since either power-on or since the counts have been reset.

=end html

=back



=over 2

=item * I<link-rate>  =>   B<string, optional>

=begin html

<br>If port-state is "ok", then this is a floating number, representing SAS-1.1 defined negotiated link rate value for the phy in Gb/s. Example: 3.0. For all other port states, this field will not be available.

=end html

=back



=over 2

=item * I<loss-dword-count>  =>   B<integer>

=begin html

<br>This field presents the number of times the phy has lost double-word synchronization and restarted the link reset sequence of the phy reset sequence. The value will be the count kept by the expander since either power-on or since the counts have been reset.

=end html

=back



=over 2

=item * I<pathway-timeout>  =>   B<integer>

=begin html

<br>This field the partial pathway timeout value, in microseconds, being used for the phy.

=end html

=back



=over 2

=item * I<phy-change-count>  =>   B<integer>

=begin html

<br>This field the number of times this logical phy has changed state. This count increments when the logical phy transitions from disabled to enabled. This count also increments when the logical phys transitions from enabled to disabled. The value will be the count kept by the expander since either power-on or since the counts have been reset.

=end html

=back



=over 2

=item * I<phy-number>  =>   B<integer, optional>

=begin html

<br>PHY number. Unique phy-number in the shelf, regardless of phy-type.

=end html

=back



=over 2

=item * I<phy-power-status>  =>   B<string, optional>

=begin html

<br>Current power status. Possible values: "on", "off". Will be missing if not supported or not available. Present for drive phy only.

=end html

=back



=over 2

=item * I<phy-reset-problem>  =>   B<integer>

=begin html

<br>This field presents the number of times the phy reset sequence has failed. The value will be the count kept by the expander since either power-on or since the counts have been reset.

=end html

=back



=over 2

=item * I<phy-state>  =>   B<string, optional>

=begin html

<br>State of the phy. Possible values: "rate_unknown", "disabled", "speed_negotiation_failed", "sata_oob_failed", "1.5_gbps", "3.0_gbps", "6.0_gbps", "state_unknown",

=end html

=back



=over 2

=item * I<phy-type>  =>   B<string, optional>

=begin html

<br>PHY type. Possible values: "disk", "p0", "p1", "v255", "v99".

=end html

=back



=over 2

=item * I<port-id>  =>   B<string>

=begin html

<br>Possible values are: port id in range [0..19] or "in0", "in1", "in2", "in3", "out0", "out1", "out2", "out3", representing one of the input or output ports.

=end html

=back



=over 2

=item * I<port-state>  =>   B<string>

=begin html

<br>Current port state. Possible values are: "ok", "unkwn_lnk", "unused", "unkwn", "empty", "dis_man", "dis_smp", "dis_loswd", "dis_dispa", "dis_invwd", "dis_reset", "dis_phchg", "dis_mir", "dis_crc", "dis_clk", "dis_resv", "dis_unusd", "unknown", "no_signal",

=end html

=back



=over 2

=item * I<power-cycle-count>  =>   B<integer, optional>

=begin html

<br>This field presents the number of times the driver has been power cycled via this phy. Will be missing if not supported or not available. Present for drive phy only.

=end html

=back



=over 2

=item * I<release-count>  =>   B<integer, optional>

=begin html

<br>This field presents the number of times the driver has been released (unreserved) via this phy. Will be missing if not supported or not available. Present for drive phy only.

=end html

=back



=over 2

=item * I<reserve-count>  =>   B<integer, optional>

=begin html

<br>This field presents the number of times the driver has been reserved via this phy. Will be missing if not supported or not available. Present for drive phy only.

=end html

=back



=over 2

=item * I<running-disparity-count>  =>   B<integer>

=begin html

<br>The number of Dwords with a running disparity error seen outside the phy reset sequence. The value will be the count kept by the expander since either power-on or since the counts have been reset.

=end html

=back



=head2 port-hub-info

=begin html

Hub information for an individual port.

=end html



B<Fields>

=over 2

=item * I<clock-delta>  =>   B<integer>

=begin html

<br>The clock delta between this port in respect to ESH clock and other ports in the ESH.

=end html

=back



=over 2

=item * I<disk-bay>  =>   B<integer, optional>

=begin html

<br>If port-id is "in", "out", "aux1" or "aux2" then this is not populated, otherwise, it represents the shelf bay that the disk resides in.

=end html

=back



=over 2

=item * I<insert-count>  =>   B<integer>

=begin html

<br>Number of times this port has been inserted into the loop.

=end html

=back



=over 2

=item * I<invalid-crc-count>  =>   B<integer>

=begin html

<br>Number of times this port has seen a CRC error.

=end html

=back



=over 2

=item * I<invalid-word-count>  =>   B<integer>

=begin html

<br>Number of times this port has seen invalid FC-AL words transmitted.

=end html

=back



=over 2

=item * I<lip-count>  =>   B<integer, optional>

=begin html

<br>Lip count, number of times loop initialization primitive has been generated. This field is not available on all shelf modules.

=end html

=back



=over 2

=item * I<loop-up-count>  =>   B<integer>

=begin html

<br>Number of times this port has seen the loop come up/transition to up.

=end html

=back



=over 2

=item * I<port-id>  =>   B<string>

=begin html

<br>Possible values are: port number in the range of 0 to 255 or "in", "out", "aux1" or "aux2" representing input, output or one of auxiliary ports. This is the same as FCAL ALPA for the port.

=end html

=back



=over 2

=item * I<port-state>  =>   B<string>

=begin html

<br>Current port state. Possible values are: "ok", "empty", "byp_init", "byp_gen", "byp_man", "byp_xmit", "byp_lipf8", "byp_dto", "byp_rlos", "byp_clos", "byp_tbi", "byp_rprt", "byp_stall", "byp_wrd", "byp_crc", "byp_lip", "byp_osc", "byp_clk", "byp_mir", "byp_lipf7", "byp_bzr", "byp_self", "byp_flt", "byp_pwr", "byp_pcycl", "warn_lip", "warn_wrdb", "warn_wrd", "warn_crc", "warn_clk", "unknown", "term-err", "term", "autoterm".

=end html

=back



=over 2

=item * I<stall-count>  =>   B<integer>

=begin html

<br>Number of times this port exceeded the OPN/CLS maximum threshold.

=end html

=back



=over 2

=item * I<utilization-percentage>  =>   B<integer>

=begin html

<br>Relative utilization of this port vs. other ports in the ESH.

=end html

=back



=head2 power-supply-info

=begin html

Power supply information

=end html



B<Fields>

=over 2

=item * I<is-auto-power-reset-enabled>  =>   B<boolean, optional>

=begin html

<br>Indicates whether the auto power reset of the supply is enabled. This field will not be present if the power supply is missing.

=end html

=back



=over 2

=item * I<is-power-reset-capable>  =>   B<boolean, optional>

=begin html

<br>Indicates whether the power supply can be reset via software control. This field will not be present if power supply is missing.

=end html

=back



=over 2

=item * I<power-supply-element-number>  =>   B<integer>

=begin html

<br>Element number the power supply.

=end html

=back



=over 2

=item * I<power-supply-firmware-revision>  =>   B<string, optional>

=begin html

<br>Power supply firmware revision. This field will not be present if firmware rev is unavailable or feature not implemented, or if the power supply is missing.

=end html

=back



=over 2

=item * I<power-supply-is-error>  =>   B<boolean, optional>

=begin html

<br>Indicates whether the power supply has reported any errors. This field will not be present if the power supply is missing.

=end html

=back



=over 2

=item * I<power-supply-is-not-installed>  =>   B<boolean, optional>

=begin html

<br>Indicates the power supply for this element is not installed. This will only be presented if the power supply is missing, in which case no further information for the element will be available.

=end html

=back



=over 2

=item * I<power-supply-part-no>  =>   B<string, optional>

=begin html

<br>Power supply part number. The field will not be present if part number is unavailable or not implemented or if the power supply is missing.

=end html

=back



=over 2

=item * I<power-supply-serial-no>  =>   B<string, optional>

=begin html

<br>Power supply serial number. This field will not be present if the power supply is missing.

=end html

=back



=over 2

=item * I<power-supply-swap-count>  =>   B<integer, optional>

=begin html

<br>Number of power supply swap counts since boot. This field will not be present if the power supply is missing.

=end html

=back



=over 2

=item * I<power-supply-type>  =>   B<string, optional>

=begin html

<br>Power supply type. This field will not be present if power supply type is unavailable or feature is not implemented, or if the power supply is missing.

=end html

=back



=head2 processor-complex-info

=begin html

Available information on the processor complex modules (PCMs) in the shelf.

=end html



B<Fields>

=over 2

=item * I<is-pcm-element-error>  =>   B<boolean, optional>

=begin html

<br>Indicates if there has been a failure in the PCM. Will not be present if a PCM element is not installed.

=end html

=back



=over 2

=item * I<is-pcm-element-not-installed>  =>   B<boolean, optional>

=begin html

<br>Indicates if PCM element has been installed. Will be present only if the element is not installed, in which case no further information will be provided.

=end html

=back



=over 2

=item * I<pcm-element-no>  =>   B<integer>

=begin html

<br>PCM element number

=end html

=back



=head2 sas-connector-info

=begin html

Detailed information on SAS cables and connectors connected to the shelf. Only information on the connectors with cables attached will be presented.

=end html



B<Fields>

=over 2

=item * I<cable-end-identifier>  =>   B<string, optional>

=begin html

<br>Each cable has two ends. This field shows which end of the cable is connected to the shelf. This field will not be present if the information is not available or accessible, or if a cable is not connected at this connector. Possible values: "end_0", "end_1".

=end html

=back



=over 2

=item * I<cable-length>  =>   B<string, optional>

=begin html

<br>Cable length. This field will not be present if the information is not available or accessible, or if a cable is not connected at this connector.

=end html

=back



=over 2

=item * I<cable-manufacturer>  =>   B<string, optional>

=begin html

<br>Manufacturer of the cable. Will not be present if a cable is not connected at this connector.

=end html

=back



=over 2

=item * I<cable-part-no>  =>   B<string, optional>

=begin html

<br>Part number of the cable as assigned by the cable manufacturer. This field will not be present if the information is not available, or if a cable is not connected at this connector.

=end html

=back



=over 2

=item * I<cable-serial-no>  =>   B<string, optional>

=begin html

<br>Serial number of the cable as assigned by the cable manufacturer. This field will not be present if the information is not available, or if a cable is not connected at this connector.

=end html

=back



=over 2

=item * I<cable-technology>  =>   B<string, optional>

=begin html

<br>Cable technology. This field will not be present if the information is not available or accessible, or if a cable is not connected at this connector. Possible values: "cupper", "optical".

=end html

=back



=over 2

=item * I<cable-type>  =>   B<string, optional>

=begin html

<br>Type of the cable being used. This field will not be present if the information is not available or accessible, or if a cable is not connected at this connector. Possible values: "qsfp".

=end html

=back



=over 2

=item * I<connector-designator>  =>   B<string, optional>

=begin html

<br>Connector desiagnator. <ul> <li> "sqr" - The port is marked with a square on the shelf connector panel, <li> "cir" - The port is marked with a circle on the shelf connector panel. </ul> Will be missing if unknown or not available.

=end html

=back



=over 2

=item * I<connector-no>  =>   B<integer>

=begin html

<br>Connector number.

=end html

=back



=over 2

=item * I<is-cable-connected>  =>   B<boolean>

=begin html

<br>Indicates whether a cable is connected at this connector location. No further information will be provided if a cable is not connected at this connector location. Note that a cable connection does not necessarily mean that the shelf is connected to a storage cointroller. This will also depend on the other end of the cable.

=end html

=back



=over 2

=item * I<is-connector-error>  =>   B<boolean, optional>

=begin html

<br>Indicates whether the connector element has encountered an error.

=end html

=back



=over 2

=item * I<shelf-module>  =>   B<string, optional>

=begin html

<br>Shelf module for this connector <ul> <li> "a" - Presenting data for shelf module A. <li> "b" - Presenting data for shelf module B. </ul>

=end html

=back



=over 2

=item * I<swap-count>  =>   B<integer, optional>

=begin html

<br>Number of times, since last boot, a cable has been inserted into this connector

=end html

=back



=head2 sas-specific-info

=begin html

Vendor specific enclosure system information for SAS shelf.

=end html



B<Fields>

=over 2

=item * I<serial-no>  =>   B<string>

=begin html

<br>Shelf backplane serial number.

=end html

=back



=head2 ses-generic-info

=begin html

Generic SES (SCSI enclosure services) information.

=end html



B<Fields>

=over 2

=item * I<ses-chassis-part-number>  =>   B<string, optional>

=begin html

<br>Chassis part number. The field will not be present if the part number is unavailable or not implemented.

=end html

=back



=over 2

=item * I<ses-config-access>  =>   B<string, optional>

=begin html

<br>The method shelf configuration was obtained. Possible values: "via_embedded_ses", "via_scsi_from_shelf", "via_loop_from_shelf", "remote_access_via_controller", "not_available".

=end html

=back



=over 2

=item * I<ses-config-access-controller-name>  =>   B<string, optional>

=begin html

<br>If the value of ses-config-access field is "remote_access_via_controller" then this field will return the name of storage controller the configuration was obtained from. This field will not be present if storage controller name is not available or if the value of ses-config-access field is not "remote_access_via_controller".

=end html

=back



=over 2

=item * I<ses-config-access-shelf-id>  =>   B<string, optional>

=begin html

<br>If ses-config-access is either "via_scsi_from_shelf" or "via_loop_from_shelf" then this would be the shelf id of the device the configuration was obtained from.

=end html

=back



=over 2

=item * I<ses-config-access-source-id>  =>   B<integer, optional>

=begin html

<br>If ses-config-access is either "via_scsi_from_shelf" or "via_loop_from_shelf" then this would be the SCSI or loop id of the device that the configuration was obtained from.

=end html

=back



=over 2

=item * I<ses-contact-state>  =>   B<string>

=begin html

<br>Enclosure contact state. Possible values are: "active", "initializing", "transitioning", "inactive", "reconfiguring", "non_existent".

=end html

=back



=over 2

=item * I<ses-logical-id>  =>   B<string>

=begin html

<br>Enclosure logical identifier.

=end html

=back



=over 2

=item * I<ses-product-id>  =>   B<string, optional>

=begin html

<br>Enclosure product identifier. Not available on all shelf types.

=end html

=back



=over 2

=item * I<ses-product-revision>  =>   B<string>

=begin html

<br>Enclosure product revision.

=end html

=back



=over 2

=item * I<ses-vendor-id>  =>   B<string>

=begin html

<br>Enclosure vendor identifier.

=end html

=back



=head2 shelf-bay-info

=begin html

Shelf bay information.

=end html



B<Fields>

=over 2

=item * I<bay-count>  =>   B<integer, optional>

=begin html

<br>Disk bays are the slots into which disks are placed. The bays are numbered from 0 to bay-count-1. Bay 0 is the right most bay (when looking at the front of the shelf) and bay bay-count-1 is left most. These bay numbers can be used by other commands, including storage-shelf-set-led-state.

=end html

=back



=over 2

=item * I<bay-list>  =>   B<L<"bay-info">[]>

=begin html

<br>A list of shelf-bay numbers which have disk drives. The bay-list field is not optional, but it may contain zero bay-info elements.

=end html

=back



=head2 shelf-bay-list-info

=begin html

Bay and port information on a shelf module.

=end html



B<Fields>

=over 2

=item * I<channel-name>  =>   B<string>

=begin html

<br>The channel the shelf (hub) is attached to. Example: 0c.

=end html

=back



=over 2

=item * I<module>  =>   B<string>

=begin html

<br>The shelf module attachment. Possible values: "a", "b".

=end html

=back



=over 2

=item * I<port-list>  =>   B<L<"shelf-bay-port-info">[], optional>

=begin html

<br>Shelf bay specific information.

=end html

=back



=over 2

=item * I<shelf-id>  =>   B<integer>

=begin html

<br>The shelf id switch setting. This is the shelf id switch that is used to uniquely identify the shelf on the filer node.

=end html

=back



=over 2

=item * I<shelf-name>  =>   B<string>

=begin html

<br>Shelf name that the hub is attached to. This can also be considered as hub name. Example: 0c.shelf1.

=end html

=back



=over 2

=item * I<shelf-state>  =>   B<string>

=begin html

<br>Current state of the shelf. Possible values are: "no_status", "init_required", "online", "offline", "missing", "failed", "unknown".

=end html

=back



=over 2

=item * I<shelf-type>  =>   B<string>

=begin html

<br>Shelf module type. Possible values: "edm", "vem", "esp", "lrc", "esh", "esh2", "esh4", "eshfx", "eshtx", "emu", "efh", "at-fc", "at-fc2", "at-fcx", "at-fcx2", "sas", "esas", "sas-fc", "iom3", "iom6".

=end html

=back



=over 2

=item * I<shelf-uid>  =>   B<string>

=begin html

<br>Shelf unique identifier that distinguishes it from other shelves manufactured. Example: 50:05:0c:c0:02:10:64:26.

=end html

=back



=head2 shelf-bay-port-info

=begin html

Shelf bay port specific information.

=end html



B<Fields>

=over 2

=item * I<bay-no>  =>   B<integer, optional>

=begin html

<br>Disk bay number or port number, if applicable. In some instances bay numbers do apply and will not be present. An example is an ESH shelf with a single "in" and a single "out" port.

=end html

=back



=over 2

=item * I<disk-name>  =>   B<string, optional>

=begin html

<br>if port-designator is "disk_bay" and there is a disk installed in the bay, then this will be the disk name. Otherwise the field will be missing.

=end html

=back



=over 2

=item * I<disk-uid>  =>   B<string, optional>

=begin html

<br>if port-designator is "disk_bay" and there is a disk installed in the bay, then this will be UID of the disk. Otherwise the field will be missing.

=end html

=back



=over 2

=item * I<port-designator>  =>   B<string, optional>

=begin html

<br>Shelf bay port designator. Possible values: "in", "out", "aux", "sqr", "cir", "sil", "hi_lo", "a_to_b", "b_to_a", "disk_bay".

=end html

=back



=over 2

=item * I<port-state>  =>   B<string, optional>

=begin html

<br>Current port state. Possible values are: "ok", "empty", "unkwn_lnk", "no_signal", "unused", "unkwn", "unknown", "dis_man", "dis_unusd", "dis_smp", "dis_loswd", "dis_dispa", "dis_invwd", "dis_reset", "dis_phchg", "dis_mir", "dis_crc", "dis_clk", "byp_init", "byp_gen", "byp_man", "byp_xmit", "byp_lipf8", "byp_dto", "byp_rlos", "byp_clos", "byp_tbi", "byp_rprt", "byp_stall", "byp_wrd", "byp_crc", "byp_lip", "byp_osc", "byp_clk", "byp_mir", "byp_lipf7", "byp_bzr", "byp_self", "byp_flt", "byp_pwr", "byp_pcycl", "warn_lip", "warn_wrdb", "warn_wrd", "warn_crc", "warn_clk", "term-err", "term", "autoterm".

=end html

=back



=head2 shelf-environ-channel-address-map

=begin html

A list of all the shelf assigned addresses assigned on this channel.

=end html



B<Fields>

=over 2

=item * I<address-map>  =>   B<string>

=begin html

<br>A comma separated list of addresses assigned on this channel by the shelf specified in shelf-no output above.

=end html

=back



=over 2

=item * I<shelf-id>  =>   B<integer>

=begin html

<br>Shelf number for presented address map.

=end html

=back



=head2 shelf-environ-channel-info

=begin html

Shelf environment information.

=end html



B<Fields>

=over 2

=item * I<channel-name>  =>   B<string>

=begin html

<br>Storage controller channel the shelf is connected to.

=end html

=back



=over 2

=item * I<is-channel-monitor-enabled>  =>   B<boolean>

=begin html

<br>Indicates whether monitoring is enabled on this channel.

=end html

=back



=over 2

=item * I<is-shelf-channel-failure>  =>   B<boolean>

=begin html

<br>Indicates whether any shelves on this channel have experienced a failure.

=end html

=back



=over 2

=item * I<shelf-environ-channel-address>  =>   B<L<"shelf-environ-channel-address-map">[], optional>

=begin html

<br>A list of all the shelf assigned addresses assigned on this channel.

=end html

=back



=over 2

=item * I<shelf-environ-shelf-list>  =>   B<L<"shelf-environ-shelf-info">[]>

=begin html

<br>List of shelves in the channel and associated environment information.

=end html

=back



=over 2

=item * I<shelves-present>  =>   B<integer>

=begin html

<br>Number of shelves present on this channel.

=end html

=back



=head2 shelf-environ-shelf-info

=begin html

Shelf environment information.

=end html



B<Fields>

=over 2

=item * I<alternate-control-path-information>  =>   B<L<"alternate-control-path-info">[], optional>

=begin html

<br>Available information on the alternate control path (ACP) to the shelf.

=end html

=back



=over 2

=item * I<ariodata-specific-info>  =>   B<L<"ariodata-specific-info">, optional>

=begin html

<br>Vendor specific enclosure system information for Ariodata shelves.

=end html

=back



=over 2

=item * I<attached-shelf-bay-error-list>  =>   B<string, optional>

=begin html

<br>A list of bays numbers in this shelf that have disk devices with errors. All bays with error devices will be listed. This is a comma separated list from high to low. Example: "13, 10, 4, 1".

=end html

=back



=over 2

=item * I<attached-shelf-bay-list>  =>   B<string>

=begin html

<br>A list of bays numbers in this shelf that have disk devices installed. All bays with disks installed will be listed. This is a comma separated list from high to low. Example: "13, 11, 10, 4, 3, 2, 1".

=end html

=back



=over 2

=item * I<connector-information>  =>   B<L<"connector-info">[], optional>

=begin html

<br>Cable and connector information if available and supported by the hardware. Will not be present if the feature is not supported in the hardware.

=end html

=back



=over 2

=item * I<control-writes-attempted>  =>   B<integer>

=begin html

<br>Number of times attempted to write shelf controls.

=end html

=back



=over 2

=item * I<control-writes-failed>  =>   B<integer>

=begin html

<br>Number of times failed to write shelf controls.

=end html

=back



=over 2

=item * I<controller-device-path>  =>   B<string>

=begin html

<br>Device path to the shelf controller. Possible values: "embedded_access", "local_access", "unknown", "not_available".

=end html

=back



=over 2

=item * I<controller-device-path-port>  =>   B<string, optional>

=begin html

<br>If controller-device-path is "local_access", then this presents the local access port number.

=end html

=back



=over 2

=item * I<cooling-element-list>  =>   B<L<"cooling-element-info">[], optional>

=begin html

<br>Information on installed cooling elements in the shelf.

=end html

=back



=over 2

=item * I<current-sensor-list>  =>   B<L<"current-sensor-info">[], optional>

=begin html

<br>Information on current sensors in the shelf.

=end html

=back



=over 2

=item * I<enclosure-information>  =>   B<L<"enclosure-info">, optional>

=begin html

<br>Information on the enclosure type. This information will be presented for ESH and SAS shelves only.

=end html

=back



=over 2

=item * I<es-electronics-list>  =>   B<L<"es-electronics-info">[], optional>

=begin html

<br>Information on the installed enclosure services electronics.

=end html

=back



=over 2

=item * I<eurologic-specific-info>  =>   B<L<"eurologic-specific-info">, optional>

=begin html

<br>Vendor specific enclosure system information for Eurologic shelves.

=end html

=back



=over 2

=item * I<is-shelf-monitor-enabled>  =>   B<boolean>

=begin html

<br>Indicates whether monitoring is enabled on this shelf.

=end html

=back



=over 2

=item * I<power-control-failure-state>  =>   B<string, optional>

=begin html

<br>Extension to the power-control-status to provide more information in case of shelf failures. Possible values: "dual_esh4_modules_not_present", "power_control_fault_detected", "incompatible_power_control_implementation", "power_control_function_not_available", "backplane_cpld_fault_detected".

=end html

=back



=over 2

=item * I<power-control-status>  =>   B<string, optional>

=begin html

<br>Power control element status. This is generalization of the ESH4 shelf power status. Currently available on ESH 4 shelves only. Possible values: "ok", "not_supported", "critical", "non_critical", "unknown".

=end html

=back



=over 2

=item * I<power-supply-list>  =>   B<L<"power-supply-info">[], optional>

=begin html

<br>Information on installed power supplies in the shelf.

=end html

=back



=over 2

=item * I<processor-complex-information>  =>   B<L<"processor-complex-info">[], optional>

=begin html

<br>Available information on the processor complex modules (PCMs) in the shelf.

=end html

=back



=over 2

=item * I<sas-specific-info>  =>   B<L<"sas-specific-info">, optional>

=begin html

<br>Vendor specific enclosure system information for SAS shelves.

=end html

=back



=over 2

=item * I<ses-generic-info>  =>   B<L<"ses-generic-info">>

=begin html

<br>Generic SES (scsi enclosure services) information.

=end html

=back



=over 2

=item * I<shelf-id>  =>   B<integer>

=begin html

<br>Shelf number.

=end html

=back



=over 2

=item * I<shelf-status>  =>   B<string>

=begin html

<br>Current shelf status. Possible values: "unrecoverable", "critical", "non_critical", "informational", "normal".

=end html

=back



=over 2

=item * I<shelf-type>  =>   B<string>

=begin html

<br>Shelf type. Possible values: "edm", "vem", "esp", "lrc", "lrc2", "esh", "esh2", "esh4", "eshfx", "emu", "efh", "eshtx", "sas", "esas", "sas_fc", "iom3", "at_fcx", "at_fcx2", "iom6", "iom6e".

=end html

=back



=over 2

=item * I<status-reads-attempted>  =>   B<integer>

=begin html

<br>Number of times attempted to read shelf status.

=end html

=back



=over 2

=item * I<status-reads-failed>  =>   B<integer>

=begin html

<br>Number of times failed to read shelf status.

=end html

=back



=over 2

=item * I<temp-sensor-list>  =>   B<L<"temp-sensor-info">[], optional>

=begin html

<br>Information on installed temperature sensors in the shelf.

=end html

=back



=over 2

=item * I<voltage-sensor-list>  =>   B<L<"voltage-sensor-info">[], optional>

=begin html

<br>Information on voltage sensors in the shelf.

=end html

=back



=over 2

=item * I<xyratex-specific-info>  =>   B<L<"xyratex-specific-info">, optional>

=begin html

<br>Vendor specific enclosure system information for Xyratex shelves.

=end html

=back



=head2 shelf-info

=begin html

Describes a shelf.

=end html



B<Fields>

=over 2

=item * I<channel-name>  =>   B<string>

=begin html

<br>The channel/port-number the shelf (hub) is attached to. If it is the partner node that is being reported, the value will be shown as "PARTNER". Examples: "0c" or "PARTNER".

=end html

=back



=over 2

=item * I<firmware-rev-A>  =>   B<string, optional>

=begin html

<br>Shelf Module A firmware revision. When the channel-name field is "PARTNER" this field will not be present.

=end html

=back



=over 2

=item * I<firmware-rev-B>  =>   B<string, optional>

=begin html

<br>Shelf Module B firmware revision. When the channel-name field is "PARTNER" this field will not be present.

=end html

=back



=over 2

=item * I<module>  =>   B<string>

=begin html

<br>The shelf module attachment. Possible values are: "a", "b".

=end html

=back



=over 2

=item * I<module-state>  =>   B<string, optional>

=begin html

<br>Current state of the IO module attached to the shelf port (if any). Possible values are: "no_status", "ok", "missing", "transport error", "critical", "unreachable", "unknown".

=end html

=back



=over 2

=item * I<phy-expander-list>  =>   B<L<"phy-expander-info">[], optional>

=begin html

<br>Each instance of phy-expander-list contains PHY (physical layer) expander information about each port. This applies to direct attached shelves with SAS modules only.

=end html

=back



=over 2

=item * I<port-hub-list>  =>   B<L<"port-hub-info">[], optional>

=begin html

<br>Each instance of port-hub-list contains hub information about each port. This applies to shelves with ESH modules only.

=end html

=back



=over 2

=item * I<shelf-bay-info>  =>   B<L<"shelf-bay-info">, optional>

=begin html

<br>Detailed information on populated shelf bays. When the channel-name field is "PARTNER" this field will not be present.

=end html

=back



=over 2

=item * I<shelf-id>  =>   B<integer>

=begin html

<br>The shelf id switch setting. This is the shelf id switch that is used to uniquely identify the shelf on the filer node.

=end html

=back



=over 2

=item * I<shelf-name>  =>   B<string>

=begin html

<br>Shelf name that the hub is attached to. This can also be considered as hub name. Example: 0c.shelf1.

=end html

=back



=over 2

=item * I<shelf-state>  =>   B<string>

=begin html

<br>Current state of the shelf. Possible values are: "no status", "init required", "online", "offline", "missing", "unknown".

=end html

=back



=over 2

=item * I<shelf-type>  =>   B<string>

=begin html

<br>Shelf module type. Some examples are: "esh2", and "at-fcx".

=end html

=back



=over 2

=item * I<shelf-uid>  =>   B<string>

=begin html

<br>Similar to serial number, this is the shelf unique identifier that distinguishes it from any other shelf manufactured. Example: 50:05:0c:c0:02:10:64:26.

=end html

=back



=over 2

=item * I<termination-switch>  =>   B<string, optional>

=begin html

<br>State of the termination switch on the shelf. Possible values are: "on", "off" and "n/a".

=end html

=back



=head2 temp-sensor-info

=begin html

information on the temperature sensors installed in the shelf.

=end html



B<Fields>

=over 2

=item * I<temp-sensor-current-condition>  =>   B<string, optional>

=begin html

<br>Current temperature condition for this sensor. One of: "under_temperature_warning", "under_temperature_failure", "over_temperature_warning", "over_temperature_failure", "normal_temperature_range".

=end html

=back



=over 2

=item * I<temp-sensor-current-temperature>  =>   B<integer, optional>

=begin html

<br>Current temperature reading in degrees Celsius.

=end html

=back



=over 2

=item * I<temp-sensor-element-no>  =>   B<integer>

=begin html

<br>Element number for the temperature sensor.

=end html

=back



=over 2

=item * I<temp-sensor-hi-critical>  =>   B<integer>

=begin html

<br>High critical temperature in degree Celsius.

=end html

=back



=over 2

=item * I<temp-sensor-hi-warning>  =>   B<integer>

=begin html

<br>High warning temperature in degree Celsius.

=end html

=back



=over 2

=item * I<temp-sensor-is-ambient>  =>   B<boolean, optional>

=begin html

<br>Indicates whether the temp-sensor-current-temp is the ambient temperature.

=end html

=back



=over 2

=item * I<temp-sensor-is-error>  =>   B<boolean, optional>

=begin html

<br>Indicates whether the sensor has indicated an error in temperature.

=end html

=back



=over 2

=item * I<temp-sensor-is-not-installed>  =>   B<string, optional>

=begin html

<br>Indicates the sensor for this element is not installed. This will only be presented if the sensor is missing, and no further data for this sensor will be presented.

=end html

=back



=over 2

=item * I<temp-sensor-low-critical>  =>   B<integer>

=begin html

<br>Low critical temperature in degree Celsius.

=end html

=back



=over 2

=item * I<temp-sensor-low-warning>  =>   B<integer>

=begin html

<br>Low warning temperature in degree Celsius.

=end html

=back



=head2 voltage-sensor-info

=begin html

Presents the voltage sensor information, if implemented on the system.

=end html



B<Fields>

=over 2

=item * I<is-sensor-error>  =>   B<boolean, optional>

=begin html

<br>Indicates whether the sensor has encountered an error.

=end html

=back



=over 2

=item * I<is-sensor-not-installed>  =>   B<boolean, optional>

=begin html

<br>Indicates the voltage sensor elements is not installed. This will only be present if the element is missing, in such case no further data for this element will be presented.

=end html

=back



=over 2

=item * I<sensor-condition>  =>   B<string, optional>

=begin html

<br>A Text string describing whether the sensor-reading field is within normal operating range. This field is present only if sensor-reading field is also present. Possible values are: "overvoltage_failure", "overvoltage_warning", "undervoltage_warning", "undervoltage_failure", "normal_operating_range".

=end html

=back



=over 2

=item * I<sensor-reading>  =>   B<string, optional>

=begin html

<br>Voltage reading of the sensor. This field will be not be present if unable to read the sensor value properly.

=end html

=back



=over 2

=item * I<voltage-sensor-no>  =>   B<integer>

=begin html

<br>Voltage sensor number.

=end html

=back



=head2 xyratex-specific-info

=begin html

Vendor specific enclosure system information for Xyratex shelf.

=end html



B<Fields>

=over 2

=item * I<xyratex-option-setting>  =>   B<string>

=begin html

<br>Option setting for the Xyratex shelf.

=end html

=back



=over 2

=item * I<xyratex-serial-no>  =>   B<string>

=begin html

<br>serial number for Xyratex shelf.

=end html

=back



=head2 dense-status

=begin html

null

=end html



B<Fields>

=over 2

=item * I<blocks-skipped-sharing>  =>   B<integer, optional>

=begin html

<br>Number of blocks not considered for sharing because contiguous duplicate blocks were less than the value set for minimum-blocks-shared. Returned only if verbose option is set. This parameter is not supported on Infinite Volumes.

=end html

=back



=over 2

=item * I<changelog-used-percent>  =>   B<integer, optional>

=begin html

<br>Percentage of changelog used. Returned only if verbose option is set. This parameter is not supported on Infinite Volumes.

=end html

=back



=over 2

=item * I<checkpoint-op-type>  =>   B<string, optional>

=begin html

<br>Checkpoint Operation Type. Possible values: <ul> <li> "-", <li> "Scan", <li> "Start", <li> "Check", <li> "Undo", <li> "Downgrade" </ul> Returned only if verbose option is set. This field is deprecated in Data ONTAP 8.1 and later. This parameter is not supported on Infinite Volumes.

=end html

=back



=over 2

=item * I<checkpoint-progress>  =>   B<string, optional>

=begin html

<br>Checkpoint Stage Progress with information as to which stage of sis is checkpointed and how much data is processed for that stage. For example: 25 MB Scanned, 20 MB Searched, 40 MB (20%) Done, 30 MB Verified. Returned only if verbose option is set. This field is deprecated in Data ONTAP 8.1 and later. This parameter is not supported on Infinite Volumes.

=end html

=back



=over 2

=item * I<checkpoint-stage>  =>   B<string, optional>

=begin html

<br>Checkpoint Stage information. Possible values: <ul> <li> "-", <li> "Gathering", <li> "Sorting", <li> "Saving_pass1", <li> "Saving_pass2", <li> "Checking", <li> "Checking_pass1", <li> "Checking_pass2", <li> "Compress_preproc", <li> "Compressing", <li> "Saving_sharing", <li> "Saving_end", <li> "Unknown_stage" </ul> Returned only if verbose option is set. This field is deprecated in Data ONTAP 8.1 and later. This parameter is not supported on Infinite Volumes.

=end html

=back



=over 2

=item * I<checkpoint-sub-stage>  =>   B<string, optional>

=begin html

<br>Checkpoint Sub Stage information. Possible values: <ul> <li> "-", <li> "Sort_pass1", <li> "Sort_p1merge", <li> "Sort_pass2", <li> "Bucket_sort_init", <li> "Bucket_sort", <li> "Bucket_sort_done" </ul> Returned only if verbose option is set. This field is deprecated in Data ONTAP 8.1 and later. This parameter is not supported on Infinite Volumes.

=end html

=back



=over 2

=item * I<checkpoint-time>  =>   B<integer, optional>

=begin html

<br>Checkpoint creation timestamp. The value is in seconds since January 1, 1970. Returned only if verbose option is set. This field is deprecated in Data ONTAP 8.1 and later. This parameter is not supported on Infinite Volumes.

=end html

=back



=over 2

=item * I<is-compression-enabled>  =>   B<boolean, optional>

=begin html

<br>compression state of the volume Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<is-idd-enabled>  =>   B<boolean, optional>

=begin html

<br>Indicates incompressible data detection is enabled. Possible values: <ul> <li> "true", <li> "false" </ul> Once this set to 'true', inline compression will do a 4k compression quick check for large files before proceeding with full CG compression. If quick check finds a 4k within a CG as incompressible, inline compression won't attempt to compress the CG. Also indicates file level incompressible data detection is enabled for small files. Once this is enabled, when inline compression encounters a incompressible CG within a small file, it will mark the file with do not compress flag. As long as this flag is set on a small file, inline compression won't attempt to compress the file. This parameter is not supported on Infinite Volumes.

=end html

=back



=over 2

=item * I<is-inline-compression-enabled>  =>   B<boolean, optional>

=begin html

<br>inline compression state of the volume Attributes: non-creatable, non-modifiable

=end html

=back



=over 2

=item * I<last-operation-begin-timestamp>  =>   B<integer, optional>

=begin html

<br>Start timestamp of the last sis operation. The value is in seconds since January 1, 1970. Returned only if verbose option is set. This parameter is not supported on Infinite Volumes.

=end html

=back



=over 2

=item * I<last-operation-end-timestamp>  =>   B<integer, optional>

=begin html

<br>End timestamp of the last sis operation. The value is in seconds since January 1, 1970. Returned only if verbose option is set. This parameter is not supported on Infinite Volumes.

=end html

=back



=over 2

=item * I<last-operation-error>  =>   B<string, optional>

=begin html

<br>A human readable error message of the last sis operation. Present when there was an error. Returned only if verbose option is set. and when there is a valid error. This parameter is not supported on Infinite Volumes.

=end html

=back



=over 2

=item * I<last-operation-size>  =>   B<string, optional>

=begin html

<br>The size of the last sis operation in human readable format. This output element is deprecated in Data ONTAP 8.1. Please use the last-operation-size-bytes output element instead. Returned only if verbose option is set. This parameter is not supported on Infinite Volumes.

=end html

=back



=over 2

=item * I<last-operation-size-bytes>  =>   B<integer, optional>

=begin html

<br>The size in bytes of the last sis operation. Returned only if verbose option is set. This parameter is not supported on Infinite Volumes.

=end html

=back



=over 2

=item * I<last-operation-state>  =>   B<string, optional>

=begin html

<br>Completion status for the last operation. Possible values: <ul> <li> "success", <li> "failure" </ul> Returned only if verbose option is set and when there is last completed operation. This parameter is not supported on Infinite Volumes.

=end html

=back



=over 2

=item * I<last-success-operation-begin-timestamp>  =>   B<integer, optional>

=begin html

<br>Start timestamp of the last successful sis operation. The value is in seconds since January 1, 1970. Returned only if verbose option is set and when there is last successfully completed operation. This parameter is not supported on Infinite Volumes.

=end html

=back



=over 2

=item * I<last-success-operation-end-timestamp>  =>   B<integer, optional>

=begin html

<br>End timestamp of the last successful sis operation. The value is in seconds since January 1, 1970. Returned only if verbose option is set and when there is last successfully completed operation. This parameter is not supported on Infinite Volumes.

=end html

=back



=over 2

=item * I<logical-data>  =>   B<L<"sis-logical-data">, optional>

=begin html

<br>This contains logical size attributes of a volume. Returned only if verbose option is set. This parameter is not supported on Infinite Volumes.

=end html

=back



=over 2

=item * I<minimum-blocks-shared>  =>   B<integer, optional>

=begin html

<br>The minimum number of contiguous blocks in a file that will be considered for block sharing. If the number of contiguous duplicate blocks is less than this number, then they won't be considered for sharing. Returned only if verbose option is set.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Volume for which sis information is returned.

=end html

=back



=over 2

=item * I<progress>  =>   B<string>

=begin html

<br>The progress of the current sis operation with information as to which stage is currently in progress and how much data is processed for that stage. For example: 25 MB Scanned, 20 MB Searched, 40 MB (20%) Done, 30 MB Verified. This parameter is not supported on Infinite Volumes.

=end html

=back



=over 2

=item * I<queued-job-type>  =>   B<string, optional>

=begin html

<br>Type of sis operation that is queued for the volume. Possible values: <ul> <li> "-" - No sis operation is queued for the volume, <li> "Scan", <li> "Start", <li> "Check", <li> "Downgrade" </ul> Returned only if verbose option is set. This parameter is not supported on Infinite Volumes.

=end html

=back



=over 2

=item * I<quick-check-fsize>  =>   B<integer, optional>

=begin html

<br>Quick check file size for Incompressible Data Detection. If Incompressible data detection is enabled and if the file size is >= quick-check-fsize, inline compression will do a 4k quick check before doing full CG compression. This parameter is not supported on Infinite Volumes.

=end html

=back



=over 2

=item * I<schedule>  =>   B<string, optional>

=begin html

<br>The schedule for sis operation on the volume. See sis-set-config for the format of the schedule. Returned only if verbose option is set.

=end html

=back



=over 2

=item * I<stale-fingerprint-percentage>  =>   B<integer, optional>

=begin html

<br>Percentage of fingerprints that are stale in the fingerprint database. Returned only if verbose option is set. This parameter is not supported on Infinite Volumes.

=end html

=back



=over 2

=item * I<state>  =>   B<string>

=begin html

<br>Possible values: <ul> <li> "Enabled", <li> "Disabled" </ul>

=end html

=back



=over 2

=item * I<status>  =>   B<string>

=begin html

<br>Possible values: <ul> <li> "Idle" - No sis operations are happening on this volume, <li> "Initializing" - sis operation is being initialized, <li> "Active" - sis operation is active on the volume, <li> "Undoing" - sis is being undone on the volume, <li> "Pending" - sis operations are scheduled for the volume, <li> "Downgrading" - The sis operation necessary to downgrade the volume is active, <li> "Disabled" - sis operation is disabled on the volume. </ul> This parameter is not supported on Infinite Volumes.

=end html

=back



=over 2

=item * I<type>  =>   B<string, optional>

=begin html

<br>Possible values: <ul> <li> "Regular", <li> "SnapVault" </ul> Any sis volume with Snapvault qtree in it would be marked as Snapvault and all others would be returned as type Regular. Returned only if verbose option is set.

=end html

=back



=head2 sis-logical-data

=begin html

This contains logical size attributes of a volume.

=end html



B<Fields>

=over 2

=item * I<logical-data-limit>  =>   B<integer>

=begin html

<br>Dedupe logical data limit in bytes. This parameter is not supported on Infinite Volumes.

=end html

=back



=over 2

=item * I<logical-data-size>  =>   B<integer>

=begin html

<br>The size of logical data in the volume in bytes. This is calculated as [size-saved + size-used + compressed-data bytes]. This parameter is not supported on Infinite Volumes.

=end html

=back



=head2 compliance-clock-info

=begin html

Compliance Clock

=end html



B<Fields>

=over 2

=item * I<formatted-snaplock-compliance-clock>  =>   B<string>

=begin html

<br>If Compliance Clock is initialized then human readable time <day> <month> <day of month> <hour>:<min>:<sec> <year> is displayed. A value of "Not Initalized" indicates that Compliance Clock has not been initialized.

=end html

=back



=over 2

=item * I<snaplock-compliance-clock>  =>   B<integer, optional>

=begin html

<br>If Compliance Clock is initialized then time in seconds in the standard UNIX format (since 01/01/1970 00:00:00) is displayed. Range:[0..2^64-1].

=end html

=back



=head2 file-retention-info

=begin html

retention information for each file

=end html



B<Fields>

=over 2

=item * I<formatted-retention-time>  =>   B<string, optional>

=begin html

<br>expiry date of the worm file formatted in a human-readable format. This takes care of wrap-around dates and prints the expiry date of the file in the the format <month> <day of month> <hour>:<min>:<sec> <year> A value of "INFINITE" indicates that this file has infinite retention-time. This field is not included in non-worm files (when snaplock-type is NONE).

=end html

=back



=over 2

=item * I<is-wraparound>  =>   B<boolean, optional>

=begin html

<br>True if the date represented in retention-time is a wrap-around date. This field is not included in case the file is not a worm file or if it has infinite retention.

=end html

=back



=over 2

=item * I<pathname>  =>   B<string>

=begin html

<br>pathname of the file. This will always have the same format and values as the input pathname-info array.

=end html

=back



=over 2

=item * I<retention-time>  =>   B<integer, optional>

=begin html

<br>retention time in seconds in the standard UNIX format (since 01/01/1970 00:00:00). SnapLock wraps around the retention time to indicate dates after 01/19/2038. It remaps 01/01/1970 - 12/31/2002 to 01/19/2038 - 01/19/2071 This field is not included in case the file is not a worm file or if the file has infinite retention. The flag is-wraparound indicates if this date is in the normal format or is wrapped around. The field formatted-retention-time represents the date as understood by SnapLock for retention of the file. Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<snaplock-error>  =>   B<L<"snaplock-error">, optional>

=begin html

<br>This value is only present if there is an error for a specific pathname entry. Error numbers returned EFILENOTFOUND, EINVALIDINPUTERROR, EVOLUMEOFFLINE, EVOLUMEDOESNOTEXIST, EVOLUMEQUIESCED, EINTERNALERROR

=end html

=back



=over 2

=item * I<snaplock-type>  =>   B<string, optional>

=begin html

<br>type of snaplock license applicable for this file Possible values "SLC" - indicates it is a worm file with snaplock compliance restrictions applying to it. "SLE" - indicates it is a worm file with snaplock enterprise restrictions applying to it. "NONE" - Not a worm file

=end html

=back



=head2 log-file-info

=begin html

Status information for each active WORM log file

=end html



B<Fields>

=over 2

=item * I<file-size>  =>   B<string, optional>

=begin html

<br>size of the active WORM log file (units are given when more than 1024 bytes)

=end html

=back



=over 2

=item * I<formatted-retention-date>  =>   B<string, optional>

=begin html

<br>Expiry date of the active WORM log file. This takes care of wraparound dates and prints the expiry date of the file in the format <month> <day of month> <hour>:<min>:<sec> <year>. The value of "INFINITE" indicates that the file has infinite retention and will never expire.

=end html

=back



=over 2

=item * I<log-basename>  =>   B<string>

=begin html

<br>The basename for the active WORM log file. If the caller of the ZAPI passed in the optional parameter log-basename, this should have the same value

=end html

=back



=over 2

=item * I<log-complete-path>  =>   B<string, optional>

=begin html

<br>The complete pathname of the active WORM log file. The format of the filename is basename.<creation_date>-present.

=end html

=back



=over 2

=item * I<snaplock-error>  =>   B<L<"snaplock-error">, optional>

=begin html

<br>This value is only present if there is an error for a specific pathname entry. Error numbers returned EFILENOTFOUND, EINVALIDINPUTERROR, EVOLUMEOFFLINE, EVOLUMEDOESNOTEXIST, EVOLUMEQUIESCED, EINTERNALERROR

=end html

=back



=head2 snaplock-error

=begin html

Information about a single quota error.

=end html



B<Fields>

=over 2

=item * I<errno>  =>   B<integer>

=begin html

<br>The error number Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<reason>  =>   B<string>

=begin html

<br>A human-readable concise reason for the error.

=end html

=back



=head2 address-pair

=begin html

Source and destination address pair.

=end html



B<Fields>

=over 2

=item * I<destination-addr>  =>   B<string>

=begin html

<br>Destination address in the form of filer name or IP address.

=end html

=back



=over 2

=item * I<source-addr>  =>   B<string>

=begin html

<br>Source address in the form of filer name or IP address.

=end html

=back



=head2 destination-info

=begin html

Source location, destination location, and source snapshot of a snapmirrored pair.

=end html



B<Fields>

=over 2

=item * I<destination-location>  =>   B<string>

=begin html

<br>Destination location of the snapmirrored pair. The destination location is of the volume form: &lt;filer&gt;:&lt;volume&gt; or the qtree form: &lt;filer&gt;:/vol/&lt;volume&gt;/&lt;qtree&gt; or the clone form: &lt;filer&gt;:&lt;volume&gt;-&gt;[clone:&lt;clone_name&gt;].

=end html

=back



=over 2

=item * I<source-location>  =>   B<string>

=begin html

<br>The source location of the snapmirrored pair. The source location is of the volume form: &lt;filer&gt;:&lt;volume&gt;, or it is of the qtree form: &lt;filer&gt;:/vol/&lt;volume&gt;/&lt;qtree&gt;. In versions of ONTAP earlier than 7.0, there was a bug which omitted the filer name, so the volume form is: &lt;volume&gt;, and the qtree form is: /vol/&lt;volume&gt;/&lt;qtree&gt;.

=end html

=back



=over 2

=item * I<source-snapshot>  =>   B<string>

=begin html

<br>The source snapshot.

=end html

=back



=head2 snapmirror-connection-info

=begin html

Information about one connection.

=end html



B<Fields>

=over 2

=item * I<address-pair1>  =>   B<L<"address-pair">>

=begin html

<br>The first source and destination address pair.

=end html

=back



=over 2

=item * I<address-pair2>  =>   B<L<"address-pair">, optional>

=begin html

<br>The second source and destination address pair.

=end html

=back



=over 2

=item * I<mode>  =>   B<string>

=begin html

<br>Connection mode. Possible values are: "multi" and "failover".

=end html

=back



=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Name of the connection. The name is in ASCII and must begin with an alpha character.

=end html

=back



=over 2

=item * I<snapmirror-error>  =>   B<L<"snapmirror-error">, optional>

=begin html

<br>Present if there is an error for a snapmirror connection.

=end html

=back



=head2 snapmirror-error

=begin html

Information about a single snapmirror schedule error.

=end html



B<Fields>

=over 2

=item * I<errno>  =>   B<integer>

=begin html

<br>The error number.

=end html

=back



=over 2

=item * I<reason>  =>   B<string>

=begin html

<br>A human-readable concise reason for the error.

=end html

=back



=head2 snapmirror-schedule-info

=begin html

Contains the SnapMirror schedule per destination. If the schedule contains an error, only destination-location and snapmirror-error will be present.

=end html



B<Fields>

=over 2

=item * I<days-of-month>  =>   B<string, optional>

=begin html

<br>Days in the month for which the schedule is set. The form is crontab-like, with possible values of: <ul> <li> - := match nothing; <li> 1 := match day 1; <li> 1,3 := match day 1 and 3; <li> 2-5 := match day 2,3,4,5; <li> 1-30/7 := match day 1,8,15,22,29; <li> * := matches all possible legal values; </ul> If there is an error, days-of-month will not be present and snapmirror-error will be present.

=end html

=back



=over 2

=item * I<days-of-week>  =>   B<string, optional>

=begin html

<br>Days in the week for which the schedule is set. 0 represents Sunday, and 6 represents Saturday. The form is crontab-like, with possible values of: <ul> <li> - := match nothing. <li> 1 := match day 1 (Mon); <li> 1,3 := match day 1 and 3 (Mon and Wed); <li> 2-5 := match day 2,3,4,5 (Tue,Wed,Thu,Fri); <li> * := matches all possible legal values; </ul> If there is an error, days-of-week will not be present and snapmirror-error will be present.

=end html

=back



=over 2

=item * I<destination-location>  =>   B<string>

=begin html

<br>The destination location of the schedule. The destination location is of the volume form: &lt;filer&gt;:&lt;volume&gt; or the qtree form: &lt;filer&gt;:/vol/&lt;volume&gt;/&lt;qtree&gt;.

=end html

=back



=over 2

=item * I<hours>  =>   B<string, optional>

=begin html

<br>Hours in the day for which the schedule is set. The form is crontab-like, with possible values of: <ul> <li> - := match nothing; <li> 1 := match hour 1; <li> 1,3 := match hour 1 and 3; <li> 2-5 := match hour 2,3,4,5; <li> 1-24/3 := match hour 1,4,7,10,13,16,19,22; <li> * := matches all possible legal values; </ul> If there is an error, hours will not be present and snapmirror-error will be present.

=end html

=back



=over 2

=item * I<is-compressed>  =>   B<boolean, optional>

=begin html

<br>If true SnapMirror will compress/decompress the data that is transferred between the source and destination storage system. If false, transferred data will not be compressed. The default is false.

=end html

=back



=over 2

=item * I<max-transfer-rate>  =>   B<integer, optional>

=begin html

<br>Maximum transfer rate in kilobytes per second. If not present, then the transfer rate is as fast as the filer can transfer.

=end html

=back



=over 2

=item * I<minutes>  =>   B<string, optional>

=begin html

<br>Minutes in the hour for which the schedule is set. The form is crontab-like, with possible values of: <ul> <li> - := match nothing; <li> 1 := match minute 1; <li> 1,3 := match minute 1 and 3; <li> 2-5 := match minute 2,3,4,5; <li> 1-12/3 := match minute 1,4,7,10; <li> 0-55/5 := match minute 0,5,10,15,20,25,30,35,40, 45,50,55; <li> * := matches all possible legal values; </ul> If there is an error, minutes will not be present and snapmirror-error will be present.

=end html

=back



=over 2

=item * I<snapmirror-error>  =>   B<L<"snapmirror-error">, optional>

=begin html

<br>Present if there is an error for a snapmirror schedule.

=end html

=back



=over 2

=item * I<source-location>  =>   B<string, optional>

=begin html

<br>The source location of the schedule. The source location is of the volume form: &lt;filer&gt;:&lt;volume&gt; or the qtree form: &lt;filer&gt;:/vol/&lt;volume&gt;/&lt;qtree&gt;. If there is an error, source-location will not be present and snapmirror-error will be present.

=end html

=back



=over 2

=item * I<tcp-window-size>  =>   B<integer, optional>

=begin html

<br>TCP window size in bytes. If not present, then the TCP window size is set to an internally determined default value.

=end html

=back



=head2 snapmirror-status-info

=begin html

The SnapMirror pair status.

=end html



B<Fields>

=over 2

=item * I<base-snapshot>  =>   B<string, optional>

=begin html

<br>Base snapshot name. Only present if available.

=end html

=back



=over 2

=item * I<contents>  =>   B<string>

=begin html

<br>State of the active file system of snapmirror destinations. Possible values are: "replica", "transitioning", and "original".

=end html

=back



=over 2

=item * I<current-transfer-error>  =>   B<string, optional>

=begin html

<br>A human readable transfer error of the current snapmirror transfer. Present when there is a current error.

=end html

=back



=over 2

=item * I<current-transfer-type>  =>   B<string, optional>

=begin html

<br>Type of the current SnapMirror transfer. Possible values are: initialize, store, schedule, retry, retrieve, resync, and migrate. Only present when there is a transfer.

=end html

=back



=over 2

=item * I<destination-location>  =>   B<string>

=begin html

<br>The destination location of the SnapMirror pair. The form is &lt;filer&gt;:&lt;volume&gt; or &lt;filer&gt;:/vol/&lt;volume&gt;/&lt;qtree&gt;.

=end html

=back



=over 2

=item * I<inodes-replicated>  =>   B<integer, optional>

=begin html

<br>Shows the number of inodes replicated. Present during directory processing phase.

=end html

=back



=over 2

=item * I<lag-time>  =>   B<integer>

=begin html

<br>Amount of time since the last snapmirror transfer in seconds.

=end html

=back



=over 2

=item * I<last-transfer-duration>  =>   B<integer>

=begin html

<br>Duration of the last SnapMirror transfer in seconds.

=end html

=back



=over 2

=item * I<last-transfer-from>  =>   B<string>

=begin html

<br>Source location of the last SnapMirror transfer.

=end html

=back



=over 2

=item * I<last-transfer-size>  =>   B<integer>

=begin html

<br>The size in kilo bytes (1024) of the last SnapMirror transfer.

=end html

=back



=over 2

=item * I<last-transfer-type>  =>   B<string, optional>

=begin html

<br>Last SnapMirror transfer type. Possible values are: "initialize", "store", "schedule", "retry", "retrieve", "resync", and "migrate". Only present when there was a last transfer.

=end html

=back



=over 2

=item * I<mirror-timestamp>  =>   B<integer>

=begin html

<br>Access time in seconds since Jan 1, 1970.

=end html

=back



=over 2

=item * I<replication-ops>  =>   B<integer, optional>

=begin html

<br>Counter that is incremented for every replication operation. Present during directory processing phase.

=end html

=back



=over 2

=item * I<source-location>  =>   B<string>

=begin html

<br>The source location of the SnapMirror pair. The form is &lt;filer&gt;:&lt;volume&gt; or &lt;filer&gt;:/vol/&lt;volume&gt;/&lt;qtree&gt;.

=end html

=back



=over 2

=item * I<state>  =>   B<string>

=begin html

<br>SnapMirror pair state. Possible values are: "uninitialized", "snapmirrored", "broken-off", "quiesced", "source", and "unknown".

=end html

=back



=over 2

=item * I<status>  =>   B<string>

=begin html

<br>SnapMirror pair transfer status. Possible values are: "Idle, "Transferring", "Pending", "Aborting", "Migrating", "Quiescing", "Resyncing", "Waiting", "Syncing", "In-sync" and "Paused". In case the previous transfer was failed/aborted and had a restart checkpoint set, the status could be "Idle with restart checkpoint" or "Pending with restart checkpoint". In addition the status could be "Checking", "Fixing" and "Transferring, Checking" when "snapmirror check" command is being run on the destination volume.

=end html

=back



=over 2

=item * I<transfer-progress>  =>   B<integer>

=begin html

<br>Number of kilo bytes (1024) transfered in a current on-going transfer.

=end html

=back



=head2 snapmirror-sync-schedule-info

=begin html

Contains the synchronous SnapMirror schedule per destination. If the schedule contains an error, only destination-location and snapmirror-error will be present.

=end html



B<Fields>

=over 2

=item * I<destination-location>  =>   B<string>

=begin html

<br>The destination location of the schedule. The destination location is of the volume form: &lt;filer&gt;:&lt;volume&gt; or the qtree form: &lt;filer&gt;:/vol/&lt;volume&gt;/&lt;qtree&gt;.

=end html

=back



=over 2

=item * I<is-compressed>  =>   B<boolean, optional>

=begin html

<br>If true SnapMirror will compress/decompress the data that is transferred between the source and destination storage system. If false, transferred data will not be compressed. The default is false.

=end html

=back



=over 2

=item * I<max-transfer-rate>  =>   B<integer, optional>

=begin html

<br>Maximum transfer rate in kilobytes per second. If not present, then the transfer rate is as fast as the filer can transfer.

=end html

=back



=over 2

=item * I<ops-throttle>  =>   B<string, optional>

=begin html

<br>The number of outstanding operations allowed before blocking on the source. The format is a number followed by the one of the following units: "ops", "s", or "ms". If the specified value is less than 10s, the mirror is configured to run in a fully synchronous mode. If the specified value is greater than or equal to 10s, the mirror is configured to run in semi-synchronous mode.

=end html

=back



=over 2

=item * I<snapmirror-error>  =>   B<L<"snapmirror-error">, optional>

=begin html

<br>Present if there is an error for a snapmirror schedule.

=end html

=back



=over 2

=item * I<source-location>  =>   B<string, optional>

=begin html

<br>The source location of the schedule. The source location is of the volume form: &lt;filer&gt;:&lt;volume&gt; or the qtree form: &lt;filer&gt;:/vol/&lt;volume&gt;/&lt;qtree&gt;. If there is an error, source-location will not be present and snapmirror-error will be present.

=end html

=back



=over 2

=item * I<sync-mode>  =>   B<string>

=begin html

<br>This specifies whether the mirror is configured in sync or in semi-sync mode. Possible values are: "full_sync" and "semi_sync". "full_sync" means that the mirror is configured to run in a fully synchronous mode. "semi_sync" means that the mirror is configured to run in a semi synchronous mode.

=end html

=back



=over 2

=item * I<tcp-window-size>  =>   B<integer, optional>

=begin html

<br>TCP window size in bytes. If not present, then the TCP window size is set to an internally determined default value.

=end html

=back



=over 2

=item * I<visibility-frequency>  =>   B<integer, optional>

=begin html

<br>Controls how often the source snapspot will be visible on the destination mirror.

=end html

=back



=head2 snapshot-autodelete-info

=begin html

Option name and value.

=end html



B<Fields>

=over 2

=item * I<option-name>  =>   B<string>

=begin html

<br>Option key. Possible values: "state" (value: "on" | "off") "commitment" (value: "try" | "disrupt") "trigger" (value: "volume" | "snap_reserve" | "space_reserve") "target_free_space" (value: &lt; number &gt;) "delete_order" (value: newest_first | oldest_first) "defer_delete" (value: scheduled | user_created | prefix | none) "destroy_list" (value: &lt; user-defined &gt;) "prefix" (value: &lt; string &gt;)

=end html

=back



=over 2

=item * I<option-value>  =>   B<string>

=begin html

<br>Option value.

=end html

=back



=head2 snapshot-info

=begin html

One snapshot contained in the specified volume. This type is used by snapshot-get-iter, snapshot-modify-iter and snapshot-list-info ZAPIs. When using this type to modify snapshot information, every field except snapmirror-label is non-modifiable.

=end html



B<Fields>

=over 2

=item * I<access-time>  =>   B<integer, optional>

=begin html

<br>The volume access time when the snapshot was created in seconds since Jan 1, 1970. This value will not change even if the snapshot is accessed.

=end html

=back



=over 2

=item * I<busy>  =>   B<boolean, optional>

=begin html

<br>True if the snapshot is being used by an application.

=end html

=back



=over 2

=item * I<contains-lun-clones>  =>   B<boolean, optional>

=begin html

<br>This snapshots contains lun clones. If true, this snapshot contains lun clones. This is available only if the 'lun-clone-snapshot' option is specified.

=end html

=back



=over 2

=item * I<cumulative-percentage-of-total-blocks>  =>   B<integer, optional>

=begin html

<br>Percentage of blocks owned by this snapshot and all more recent snapshots, relative to the total number of blocks in the volume. Not returned for Infinite Volumes.

=end html

=back



=over 2

=item * I<cumulative-percentage-of-used-blocks>  =>   B<integer, optional>

=begin html

<br>Percentage of blocks owned by this snapshot and all more recent snapshots, relative to the number of blocks currently used in the volume. Not returned for Infinite Volumes.

=end html

=back



=over 2

=item * I<cumulative-total>  =>   B<integer, optional>

=begin html

<br>Cumulative total of 1024 byte blocks of this snapshot and previous snapshots. If the "terse" input is true, this value is omitted.

=end html

=back



=over 2

=item * I<dependency>  =>   B<string, optional>

=begin html

<br>Application(s) dependent on this snapshot. Possible values include "snapmirror", "snapvault", "dump", "vclone", "LUNs", "snaplock". Comma separated if more than one application depends on this snapshot.

=end html

=back



=over 2

=item * I<is-7-mode-snapshot>  =>   B<boolean, optional>

=begin html

<br>True if the snapshot is a 7-mode snapshot.

=end html

=back



=over 2

=item * I<name>  =>   B<string, optional>

=begin html

<br>Name of the snapshot to be listed.

=end html

=back



=over 2

=item * I<percentage-of-total-blocks>  =>   B<integer, optional>

=begin html

<br>Percentage of blocks owned by this snapshot, relative to the total number of blocks in the volume.

=end html

=back



=over 2

=item * I<percentage-of-used-blocks>  =>   B<integer, optional>

=begin html

<br>Percentage of blocks owned by this snapshot, relative to the number of blocks currently used in the volume.

=end html

=back



=over 2

=item * I<snapmirror-label>  =>   B<string, optional>

=begin html

<br>A human readable SnapMirror Label attached with the snapshot. Size of the label can be at most 31 characters. This label will be used by the vaulting system to identify a vaulting scheme.

=end html

=back



=over 2

=item * I<snapshot-instance-uuid>  =>   B<uuid, optional>

=begin html

<br>The 128 bit unique snapshot identifier expressed in the form of UUID. This field uniquely identifies the snapshot's physical data layout.

=end html

=back



=over 2

=item * I<snapshot-owners-list>  =>   B<L<"snapshot-owner">[], optional>

=begin html

<br>The list of owners of a busy snapshot.

=end html

=back



=over 2

=item * I<snapshot-version-uuid>  =>   B<uuid, optional>

=begin html

<br>The 128 bit unique snapshot identifier expressed in the form of UUID. This field uniquely identifies the snapshot's logical data layout.

=end html

=back



=over 2

=item * I<state>  =>   B<string, optional>

=begin html

<br>The state of the snapshot. Possible values: <ul> <li> 'valid' ... The snapshot is complete and consistent <li> 'invalid' ... The namespace constituent snapshot is missing <li> 'partial' ... One or more data constituent snapshots are missing </ul> Only a snapshot on an Infinite Volume can have a state of partial or invalid. <p> The default value is valid.

=end html

=back



=over 2

=item * I<total>  =>   B<integer, optional>

=begin html

<br>Number of 1024 byte blocks in the snapshot. If the "terse" input is true, this value is omitted.

=end html

=back



=over 2

=item * I<volume-provenance-uuid>  =>   B<uuid, optional>

=begin html

<br>Provenance UUID of the volume at the time the snapshot was created. Refer to the volume-get-iter API for a description of the volume provenance UUID.

=end html

=back



=head2 snapshot-name

=begin html

Name of a snapshot.

=end html



B<Fields>

=over 2

=item * None

=back



=head2 snapshot-owner

=begin html

owner of a busy snapshot

=end html



B<Fields>

=over 2

=item * I<owner>  =>   B<string>

=begin html

<br>Name of the owner of a busy snapshot

=end html

=back



=head2 snapshot-reserve-detail-info

=begin html

Information about a volume's snapshot space reservation configuration.

=end html



B<Fields>

=over 2

=item * I<percentage>  =>   B<integer>

=begin html

<br>Percentage of volume reserved for snapshots. Range : [0 - 100].

=end html

=back



=over 2

=item * I<size>  =>   B<integer>

=begin html

<br>Size in bytes of volume reserved for snapshots. Range : [0 - 2^64-1].

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of volume.

=end html

=back



=head2 volume-error

=begin html

The error code of a given volume.

=end html



B<Fields>

=over 2

=item * I<errno>  =>   B<integer, optional>

=begin html

<br>The error code of the snapshot operation for a given volume. It is returned only when an error is found.

=end html

=back



=over 2

=item * I<name>  =>   B<volume-name>

=begin html

<br>Name of a volume.

=end html

=back



=over 2

=item * I<reason>  =>   B<string, optional>

=begin html

<br>Description of the error. It is returned only when an error is found.

=end html

=back



=over 2

=item * I<vserver>  =>   B<string, optional>

=begin html

<br>Virtual server containing the volume.

=end html

=back



=head2 volume-is-snapcreated

=begin html

The status of the snapshot creation for a given volume.

=end html



B<Fields>

=over 2

=item * I<is-snapcreated>  =>   B<boolean>

=begin html

<br>TRUE means a snapshot has been created for the volume.

=end html

=back



=over 2

=item * I<name>  =>   B<volume-name>

=begin html

<br>Name of a volume.

=end html

=back



=head2 snapvault-chained-destination-info

=begin html

Structure of each entry of destinations-chain.

=end html



B<Fields>

=over 2

=item * I<destination-path>  =>   B<string>

=begin html

<br>Destination path.

=end html

=back



=over 2

=item * I<destination-system>  =>   B<string, optional>

=begin html

<br>Hostname of the destination system.

=end html

=back



=head2 snapvault-configuration-info

=begin html

Describes the elements of the snapvault configuration entry.

=end html



B<Fields>

=over 2

=item * I<connection-mode>  =>   B<string, optional>

=begin html

<br>This option specifies the mode to be used for establising connection between primary and secondary. If this option is set to "inet6", connections between primary and secondary will be established using IPv6 addresses only. If there are no IPv6 addressess configured, then the connection will fail. If the option is set to "inet", connections between primary and secondary will be established using IPv4 addresses only. If there are no IPv4 addresses configured, then the connection will fail. When this option is not specified, Connection will be tried using both "inet6" and "inet". "inet6" will have higher precedence than "inet". If connection request using "inet6" fails, SnapMirror will retry the connection using "inet". This argument is not effective when an IP address is specified instead of primary hostname. If the IP address format and connection mode do not match, the operation will fail with proper error message.

=end html

=back



=over 2

=item * I<is-access-time-change-ignored>  =>   B<boolean, optional>

=begin html

<br>Sets the ignore_atime option in snapvault configuration entry. When set to 'true', snapvault primary does not send files with only access time changes during incremental transfers. The default value is 'false'

=end html

=back



=over 2

=item * I<is-open-file-backup-allowed>  =>   B<boolean, optional>

=begin html

<br>Sets the back_up_open_files option in the snapvault configuration entry. This option is used to allow or disallow the inclusion of open files on the primary system at the time of the transfer. This option is currently applicable only for OSSV relationships. When set to 'false' the OSSV primary agents will exclude files that are open from the transfer. The default value for this parameter is 'true'.

=end html

=back



=over 2

=item * I<is-primary-path-utf8-encoded>  =>   B<boolean, optional>

=begin html

<br>Specifies encoding format for the primary pathname. A 'true' value indicates that the primary pathname is in UTF8 format. The default encoding format is ASCII/extended ASCII. The default value is 'false'.

=end html

=back



=over 2

=item * I<max-transfer-rate>  =>   B<integer, optional>

=begin html

<br>The maximum transfer rate in kilobytes (1024 bytes) per second that will be used for this relationship as well as baseline transfer. The default value for this parameter will allow transfers to proceed as fast as possible. Range:[1..2^31-2]

=end html

=back



=over 2

=item * I<primary-path>  =>   B<string>

=begin html

<br>The primary path that will be used as the source for this relationship as well as for baseline transfer. This can be either in UTF8 or ASCII/extended ASCII depending on whether or not 'is-primary-path-utf8-encoded' flag is set. If option 'is-primary-path-utf8-encoded' is not specified, then the primary-path considered as in ASCII/extended ASCII.

=end html

=back



=over 2

=item * I<primary-system>  =>   B<string>

=begin html

<br>The primary system for this relationship as well as for the baseline transfer. This input will be used by the secondary system to establish contact with the primary. Therefore this input is expected to be a hostname that the primary can resolve.

=end html

=back



=over 2

=item * I<secondary-path>  =>   B<string>

=begin html

<br>The secondary path that will be used as destination for this relationship as well as baseline transfer. The secondary path will be created during the baseline transfer and hence it must not exist when issuing this request.

=end html

=back



=over 2

=item * I<tries-count>  =>   B<integer, optional>

=begin html

<br>The maximum number of times a transfer will be tried. Transfers that are retried using this mechanism may be capable of restarting from where the previous attempt failed. If a transfer does not succeed even after those many attempts, then the secondary will give up. All the data that was transferred during previous tries for this transfer will be discarded. The default value for this parameter is 2. When set to 0, the relationship will become dormant. In other words no transfers will be allowed to this secondary path. The maximum value accepted for this input is 120. Range:[0..120]

=end html

=back



=over 2

=item * I<use-compression>  =>   B<string, optional>

=begin html

<br>Specifies whether to compress the network data stream. Possible values are 'on', 'off', and 'default'. When the value is set to 'on', stream compression will be enabled. When the value is set to 'off', stream compression will be disabled. When the value is set to 'default' then the default value will be used. In case of snapvault create relationship API, when this option is not specified, the default value will be used. In case of snapvault modify API, when this option is not specified, the last configured value for this relationship will be used. The default value for this option is the value of global compression option.

=end html

=back



=head2 snapvault-destination-info

=begin html

Structure of each entry of destinations list.

=end html



B<Fields>

=over 2

=item * I<chained-destinations>  =>   B<L<"snapvault-chained-destination-info">[]>

=begin html

<br>List of destinations that form a dependency chain starting from the source-path. This list will contain only one element for non-cascaded configurations. The last element of this list represents the destination for which the snapshot returned in source-snapshot has been preserved on the source system.

=end html

=back



=over 2

=item * I<source-path>  =>   B<string>

=begin html

<br>The source path for this destination.

=end html

=back



=over 2

=item * I<source-snapshot>  =>   B<string>

=begin html

<br>The source snapshot that has been preserved on the source system for the destination.

=end html

=back



=head2 snapvault-primary-snapshot-schedule-info

=begin html

Structure of each snapshot schedule.

=end html



B<Fields>

=over 2

=item * I<is-auto-update>  =>   B<boolean, optional>

=begin html

<br>Schedules that have is-auto-update set to 'true' will initiate update transfers for all relationships in that volume before creating a new snapshot. Default value is 'false'. This setting is honoured only for the secondary schedules. It is ignored for the SnapVault primary schedules.

=end html

=back



=over 2

=item * I<options>  =>   B<L<"snapvault-schedule-options">, optional>

=begin html

<br>Describes snapvault schedule options.

=end html

=back



=over 2

=item * I<preserve-snapshots>  =>   B<string, optional>

=begin html

<br>Allowed values are on/off/default. It prevents SnapVault from auto-deleting older snapshots from this SnapVault snapshot schedule to create new snapshots when set to on. When unspecified, value is set to default. When set to default, the behaviour of preserving snapshots is guided by the global snapvault.preservesnap option. This setting is honoured only for the secondary schedules. It is ignored for the SnapVault primary schedules.

=end html

=back



=over 2

=item * I<retention-count>  =>   B<integer>

=begin html

<br>Denotes the maximum number of most recent snapshots that will be retained by this schedule. Range:[0..254]

=end html

=back



=over 2

=item * I<schedule>  =>   B<L<"snapvault-schedule-info">, optional>

=begin html

<br>Describes the actual schedule.

=end html

=back



=over 2

=item * I<schedule-name>  =>   B<string>

=begin html

<br>Uniquely identifies this schedule within a primary volume. The schedule-name will be used as a prefix in the name of each snapshot created by this schedule.

=end html

=back



=over 2

=item * I<volume-name>  =>   B<string>

=begin html

<br>The primary volume for which this schedule has been configured.

=end html

=back



=over 2

=item * I<warn-at-count>  =>   B<integer, optional>

=begin html

<br>On SnapVault secondary, when preserve-snapshots is set, SnapVault sends a warning message when the number of remaining snapshots for this backup schedule is less than this input. Setting this to zero turns off the same warning. Default value is 0. This setting is honoured only for the secondary schedules. It is ignored for the SnapVault primary schedules. Range:[0..retention-count - 1]

=end html

=back



=head2 snapvault-schedule-info

=begin html

Representation of the scheduling information.

=end html



B<Fields>

=over 2

=item * I<days-of-week>  =>   B<string, optional>

=begin html

<br>Days of the week for which this schedule has been set. This is a comma separated list of days, where a day is specified by the first three letters of the day. Day ranges are also allowed. Here are the possible formats: <ul> <li> - := matches no day of the week <li> mon := matches Monday <li> tue,thu := matches Tuesday and Thursday <li> mon-fri := matches mon,tue,wed,thu,fri </ul> Default value is mon-sun, i.e. every day.

=end html

=back



=over 2

=item * I<hours-of-day>  =>   B<string, optional>

=begin html

<br>Hours of the day for which this schedule has been set. This is a comma separated list of the hours during the day where hours are specified as integers from 0 to 23. Hour ranges are also allowed. Step values are allowed in conjunction with ranges. Here are the possible formats: <ul> <li> 4 := matches 4 am. <li> 0,13 := matches midnight and 1pm. <li> 0-23 := matches all hours <li> 0-8/2 := matches 'every 2 hours' starting from midnight until 8am. </ul> Default value is 0, i.e. midnight.

=end html

=back



=head2 snapvault-schedule-options

=begin html

Describes snapvault schedule options.

=end html



B<Fields>

=over 2

=item * I<retention-period>  =>   B<string, optional>

=begin html

<br>This option is used to specify a retention period for snapshots, which are created by this schedule, for SnapLock volumes. The retention period is specified as a count followed by a suffix. the valid suffixes are d - for days m - for months y - for years For example a value of 6m represents a retention period of 6 months. THe maximum valid retention period is 30 years, or the maximum retention period set for the volume, whichever is shorter. The minimum valid retention period is 0 days, ir the minimum retention period set for the volume, whichever is longer. If the option value is default or the retention-period option is not specified, the snapshots will be created with retention period equal to the default retention period of the secondary SnapLock volume, or 30 years, whichever is shorter.

=end html

=back



=over 2

=item * I<tries-count>  =>   B<integer, optional>

=begin html

<br>Number of times SnapVault should try creating each scheduled snapshot before giving up. If the snapshot creation fails due to transient errors such as the volume being out of space, SnapVault will keep trying to create the snapshot every minute untill the request is fulfilled. The allowed range is from 0 to 120. The default value is unlimited. If tries-count is not use, then the value will remain unchanged and the already configured value will be used. The default value for this option is -1. Range:[-1..120]

=end html

=back



=head2 snapvault-secondary-snapshot-schedule-info

=begin html

Snapshot schedules for each volume.

=end html



B<Fields>

=over 2

=item * I<is-auto-update>  =>   B<boolean>

=begin html

<br>Schedules that have is-auto-update set to 'true' will initiate update transfers for all relationships in that volume before creating a new snapshot.

=end html

=back



=over 2

=item * I<options>  =>   B<L<"snapvault-schedule-options">, optional>

=begin html

<br>Describes schedule options.

=end html

=back



=over 2

=item * I<preserve-snapshots>  =>   B<string, optional>

=begin html

<br>Allowed values are on/off/default. It prevents SnapVault from auto-deleting older snapshots from this SnapVault snapshot schedule to create new snapshots when set to on. When unspecified, value is set to default. When set to default, the behaviour of preserving snapshots is guided by the global snapvault.preservesnap option. This setting is honoured only for the secondary schedules. It is ignored for the SnapVault primary schedules.

=end html

=back



=over 2

=item * I<retention-count>  =>   B<integer>

=begin html

<br>Denotes the maximum number of most recent snapshots that will be retained by this schedule. Range:[0..254]

=end html

=back



=over 2

=item * I<schedule>  =>   B<L<"snapvault-schedule-info">, optional>

=begin html

<br>Describes the actual schedule.

=end html

=back



=over 2

=item * I<schedule-name>  =>   B<string>

=begin html

<br>Uniquely identifies the schedule within a secondary volume. The schedule-name is used as a prefix in the name of each snapshot created by this schedule.

=end html

=back



=over 2

=item * I<volume-name>  =>   B<string>

=begin html

<br>The secondary volume for which these schedules have been configured.

=end html

=back



=over 2

=item * I<warn-at-count>  =>   B<integer, optional>

=begin html

<br>On SnapVault secondary, when preserve-snapshots is set, SnapVault sends a warning message when the number of remaining snapshots for this backup schedule is less than this input. Setting this to zero turns off the same warning. Default value is 0. Range:[0..retention-count - 1]

=end html

=back



=head2 snapvault-snapcreate-options

=begin html

Snap create options.

=end html



B<Fields>

=over 2

=item * I<tries-count>  =>   B<integer>

=begin html

<br>This option is similar to one in snapvault-schedule-options. Range:[-1..120]

=end html

=back



=head2 snapvault-snapshot-schedule-status-info

=begin html

Structure of the snapshot schedule status entry.

=end html



B<Fields>

=over 2

=item * I<schedule-name>  =>   B<string>

=begin html

<br>Uniquely identifies schedule within a volume.

=end html

=back



=over 2

=item * I<status>  =>   B<string>

=begin html

<br>Status of this schedule. Possible values are: "Idle", "Active", "Aborting", "Queued", "Saving".

=end html

=back



=over 2

=item * I<volume-name>  =>   B<string>

=begin html

<br>Volume for which this schedule is configured.

=end html

=back



=head2 snapvault-softlock-info

=begin html

Structure of the snapvault softlock.

=end html



B<Fields>

=over 2

=item * I<softlock-name>  =>   B<string>

=begin html

<br>Name of the softlock. This field will be empty if softlock-name is not specified while adding softlock.

=end html

=back



=over 2

=item * I<type>  =>   B<string>

=begin html

<br>Type of snapvault softlock. This indicates whether the softlock added using zapi or command line interface. Possible types are "cli", "api"

=end html

=back



=head2 snapvault-status-info

=begin html

Format of each status entry.

=end html



B<Fields>

=over 2

=item * I<base-snapshot>  =>   B<string, optional>

=begin html

<br>Snapshot the relationship is currently based upon.

=end html

=back



=over 2

=item * I<compressed-bytes>  =>   B<integer, optional>

=begin html

<br>Number of compressed bytes transferred if QSM compression is being used. This field is absent if the transfer is not compressed. Range:[0..2^64-1]

=end html

=back



=over 2

=item * I<contents>  =>   B<string, optional>

=begin html

<br>State of the active file system of the snapvault path on this system. Possible values are: "replica", "transitioning" and "original". This field is present only on the destination.

=end html

=back



=over 2

=item * I<current-transfer-error>  =>   B<string, optional>

=begin html

<br>A human readable error string for the current transfer.

=end html

=back



=over 2

=item * I<current-transfer-type>  =>   B<string, optional>

=begin html

<br>Type of the current transfer. Possible values are: "initialize", "update", "retry", "resync". Only available for active transfers.

=end html

=back



=over 2

=item * I<destination-path>  =>   B<string>

=begin html

<br>Destination path.

=end html

=back



=over 2

=item * I<destination-system>  =>   B<string>

=begin html

<br>Destination hostname.

=end html

=back



=over 2

=item * I<inodes-replicated>  =>   B<integer, optional>

=begin html

<br>Shows the number of inodes replicated. Present during directory processing phase.

=end html

=back



=over 2

=item * I<lag-time>  =>   B<integer, optional>

=begin html

<br>Amount of time in seconds since the beginning of the most recently successful transfer from source. This field is present only when there has been a successful baseline transfer. Range:[1..2^32-1]

=end html

=back



=over 2

=item * I<last-transfer-duration>  =>   B<integer, optional>

=begin html

<br>Duration of last transfer in seconds. Range:[0..2^32-1]

=end html

=back



=over 2

=item * I<last-transfer-from-path>  =>   B<string, optional>

=begin html

<br>Source path used for the last transfer.

=end html

=back



=over 2

=item * I<last-transfer-from-system>  =>   B<string, optional>

=begin html

<br>Source system used for the last transfer.

=end html

=back



=over 2

=item * I<last-transfer-size>  =>   B<integer, optional>

=begin html

<br>Size in kilobytes (1024 bytes) of the last transfer. Range:[0..2^32-1]

=end html

=back



=over 2

=item * I<last-transfer-type>  =>   B<string, optional>

=begin html

<br>Last transfer type. Possible values are: "initialize", "update", "retry", "resync".

=end html

=back



=over 2

=item * I<mirror-timestamp>  =>   B<integer, optional>

=begin html

<br>Creation time of the snapshot used for the most recent successful transfer. Specified in seconds since Jan 1, 1970. This field is present only when there has been a successful baseline transfer. Range:[1..2^32-1]

=end html

=back



=over 2

=item * I<replication-ops>  =>   B<integer, optional>

=begin html

<br>Counter that is incremented for every replication operation. Present during directory processing phase.

=end html

=back



=over 2

=item * I<source-path>  =>   B<string>

=begin html

<br>Source path.

=end html

=back



=over 2

=item * I<source-system>  =>   B<string>

=begin html

<br>Source hostname.

=end html

=back



=over 2

=item * I<state>  =>   B<string>

=begin html

<br>State of this relationship. Possible values are: "uninitialized","snapvaulted","broken-off","unknown", "source","restoring","quiesced".

=end html

=back



=over 2

=item * I<status>  =>   B<string>

=begin html

<br>Transfer status for this relationship. Possible values are: "idle", "transferring", "pending", "aborting", "quiescing", "resyncing", "restoring".

=end html

=back



=over 2

=item * I<transfer-progress>  =>   B<integer, optional>

=begin html

<br>Number of kilobytes (1024 bytes) transferred so far. This field is valid only for active transfers. If there is no active transfer in progress, this field is absent. Range:[0..2^32-1]

=end html

=back



=over 2

=item * I<uncompressed-bytes>  =>   B<integer, optional>

=begin html

<br>Number of uncompressed bytes transferred if QSM compression is being used. This field is absent if the transfer is not compressed. Range:[0..2^64-1]

=end html

=back



=head2 community-info

=begin html

Information about a single community.

=end html



B<Fields>

=over 2

=item * I<access-control>  =>   B<string>

=begin html

<br>Access control of the community. Possible values are "ro" (read-only), and "rw" (read-write).

=end html

=back



=over 2

=item * I<community>  =>   B<string>

=begin html

<br>Community name.

=end html

=back



=head2 trap-info

=begin html

Information about a single user defined trap.

=end html



B<Fields>

=over 2

=item * I<OID>  =>   B<string, optional>

=begin html

<br>Specifies the OID of the MIB object that is queried to determine the trap's value. This attribute is set to "undefined" on output if not explicitly specified in trap definition. If absent on input, there is no default value, and trap definition is incomplete.

=end html

=back



=over 2

=item * I<active>  =>   B<string, optional>

=begin html

<br>Notification state of trap. Possible values are "on" indicating agent will deliver notification if triggered, "off" indicating trap is inactive, and "incomplete" indicating one or more of the required attributes have not been defined. The default value for a fully defined trap is "off".

=end html

=back



=over 2

=item * I<backoff-calculator>  =>   B<string, optional>

=begin html

<br>Specifies a method by which the frequency of trap evaluation may be modified. Possible values are "step-backoff", "exponential-backoff", and "no-backoff" This attribute may be absent on output if not explicitly specified in trap definition. If absent on input, the default is "no-backoff".

=end html

=back



=over 2

=item * I<backoff-multiplier>  =>   B<integer, optional>

=begin html

<br>Factor by which interval is multiplied when exponential-backoff method used. Used with "exponential-backoff" calculator. This attribute may be absent on output if not explicitly specified in trap definition. If absent on input, the default is 1. Range may be [0..2^31-1].

=end html

=back



=over 2

=item * I<backoff-step>  =>   B<integer, optional>

=begin html

<br>Time in seconds by which evaluation interval is increased when step-backoff method used. Used with "step-backoff" calculator. This attribute may be absent on output if not explicitly specified in trap definition. If absent on input, the default is 0. Range may be [0..2^31-1].

=end html

=back



=over 2

=item * I<current-value>  =>   B<integer, optional>

=begin html

<br>Value of trap at time of query. On input, this attribute is ignored. Range may be [-2^31..2^31-1].

=end html

=back



=over 2

=item * I<edge-1>  =>   B<integer, optional>

=begin html

<br>Threshold value at which trap is triggered. If not specified on input, the default value is 2^31-1. Range may be [-2^31..2^31-1].

=end html

=back



=over 2

=item * I<edge-1-direction>  =>   B<string, optional>

=begin html

<br>Sets the direction of travel across the edge-1 threshold beyond which the trap is triggered. Possible values are "up", and "down". If not specified on input, the default value is "up".

=end html

=back



=over 2

=item * I<edge-2>  =>   B<integer, optional>

=begin html

<br>Threshold value at which trap is triggered. Used with double-edge-trigger condition. This attribute may be absent on output if not explicitly specified in trap definition. If absent on input, the default is 0. Range may be [-2^31..2^31-1].

=end html

=back



=over 2

=item * I<edge-2-direction>  =>   B<string, optional>

=begin html

<br>Sets the direction of travel across the edge-2 threshold beyond which the trap is triggered. Possible values are "up", and "down". Used with double-edge-trigger condition. This attribute may be absent on output if not explicitly specified in trap definition. If absent on input, the default is "down".

=end html

=back



=over 2

=item * I<interval>  =>   B<integer, optional>

=begin html

<br>Time in seconds between evaluations of the trap. A trap can send data only as often as it is evaluated. If not specified on input, the default value is 3600 seconds (1-hour). Range may be [0..31536000].

=end html

=back



=over 2

=item * I<interval-offset>  =>   B<integer, optional>

=begin html

<br>Time in seconds until the first trap evaluation. This attribute may be absent on output if not explicitly specified in trap definition. If absent on input, the default is 0. Range may be [0..31536000].

=end html

=back



=over 2

=item * I<message>  =>   B<string, optional>

=begin html

<br>Message associated with trap. May be either a literal string, or specifies an OID. This attribute is set to "undefined" on output if not explicitly specified in trap definition. If absent on input, there is no default value, and trap definition is incomplete.

=end html

=back



=over 2

=item * I<priority>  =>   B<string, optional>

=begin html

<br>Priority level of trap. Possible values (in descending order of severity) are "emergency", "alert", "critical", "error", "warning", "notification", "informational", or "debug". This attribute may be absent on output if not explicitly specified in trap definition. If absent on input, the default is "notification".

=end html

=back



=over 2

=item * I<rate-interval>  =>   B<integer, optional>

=begin html

<br>Time in seconds over which rate of change is calculated from sample data. This attribute may be absent on output if not explicitly specified in trap definition. If absent on input, the default is 0. Range may be [0..2^31-1].

=end html

=back



=over 2

=item * I<trap-name>  =>   B<string>

=begin html

<br>Name of the trap given by the user. Note that trap-name may not contain embedded periods.

=end html

=back



=over 2

=item * I<trigger>  =>   B<string, optional>

=begin html

<br>Sets the condition under which the trap will send a notification. Possible values are "single-edge-trigger", "double-edge-trigger", or "level-trigger". This attribute is set to "undefined" on output if not explicitly specified in trap definition. If absent on input, there is no default value, and trap definition is incomplete.

=end html

=back



=head2 traphost-info

=begin html

Information about a single registered trap host.

=end html



B<Fields>

=over 2

=item * I<host-name>  =>   B<string>

=begin html

<br>Name of the trap host given by the user. Can be one of the following: hostname, ip-address, or alias Hostname will be a fully qualified Domain Name.

=end html

=back



=over 2

=item * I<ip-address>  =>   B<string>

=begin html

<br>IP address of the trap host.

=end html

=back



=head2 npm-meta-elem-info

=begin html

Single metadata element with metadata information

=end html



B<Fields>

=over 2

=item * I<npm-meta-name>  =>   B<string>

=begin html

<br>Name of metdata element

=end html

=back



=over 2

=item * I<npm-meta-value>  =>   B<string>

=begin html

<br>One or more values for the meta element in one string

=end html

=back



=head2 adapter-bar-info

=begin html

display base address information

=end html



B<Fields>

=over 2

=item * I<bar-base>  =>   B<integer>

=begin html

<br>Base address occupied by the storage port adapter. Range : [0..2^32-1]

=end html

=back



=over 2

=item * I<bar-size>  =>   B<integer>

=begin html

<br>Address range occupied by the storage port adapter. Range : [0..2^32-1]

=end html

=back



=over 2

=item * I<bar-type>  =>   B<string>

=begin html

<br>Type of base address information. Possible values are: "I/O", and "memory mapped I/O".

=end html

=back



=head2 adapter-detail-info

=begin html

Detailed information for specific adapter. Display different info base on the type of adapter.

=end html



B<Fields>

=over 2

=item * I<adapter-fc>  =>   B<L<"adapter-fc-info">, optional>

=begin html

<br>Information for fc (Fibre Channel) adapter.

=end html

=back



=over 2

=item * I<adapter-name>  =>   B<string>

=begin html

<br>Adapter port name, which is adapter slot number and, if presented, the port letter designator together. Examples are 8a, 11b. Note that a physical adapter may contain multiple ports.

=end html

=back



=over 2

=item * I<adapter-parallel-scsi>  =>   B<L<"adapter-parallel-scsi-info">, optional>

=begin html

<br>Information for parallel SCSI adapter.

=end html

=back



=over 2

=item * I<adapter-sas>  =>   B<L<"adapter-sas-info">, optional>

=begin html

<br>Information for sas (serial attached SCSI) adapter.

=end html

=back



=over 2

=item * I<adapter-type>  =>   B<string>

=begin html

<br>Type of adapter present in the system. Possible values: "ADT_IF_ATA", "ADT_IF_PARALLEL_SCSI", "ADT_IF_SAS", "ADT_IF_FC".

=end html

=back



=head2 adapter-fc-info

=begin html

Detailed information for fc adapter.

=end html



B<Fields>

=over 2

=item * I<adapter-bar>  =>   B<L<"adapter-bar-info">[], optional>

=begin html

<br>List of base address information

=end html

=back



=over 2

=item * I<adapter-model>  =>   B<string>

=begin html

<br>Model of the adapter.

=end html

=back



=over 2

=item * I<adapter-sff-info>  =>   B<L<"adapter-sff-info">, optional>

=begin html

<br>If the port has a small form factor transceiver/connector (also known as sff), then this is the vendor information on the sff.

=end html

=back



=over 2

=item * I<adapter-sfp-info>  =>   B<L<"adapter-sfp-info">, optional>

=begin html

<br>If the port has a small form factor pluggable transceiver/connector (also known as sfp), then this is the vendor information on the sfp.

=end html

=back



=over 2

=item * I<cache-line-sz>  =>   B<integer, optional>

=begin html

<br>Storage port adapter's data cache size,

=end html

=back



=over 2

=item * I<fc-link-rate>  =>   B<integer>

=begin html

<br>Link rate of Fibre Channel port.

=end html

=back



=over 2

=item * I<fc-node-name>  =>   B<string>

=begin html

<br>Fibre Channel node name.

=end html

=back



=over 2

=item * I<fc-packet-size>  =>   B<integer>

=begin html

<br>Size of Fibre Channel packets.

=end html

=back



=over 2

=item * I<fc-port-name>  =>   B<string, optional>

=begin html

<br>Fibre Channel World Wide Port Name (WWPN) of adapter.

=end html

=back



=over 2

=item * I<firmware-rev>  =>   B<string>

=begin html

<br>Firmware revision of adapter.

=end html

=back



=over 2

=item * I<hardware-rev>  =>   B<string>

=begin html

<br>Hardware revision of adapter.

=end html

=back



=over 2

=item * I<host-loop-id>  =>   B<integer, optional>

=begin html

<br>Storage port adapter's Fibre Channel loop id,

=end html

=back



=over 2

=item * I<host-port-id>  =>   B<integer, optional>

=begin html

<br>Storage port adapter's port id,

=end html

=back



=over 2

=item * I<is-enabled>  =>   B<boolean>

=begin html

<br>Is the adapter enabled? true or false.

=end html

=back



=over 2

=item * I<is-ext-gbic>  =>   B<boolean>

=begin html

<br>Is the Fibre Channel gbic external? true or false.

=end html

=back



=over 2

=item * I<is-in-use>  =>   B<boolean>

=begin html

<br>Is the adapter inuse? true or false

=end html

=back



=over 2

=item * I<is-pci-64-capable>  =>   B<boolean, optional>

=begin html

<br>Is the adapter pci-64-capable? true or false.

=end html

=back



=over 2

=item * I<is-redundant>  =>   B<boolean>

=begin html

<br>Is the adapter used in dual-attached config? true or false

=end html

=back



=over 2

=item * I<is-sram-parity>  =>   B<boolean, optional>

=begin html

<br>Is the adapter sram parity configured and enabled? true or false.

=end html

=back



=over 2

=item * I<preload-table-rev>  =>   B<string, optional>

=begin html

<br>Preload table revision of adapter.

=end html

=back



=head2 adapter-name-elem

=begin html

A list of adapter-names that can be used in other storage-adapter interface calls.

=end html



B<Fields>

=over 2

=item * I<adapter-name>  =>   B<string>

=begin html

<br>The adapter name is the slot number and, if present, the port letter designate. Examples are 8a, 11b

=end html

=back



=head2 adapter-parallel-scsi-info

=begin html

Detailed information for parallel SCSI adapter.

=end html



B<Fields>

=over 2

=item * I<adapter-model>  =>   B<string>

=begin html

<br>Model of the adapter.

=end html

=back



=over 2

=item * I<bus-width>  =>   B<string>

=begin html

<br>Possible values: "narrow", or "wide".

=end html

=back



=over 2

=item * I<firmware-rev>  =>   B<string>

=begin html

<br>Firmware revision of adapter.

=end html

=back



=over 2

=item * I<hardware-rev>  =>   B<string>

=begin html

<br>Hardware revision of adapter.

=end html

=back



=over 2

=item * I<is-enabled>  =>   B<boolean>

=begin html

<br>Is the adapter enabled?

=end html

=back



=head2 adapter-sas-info

=begin html

Detailed information for sas (Serial Attached SCSI) adapter.

=end html



B<Fields>

=over 2

=item * I<adapter-board-revision>  =>   B<string, optional>

=begin html

<br>Adapter board revision as assigned by the manufacturer. Will be missing if data not available or not supported.

=end html

=back



=over 2

=item * I<adapter-date-code>  =>   B<string, optional>

=begin html

<br>Adapter data code assigned by the manufacturer. Will be missing if data not available or not supported.

=end html

=back



=over 2

=item * I<adapter-family>  =>   B<string, optional>

=begin html

<br>Adapter family as assigned by the vendor. Example: 2432. Will be missing if data not available or not supported.

=end html

=back



=over 2

=item * I<adapter-manufacturer>  =>   B<string, optional>

=begin html

<br>Manufacturing facility where adapter was built. Will be missing if data not available or not supported.

=end html

=back



=over 2

=item * I<adapter-manufacturer-part-number>  =>   B<string, optional>

=begin html

<br>Adapter part number assigned by the manufacturer. Will be missing if data not available or not supported.

=end html

=back



=over 2

=item * I<adapter-model>  =>   B<string>

=begin html

<br>Model of the adapter. This is the same as adapter-vendor followed with adapter-family. Example: "Qlogic 2432"

=end html

=back



=over 2

=item * I<adapter-part-number>  =>   B<string, optional>

=begin html

<br>Adapter part number assigned by the vendor. Will be missing if data not available or not supported.

=end html

=back



=over 2

=item * I<adapter-serial-number>  =>   B<string, optional>

=begin html

<br>Adapter serial number. Will be missing if data not available or not supported.

=end html

=back



=over 2

=item * I<adapter-slot>  =>   B<integer>

=begin html

<br>Slot number for the adapter port.

=end html

=back



=over 2

=item * I<adapter-state>  =>   B<string>

=begin html

<br>Current state of the adapter. Possible values: "up", "down", "offline_soft", "offline_hard", "offline_loopback".

=end html

=back



=over 2

=item * I<adapter-vendor>  =>   B<string, optional>

=begin html

<br>Represents the adapter vendor. Example: Qlogic. Will be missing if data not available or not supported.

=end html

=back



=over 2

=item * I<base-wwn>  =>   B<string>

=begin html

<br>Physical base node world-wide name

=end html

=back



=over 2

=item * I<firmware-rev>  =>   B<string>

=begin html

<br>Firmware revision of adapter

=end html

=back



=over 2

=item * I<hardware-rev>  =>   B<string>

=begin html

<br>This is the hardware chip revision of adapter.

=end html

=back



=over 2

=item * I<is-enabled>  =>   B<boolean>

=begin html

<br>Is the adapter enabled?

=end html

=back



=over 2

=item * I<is-in-use>  =>   B<boolean>

=begin html

<br>Is adapter in use? true or false.

=end html

=back



=over 2

=item * I<is-redundant>  =>   B<boolean>

=begin html

<br>Is adapter dual-attached? true or false.

=end html

=back



=over 2

=item * I<sas-adapter-disabled-phy-count>  =>   B<integer, optional>

=begin html

<br>Number of disabled PHYs on the host adapter.

=end html

=back



=over 2

=item * I<sas-adapter-enabled-phy-count>  =>   B<integer, optional>

=begin html

<br>Number of enabled PHYs on the host adapter.

=end html

=back



=over 2

=item * I<sas-adapter-expander-phy-states>  =>   B<L<"sas-adapter-expander-phy-state-info">[], optional>

=begin html

<br>List of expander PHYs, a SAS adapter transceivers, state info. It will be missing if data is not available or if no expander is connected to the adapter.

=end html

=back



=over 2

=item * I<sas-phy>  =>   B<L<"phy-state-info">[], optional>

=begin html

<br>List of adapter PHY state info.

=end html

=back



=over 2

=item * I<sas-qsfp-cable>  =>   B<L<"sas-qsfp-cable-info">, optional>

=begin html

<br>QSFP information of the cable. QSFP is acronym for Quad Small Form-factor Pluggable.. Will be missing if data not available or not or cable not present supported.

=end html

=back



=head2 adapter-sff-info

=begin html

Information on small form factor transceiver/connector (also known as sff).

=end html



B<Fields>

=over 2

=item * I<part-number>  =>   B<string>

=begin html

<br>Vendor's part number for the sff. If data not available, value will be "not_available".

=end html

=back



=over 2

=item * I<serial-number>  =>   B<string>

=begin html

<br>Serial number for sff. If data not available, value will be "not_available".

=end html

=back



=over 2

=item * I<speed-capabilities>  =>   B<string>

=begin html

<br>Comma separated list of speed capabilities of the sff. Example: "1, 2 Gbit/Sec". If data not available, value will be "not_available".

=end html

=back



=over 2

=item * I<vendor>  =>   B<string>

=begin html

<br>sff vendor name. If data not available, value will be "not_available".

=end html

=back



=head2 adapter-sfp-info

=begin html

Information on small form factor pluggable transceiver/connector (also known as sfp).

=end html



B<Fields>

=over 2

=item * I<part-number>  =>   B<string>

=begin html

<br>Vendor's part number for the sfp. If data not available, value will be "not_available".

=end html

=back



=over 2

=item * I<serial-number>  =>   B<string>

=begin html

<br>Serial number for sfp. If data not available, value will be "not_available".

=end html

=back



=over 2

=item * I<speed-capabilities>  =>   B<string, optional>

=begin html

<br>Comma separated list of speed capabilities of the sfp. Example: "1, 2 Gbit/Sec". If data not available, value will be "not_available".

=end html

=back



=over 2

=item * I<vendor>  =>   B<string>

=begin html

<br>sfp vendor name If data not available, value will be "not_available".

=end html

=back



=head2 expander-phy-state-info

=begin html

Expander PHY state information.

=end html



B<Fields>

=over 2

=item * I<expander-phy>  =>   B<integer>

=begin html

<br>A PHY is a transceiver; it is the object in a device that electrically interfaces to a physical link.

=end html

=back



=over 2

=item * I<expander-phy-attached-device-type>  =>   B<string>

=begin html

<br>Device type attached to an adapter PHY. Possible values: <ul> <li> "initiator" - A device type that can initiate a SAS communication, <li> "expander" - A device type that facilitates communication between multiple SAS devices, <li> "sas_end_device" - A SAS device that is not contained within an expander device, <li> "sata_end_device" - A SATA end device, <li> "unknown" - An unknown device type. </ul>

=end html

=back



=over 2

=item * I<expander-phy-state>  =>   B<string>

=begin html

<br>Expander PHY state info. Possible values: <ul> <li> "sas_phy_state_enabled_rate_unknown" - PHY is enabled but data transfer rate is unknown, <li> "sas_phy_state_disabled" - PHY is disabled, <li> "sas_phy_state_speed_neg_failed" - Data tranfer rate negotiation failed, <li> "sas_phy_state_sata_oob_failed" - SATA OOB(Out Of Band) signaling failed, <li> "sas_phy_state_enabled_15gbs" - 1.5 Gb/s data transfer rate, <li> "sas_phy_state_enabled_30gbs" - 3.0 Gb/s data transfer rate, <li> "sas_phy_state_enabled_60gbs" - 6.0 Gb/s data transfer rate, <li> "unknown" - Unknown PHY state. </ul>

=end html

=back



=over 2

=item * I<expander-phy-wwn>  =>   B<string>

=begin html

<br>Expander PHY's world-wide name.

=end html

=back



=head2 phy-state-info

=begin html

Adapter PHY state information.

=end html



B<Fields>

=over 2

=item * I<phy>  =>   B<integer>

=begin html

<br>A PHY is a transceiver; it is the object in a device that electrically interfaces to a physical link.

=end html

=back



=over 2

=item * I<phy-state>  =>   B<string>

=begin html

<br>Adapter PHY state info. Possible values: "sas_phy_state_enabled_rate_unknown", "sas_phy_state_disabled", "sas_phy_state_speed_neg_failed", "sas_phy_state_SATA_OOB_failed", "sas_phy_state_enabled_15gbs", "sas_phy_state_enabled_30gbs", "sas_phy_state_enabled_60gbs", "unknown".

=end html

=back



=over 2

=item * I<phy-wwn>  =>   B<string, optional>

=begin html

<br>Adapter PHY's world-wide name.

=end html

=back



=head2 sas-adapter-expander-phy-state-info

=begin html

Adapter PHY and list of connected expander PHYs.

=end html



B<Fields>

=over 2

=item * I<adapter-phy>  =>   B<integer>

=begin html

<br>Adapter PHY connected to a list of expander PHYs.

=end html

=back



=over 2

=item * I<expander-phy-states>  =>   B<L<"expander-phy-state-info">[]>

=begin html

<br>List of all expanders connected to an adapter's PHY.

=end html

=back



=head2 sas-qsfp-cable-info

=begin html

QSPF Cable information.

=end html



B<Fields>

=over 2

=item * I<cable-end-identifier>  =>   B<string, optional>

=begin html

<br>Each cable has two ends. This field shows which end of the cable is connected to the shelf. This field will not be present if the information is not available or accessible, or if a cable is not connected at this connector. Possible values: "end_0", "end_1".

=end html

=back



=over 2

=item * I<cable-length>  =>   B<string, optional>

=begin html

<br>Length of the cable. Will be missing if data not available or not present.

=end html

=back



=over 2

=item * I<cable-manufacturer>  =>   B<string, optional>

=begin html

<br>Manufacturer of the cable. Will be missing if data not available or not present.

=end html

=back



=over 2

=item * I<cable-part-number>  =>   B<string, optional>

=begin html

<br>Cable part number as assigned by the manufacturer. Will be missing if data not available or not present.

=end html

=back



=over 2

=item * I<cable-serial-number>  =>   B<string, optional>

=begin html

<br>Cable serial number as assigned by the manufacturer. Will be missing if data not available or not present.

=end html

=back



=over 2

=item * I<cable-technology>  =>   B<string, optional>

=begin html

<br>Cable technology. This field will not be present if the information is not available or accessible, or if a cable is not connected at this connector. Possible values: "copper", "optical".

=end html

=back



=head2 storage-array-config-summary

=begin html

A summary of array LUN connectivity for each attached array.

=end html



B<Fields>

=over 2

=item * I<array-name>  =>   B<string>

=begin html

<br>The name assigned to the array this group of array LUNs is exported from. 28 character string, no spaces.

=end html

=back



=over 2

=item * I<device-type>  =>   B<string, optional>

=begin html

<br>Type of LUN device. Describes the type of lun device or tape library. Possible Values are: <ul> <li> "array_lun" - Array LUN type <li> "tape_mc" - Tape Drive or Media Changer/library type <li> "unknown" - Unknown device type </ul>

=end html

=back



=over 2

=item * I<group-number>  =>   B<integer>

=begin html

<br>A unique number associated with a set of array LUNs that share the exact same pathing/connectivity information. Range: [0..65535]

=end html

=back



=over 2

=item * I<initiator-port>  =>   B<string>

=begin html

<br>Initiator port name, e.g. 0a.

=end html

=back



=over 2

=item * I<lun-count>  =>   B<integer>

=begin html

<br>The number of array LUNs assigned to this group. Range: [0..65535]

=end html

=back



=over 2

=item * I<switch-port>  =>   B<string>

=begin html

<br>Name of switch port connected to the HBA (controller's initiator port), or UNKNOWN if direct attached.

=end html

=back



=over 2

=item * I<target-side-switch-port>  =>   B<string>

=begin html

<br>Name of switch port connected to target array, or UNKNOWN if direct attached.

=end html

=back



=over 2

=item * I<target-wwpn>  =>   B<string>

=begin html

<br>World wide port name of array's target port (64 chars).

=end html

=back



=head2 storage-array-port

=begin html

Maps array definition to target port

=end html



B<Fields>

=over 2

=item * I<array-id>  =>   B<integer>

=begin html

<br>Primary key (system defined) for the array record. Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<array-name>  =>   B<string>

=begin html

<br>Name of the array in the array record. (28 char max)

=end html

=back



=over 2

=item * I<wwnn>  =>   B<string>

=begin html

<br>World wide node name of array's target port (64 chars).

=end html

=back



=over 2

=item * I<wwpn>  =>   B<string>

=begin html

<br>World wide port name of array's target port (64 chars).

=end html

=back



=head2 storage-array-profile

=begin html

data describing characteristics/parameters of/about a storage array

=end html



B<Fields>

=over 2

=item * I<array-id>  =>   B<integer>

=begin html

<br>primary key (system defined) for the array record. Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<firmware>  =>   B<string>

=begin html

<br>The firmware revision of the array. (64 chars max)

=end html

=back



=over 2

=item * I<model>  =>   B<string>

=begin html

<br>The model name of the array. (16 chars max)

=end html

=back



=over 2

=item * I<name>  =>   B<string>

=begin html

<br>A unique node-level user supplied name for the array. (28 char max)

=end html

=back



=over 2

=item * I<network-address>  =>   B<string>

=begin html

<br>IP address/node name of the array's SNMP management port. (1024 char max)

=end html

=back



=over 2

=item * I<options>  =>   B<string>

=begin html

<br>A comma separated list of name value pairs of array specific settings. (128 chars max)

=end html

=back



=over 2

=item * I<port-failover-type>  =>   B<string>

=begin html

<br>The pathing failover supported by the array, either ACTIVE-ACTIVE or ACTIVE-PASSIVE.

=end html

=back



=over 2

=item * I<prefix>  =>   B<string>

=begin html

<br>A unique user supplied 5 character code used to refer to this array and used in naming the array's LUNs.

=end html

=back



=over 2

=item * I<serial-number>  =>   B<string>

=begin html

<br>The serial number of the array. (17 char max)

=end html

=back



=over 2

=item * I<vendor>  =>   B<string>

=begin html

<br>The name of the array's vendor, e.g. NetApp. (8 chars max)

=end html

=back



=head2 disk-aggregate-info

=begin html

Details giving disk's basic disposition within its overlying aggregate or traditional volume. Information that is specific to a disk contained within an aggregate or traditional volume is returned here. Returned only if 'container-type' is "aggregate" or "volume".

=end html



B<Fields>

=over 2

=item * I<aggregate-name>  =>   B<string, optional>

=begin html

<br>Name of aggregate or traditional volume with which this disk is associated. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<checksum-type>  =>   B<string, optional>

=begin html

<br>The checksum type that has been assigned to this disk. Omitted if information is unavailable, or if excluded by 'desired-attributes'. <p> Possible values: <ul> <li> "advanced_zoned" - Advanced zoned checksum. <li> "block" - Block checksum. <li> "none" - No checksum type assigned. <li> "wafl" - WAFL checksum. <li> "zoned" - Zoned checksum. </ul>

=end html

=back



=over 2

=item * I<copy-destination-name>  =>   B<string, optional>

=begin html

<br>name of copy destination. Omitted if both 'is-prefailed' and 'is-replacing' are false, or if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<copy-percent-complete>  =>   B<integer, optional>

=begin html

<br>Percent completion of disk copy. Omitted if no copy operation involving this disk is in progress. So omitted if neither 'is-prefailed' nor 'is-replacing' is true, and if position is not "copy".

=end html

=back



=over 2

=item * I<is-media-scrubbing>  =>   B<boolean, optional>

=begin html

<br>True if media scrub is currently active for this disk. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<is-offline>  =>   B<boolean, optional>

=begin html

<br>True if disk is offline. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<is-prefailed>  =>   B<boolean, optional>

=begin html

<br>True if the admin issued a 'disk fail' or if the the system marked this disk for Rapid RAID Recovery. This flag is expected to remain set until the system has copied the contents of this disk to a system-selected replacement disk. At that point, this disk is expected to be removed from service and placed in in the broken pool. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<is-reconstructing>  =>   B<boolean, optional>

=begin html

<br>True if disk is in process of being reconstructed. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<is-replacing>  =>   B<boolean, optional>

=begin html

<br>True if the admin issued 'disk replace' to replace this disk with a specified replacement disk. This flag is expected to remain true until the system has copied the contents of this disk to the admin-specified replacement disk. At that point this disk is expected to be released to the spare pool. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<is-zeroed>  =>   B<boolean, optional>

=begin html

<br>True if disk is in pre-zeroed state. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<is-zeroing>  =>   B<boolean, optional>

=begin html

<br>True only if disk position is 'pending' and disk is in process of being zeroed. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<plex-name>  =>   B<string, optional>

=begin html

<br>Name of plex with which this disk is associated. Omitted if disk is not associated with a plex, or if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<raid-group-name>  =>   B<string, optional>

=begin html

<br>Name of RAID group to which this disk belongs. Omitted if disk does not belong to a RAID group, or if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<reconstruct-percent-complete>  =>   B<integer, optional>

=begin html

<br>Percent completion of disk reconstruction. Omitted if 'is-reconstructing' is not true, or if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<zeroing-percent-complete>  =>   B<integer, optional>

=begin html

<br>Percent completion of disk zeroing. Omitted if is-zeroing' is not true, or if excluded by 'desired-attributes'.

=end html

=back



=head2 disk-inventory-info

=begin html

Disk inventory info.

=end html



B<Fields>

=over 2

=item * I<bytes-per-sector>  =>   B<integer, optional>

=begin html

<br>Number of bytes per disk sector. A sector count element, such as 'capacity-sectors' and 'right-size-sectors', may be multiplied by this value to convert to a byte count. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<capacity-sectors>  =>   B<integer, optional>

=begin html

<br>Total number of disk sectors on this disk, given in units of 'bytes-per-sector'. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<carrier-id>  =>   B<string, optional>

=begin html

<br>Unique identifier of the disk carrier. Maximum length of 34 characters. It is not returned if is-multidisk-carrier is set to false. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<carrier-serialno>  =>   B<string, optional>

=begin html

<br>Unique serial number of the disk carrier. Maximum length of 17 characters. It is not returned if is-multidisk-carrier is set to false. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<checksum-compatibility>  =>   B<string, optional>

=begin html

<br>An indication of the checksum types that this disk is capable of supporting. Each possible return value represents one or more checksum types. Omitted if not available or if excluded by 'desired-attributes'. <p> Starting in Data ONTAP 8.1, "zoned/block" is no longer supported. <p> Possible values: <ul> <li> "advanced_zoned" - Supports advanced zoned checksum. <li> "block" - Supports block checksum. <li> "none" - No checksum support. <li> "zoned/advanced_zoned" - Supports zoned and advanced zoned checksum. </ul>

=end html

=back



=over 2

=item * I<disk-type>  =>   B<string, optional>

=begin html

<br>Disk interface type. Omitted if excluded by 'desired-attributes'. <p> Possible values: <ul> <li> "ATA" <li> "BSAS" <li> "EATA" <li> "FCAL" <li> "LUN" <li> "MSATA" <li> "SAS" <li> "SATA" <li> "SCSI" <li> "SSD" <li> "XATA" <li> "XSAS" <li> "FSAS" <li> "unknown" </ul>

=end html

=back



=over 2

=item * I<disk-uid>  =>   B<string, optional>

=begin html

<br>Disk unique identifier. Maximum length of 90 characters. Omitted if excluded by desired-attributes'.

=end html

=back



=over 2

=item * I<firmware-revision>  =>   B<string, optional>

=begin html

<br>Firmware revision of disk. The format of the firmware revision will vary depending on the type of disk and its vendor. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<grown-defect-list-count>  =>   B<integer, optional>

=begin html

<br>Number of entries in the drive's grown defect list. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<health-monitor-time-interval>  =>   B<integer, optional>

=begin html

<br>Number of seconds we have been keeping track of errors from storage health monitor (SHM). Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<is-dynamically-qualified>  =>   B<boolean, optional>

=begin html

<br>True if the drive was dynamically qualified. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<is-foreign>  =>   B<boolean, optional>

=begin html

<br>Indicates an array LUN has been designated as a foreign LUN and cannot be assigned. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<is-multidisk-carrier>  =>   B<boolean, optional>

=begin html

<br>True if the disk is in a carrier which contains more than one disk. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<media-scrub-count>  =>   B<integer, optional>

=begin html

<br>Number of times media has been scrubbed since controller last powered on. Omitted if not available.

=end html

=back



=over 2

=item * I<media-scrub-last-done-time-interval>  =>   B<integer, optional>

=begin html

<br>Number of seconds since a media scrub last completed. Omitted if not available.

=end html

=back



=over 2

=item * I<model>  =>   B<string, optional>

=begin html

<br>Disk model string. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<right-size-sectors>  =>   B<integer, optional>

=begin html

<br>Number of usable disk sectors that remain after subtracting the right-size adjustment for this disk. Given in units of 'bytes-per-sector'. Omitted if information is unavailable, or if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<rpm>  =>   B<integer, optional>

=begin html

<br>Rotational speed in revolutions per minute. Possible values are: 5400, 7200, 10000, and 15000. Omitted if information is unavailable, if rpm does not apply to this 'disk-type', or if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<serial-number>  =>   B<string, optional>

=begin html

<br>Disk serial number. Maximum length of 129 characters. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<shelf>  =>   B<string, optional>

=begin html

<br>Disk shelf, if it can be determined. Omitted if Shelf Enclosure Service is not enabled for this device, information is unavailable, or excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<shelf-bay>  =>   B<string, optional>

=begin html

<br>Disk shelf bay, if it can be determined. Omitted if Shelf Enclosure Service is not enabled for this device, information is unavailable, or excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<storage-ssd-info>  =>   B<L<"storage-ssd-info">, optional>

=begin html

<br>solid state device specific lifecycle data Omitted if 'disk-type' is not "SSD", or if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<vendor>  =>   B<string, optional>

=begin html

<br>Vendor of this disk. Omitted if excluded by 'desired-attributes'.

=end html

=back



=head2 disk-outage-info

=begin html

Information about a disk that is not in service.

=end html



B<Fields>

=over 2

=item * I<is-in-fdr>  =>   B<boolean, optional>

=begin html

<br>True if disk has entry in the persistent Failed Disk Registry. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<reason>  =>   B<string>

=begin html

<br>Reason disk is not in service. Omitted if excluded by 'desired-attributes'. <p> Possible values: <ul> <li> "admin failed" - Admin has persistently failed disk. <li> "admin removed" - Admin requested spare disk to be removed from system. <li> "admin testing" - Admin isolated disk for maintenance testing. <li> "bad label" - Disk has bad RAID label. <li> "bypassed" - Disk has been bypassed. <li> "failed" - Disk is persistently failed. <li> "init failed" - Disk failed initialization. <li> "label version" - Disk has invalid RAID label version. <li> "labeled broken" - Disk was persistently failed in a prior Data ONTAP release. <li> "labelmaint" - Disk is isolated for online label maintenance. <li> "LUN resized" - Array LUN was inappropriately resized. <li> "missing" - Disk has gone missing. <li> "not responding" - Disk is non-responsive. <li> "predict failure" - Disk failure is predicted. capacity than previously. <li> "rawsize shrank" - Disk reporting smaller <li> "recovering" - Disk is underoing recovery. <li> "sanitizing" - Disk is in process of being sanitized. <li> "sanitized" - Disk sanitization complete, but admin has not yet released disk back to the spare pool. in this release. <li> "SFO Disk" - SFO disk, not supported on 7-mode systems. <li> "SnapLock Disk" - SnapLock disk, not supported. <li> "testing" - System isolated disk for maintenance testing. <li> "unassigned" - Disk ownership has not been assigned. <li> "unknown" - Don't know reason disk is not in service. </ul>

=end html

=back



=head2 disk-ownership-info

=begin html

Disk sanown information.

=end html



B<Fields>

=over 2

=item * I<disk-uid>  =>   B<string, optional>

=begin html

<br>Disk unique identifier. Maximum length of 90 characters. Example of output format is: 20000000:87A9652B:00000000:00000000:00000000:00000000:00000000:00000000:00000000:00000000 Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<home-node-id>  =>   B<integer, optional>

=begin html

<br>ID (NVRAM ID) of home node to which this disk is assigned. Omitted if disk is unassigned, or if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<home-node-name>  =>   B<string, optional>

=begin html

<br>Name of the home node to which this disk is assigned. Omitted if disk is unassigned, or if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<is-failed>  =>   B<boolean, optional>

=begin html

<br>'true' if the disk is failed such that its ownership cannot be determined. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<owner-node-id>  =>   B<integer, optional>

=begin html

<br>ID (NVRAM ID) of node that currently owns this disk. Normally 'owner-node-id' matches 'home-node-id'. However, SFO style HA changes 'owner-node-id' when it localizes partner storage on takeover; and restores it to 'home-node-id' on giveback. Omitted if disk is unassigned, or if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<owner-node-name>  =>   B<string, optional>

=begin html

<br>Name of node that currently owns this disk. Normally 'owner-node-name' matches 'home-node-name'. However, SFO style HA changes 'owner-node-name' when it localizes partner storage on takeover; and restores it to 'home-node-name' on giveback. Omitted if disk is unassigned, or if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<pool>  =>   B<integer, optional>

=begin html

<br>Pool to which disk is assigned. Omitted if disk is unassigned, or if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<reserved-by-node-id>  =>   B<integer, optional>

=begin html

<br>ID (NVRAM ID) of node which currently holds the persistent reservation on this disk, 0 if there is none. Omitted if excluded by 'desired-attributes'.

=end html

=back



=head2 disk-raid-info

=begin html

RAID specific information about a disk, including RAID specific disk properties, and the disk's overlying container.

=end html



B<Fields>

=over 2

=item * I<active-node-name>  =>   B<string, optional>

=begin html

<br>Name of the node that is the active RAID controller for this disk, if any. Omitted if unavailable, or excluded by 'desired-attrributes'.

=end html

=back



=over 2

=item * I<container-type>  =>   B<string, optional>

=begin html

<br>Type of overlying disk container. Omitted if information is unavailable, or excluded by 'desired-attributes'. <p> Possible vaules: <ul> <li> "aggregate" - Container is an aggregate. <li> "broken" - Container is broken pool. <li> "foreign" - Array LUN has been marked foreign. <li> "labelmaint" - Container is online label maintenance list. <li> "maintenance" - Container is disk maintenance center. <li> "spare" - Container is spare pool. <li> "unassigned" - Disk ownership has not been assigned. <li> "unknown" - Container is currently unknown. This is the default setting. <li> "volume" - Container is a traditional volume. </ul>

=end html

=back



=over 2

=item * I<disk-aggregate-info>  =>   B<L<"disk-aggregate-info">, optional>

=begin html

<br>Information giving disk's basic disposition within its overlying aggregate or traditional volume. Omitted if container-type is not "aggregate" or "volume", or if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<disk-outage-info>  =>   B<L<"disk-outage-info">, optional>

=begin html

<br>Information about a disk that is not in service. Omitted if container-type is not "broken", "maintenance", "labelmaint", or "unassigned", or if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<disk-spare-info>  =>   B<L<"disk-spare-info">, optional>

=begin html

<br>Information giving disk's basic disposition within its overlying spare pool. Omitted if container-type is not "spare", or if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<disk-uid>  =>   B<string, optional>

=begin html

<br>Disk unique identifier. Maximum length of 90 characters. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<effective-disk-type>  =>   B<string, optional>

=begin html

<br>Effective disk interface type. Disks can report different physical 'disk-type', but the same 'effective-disk-type'. Disks with the same 'effective-disk-type' are compatible for use within the same aggregate or traditional volume. Omitted if information is unavailable, or excluded by 'desired-attributes'. <p> Possible values: <ul> <li> "ATA" <li> "EATA" <li> "FCAL" <li> "LUN" <li> "MSATA" <li> "SAS" <li> "BSAS" <li> "SATA" <li> "SCSI" <li> "SSD" <li> "XATA" <li> "XSAS" <li> "FSAS" <li> "unknown" </ul>

=end html

=back



=over 2

=item * I<effective-rpm>  =>   B<integer, optional>

=begin html

<br>Effective rotational speed in revolutions per minute. Disks can report different actual 'rpm', but have the same 'effective-rpm'. Disks with the same 'effective- rpm' are compatible for use within the same aggregate or traditional volume. Omitted if information is unavailable, or excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<physical-blocks>  =>   B<integer, optional>

=begin html

<br>RAID recorded disk capacity expressed in units of 4096-byte blocks. Typically this is the disk capacity reported by disk driver, but rounded down to the nearest 4096-byte block. Omitted if information is unavailable, or if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<position>  =>   B<string, optional>

=begin html

<br>Position of disk relative to its container-type. Omitted if excluded by 'desired-attributes'. <p> Possible values: <ul> <li> "copy" - RAID group copy destination disk. <li> "data" - RAID group data disk. <li> "dparity" - RAID group diagonal parity disk. <li> "orphan" - Disk is orphan of an aggregate or traditional volume. <li> "parity" - RAID group parity disk. <li> "pending" - Disk is pending addition to an aggregate or traditional volume. <li> "present" - Disk is present in system. This is the default setting. </ul>

=end html

=back



=over 2

=item * I<spare-pool>  =>   B<string, optional>

=begin html

<br>Name of RAID managed spare pool with which this disk is associated. Omitted if unavailable. Generally determined both by whether ownership has been assigned for this disk, and whether SyncMirror feature is supported on the reporting node. This disk may not currently be contained within this spare-pool, such as if it's been allocated to an aggregate or removed from service. This is the spare pool with which disk would be contained if/when it is initialized or released as a spare. Omitted if excluded by 'desired-attributes'. <p> Possible values: <ul> <li> "Pool0" - Disk is associated with spare Pool0. <li> "Pool1" - Disk is associated with spare Pool1. <li> "spare" - Disk is associated with the general spare pool. <li> "unknown" - Cannot determine spare pool associativity for this disk. </ul>

=end html

=back



=over 2

=item * I<used-blocks>  =>   B<integer, optional>

=begin html

<br>RAID recorded size of file system region on this disk, given in units of 4096-byte blocks. Typically based upon the disk's right-size capacity, but it may be smaller if RAID has downsized this disk, such as due to reconstruct replacing a smaller with a larger disk. This is distinct from WAFL usage of file system space. Omitted if information is unavailable, or if excluded by 'desired-attributes'.

=end html

=back



=head2 disk-spare-info

=begin html

Details giving disk's basic disposition within its overlying spare pool. Information that is specific to a disk that is contained within a spare pool belongs here.

=end html



B<Fields>

=over 2

=item * I<is-media-scrubbing>  =>   B<boolean, optional>

=begin html

<br>True if media scrub is currently active for this disk. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<is-offline>  =>   B<boolean, optional>

=begin html

<br>True if disk is offline. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<is-sparecore>  =>   B<boolean, optional>

=begin html

<br>True if disk is sparecore disk. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<is-zeroed>  =>   B<boolean, optional>

=begin html

<br>True if disk has been pre-zeroed. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<is-zeroing>  =>   B<boolean, optional>

=begin html

<br>True if disk is in process of being zeroed. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<zeroing-percent-complete>  =>   B<integer, optional>

=begin html

<br>Percent completion of disk zeroing. Omitted if is-zeroing' is not true, or if excluded by 'desired-attributes'.

=end html

=back



=head2 disk-stats-info

=begin html

Contains disk statistics.

=end html



B<Fields>

=over 2

=item * I<average-latency>  =>   B<integer, optional>

=begin html

<br>Access time to disk in milliseconds. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<bytes-per-sector>  =>   B<integer, optional>

=begin html

<br>Number of bytes per disk sector. A sector count element, such as 'sectors-read' and 'sectors-written', may be multipled by this value to convert to a byte count. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<disk-io-kbps>  =>   B<integer, optional>

=begin html

<br>Rolling average of kilobytes per second read and written to this disk. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<disk-iops>  =>   B<integer, optional>

=begin html

<br>Rolling average of I/O operations per second read and written to this disk. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<disk-uid>  =>   B<string, optional>

=begin html

<br>Unique identifier of disk for this disk. Maximum length of 90 characters. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<path-error-count>  =>   B<integer, optional>

=begin html

<br>The number of errors on this disk. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<power-on-time-interval>  =>   B<integer, optional>

=begin html

<br>Number of seconds the drive has been powered on. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<sectors-read>  =>   B<integer, optional>

=begin html

<br>Number of disk sectors read since system last booted, given in units of 'bytes-per-sector'. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<sectors-written>  =>   B<integer, optional>

=begin html

<br>Number of disk sectors written since system last booted, given in units of 'bytes-per-sector'. Omitted if excluded by 'desired-attributes'.

=end html

=back



=head2 fw-update-status-info

=begin html

List of disks that are pending updates, but not able to be updated.

=end html



B<Fields>

=over 2

=item * I<avg-duration>  =>   B<integer, optional>

=begin html

<br>Average firmware update duration per disk in seconds.

=end html

=back



=over 2

=item * I<update-completion>  =>   B<integer, optional>

=begin html

<br>Estimate for background firmware download completion in minutes.

=end html

=back



=over 2

=item * I<update-unable>  =>   B<string, optional>

=begin html

<br>Name of disk that cannot be updated.

=end html

=back



=over 2

=item * I<waiting-disks>  =>   B<integer, optional>

=begin html

<br>The number of disks waiting for firmware update.

=end html

=back



=head2 storage-disk-info

=begin html

Disk record.

=end html



B<Fields>

=over 2

=item * I<disk-inventory-info>  =>   B<L<"disk-inventory-info">, optional>

=begin html

<br>Device driver information. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<disk-name>  =>   B<string, optional>

=begin html

<br>Name of the disk, e.g. 0a.25. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<disk-ownership-info>  =>   B<L<"disk-ownership-info">, optional>

=begin html

<br>Disk ownership information. Omitted if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<disk-paths>  =>   B<L<"disk-path-info">[], optional>

=begin html

<br>List of all known paths associated with this disk. Omitted if no paths to report, or if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<disk-raid-info>  =>   B<L<"disk-raid-info">, optional>

=begin html

<br>RAID disk information. Omitted if disk is not visible to RAID, or if this information is excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<disk-stats-info>  =>   B<L<"disk-stats-info">, optional>

=begin html

<br>Statistics about disk. Omitted if no stats to report, or if excluded by 'desired-attributes'.

=end html

=back



=over 2

=item * I<disk-uid>  =>   B<string, optional>

=begin html

<br>Disk unique identifier. Maximum length of 90 characters. Example of output format is: 20000000:87A9652B:00000000:00000000:00000000:00000000:00000000:00000000:00000000:00000000 Omitted if excluded by 'desired-attributes'.

=end html

=back



=head2 disk-path-info

=begin html

Contains per path statistics, errors and other related data.

=end html



B<Fields>

=over 2

=item * I<array-name>  =>   B<string>

=begin html

<br>The name of the array providing the lun.

=end html

=back



=over 2

=item * I<disk-name>  =>   B<string>

=begin html

<br>The name of the disk this path information is for

=end html

=back



=over 2

=item * I<disk-port>  =>   B<string, optional>

=begin html

<br>Disk port associated with this path. Possible values are "A" or "B". Omitted for non-disk target.

=end html

=back



=over 2

=item * I<disk-port-name>  =>   B<string, optional>

=begin html

<br>Disk port name associated with this path. This has the form &lt;attachment-style&gt;:&lt;disk-port&gt;, where &lt;attachment-style&gt; is either "FC" for FibreChannel, or "SA" for SAS, and &lt;disk-port&gt; is either "A" or "B". Omitted for non-disk target. <p> Possible values: <ul> <li> "FC:A" <li> "FC:B" <li> "SA:A" <li> "SA:B" </ul>

=end html

=back



=over 2

=item * I<disk-uid>  =>   B<string>

=begin html

<br>Disk's UID, as supplied by the hardware, used to uniquely identify this disk.

=end html

=back



=over 2

=item * I<initiator-io-kbps>  =>   B<integer>

=begin html

<br>Rolling average of kilobytes per second read and written over this initiator port. Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<initiator-iops>  =>   B<integer>

=begin html

<br>Rolling average of I/O operations per second read and written over this initiator port. Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<initiator-lun-in-use-count>  =>   B<integer>

=begin html

<br>Number of LUNs in the IN-USE state on this initiator. Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<initiator-port>  =>   B<string>

=begin html

<br>Initiator port name, e.g. 0a.

=end html

=back



=over 2

=item * I<initiator-port-speed>  =>   B<string>

=begin html

<br>The speed that the initiator port has negotiated with its connected switch, or target port if direct attached.

=end html

=back



=over 2

=item * I<initiator-side-switch-port>  =>   B<string>

=begin html

<br>The name of the switch connected to the controller's initiator port, or N/A when using direct attach

=end html

=back



=over 2

=item * I<lun-io-kbps>  =>   B<integer>

=begin html

<br>Rolling average of kilobytes per second read and written to this LUN. Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<lun-iops>  =>   B<integer>

=begin html

<br>Rolling average of I/O operations per second read and written to this LUN. Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<lun-number>  =>   B<integer>

=begin html

<br>LU number. Range: [0..65535]

=end html

=back



=over 2

=item * I<lun-path-use-state>  =>   B<string>

=begin html

<br>ONTAP's use of this path INU - (In Use) This path is currently used for I/O. RDY - (Ready) This path is not being used for I/O currently, but might transition to INU if storge errors or load balancing cause it to transition to INU. ERR - (High Error) The weighted error total on this path is 20% or more of the error threshold. Load balancing will not use it, and the error handling code will only use it as a last resort. QNG - (Quiescing) : The disk is becoming quiesced on this path. QED - (Quiesced) : The disk is quiesced on this path. MCF - (Misconfigured) : The disk is misconfigured on this path. The path is not available for I/O. Refer to storage_initiator_errors_list_info for details.

=end html

=back



=over 2

=item * I<node>  =>   B<string>

=begin html

<br>Controller with the initiator port for this path.

=end html

=back



=over 2

=item * I<path-io-kbps>  =>   B<integer>

=begin html

<br>Rolling average of kilobytes per second read and written to this path. Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<path-iops>  =>   B<integer>

=begin html

<br>Rolling average of I/O operations per second read and written to this path. Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<path-link-errors>  =>   B<integer>

=begin html

<br>Number of link errors reported on the path. Range: [0..2^32-1]

=end html

=back



=over 2

=item * I<path-lun-in-use-count>  =>   B<integer>

=begin html

<br>Number of LUNs in the IN-USE state on this path. Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<path-quality>  =>   B<integer>

=begin html

<br>The percentage of the error threshold. 0% NO ERROR 1-20% LOW ERROR, available to load balancing and error retry code. 21-99% MEDIUM ERROR, load balancing and error retry code will not switch to this path. 100-? HIGH_ERROR, Excessive errors EMS event will be logged Range: [0..2^32-1]

=end html

=back



=over 2

=item * I<preferred-target-port>  =>   B<boolean, optional>

=begin html

<br>For a logical unit which reports asymmetric access, preferred-target-port indicates that a path, regardless of the current access state, routes to a preferred target port group. Possible values are: <ul> <li> true: This path routes to a preferred target port group for this array LUN. <li> false: This path does not route to a preferred target port group or the array LUN reports that there is no preferred target port group. </ul>

=end html

=back



=over 2

=item * I<target-io-kbps>  =>   B<integer>

=begin html

<br>Rolling average of kilobytes per second read and written to this target port. Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<target-iops>  =>   B<integer>

=begin html

<br>Rolling average of I/O operations per second read and written to this target port. Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<target-lun-in-use-count>  =>   B<integer>

=begin html

<br>Number of LUNs in the IN-USE state on this target port. Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<target-port-access-state>  =>   B<string>

=begin html

<br>failover optimization type

=end html

=back



=over 2

=item * I<target-side-switch-port>  =>   B<string>

=begin html

<br>Name of the switch port connected to the target array, or UNKNOWN if direct attached.

=end html

=back



=over 2

=item * I<target-wwpn>  =>   B<string>

=begin html

<br>World Wide Port Name of target port providing the disk.

=end html

=back



=over 2

=item * I<tpgn>  =>   B<integer>

=begin html

<br>The Target Port Group Number of the array's target port. Range: [0..2^64-1]

=end html

=back



=head2 storage-error-info

=begin html

Contains error messages associated with back end array/shelf/LUNs.

=end html



B<Fields>

=over 2

=item * I<array-name>  =>   B<string>

=begin html

<br>Name of the array/shelf with the configuration error.

=end html

=back



=over 2

=item * I<disk-name>  =>   B<string>

=begin html

<br>The name of the disk or array lun this error information is for.

=end html

=back



=over 2

=item * I<disk-uid>  =>   B<string>

=begin html

<br>Disk's UID, as supplied by the hardware, used to uniquely identify this disk.

=end html

=back



=over 2

=item * I<error-id>  =>   B<integer>

=begin html

<br>A unique ID for each error returned. ID is unique on a per API call basis only. Range: [0..2^32-1]

=end html

=back



=over 2

=item * I<error-text>  =>   B<string>

=begin html

<br>A description of the error being reported.

=end html

=back



=over 2

=item * I<error-type>  =>   B<integer>

=begin html

<br>Enum describing type of error. Range: [0..2^32-1] 1. Redundancy error, less than two paths to a disk. 2. Redundancy error, device is only accessible via a single fault domain, all paths go into the same target port group. 3. Device is a control LUN. 4. This LUN has non WAFL data on it, and is write protected. 5. LUN too large, A LUN has been detected that is larger than the maximum size supported. 6. LUN too small, A LUN has been detected that is smaller than the minimum size supported. 7. Invalid Block Size, A LUN has been detected that has an unsupported block size. 8. A target port is accessable via multiple HBAs but the device to LUN id mappings aren't the same. 9. A device is presented at different LUN ids on different ports. 10. Multiple failover mode policies detected 11. Unknown array LUN 12. Data ONTAP(R) LUN

=end html

=back



=over 2

=item * I<lun-serial-number>  =>   B<string>

=begin html

<br>The serial number of the lun the error occurs on, blank if the error is not lun related.

=end html

=back



=over 2

=item * I<node>  =>   B<string>

=begin html

<br>The nodename reporting the disk or array lun with the error.

=end html

=back



=head2 storage-initiator-load-info

=begin html

Contains per port per disk load information.

=end html



B<Fields>

=over 2

=item * I<initiator-port>  =>   B<string>

=begin html

<br>Initiator port name, e.g. 0a. If port is not specified, data for all ports is returned.

=end html

=back



=over 2

=item * I<io-count>  =>   B<integer>

=begin html

<br>Megabytes of data sent to this disk over this port. Range: [0..2^32-1]

=end html

=back



=over 2

=item * I<lun-number>  =>   B<integer>

=begin html

<br>Logical Unit Number. Range: [0..65535]

=end html

=back



=over 2

=item * I<nodename>  =>   B<string>

=begin html

<br>IP address of the node serving the port in dotted-decimal format (for example, "192.168.11.12").

=end html

=back



=over 2

=item * I<percent-io>  =>   B<string>

=begin html

<br>Percentage of all I/O on this port sent to this disk. Range: [0..100]

=end html

=back



=over 2

=item * I<serial-number>  =>   B<string>

=begin html

<br>Disk/LUN serial number. Maximum length of 129 characters.

=end html

=back



=over 2

=item * I<switch-name>  =>   B<string>

=begin html

<br>The name of the switch connected to the controller's initiator port, or N/A when using direct attach.

=end html

=back



=over 2

=item * I<target-side-switch-port>  =>   B<string>

=begin html

<br>Name of the switch port connected to the target array, or UNKNOWN if direct attached.

=end html

=back



=over 2

=item * I<target-wwpn>  =>   B<string>

=begin html

<br>World Wide Port Name of array's target port.

=end html

=back



=head2 storage-initiator-path-info

=begin html

Contains per path statistics, errors and other related data.

=end html



B<Fields>

=over 2

=item * I<array-name>  =>   B<string>

=begin html

<br>The name of the array providing this path is connected to.

=end html

=back



=over 2

=item * I<device-type>  =>   B<string, optional>

=begin html

<br>Type of LUN device. Describes the type of lun device or tape library. Possible Values are: <ul> <li> "array_lun" - Array LUN type <li> "tape_mc" - Tape Drive or Media Changer/library type <li> "unknown" - Unknown device type </ul>

=end html

=back



=over 2

=item * I<initiator-io-kbps>  =>   B<integer>

=begin html

<br>Rolling average of kilobytes per second read and written over this initiator port Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<initiator-iops>  =>   B<integer>

=begin html

<br>Rolling average of I/O operations per second over this initiator port Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<initiator-lun-in-use-count>  =>   B<integer>

=begin html

<br>Number of LUNs in the IN-USE state on this initiator. Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<initiator-port>  =>   B<string>

=begin html

<br>Initiator port name, e.g. 0a.

=end html

=back



=over 2

=item * I<initiator-port-speed>  =>   B<string>

=begin html

<br>The speed that the initiator port has negotiated with its connected switch port, or target port if direct attached.

=end html

=back



=over 2

=item * I<initiator-side-switch-port>  =>   B<string>

=begin html

<br>The name of the switch connected to the controller's initiator port, or N/A when using direct attach.

=end html

=back



=over 2

=item * I<path-io-kbps>  =>   B<integer>

=begin html

<br>Rolling average of kilobytes per second read and written to this path. Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<path-iops>  =>   B<integer>

=begin html

<br>Rolling average of I/O operations per second read and written to this path. Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<path-link-errors>  =>   B<integer>

=begin html

<br>Number link errors reported on the path. Range: [0..2^32-1]

=end html

=back



=over 2

=item * I<path-lun-in-use-count>  =>   B<integer>

=begin html

<br>Number of disks in the IN-USE state on this path. Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<path-quality>  =>   B<integer>

=begin html

<br>The percentage of the error threshold. 0% NO ERROR 1-20% LOW ERROR, available to load balancing and error retry code. 21-99% MEDIUM ERROR, load balancing and error retry code will not switch to this path. 100-? HIGH_ERROR, Excessive errors EMS event will be logged Range: [0..2^32-1]

=end html

=back



=over 2

=item * I<target-io-kbps>  =>   B<integer>

=begin html

<br>Rolling average of kilobytes per second read and written to this target port. Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<target-iops>  =>   B<integer>

=begin html

<br>Rolling average of I/O operations per second read and written to this target port. Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<target-lun-in-use-count>  =>   B<integer>

=begin html

<br>Number of disks in the IN-USE state on this target port. Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<target-side-switch-port>  =>   B<string>

=begin html

<br>Name of the switch port connected to the target array, or UNKNOWN if direct attached.

=end html

=back



=over 2

=item * I<target-wwpn>  =>   B<string>

=begin html

<br>World Wide Port Name of target port providing the disk.

=end html

=back



=over 2

=item * I<tpgn>  =>   B<integer>

=begin html

<br>The Target Port Group Number of the array's target port. Range: [0..2^64-1]

=end html

=back



=head2 api-list-info

=begin html

name of the API

=end html



B<Fields>

=over 2

=item * None

=back



=head2 replication-transfer-info

=begin html

Structure of each entry in the transfer accounting table

=end html



B<Fields>

=over 2

=item * I<replication-available-transfers>  =>   B<integer>

=begin html

<br>Number of transfers that could be started at this point in time, if we choose only this particular replication type. Range:[0..2^32-1]

=end html

=back



=over 2

=item * I<replication-maximum-transfers>  =>   B<integer>

=begin html

<br>Maximum number of transfers that can be started, if we choose only this particular replication type. Range:[1..2^32-1]

=end html

=back



=over 2

=item * I<replication-type>  =>   B<string>

=begin html

<br>Type of replication operation. Qtree-snapmirror/SnapVault have two core data transfer mechanisms which they can utilize for data transfer. One is the legacy engine and the other is the newer engine. By default Data ONTAP enables the new engine. The user can choose to flip between the new engine and legacy engine. options-get api with an input of replication.logical.transfer_limits can be used to detect the type of engine. "current" implies a new engine while "previous" implies the legacy engine. Open Systems SnapVault (OSSV) always uses the legacy engine for transfers. Legacy volume-snapmirror limits are used when data resides on a traditional volume. Possible values of a replication operation are <ul> <li> "legacy_qtree_snapmirror_source"; <li> "legacy_qtree_snapmirror_destination"; <li> "qtree_snapmirror_source"; <li> "qtree_snapmirror_destination"; <li> "legacy_volume_snapmirror_source"; <li> "legacy_volume_snapmirror_destination"; <li> "volume_snapmirror_source"; <li> "volume_snapmirror_destination"; <li> "legacy_snapvault_source"; <li> "legacy_snapvault_destination"; <li> "snapvault_source"; <li> "snapvault_destination"; <li> "sync_snapmirror_source"; <li> "sync_snapmirror_destination"; <li> "volume_copy_source"; <li> "volume_copy_destination"; </ul>

=end html

=back



=head2 system-api-element-info

=begin html

api element description. This can be a simple type or a reference to another typedef (as defined in the 'type' element. Arrays are signified by having '[]' appended to the type name.

=end html



B<Fields>

=over 2

=item * I<encrypted>  =>   B<string, optional>

=begin html

<br>encryption type. If missing the parameter isn't encrypted

=end html

=back



=over 2

=item * I<is-nonempty>  =>   B<boolean, optional>

=begin html

<br>must element be non-empty. If false or missing element value may be empty.

=end html

=back



=over 2

=item * I<is-optional>  =>   B<boolean, optional>

=begin html

<br>is element optional. If false or missing element is required.

=end html

=back



=over 2

=item * I<is-output>  =>   B<boolean, optional>

=begin html

<br>is element an output element. If false or missing then is an input element

=end html

=back



=over 2

=item * I<is-validated>  =>   B<boolean, optional>

=begin html

<br>argument will have strong validation done by the server (e.g. integer range). If false or empty, no validation will be done.

=end html

=back



=over 2

=item * I<name>  =>   B<string>

=begin html

<br>name of element

=end html

=back



=over 2

=item * I<type>  =>   B<string>

=begin html

<br>type of variable possible values: "string", "integer", "boolean", type-name

=end html

=back



=head2 system-api-entry-info

=begin html

list of api names and their elements

=end html



B<Fields>

=over 2

=item * I<api-elements>  =>   B<L<"system-api-element-info">[]>

=begin html

<br>list of api elements

=end html

=back



=over 2

=item * I<name>  =>   B<string>

=begin html

<br>api name

=end html

=back



=head2 system-api-info

=begin html

api information

=end html



B<Fields>

=over 2

=item * I<is-streaming>  =>   B<boolean, optional>

=begin html

<br>does api stream data?

=end html

=back



=over 2

=item * I<license>  =>   B<string, optional>

=begin html

<br>license needed if any

=end html

=back



=over 2

=item * I<name>  =>   B<string>

=begin html

<br>name of api

=end html

=back



=head2 system-api-type-entry-info

=begin html

list of type names and their elements

=end html



B<Fields>

=over 2

=item * I<name>  =>   B<string>

=begin html

<br>type name

=end html

=back



=over 2

=item * I<type-elements>  =>   B<L<"system-api-element-info">[]>

=begin html

<br>list of type elements

=end html

=back



=head2 system-info

=begin html

Information about the system. Here system refers to a cluster node when running in cluster mode.

=end html



B<Fields>

=over 2

=item * I<backplane-part-number>  =>   B<string, optional>

=begin html

<br>Part number of the backplane.

=end html

=back



=over 2

=item * I<backplane-revision>  =>   B<string, optional>

=begin html

<br>Revision of the backplane part number.

=end html

=back



=over 2

=item * I<backplane-serial-number>  =>   B<string, optional>

=begin html

<br>Backplane serial number.

=end html

=back



=over 2

=item * I<board-speed>  =>   B<integer>

=begin html

<br>Speed of the system board in mega Hertz.

=end html

=back



=over 2

=item * I<board-type>  =>   B<string>

=begin html

<br>Type of the system board. This is defined by the vendor

=end html

=back



=over 2

=item * I<controller-address>  =>   B<string, optional>

=begin html

<br>The location of the controller in a multi-controller platform. Defined by the platform layer. Possible values: A,B,C,...

=end html

=back



=over 2

=item * I<cpu-ciob-revision-id>  =>   B<string, optional>

=begin html

<br>Processor's CIOB (Champion I/O Bus) revision ID. Defined by the CPU manufacturer.

=end html

=back



=over 2

=item * I<cpu-firmware-release>  =>   B<string, optional>

=begin html

<br>Firmware release number. Defined by the CPU manufacturer.

=end html

=back



=over 2

=item * I<cpu-microcode-version>  =>   B<integer>

=begin html

<br>cpu's microcode version. Defined by the CPU manufacturer. Range: [0..2^31-1]

=end html

=back



=over 2

=item * I<cpu-part-number>  =>   B<string, optional>

=begin html

<br>CPU's part number. Defined by the CPU manufacturer.

=end html

=back



=over 2

=item * I<cpu-processor-id>  =>   B<string, optional>

=begin html

<br>Processor's ID. Defined by the CPU manufacturer.

=end html

=back



=over 2

=item * I<cpu-processor-type>  =>   B<string, optional>

=begin html

<br>Processor's Type. Defined by the CPU manufacturer.

=end html

=back



=over 2

=item * I<cpu-revision>  =>   B<string, optional>

=begin html

<br>CPU's part number revision. Defined by the CPU manufacturer.

=end html

=back



=over 2

=item * I<cpu-serial-number>  =>   B<string, optional>

=begin html

<br>CPU's serial number. Defined by the CPU manufacturer.

=end html

=back



=over 2

=item * I<maximum-aggregate-size>  =>   B<integer, optional>

=begin html

<br>The platform's maximum aggregate size in bytes.

=end html

=back



=over 2

=item * I<maximum-flexible-volume-count>  =>   B<integer, optional>

=begin html

<br>The platform's maximum number of flexible volumes supported on this node. This does not include the number of volumes which can be supported when this node does a takeover of its partner node in a High Availability configuration.

=end html

=back



=over 2

=item * I<maximum-flexible-volume-size>  =>   B<integer, optional>

=begin html

<br>The platform's maximum flexible volume size in bytes.

=end html

=back



=over 2

=item * I<memory-size>  =>   B<integer>

=begin html

<br>Memory size in megabytes. (1024*1024).

=end html

=back



=over 2

=item * I<number-of-processors>  =>   B<integer>

=begin html

<br>Number of processors in the appliance.

=end html

=back



=over 2

=item * I<partner-system-id>  =>   B<string, optional>

=begin html

<br>Partner's system ID. Displayed in a cluster environment. A string of 10 characters.

=end html

=back



=over 2

=item * I<partner-system-name>  =>   B<string, optional>

=begin html

<br>Partner's system name. Displayed in a cluster environment. Defined in the partner's setup.

=end html

=back



=over 2

=item * I<partner-system-serial-number>  =>   B<string, optional>

=begin html

<br>Partner System serial number. Currently a string of numbers.

=end html

=back



=over 2

=item * I<prod-type>  =>   B<string, optional>

=begin html

<br>Will be set to "V-Series","gfiler" or "gateway" depending upon the vendor providing the raw storage.

=end html

=back



=over 2

=item * I<supports-raid-array>  =>   B<boolean>

=begin html

<br>Indicates whether the system supports raid arrays back-end connectivity or not. Possible values: "true" or "false".

=end html

=back



=over 2

=item * I<system-id>  =>   B<string>

=begin html

<br>System ID. This is defined by the vendor. Currently, it is a string of numbers

=end html

=back



=over 2

=item * I<system-machine-type>  =>   B<string>

=begin html

<br>Machine type of the system, like FAS3050

=end html

=back



=over 2

=item * I<system-model>  =>   B<string>

=begin html

<br>Model name of the system, like FAS3050

=end html

=back



=over 2

=item * I<system-name>  =>   B<string>

=begin html

<br>System name. This is the name defined during setup.

=end html

=back



=over 2

=item * I<system-revision>  =>   B<string, optional>

=begin html

<br>System revision. There revision id of the system board. Currently, a character followed by a number, B0.

=end html

=back



=over 2

=item * I<system-serial-number>  =>   B<string, optional>

=begin html

<br>System serial number.Currently a string of numbers.

=end html

=back



=over 2

=item * I<vendor-id>  =>   B<string>

=begin html

<br>Hardware vendor identifier.

=end html

=back



=head2 sid

=begin html

Windows security identifier describing a user. A SID has the format S-1-5-21-int-int-int-rid.

=end html



B<Fields>

=over 2

=item * None

=back



=head2 useradmin-capability-info

=begin html

Capability to run a command or commands on the filer.

=end html



B<Fields>

=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Name of the capability Possible values include: "*", "login-*", "cli-*", "api-*", "security-*"... Instead of "*", commands and subcommands can be specified directly. Please see man page or other documentation for more details.

=end html

=back



=head2 useradmin-group-info

=begin html

Structure containing information pertaining to a group.

=end html



B<Fields>

=over 2

=item * I<allowed-capabilities>  =>   B<L<"useradmin-capability-info">[], optional>

=begin html

<br>List of capabilities the group is allowed.

=end html

=back



=over 2

=item * I<comment>  =>   B<string, optional>

=begin html

<br>Comment for the group.

=end html

=back



=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Name of the group.

=end html

=back



=over 2

=item * I<rid>  =>   B<string, optional>

=begin html

<br>Unique relative identifier (per domain) for this group. (Used only for Windows.)

=end html

=back



=over 2

=item * I<useradmin-roles>  =>   B<L<"useradmin-role-info">[], optional>

=begin html

<br>List of roles this group contains. The only included entry in this structure is the name field. For full role information user useradmin-role-list.

=end html

=back



=head2 useradmin-role-info

=begin html

Structure containing information pertaining to a role.

=end html



B<Fields>

=over 2

=item * I<allowed-capabilities>  =>   B<L<"useradmin-capability-info">[], optional>

=begin html

<br>List of capabilities the role is allowed.

=end html

=back



=over 2

=item * I<comment>  =>   B<string, optional>

=begin html

<br>Comment for the role.

=end html

=back



=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Name of the role.

=end html

=back



=head2 useradmin-user-info

=begin html

Structure containing information pertaining to a user.

=end html



B<Fields>

=over 2

=item * I<allowed-capabilities>  =>   B<L<"useradmin-capability-info">[], optional>

=begin html

<br>List of capabilities the user is allowed.

=end html

=back



=over 2

=item * I<comment>  =>   B<string, optional>

=begin html

<br>Comment for the user. This is only set if the user has a comment.

=end html

=back



=over 2

=item * I<full-name>  =>   B<string, optional>

=begin html

<br>Full name of the user. (Used only for Windows.) This is only set if the user has a full-name.

=end html

=back



=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Name of the user.

=end html

=back



=over 2

=item * I<password-maximum-age>  =>   B<integer, optional>

=begin html

<br>Number of days that this user's password can be active before the user must change it. Default value is 2^31-1 days.

=end html

=back



=over 2

=item * I<password-minimum-age>  =>   B<integer, optional>

=begin html

<br>Number of days that this user's password must be active before the user can change it. Default value is 0.

=end html

=back



=over 2

=item * I<rid>  =>   B<string, optional>

=begin html

<br>Unique relative identifier (per domain) for this user. (Used only for Windows.)

=end html

=back



=over 2

=item * I<status>  =>   B<string, optional>

=begin html

<br>Current status of the user account. This element cannot be used as an input. It is used as an output for useradmin-user-list. Possible values: "enabled", "disabled", or "expired".

=end html

=back



=over 2

=item * I<useradmin-groups>  =>   B<L<"useradmin-group-info">[]>

=begin html

<br>List of groups this user is part of. The only included entry in this structure is the name field. For full group information user useradmin-group-list.

=end html

=back



=head2 adminhost

=begin html

This is information about the administrative host

=end html



B<Fields>

=over 2

=item * I<ipaddress>  =>   B<string>

=begin html

<br>IP address of administrative host. IP address is either IPv4 address or IPv6 address.

=end html

=back



=over 2

=item * I<name>  =>   B<string>

=begin html

<br>name of administrative host, pass an empty string if this is not known

=end html

=back



=head2 authentication-info

=begin html

Login and password information

=end html



B<Fields>

=over 2

=item * I<password>  =>   B<string, encrypted>

=begin html

<br>password to use on remote filer

=end html

=back



=over 2

=item * I<username>  =>   B<string>

=begin html

<br>login name to use on remote filer

=end html

=back



=head2 dns-info

=begin html

Information about one vfiler DNS configuration.

=end html



B<Fields>

=over 2

=item * I<dns-domain-name>  =>   B<string, optional>

=begin html

<br>Configured DNS domain name

=end html

=back



=over 2

=item * I<dns-servers>  =>   B<L<"server-address">[], optional>

=begin html

<br>IP addresses of the DNS servers.

=end html

=back



=head2 dnsserver-info

=begin html

This is information about one DNS server

=end html



B<Fields>

=over 2

=item * I<ipaddress>  =>   B<string>

=begin html

<br>DNS server IP address. IP address is either IPv4 address or IPv6 address.

=end html

=back



=head2 encrypted-authentication-info

=begin html

Encrypted Login and password information.

=end html



B<Fields>

=over 2

=item * I<password>  =>   B<string, encrypted>

=begin html

<br>encrypted password to use on remote filer

=end html

=back



=over 2

=item * I<username>  =>   B<string, encrypted>

=begin html

<br>encrypted login name to use on remote filer

=end html

=back



=head2 hostname-pair

=begin html

Alternate hostnames or IP addresses for redundancy purposes

=end html



B<Fields>

=over 2

=item * I<alternate-destination>  =>   B<string>

=begin html

<br>Hostname or IP address of alternate destination filer.

=end html

=back



=over 2

=item * I<alternate-source>  =>   B<string>

=begin html

<br>Hostname or IP address of alternate source filer.

=end html

=back



=head2 ipaddr-info

=begin html

Information about one IP address that should be bound to the vfiler at the destination.

=end html



B<Fields>

=over 2

=item * I<interface>  =>   B<string>

=begin html

<br>Name of the network interface.

=end html

=back



=over 2

=item * I<ip-address>  =>   B<string>

=begin html

<br>One ip address, in dotted-decimal format (for example, "192.168.11.12") if IPv4 address. If IPv6 address then it should be in the format a:b:c:d:e:f:g:h (for example, fd20:81be:b255:4213:2a0:98ff:fe07:609b).

=end html

=back



=over 2

=item * I<netmask>  =>   B<string>

=begin html

<br>Netmask, in dotted-decimal format (for example, "255.255.255.0") if IPv4 address, else if IPv6 then the prefix length (for example, "64").

=end html

=back



=head2 ipbinding-info

=begin html

This is information about one IP address binding

=end html



B<Fields>

=over 2

=item * I<interface>  =>   B<string>

=begin html

<br>Name of interface to bind IP address to.

=end html

=back



=over 2

=item * I<ipaddress>  =>   B<string>

=begin html

<br>IP address to bind binding. IP address is either IPv4 address or IPv6 address.

=end html

=back



=over 2

=item * I<netmask>  =>   B<string>

=begin html

<br>Netmask of IP address binding for IPv4, the prefix length in case of IPv6 address

=end html

=back



=head2 nis-info

=begin html

Information about one vfiler NIS configuration.

=end html



B<Fields>

=over 2

=item * I<nis-domain-name>  =>   B<string, optional>

=begin html

<br>Configured NIS domain name

=end html

=back



=over 2

=item * I<nis-servers>  =>   B<L<"server-address">[], optional>

=begin html

<br>Addresses of the NIS servers. Address is either IP address, or "*".

=end html

=back



=head2 nisserver-info

=begin html

This is information about one NIS server

=end html



B<Fields>

=over 2

=item * I<ipaddress>  =>   B<string>

=begin html

<br>NIS server IP address, or "*". IP address is either IPv4 address or IPv6 address.

=end html

=back



=head2 protocol-info

=begin html

This is information about one protocol

=end html



B<Fields>

=over 2

=item * I<protocol>  =>   B<string>

=begin html

<br>Name of a allowed protocol

=end html

=back



=head2 server-address

=begin html

This is information about one Server.

=end html



B<Fields>

=over 2

=item * I<ipaddress>  =>   B<string>

=begin html

<br>Address of the Server.

=end html

=back



=head2 storage-dr-status

=begin html

disaster recovery status of storage entity

=end html



B<Fields>

=over 2

=item * I<status>  =>   B<string>

=begin html

<br>status of storage entity. Possible values are: initializing, snapmirrored, unknown.

=end html

=back



=over 2

=item * I<storage-path>  =>   B<string>

=begin html

<br>path of storage entity. Example: vol1.

=end html

=back



=head2 storage-mr-status

=begin html

vfiler migration status of each storage entity

=end html



B<Fields>

=over 2

=item * I<error-msg>  =>   B<string, optional>

=begin html

<br>In case of migration failure, this field displays the reason for failure.

=end html

=back



=over 2

=item * I<status>  =>   B<string>

=begin html

<br>status of storage entity. Possible values are: "initializing", "snapmirrored", "unknown".

=end html

=back



=over 2

=item * I<storage-path>  =>   B<string>

=begin html

<br>Name of storage entity. Example: vol1.

=end html

=back



=head2 storage-unit

=begin html

one storage unit

=end html



B<Fields>

=over 2

=item * None

=back



=head2 vfiler-info

=begin html

Information about one vfiler.

=end html



B<Fields>

=over 2

=item * I<admin-host>  =>   B<L<"adminhost">, optional>

=begin html

<br>ID of administration host, if configured for this vfiler;

=end html

=back



=over 2

=item * I<dns-info>  =>   B<L<"dns-info">[]>

=begin html

<br>Information about this vfiler's DNS configuration.

=end html

=back



=over 2

=item * I<ipspace>  =>   B<string>

=begin html

<br>Name of the vfiler's ipspace

=end html

=back



=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Name of the vfiler.

=end html

=back



=over 2

=item * I<nis-info>  =>   B<L<"nis-info">[]>

=begin html

<br>Information about this vfiler's NIS configuration.

=end html

=back



=over 2

=item * I<uuid>  =>   B<string>

=begin html

<br>The vfiler's uuid.

=end html

=back



=over 2

=item * I<vfnets>  =>   B<L<"vfnet-info">[]>

=begin html

<br>List of all networking resources of this vfiler.

=end html

=back



=over 2

=item * I<vfstores>  =>   B<L<"vfstore-info">[]>

=begin html

<br>List of all storage resources of the vfiler.

=end html

=back



=head2 vfiler-location

=begin html

Name of vfiler and the physical filer hosting it

=end html



B<Fields>

=over 2

=item * I<filer>  =>   B<string>

=begin html

<br>Name of the physical filer

=end html

=back



=over 2

=item * I<vfiler>  =>   B<string>

=begin html

<br>Name of the vfiler

=end html

=back



=head2 vfnet-info

=begin html

Information about one networking resource.

=end html



B<Fields>

=over 2

=item * I<interface>  =>   B<string>

=begin html

<br>Name of the interface, which should be something that the "ifconfig" command recognizes, like "e0a" or a vif name.

=end html

=back



=over 2

=item * I<ipaddress>  =>   B<string>

=begin html

<br>IP address of the networking resource

=end html

=back



=over 2

=item * I<netmask>  =>   B<string>

=begin html

<br>Netmask, in dotted decimal format for IPv4, else the prefix length incase of IPv6. (example, "255.255.192.0" for IPV4 "32" for IPV6).

=end html

=back



=head2 vfstore-info

=begin html

Information about one storage resource.

=end html



B<Fields>

=over 2

=item * I<is-etc>  =>   B<boolean>

=begin html

<br>True if this storage unit is the etcpath, false otherwise.

=end html

=back



=over 2

=item * I<path>  =>   B<string>

=begin html

<br>Path of the storage resource

=end html

=back



=over 2

=item * I<status>  =>   B<string>

=begin html

<br>Status of the storage resource. Possible values are: online, offline, inconsistent.

=end html

=back



=head2 autosize-info

=begin html

Autosize settings of the volume This appears only if the "verbose" parameter above is set to "true".

=end html



B<Fields>

=over 2

=item * I<grow-threshold-percent>  =>   B<integer, optional>

=begin html

<br>The trigger capacity percentage at which the volume automatiacally grows.

=end html

=back



=over 2

=item * I<increment-size>  =>   B<integer, optional>

=begin html

<br>The increment size by which the volume would be grown, in kbytes.

=end html

=back



=over 2

=item * I<is-enabled>  =>   B<boolean, optional>

=begin html

<br>This element is deprecated in Data ONTAP 8.2 and later. Please use autosize-mode instead. The value of 'true' means that autosize is enabled, while 'false' means that the autosize mode is 'off'.

=end html

=back



=over 2

=item * I<maximum-size>  =>   B<integer, optional>

=begin html

<br>The maximum size to which the volume would be grown automatically, in kbytes.

=end html

=back



=over 2

=item * I<minimum-size>  =>   B<integer, optional>

=begin html

<br>The minimim size to which the volume can be shrunk automatically, in kbytes.

=end html

=back



=over 2

=item * I<mode>  =>   B<string, optional>

=begin html

<br>Defines the current mode of volume autosize. Legal modes include "grow", "grow_shrink", and "off".

=end html

=back



=over 2

=item * I<shrink-threshold-percent>  =>   B<integer, optional>

=begin html

<br>The trigger capacity percentage at which the volume automatically shrinks.

=end html

=back



=head2 clone-child-info

=begin html

Information describing each of the clones that are children of the current flexible volume.

=end html



B<Fields>

=over 2

=item * I<clone-child-name>  =>   B<string>

=begin html

<br>The name of a clone volume whose parent is the given flexible volume.

=end html

=back



=head2 clone-parent-info

=begin html

Information describing the parentage of a flexible volume clone.

=end html



B<Fields>

=over 2

=item * I<parent-snapshot-name>  =>   B<string>

=begin html

<br>The name of the snapshot in 'parent-volume-name' serving as the parent of this clone.

=end html

=back



=over 2

=item * I<parent-volume-name>  =>   B<string>

=begin html

<br>The name of the flexible volume serving as the parent of this clone.

=end html

=back



=head2 clone-split-detail-info

=begin html

Status information about an active clone split.

=end html



B<Fields>

=over 2

=item * I<blocks-scanned>  =>   B<integer>

=begin html

<br>Number of the clone's blocks that have been scanned to date by the split.

=end html

=back



=over 2

=item * I<blocks-updated>  =>   B<integer>

=begin html

<br>Total number of the clone's blocks that have been updated to date by the split.

=end html

=back



=over 2

=item * I<inode-percentage-complete>  =>   B<integer>

=begin html

<br>Percent of the clone's inodes processed to date by the split.

=end html

=back



=over 2

=item * I<inodes-processed>  =>   B<integer>

=begin html

<br>Number of the clone's inodes processed to date by the split.

=end html

=back



=over 2

=item * I<inodes-total>  =>   B<integer>

=begin html

<br>Total number of inodes in the clone.

=end html

=back



=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Name of the clone being split.

=end html

=back



=head2 clone-split-estimate-info

=begin html

Estimate information about a future clone split.

=end html



B<Fields>

=over 2

=item * I<estimate-blocks>  =>   B<integer>

=begin html

<br>The estimated number of 4kb blocks required to perform the volume clone split.

=end html

=back



=head2 compression-info

=begin html

Note that the use of this element is deprecated, refer to the 'dense-status' element for compression status instead.

=end html



B<Fields>

=over 2

=item * I<is-compression-enabled>  =>   B<string>

=begin html

<br>Note that the use of this field is deprecated, refer to the 'is-compression-enabled' field in the 'dense-status' element instead.

=end html

=back



=head2 errors-warnings-info

=begin html

The complete list of errors and warnings if perform-validation-only is true or all the warnings if is-override-warnings is true.

=end html



B<Fields>

=over 2

=item * I<error-warning>  =>   B<string>

=begin html

<br>Error or warning

=end html

=back



=head2 guarantee

=begin html

Type of guarantee

=end html



B<Fields>

=over 2

=item * I<type>  =>   B<string>

=begin html

<br>guarantee that is supported on a given volume. Possible values are: "volume", "file", "partial", "none"

=end html

=back



=head2 mediascrub-detail-info

=begin html

Information about media scrubbing.

=end html



B<Fields>

=over 2

=item * I<mediascrub-status>  =>   B<string>

=begin html

<br>Possible values are "suspended", "disabled" and "enabled" "suspended": Media scrub is enabled but temporarily paused because another task is running or it is in the idle cycle of its periodic run. It will resume automatically when the task is done or the idle cycle ends. "disabled": Media scrub feature is turned off. "enabled": Media scrub feature is active.

=end html

=back



=over 2

=item * I<percentage-complete>  =>   B<integer, optional>

=begin html

<br>Media scrubbing percentage complete. Range: [0..100].

=end html

=back



=over 2

=item * I<raid-group>  =>   B<string>

=begin html

<br>Name of the RAID group.

=end html

=back



=head2 raidgroup-size-info

=begin html

Default, minimum and maximum raidgroup size for each RAID type supported on this filer.

=end html



B<Fields>

=over 2

=item * I<default-size>  =>   B<integer>

=begin html

<br>Default size of a RAID group of this type in aggregates. Range : [6..16].

=end html

=back



=over 2

=item * I<maximum-size>  =>   B<integer>

=begin html

<br>Maximum size of a RAID group of this type in aggregates. Range : [6..28].

=end html

=back



=over 2

=item * I<minimum-size>  =>   B<integer>

=begin html

<br>Minimum size of a RAID group of this type in aggregates. Possible values: 2, 3.

=end html

=back



=over 2

=item * I<raidtype>  =>   B<string>

=begin html

<br>Name of the RAID type allowed on this filer. Possible values: raid0, raid4, raid_dp.

=end html

=back



=head2 raidtype-info

=begin html

RAID types allowed on this filer.

=end html



B<Fields>

=over 2

=item * I<raidtype>  =>   B<string>

=begin html

<br>Name of an allowed RAID type. Possible values: raid0, raid4, raid_dp.

=end html

=back



=head2 scrub-detail-info

=begin html

Scrubbing information.

=end html



B<Fields>

=over 2

=item * I<is-suspended>  =>   B<boolean>

=begin html

<br>Suspended state of the scrub on that RAID group.

=end html

=back



=over 2

=item * I<last-scrub-timestamp>  =>   B<integer, optional>

=begin html

<br>Time at which the last full scrub completed. If a scrub has never been performed, this value will not be returned. The time value is in seconds since January 1, 1970. Range : [0..2^31-1].

=end html

=back



=over 2

=item * I<percentage-complete>  =>   B<integer, optional>

=begin html

<br>Scrubbing percentage complete. I scrubbing is not active, this value will not be returned. Range : [0..100].

=end html

=back



=over 2

=item * I<raid-group>  =>   B<string>

=begin html

<br>Name of the RAID group involved in the scrub.

=end html

=back



=head2 sis-info

=begin html

Status and statistics for the SIS volume.

=end html



B<Fields>

=over 2

=item * I<compress-saved>  =>   B<integer>

=begin html

<br>The total disk space saved due to compression in KB (1024 Bytes) on the referenced file system. Range: [0 - 2^64-1]

=end html

=back



=over 2

=item * I<dedup-saved>  =>   B<integer>

=begin html

<br>The total disk space saved due to deduplication in KB (1024 Bytes) on the referenced file system. Range: [0 - 2^64-1]

=end html

=back



=over 2

=item * I<last-operation-begin>  =>   B<string>

=begin html

<br>Start timestamp of the last SIS operation.

=end html

=back



=over 2

=item * I<last-operation-end>  =>   B<string>

=begin html

<br>End timestamp of the last SIS operation.

=end html

=back



=over 2

=item * I<last-operation-error>  =>   B<string>

=begin html

<br>A human readable error message of the last SIS operation. Present when there was an error.

=end html

=back



=over 2

=item * I<last-operation-size>  =>   B<integer>

=begin html

<br>The size in bytes of the last SIS operation. Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<percent-compress-saved>  =>   B<integer>

=begin html

<br>The percentage of disk space saved by compression on the referenced file system. Range: [0 - 100]

=end html

=back



=over 2

=item * I<percent-dedup-saved>  =>   B<integer>

=begin html

<br>The percentage of disk space saved by deduplication on the referenced file system. Range: [0 - 100]

=end html

=back



=over 2

=item * I<percent-total-saved>  =>   B<integer>

=begin html

<br>The percentage of disk space saved by compression & deduplication on the referenced file system. Range: [0 - 100]

=end html

=back



=over 2

=item * I<percentage-saved>  =>   B<integer>

=begin html

<br>Percentage of space savings generated by the shared space. This is calculated as [size-saved / (size-saved + size-used)]. This field appears if the SIS volume is online. Range : [0..100].

=end html

=back



=over 2

=item * I<progress>  =>   B<string>

=begin html

<br>The progress of the current SIS operation.

=end html

=back



=over 2

=item * I<schedule>  =>   B<string>

=begin html

<br>The schedule for SIS operation on the volume. See sis-set-config for the format of the schedule.

=end html

=back



=over 2

=item * I<size-saved>  =>   B<integer>

=begin html

<br>The disk space savings generated by the shared space. The size is in bytes. The size-saved plus the size-used would be the total space usage, if no space is shared. This field appears if the SIS volume is online. Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<size-shared>  =>   B<integer>

=begin html

<br>Number of bytes in the used space that is shared. This field appears if this SIS volume is online. Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<state>  =>   B<string>

=begin html

<br>Possible values: "enabled", or "disabled".

=end html

=back



=over 2

=item * I<status>  =>   B<string>

=begin html

<br>Possible values: "idle", "active", "pending", or "undoing".

=end html

=back



=over 2

=item * I<total-saved>  =>   B<integer>

=begin html

<br>The total disk space saved by compression & deduplication in KB (1024 Bytes) on the referenced file system. Range: [0 - 2^64-1]

=end html

=back



=over 2

=item * I<type>  =>   B<string>

=begin html

<br>Possible values: "regular" or "snapvault".

=end html

=back



=head2 snap-autodelete-info

=begin html

Snapshot autodelete policy settings. This appears only if the "verbose" parameter above is set to "true".

=end html



B<Fields>

=over 2

=item * I<commitment>  =>   B<string>

=begin html

<br>Possible values: "try", "disrupt", or "destroy". This option determines the snapshots which snapshot autodelete is allowed to delete to get back space. Setting this option to "try" only permits the snapshots which are not locked by data protection utilities (dump, mirroring, NDMPcopy) and data backing functionalities (volume and LUN clones) to be deleted. Setting this option to "disrupt" only permits the snapshots which are not locked by data backing functionalities (volume and LUN clones) to be deleted.

=end html

=back



=over 2

=item * I<defer-delete>  =>   B<string>

=begin html

<br>Possible values "scheduled", "user_created", "prefix", or "none". This option determines which kind of snapshots to delete in the end. Setting this option value to "scheduled" will delete the snapshots created by the snapshot scheduler last. Setting this option value to "user_created" will delete the snapshots not created by the snapshot scheduler last. Setting this option value to "prefix" will delete the snapshots matching the prefix string to be deleted last. Setting this option value to "none" will disable the above choices.

=end html

=back



=over 2

=item * I<delete-order>  =>   B<string>

=begin html

<br>Possible values "oldest_first", "newest_first". This option determines if the oldest or newest snapshot is deleted first.

=end html

=back



=over 2

=item * I<destroy-list>  =>   B<string>

=begin html

<br>Possible values are the combination of "lun_clone", "vol_clone", "cifs_share", "file_clone" or "none". These options specify the list of service that can be destroyed if the snapshot is backing that service. This option is valid only when the commitment is set to destroy.

=end html

=back



=over 2

=item * I<prefix>  =>   B<string>

=begin html

<br>This option provides the prefix string for the "prefix" value of the "defer_delete" option.

=end html

=back



=over 2

=item * I<state>  =>   B<string>

=begin html

<br>Possible values: "on" or "off". This option determines if the snapshot autodelete is currently enabled for the volume.

=end html

=back



=over 2

=item * I<target-free-space>  =>   B<integer>

=begin html

<br>This option determines when snapshot autodelete should stop deleting snapshot. Depending on the trigger, snapshots are deleted till we reach the target free space percentage. Range: [1..100]

=end html

=back



=over 2

=item * I<trigger>  =>   B<string>

=begin html

<br>Possible values: "volume", "snap_reserve", or "space_reserve". This option determines the condition in which snapshots should be automatically deleted. Setting this option to "volume" triggers snapshot autodelete to run when the volume is near full. Setting this option to "snap_reseve" triggers snapshot autodelete to run when the snap reserve of the volume is near full. Setting this option to "space_reserve" triggers snapshot autodelete to run when the space reserved in the volume is near full.

=end html

=back



=head2 transition-info

=begin html

Information relating to any transition jobs running or previously run on this volume.

=end html



B<Fields>

=over 2

=item * I<transition-state>  =>   B<string, optional>

=begin html

<br>Indicates the current state of the volume transition operation.

=end html

=back



=over 2

=item * I<transitioned>  =>   B<boolean, optional>

=begin html

<br>Indicates whether the volume has gone through a transition operation.

=end html

=back



=head2 vm-align-info

=begin html

Information relating to Virtual Machine alignment settings on the volume.

=end html



B<Fields>

=over 2

=item * I<vm-align-sector>  =>   B<integer, optional>

=begin html

<br>The Virtual Machine alignment 512 byte sector number. All files created with the suffix specified in the 'vm-align-suffix' input parameter will have zero-filled <512 * 'vm-align-sector'> bytes data at the beginning so that it's actual data starts at a different offset instead of zero. This is done so that the read & writes to such files are aligned to WAFL's 4k block boundary

=end html

=back



=over 2

=item * I<vm-align-suffix>  =>   B<string, optional>

=begin html

<br>The Virtual Machine alignment suffix. The suffix such as '.xyz' is used to identify the files which needs to be aligned. See the description for 'vm-align-sector' above for more information on this.

=end html

=back



=head2 vol-footprint-info

=begin html

Details of space utilization footprint in the hosting aggregate.

=end html



B<Fields>

=over 2

=item * I<aggregate-size>  =>   B<integer>

=begin html

<br>This field represents the total aggregate size in bytes.

=end html

=back



=over 2

=item * I<dedupe-metafiles-footprint>  =>   B<integer>

=begin html

<br>This field represents temporary deduplication metadata footprint in bytes.

=end html

=back



=over 2

=item * I<dedupe-metafiles-temporary-footprint>  =>   B<integer>

=begin html

<br>This field represents temporary deduplication metadata footprint in bytes.

=end html

=back



=over 2

=item * I<delayed-free-footprint>  =>   B<integer>

=begin html

<br>This field represents the delayed free footprint in bytes. This system is used to improve delete performance by batching delete requests.

=end html

=back



=over 2

=item * I<flexvol-metadata-footprint>  =>   B<integer>

=begin html

<br>This field represents flexible volume metadata in bytes.

=end html

=back



=over 2

=item * I<snapmirror-destination-footprint>  =>   B<integer>

=begin html

<br>This field represents the SnapMirror destination footprint in bytes.

=end html

=back



=over 2

=item * I<tape-backup-metafiles-footprint>  =>   B<integer>

=begin html

<br>This fields represents the tape backup metadata footprint in bytes.

=end html

=back



=over 2

=item * I<total-footprint>  =>   B<integer>

=begin html

<br>This field represents the total footprint in bytes. It is based on the sum of all of the components of the volume's footprint in its parent aggregate.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume.

=end html

=back



=over 2

=item * I<volume-data-footprint>  =>   B<integer>

=begin html

<br>This field represents the footprint of data written to the volume in bytes.

=end html

=back



=over 2

=item * I<volume-guarantee-footprint>  =>   B<integer>

=begin html

<br>This field represents the volume guarantee footprint in bytes. Alternatively, it is the space reserved for future writes in the volume.

=end html

=back



=head2 vol-move-status-info

=begin html

status of each move

=end html



B<Fields>

=over 2

=item * I<current-transfer>  =>   B<integer, optional>

=begin html

<br>Amount of data in KB being transferred in current transfer. Appears only in verbose mode. The maximum value is the size of the volume.

=end html

=back



=over 2

=item * I<cutover-attempts>  =>   B<integer>

=begin html

<br>Number of cutover attempts. A value of -1 signifies manual cutover.

=end html

=back



=over 2

=item * I<cutover-window>  =>   B<integer>

=begin html

<br>Length of the cutover-window in seconds.

=end html

=back



=over 2

=item * I<dest-aggregate>  =>   B<string>

=begin html

<br>Name of aggregate where the volume is being moved

=end html

=back



=over 2

=item * I<dest-volume>  =>   B<string, optional>

=begin html

<br>Name of (temporary) destination volume. Appears only in verbose mode.

=end html

=back



=over 2

=item * I<error-string>  =>   B<string, optional>

=begin html

<br>Error encountered during the move

=end html

=back



=over 2

=item * I<last-transfer-duration>  =>   B<integer, optional>

=begin html

<br>Time taken for the last completed transfer in seconds. Appears only in verbose mode. There is no upper limit on how long this can take.

=end html

=back



=over 2

=item * I<last-transfer-size>  =>   B<integer, optional>

=begin html

<br>The size in KB (1024) of the last completed transfer. Appears only in verbose mode. The maximum value is the size of the volume.

=end html

=back



=over 2

=item * I<move-state>  =>   B<string>

=begin html

<br>Status of the move. Possible values are "setup", "move", "cutover", "abort", "setup(paused)", "move(paused)".

=end html

=back



=over 2

=item * I<pause-reason>  =>   B<string, optional>

=begin html

<br>Reason for the pause state of the move

=end html

=back



=over 2

=item * I<source-volume-name>  =>   B<string>

=begin html

<br>Name of volume being moved

=end html

=back



=head2 vol-space-info

=begin html

Space utilization details.

=end html



B<Fields>

=over 2

=item * I<dedupe-metafiles>  =>   B<integer>

=begin html

<br>This field represents space used by deduplication metafiles in bytes.

=end html

=back



=over 2

=item * I<dedupe-metafiles-temporary>  =>   B<integer>

=begin html

<br>This field represents space used by temporary deduplication metafiles in bytes.

=end html

=back



=over 2

=item * I<filesystem-metadata>  =>   B<integer>

=begin html

<br>This field represents volume filesystem metadata in bytes.

=end html

=back



=over 2

=item * I<inodes>  =>   B<integer>

=begin html

<br>This field represents space used by inode metadata in bytes.

=end html

=back



=over 2

=item * I<quota-metafiles>  =>   B<integer>

=begin html

<br>This field represents space used by quota metafiles in bytes.

=end html

=back



=over 2

=item * I<snapmirror-metadata>  =>   B<integer>

=begin html

<br>This field represents space used by metafiles during SnapMirror operations in bytes.

=end html

=back



=over 2

=item * I<snapshot-reserve>  =>   B<integer>

=begin html

<br>This field represents the size in bytes in the volume of space that has been set aside as a reserve for Snapshot usage.

=end html

=back



=over 2

=item * I<snapshot-spill>  =>   B<integer>

=begin html

<br>This field represents space used by Snapshot copies when it exceeds the size of the Snapshot reserve in bytes. It is computed as Snapshot used minus Snapshot reserve when Snapshot used exceeds Snapshot reserve.

=end html

=back



=over 2

=item * I<total-used>  =>   B<integer>

=begin html

<br>This field represents the total used space in the volume in bytes. This value is based on user data, metadata that resides in the volume, and Snapshot reserve.

=end html

=back



=over 2

=item * I<user-data>  =>   B<integer>

=begin html

<br>This field represents user data in bytes. If space is reserved to overwrite data in the volume, it is included in this value.

=end html

=back



=over 2

=item * I<volume>  =>   B<string>

=begin html

<br>Name of the volume

=end html

=back



=over 2

=item * I<volume-size>  =>   B<integer>

=begin html

<br>This field represents the total volume size in bytes.

=end html

=back



=head2 volume-64bit-upgrade-check-info

=begin html

Information returned when upgrade-64bit-mode in aggr-add is "check". Upgrade check results such as "used-space", "available-space", "capacity", and "grow-space" are only updated after the space estimate is completed successfully.

=end html



B<Fields>

=over 2

=item * I<age>  =>   B<integer, optional>

=begin html

<br>The age in seconds of the space check results. Range: [0..2^64-1].

=end html

=back



=over 2

=item * I<available-space>  =>   B<integer, optional>

=begin html

<br>Amount of space (in bytes) that would be available in the volume after it is upgraded to 64-bit. Range: [0..2^64-1].

=end html

=back



=over 2

=item * I<capacity>  =>   B<integer, optional>

=begin html

<br>Percentage of space that would be used in the volume after it is upgraded to 64-bit. Range: [0..100].

=end html

=back



=over 2

=item * I<grow-space>  =>   B<integer, optional>

=begin html

<br>Amount of space (in bytes) the volume must be grown by before successfully upgrading its current data. Range: [0..2^64-1]

=end html

=back



=over 2

=item * I<last-errno>  =>   B<integer, optional>

=begin html

<br>The error code of the last attempt to check for space usage on the specific volume. This field is present only if a 64-bit upgrade check was previously attempted. Possible values: 0 - indicates success EVOLUME_64BIT_UPGRADE_KIREETI_NOT_AVAIL Upgrade check results may be out of date if last-errno is not 0.

=end html

=back



=over 2

=item * I<used-space>  =>   B<integer, optional>

=begin html

<br>Amount of space (in bytes) that would be used in the volume after it is upgraded to 64-bit. Range: [0..2^64-1].

=end html

=back



=head2 volume-64bit-upgrade-info

=begin html

Information related to 64-bit upgrade.

=end html



B<Fields>

=over 2

=item * I<check>  =>   B<L<"volume-64bit-upgrade-check-info">, optional>

=begin html

<br>Information returned when upgrade-64bit-mode in aggr-add is "check".

=end html

=back



=head2 volume-info

=begin html

Volume status information.

=end html



B<Fields>

=over 2

=item * I<autosize>  =>   B<L<"autosize-info">, optional>

=begin html

<br>Display autosize settings of the volume. Appears only under "verbose" mode.

=end html

=back



=over 2

=item * I<block-type>  =>   B<string>

=begin html

<br>The indirect block format of the volume. Possible values: 32_bit, 64_bit.

=end html

=back



=over 2

=item * I<checksum-style>  =>   B<string>

=begin html

<br>The style of RAID checksum used (for a traditional volume; for a flexible volume, the corresponding value of its containing aggregate). The possible values: <ul> <li> "advanced_zoned" - advanced_zoned checksum (azcs), <li> "block" - block, <li> "mixed" - mixed, <li> "none" - none, <li> "unknown" - unknown <li> "wafl" - wafl, <li> "zoned" - zoned. </ul>

=end html

=back



=over 2

=item * I<clone-children>  =>   B<L<"clone-child-info">[], optional>

=begin html

<br><b>Flexible</b> volumes only. This field appears for a flexible volume if it is the parent of one or more clones.

=end html

=back



=over 2

=item * I<clone-parent>  =>   B<L<"clone-parent-info">[], optional>

=begin html

<br><b>Flexible</b> volumes only. This field appears for a flexible volume if it is a clone of another flexible volume, describing the clone's parentage.

=end html

=back



=over 2

=item * I<compression>  =>   B<L<"compression-info">>

=begin html

<br>Note that the use of this element is deprecated, refer to the 'dense-status' element for compression status instead.

=end html

=back



=over 2

=item * I<containing-aggregate>  =>   B<string, optional>

=begin html

<br><b>Flexible</b> volumes only. The name of the aggregate in which the given flexible volume resides.

=end html

=back



=over 2

=item * I<disk-count>  =>   B<integer>

=begin html

<br>Total number of associated disks (for a traditional volume; for a flexible volume, the corresponding value of its containing aggregate). Range : [0..2^31-1]

=end html

=back



=over 2

=item * I<expiry-date>  =>   B<integer, optional>

=begin html

<br>Expiry date of the SnapLock volume in seconds in the standard UNIX format (since 01/01/1970 00:00:00) is displayed. Range:[0..2^64-1]. The flag is-wraparound indicates if this date is in the normal format or is wrapped around. This field is not included if 1. the volume has an infinite expiry-date 2. the volume is offline 3. the volume has scan in progress 4. the volume is regular volume 5. the volume has no expiry date. The volume is SnapLock volume (is-snaplock is "true") with no WORM files and no WORM snapshots.

=end html

=back



=over 2

=item * I<files-private-used>  =>   B<integer>

=begin html

<br>Number of system (not user-visible) files (inodes) used. If the volume is restricted or offline, a a value of 0 is returned. Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<files-total>  =>   B<integer>

=begin html

<br>Total user-visible file (inode) count, i.e., current maximum number of user-visible files (inodes) that this volume can currently hold. If the volume is restricted or offline, a value of 0 is returned. Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<files-used>  =>   B<integer>

=begin html

<br>Number of user-visible files (inodes) used. If the volume is restricted or offline, a value 0 returned. Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<filesystem-size>  =>   B<integer>

=begin html

<br>Filesystem size (in bytes) of the volume. This is the total usable size of the volume, not including WAFL reserve. This value is the same as Size except for certain SnapMirror destination volumes. It is possible for destination volumes to have a different filesystem-size because the filesystem-size is sent across from the source volume. If the volume is restricted or offline, a value of 0 is returned. Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<formatted-expiry-date>  =>   B<string, optional>

=begin html

<br>Expiry date of the SnapLock volume in a human-readable format <month> <day of month> <hour>:<min>:<sec> <year> is displayed. A value of "infinite" indicates that the volume has an infinite expiry date. A value of "scan_in_progress" indicates that expiry date is not displayed since worm scan on the volume is in progress. A value of "no_expiry_date" indicates that expiry date is not displayed since the SnapLock volume has no WORM files and WORM snapshots. This field is not included if the volume is offline or the volume is regular volume (is-snaplock is "false").

=end html

=back



=over 2

=item * I<formatted-snaplock-volume-compliance-clock>  =>   B<string, optional>

=begin html

<br>If Compliance Clock is initialized then human readable time <day> <month> <day of month> <hour>:<min>:<sec> <year> is displayed. This field will be present only for SnapLock volumes.

=end html

=back



=over 2

=item * I<hybrid-cache-eligibility>  =>   B<string>

=begin html

<br>hybrid cache eligibility. Valid values are "read","read-write" and "none". Volumes which report "read" can support only read caching. Volumes which report "read-write" support both read and write caching. "none" means no hybrid caching support.

=end html

=back



=over 2

=item * I<hybrid-cache-write-caching-ineligibility-reason>  =>   B<string, optional>

=begin html

<br>informs why the volume cannot participate in write caching. This field is valid only if the volume can participate in read caching but not write caching.

=end html

=back



=over 2

=item * I<inodefile-private-capacity>  =>   B<integer>

=begin html

<br>Number of inodes that can currently be stored on disk for system (not user-visible) files. This number will dynamically increase as more system files are created. If the volume is restricted or offline, a value of zero is returned. Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<inodefile-public-capacity>  =>   B<integer>

=begin html

<br>Number of inodes that can currently be stored on disk for user-visible files. This number will dynamically increase as more user-visible files are created. If the volume is restricted or offline, a value of zero is returned. Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<is-checksum-enabled>  =>   B<boolean>

=begin html

<br>Whether RAID checksums are enabled (for a traditional volume; for a flexible volume, the corresponding value of its containing aggregate).

=end html

=back



=over 2

=item * I<is-in-snapmirror-jumpahead>  =>   B<boolean, optional>

=begin html

<br>True when the volume is in the process of SnapMirror jump ahead. Default value is false. This field is returned only for online volumes.

=end html

=back



=over 2

=item * I<is-inconsistent>  =>   B<boolean>

=begin html

<br>Whether or not there is known inconsistency in the associated file system.

=end html

=back



=over 2

=item * I<is-invalid>  =>   B<boolean, optional>

=begin html

<br>Whether or not this volume is invalid. Volumes typically become invalid as a result of an aborted 'vol copy' or SnapMirror(R) initial transfer. In such a case a volume is in a half created state and cannot be recovered. <p> By default, this field is FALSE.

=end html

=back



=over 2

=item * I<is-snaplock>  =>   B<boolean>

=begin html

<br>Whether or not this is a SnapLock volume.

=end html

=back



=over 2

=item * I<is-unrecoverable>  =>   B<boolean, optional>

=begin html

<br>Whether or not there is known inconsistency in the associated file system and it is not recoverable. This value is only present for flexible volumes. <p> By default, this field is FALSE.

=end html

=back



=over 2

=item * I<is-wraparound>  =>   B<boolean, optional>

=begin html

<br>True if the date represented in expiry-date is a wrap around date. SnapLock wraps around the expiry date to indicate dates after 01/19/2038. It remaps 01/01/1970 - 12/31/2002 to 01/19/2038 - 01/19/2071. This field is not included if 1. the volume has an infinite expiry date 2. the volume is offline 3. the volume has scan in progress 4. the volume is regular volume (is-snaplock is "false") 5. the volume has no expiry date. The volume is SnapLock volume (is-snaplock is "true") with no WORM files and no WORM snapshots.

=end html

=back



=over 2

=item * I<mirror-status>  =>   B<string>

=begin html

<br>The RAID mirror status (for a traditional volume; for a flexible volume, the corresponding value of its containing aggregate). Possible values: CP count check in progress, failed, invalid, limbo, mirror degraded, mirror resynchronizing, mirrored, needs CP count check, uninitialized, &ltunknown mirror state&gt, and unmirrored.

=end html

=back



=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Name of the volume.

=end html

=back



=over 2

=item * I<owning-vfiler>  =>   B<string, optional>

=begin html

<br>Name of the vfiler which owns this volume. This value will be returned only if the request is coming to vfiler0 and MultiStore is licensed.

=end html

=back



=over 2

=item * I<percentage-used>  =>   B<integer, optional>

=begin html

<br>Percentage of the volume size that is used. If the volume is restricted or offline, a value of 0 is returned. Range : [0..100].

=end html

=back



=over 2

=item * I<plex-count>  =>   B<integer>

=begin html

<br>Number of plexes (for a traditional volume; for a flexible volume, the corresponding value of its containing aggregate). This is also the size of the "plex" array that appears below. A plex is composed of one or more RAID groups that have been lashed together to serve as the unit for RAID mirroring. Range : [0..2^31-1]

=end html

=back



=over 2

=item * I<plexes>  =>   B<L<"plex-info">[]>

=begin html

<br>List of plexes for this volume (for a traditional volume; for a flexible volume, the corresponding value of its containing aggregate).

=end html

=back



=over 2

=item * I<quota-init>  =>   B<integer>

=begin html

<br>Quota state and percent initialized. 100% means that quotas are on, 0% means quotas are off, and anywhere inbetween means that quotas are initializing. Range : [0..100].

=end html

=back



=over 2

=item * I<raid-size>  =>   B<integer>

=begin html

<br>The current RAID group size (for a traditional volume; for a flexible volume, the corresponding value of its containing aggregate). Range : [0..2^31-1].

=end html

=back



=over 2

=item * I<raid-status>  =>   B<string>

=begin html

<br>The current RAID status (for a traditional volume; for a flexible volume, the corresponding value of its containing aggregate). Possible values: copying, degraded, foreign, growing, initializing, invalid, ironing, mirror degraded, mirrored, needs check, noparity, normal, out-of-date, partial, raid0, raid4, raid_dp, reconstruct, resyncing, snapmirrored, verifying, unrecoverable. This field can contain a combination of the above status values in a comma separated list; for example: "reconstruct,growing".

=end html

=back



=over 2

=item * I<remote-location>  =>   B<string, optional>

=begin html

<br>Displays the remote host and remote volume where the origin of the cache is located. Returned in format: <Remote-Host>:<Remote-Volume> Present only if flex volume is a FlexCache. Remote Host: Should be formatted as either the DNS hostname or as an IP address. Remote Volume: Should be formatted the same as a volume name.

=end html

=back



=over 2

=item * I<reserve>  =>   B<integer>

=begin html

<br>Number of bytes reserved for overwriting snapshotted data in an otherwise full volume. This space is usable only by space-reserved LUNs and files, and then only when the volume is full. It is equal to reserve-required if the value of the fractional_reserve option is set to the default value of 100%, but otherwise may be less than reserve-required. If the volume is restricted or offline, a value of 0 is returned. Range : [0..2^64-1]

=end html

=back



=over 2

=item * I<reserve-required>  =>   B<integer>

=begin html

<br>The number of reserved bytes that are required to ensure that the reserved space is sufficient to allow all space reserved files and LUNs to be overwritten when the volume is full. If the volume is restricted or offline, a value of 0 is returned. Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<reserve-used>  =>   B<integer>

=begin html

<br>Number of reserved bytes that is not available for new overwrites. The number includes both reserved bytes which have actually been used for overwrites as well as bytes which were never allocated in the first place. On a volume without free space, the "never allocated" component can become non-zero when reserve-required increases as holes are filled in. Because of this, the reserve-used value can exceed the number of snapshotted bytes. The reserve-used value can also exceed the value of reserve-required, as the filer maintains a small hidden reserve of last resort. If the volume is restricted or offline, a value of 0 is returned. Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<reserve-used-actual>  =>   B<integer>

=begin html

<br>Number of reserved bytes that have been used. This value is computed as the smaller of: (1) snapshotted bytes not in the active filesystem, and (2) reserve-used. This formula comes from the observation that you cannot have used more overwrite reserved than have actually overwritten data. This value can exceed the value of reserve-required, as the filer maintains a small hidden reserve of last resort. If the volume is restricted or offline, a value of 0 is returned. Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<sis>  =>   B<L<"sis-info">, optional>

=begin html

<br>Display the Single Instance Storage (SIS) related status and statistics if the volume is a SIS volume.

=end html

=back



=over 2

=item * I<size-available>  =>   B<integer>

=begin html

<br>Number of bytes still available in the volume. If the volume is restricted or offline, a value of 0 is returned. Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<size-total>  =>   B<integer>

=begin html

<br>Total usable size (in bytes) of the volume, not including WAFL reserve or volume snapshot reserve. If the volume is restricted or offline, a value of 0 is returned. Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<size-used>  =>   B<integer>

=begin html

<br>Number of bytes used in the volume. If the volume is restricted or offline, a value of 0 is returned. Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<snap-autodelete>  =>   B<L<"snap-autodelete-info">, optional>

=begin html

<br>Display the snapshot autodelete policy related status of the volume. Appears only under "verbose" mode.

=end html

=back



=over 2

=item * I<snaplock-type>  =>   B<string, optional>

=begin html

<br>The type of the snaplock volume. It is present for snaplock volumes only, i.e. volumes for which is-snaplock is "true". Possible values - "compliance" or "enterprise"

=end html

=back



=over 2

=item * I<snaplock-volume-compliance-clock>  =>   B<integer, optional>

=begin html

<br>If Compliance Clock is initialized then time in seconds in the standard UNIX format (since 01/01/1970 00:00:00) is displayed. This field will be present only for SnapLock volumes. Range:[0..2^64-1].

=end html

=back



=over 2

=item * I<snapshot-blocks-reserved>  =>   B<integer>

=begin html

<br>The number of 1024 byte blocks that has been set aside as reserve for snapshot usage. This is same as "blocks-reserved" in snapshot-get-reserve API output. Range : [0..2^64-1].

=end html

=back



=over 2

=item * I<snapshot-percent-reserved>  =>   B<integer>

=begin html

<br>The percentage of disk space that has been set aside as reserve for snapshot usage. This is same as "percent-reserved" in snapshot-get-reserve API output. Range : [0..100].

=end html

=back



=over 2

=item * I<space-reserve>  =>   B<string, optional>

=begin html

<br><b>Flexible</b> volumes only. The storage guarantee associated with the flexible volume. Possible values: none, file, volume. This field does not appear if the flexible volume is restricted or offline.

=end html

=back



=over 2

=item * I<space-reserve-enabled>  =>   B<boolean, optional>

=begin html

<br><b>Flexible</b> volumes only. Whether or not the storage guarantee associated with the flexible volume is currently in effect. This field does not appear if the flexible volume is restricted or offline.

=end html

=back



=over 2

=item * I<state>  =>   B<string>

=begin html

<br>State of the volume. Possible values: "offline", "online", "restricted" and "unknown" for both flexible and traditional volumes, and "creating", "failed", and "partial" specifically for traditional volumes.

=end html

=back



=over 2

=item * I<transition>  =>   B<L<"transition-info">, optional>

=begin html

<br>Information relating to any transition jobs running or previously run on this volume.

=end html

=back



=over 2

=item * I<type>  =>   B<string>

=begin html

<br>The type of volume. Possible values: "flex" for flexible volumes, and "trad" for traditional volumes.

=end html

=back



=over 2

=item * I<uuid>  =>   B<string>

=begin html

<br>Universal unique identifier (UUID) for the volume.

=end html

=back



=over 2

=item * I<vm-align>  =>   B<L<"vm-align-info">, optional>

=begin html

<br>Information related to the Virtual Machine alignment settings on the volume.

=end html

=back



=over 2

=item * I<volume-64bit-upgrade>  =>   B<L<"volume-64bit-upgrade-info">, optional>

=begin html

<br>Information related to 64-bit upgrade. After 64-bit upgrade completes, this information is no longer available.

=end html

=back



=head2 volume-option-info

=begin html

Option key and value.

=end html



B<Fields>

=over 2

=item * I<name>  =>   B<string>

=begin html

<br>Option key.

=end html

=back



=over 2

=item * I<value>  =>   B<string>

=begin html

<br>Option value.

=end html

=back



=head2 uuid

=begin html

The 128-bit universally-unique identifier (UUID). UUIDs are formatted as 36-character strings. These strings are composed of 32 hexadecimal characters broken up into five groupings separated by '-'s.The first grouping has 8 hex characters, the second through fourth groupings have four hex characters each, and the fifth and final grouping has 12 hex characters. Note that a leading '0x' is not used. An example UUID is 532ad684-c8ec-11d9-945f-00065b8c8a1e.

=end html



B<Fields>

=over 2

=item * None

=back



=head1 COPYRIGHT

Copyright (c) 1994-2013 NetApp, Inc. All rights reserved.

The product described in this manual may be protected by one or more U.S.A. patents, foreign patents, or pending applications.

RESTRICTED RIGHTS LEGEND: Use, duplication, or disclosure by the government is subject to restrictions as set forth in subparagraph (c)(1)(ii) of the Rights in Technical Data and Computer Software clause at DFARS 252.277-7103 (October 1988) and FAR 52-227-19 (June 1987).

=cut
